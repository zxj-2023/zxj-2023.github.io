<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="操作系统概论操作系统的主要特征并发性 (Concurrency)🔍 核心定义  并发性是指两个或两个以上的事件或活动在同一时间间隔内发生。   关键点：“同一时间间隔” ≠ “同一时刻”。它强调的是“看起来同时”，而不是“真正同时”。  📌 操作系统中的体现  多个 I&#x2F;O 设备同时工作：  你的键盘在输入，打印机在打印，网卡在收发数据。这些设备都在“同时”工作。   I&#x2F;O 和 CPU 计算">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="操作系统概论操作系统的主要特征并发性 (Concurrency)🔍 核心定义  并发性是指两个或两个以上的事件或活动在同一时间间隔内发生。   关键点：“同一时间间隔” ≠ “同一时刻”。它强调的是“看起来同时”，而不是“真正同时”。  📌 操作系统中的体现  多个 I&#x2F;O 设备同时工作：  你的键盘在输入，打印机在打印，网卡在收发数据。这些设备都在“同时”工作。   I&#x2F;O 和 CPU 计算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116191358137.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204410504.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204451732.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210257885.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210715693.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212223846.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212241091.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212521578.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115215300054.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116131448708.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132753390.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132925377.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133352988.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133432719.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141512909.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141611150.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116144745818.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116173459401.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116181426684.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182605135.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182901353.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116184516361.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221140228398.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221141919972.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221142102685.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221143811148.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144426233.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144511133.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144613218.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144633595.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221150141354.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221151214942.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221151234013.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221154628477.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221155409519.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221155532240.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221161021945.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221162559750.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170033104.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170552446.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170856192.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221173735698.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221173753487.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174117271-1766310078350-1.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174219298.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174254213.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221193222438.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223153957188.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223155431045.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223162354483.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223162608032.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223163719210.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223165755764.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171004487.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171623306.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171959180.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223173127932-1766482289243-1.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223192427585.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223194324624.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195351262.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195424991.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195452951.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195516927.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195602421.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223201528047.png">
<meta property="og:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223204707858.png">
<meta property="article:published_time" content="2025-09-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-23T12:47:14.685Z">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="大学">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116191358137.png">


<link rel="canonical" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","path":"2025/09/08/college/大三上/操作系统/操作系统/","title":"操作系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统 | Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhang XiJun</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">操作系统概论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统的主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7-Concurrency"><span class="nav-number">1.1.1.</span> <span class="nav-text">并发性 (Concurrency)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%80%A7-Sharing"><span class="nav-number">1.1.2.</span> <span class="nav-text">共享性 (Sharing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%80%A7-Asynchrony"><span class="nav-number">1.1.3.</span> <span class="nav-text">异步性 (Asynchrony)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">多道程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-number">1.2.2.</span> <span class="nav-text">cpu利用率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">计算过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%B8%8D%E6%98%AF%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">是不是同时运行的程序越多越好？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.</span> <span class="nav-text">处理器状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E5%99%A8%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">为什么需要两种处理器状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AD%97-PSW"><span class="nav-number">1.4.2.</span> <span class="nav-text">程序状态字 (PSW)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">CPU 如何判断当前是否可以执行特权指令？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">进程控制和管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">进程定义与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E2%80%9C%E8%BF%9B%E7%A8%8B%E2%80%9D%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">为什么要引入“进程”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.2.</span> <span class="nav-text">进程的五大核心属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">进程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">五态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">七态模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E7%BB%84%E6%88%90"><span class="nav-number">2.3.</span> <span class="nav-text">进程描述和组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F"><span class="nav-number">2.3.1.</span> <span class="nav-text">进程映像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">2.3.2.</span> <span class="nav-text">进程上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PCB%EF%BC%88Process-Control-Block%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%89"><span class="nav-number">2.3.3.</span> <span class="nav-text">PCB（Process Control Block，进程控制块）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97"><span class="nav-number">2.4.</span> <span class="nav-text">进程队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">链接方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.2.</span> <span class="nav-text">索引方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.5.</span> <span class="nav-text">进程切换和处理器状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2-vs-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">2.5.1.</span> <span class="nav-text">模式切换 vs. 进程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E8%8E%B7%E5%BE%97%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="nav-number">2.5.2.</span> <span class="nav-text">当进程开始运行时，操作系统如何重新获得控制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E4%BF%9D%E5%AD%98%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">2.5.3.</span> <span class="nav-text">进程需要保存哪些状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BE%85%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.5.4.</span> <span class="nav-text">如何选择下一个待执行的进程&#x2F;线程？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%EF%BC%9F%E2%80%94%E2%80%94-%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="nav-number">2.6.1.</span> <span class="nav-text">为什么需要线程？—— 引入线程的动机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E2%80%94%E2%80%94-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-number">2.6.2.</span> <span class="nav-text">什么是线程？—— 核心定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F%E2%80%94%E2%80%94-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%88%87%E6%8D%A2"><span class="nav-number">2.6.3.</span> <span class="nav-text">线程如何工作？—— 线程的生命周期与切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="nav-number">3.1.</span> <span class="nav-text">调度层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">调度算法评价指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-number">3.3.</span> <span class="nav-text">七种调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-First-Come-First-Serverd-FCFS"><span class="nav-number">3.3.1.</span> <span class="nav-text">先来先服务 (First Come First Serverd, FCFS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-Shortest-Job-First-SJF"><span class="nav-number">3.3.2.</span> <span class="nav-text">短作业优先 (Shortest Job First, SJF)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-Shortest-Remaining-Time-First-SRTF"><span class="nav-number">3.3.3.</span> <span class="nav-text">最短剩余时间优先 (Shortest Remaining Time First, SRTF)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-Highest-Response-Ratio-First-HRRF"><span class="nav-number">3.3.4.</span> <span class="nav-text">最高响应比优先 (Highest Response Ratio First, HRRF)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-Priority-Scheduling"><span class="nav-number">3.3.5.</span> <span class="nav-text">优先级调度 (Priority Scheduling)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6-Round-Robin-Scheduling-RR"><span class="nav-number">3.3.6.</span> <span class="nav-text">轮转调度 (Round Robin Scheduling, RR)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6-Multi-Level-Feedback-Queue-MLFQ"><span class="nav-number">3.3.7.</span> <span class="nav-text">多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">4.</span> <span class="nav-text">并发：互斥与同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%A4%E4%BA%92"><span class="nav-number">4.1.</span> <span class="nav-text">进程交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E2%80%9C%E8%BF%9B%E7%A8%8B%E4%BA%A4%E4%BA%92%E2%80%9D%EF%BC%9F"><span class="nav-number">4.1.1.</span> <span class="nav-text">为什么需要“进程交互”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E5%85%B3%E7%B3%BB%EF%BC%88%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%89"><span class="nav-number">4.1.2.</span> <span class="nav-text">竞争关系（进程互斥）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="nav-number">4.1.3.</span> <span class="nav-text">协作关系（进程同步）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">临界区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E4%B8%B4%E7%95%8C%E5%8C%BA%E2%80%9D%EF%BC%9F"><span class="nav-number">4.2.1.</span> <span class="nav-text">什么是“临界区”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%94%99%E8%AF%AF%EF%BC%9F%E2%80%94%E2%80%94-%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">4.2.2.</span> <span class="nav-text">如何避免错误？—— 互斥访问临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99%EF%BC%88%E7%BB%8F%E5%85%B8%EF%BC%81%EF%BC%89"><span class="nav-number">4.2.3.</span> <span class="nav-text">临界区调度的三个原则（经典！）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AE%A1%E7%90%86%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E4%B8%80Peterson%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">实现临界区管理的软件方法一Peterson方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EPV%E6%93%8D%E4%BD%9C"><span class="nav-number">4.4.</span> <span class="nav-text">信号量与PV操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="nav-number">4.4.1.</span> <span class="nav-text">信号量（Semaphore）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P-V-%E6%93%8D%E4%BD%9C%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E2%80%9C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E2%80%9D"><span class="nav-number">4.4.2.</span> <span class="nav-text">P&#x2F;V 操作：信号量的“原子操作”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.</span> <span class="nav-text">哲学家进餐问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A0%B8%E5%BF%83%E6%8F%8F%E8%BF%B0"><span class="nav-number">4.5.1.</span> <span class="nav-text">哲学家进餐问题：核心描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">4.5.2.</span> <span class="nav-text">为什么会出现死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E6%89%93%E7%A0%B4%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80"><span class="nav-number">4.5.3.</span> <span class="nav-text">解决方案：打破死锁的四个条件之一</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">4.6.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">4.7.</span> <span class="nav-text">什么是生产者-消费者问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">4.7.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%B0%86P%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BA%A4%E6%8D%A2%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">4.7.2.</span> <span class="nav-text">问题：如果将P操作的顺序交换，会出现什么情况？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BD%93%E5%89%8D%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%92%E6%96%A5%E9%94%81%E4%BC%9A%E9%80%A0%E6%88%90%E7%AB%9E%E4%BA%89"><span class="nav-number">4.7.3.</span> <span class="nav-text">问题：当前生产者消费者共用一个互斥锁会造成竞争</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F"><span class="nav-number">5.1.</span> <span class="nav-text">死锁产生</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="nav-number">5.1.1.</span> <span class="nav-text">什么是死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">5.1.2.</span> <span class="nav-text">死锁的4个必要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%98%B2%E6%AD%A2"><span class="nav-number">5.2.</span> <span class="nav-text">死锁防止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">5.3.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.1.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="nav-number">5.4.</span> <span class="nav-text">死锁检测和解除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="nav-number">5.4.1.</span> <span class="nav-text">资源分配图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E5%88%A4%E6%96%AD%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">5.4.2.</span> <span class="nav-text">如何通过资源分配图判断死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8C%96"><span class="nav-number">5.4.3.</span> <span class="nav-text">资源分配图的简化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.4.</span> <span class="nav-text">死锁检测算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">内存是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">存储层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">6.3.</span> <span class="nav-text">逻辑地址和物理地址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-Logical-Address"><span class="nav-number">6.3.1.</span> <span class="nav-text">逻辑地址 (Logical Address)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-Physical-Address"><span class="nav-number">6.3.2.</span> <span class="nav-text">物理地址 (Physical Address)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">6.4.</span> <span class="nav-text">内存复用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95"><span class="nav-number">6.4.1.</span> <span class="nav-text">四大具体方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%B7%AF%E5%BE%84-%E2%91%A0%EF%BC%9A%E5%8D%95%E8%BF%9E%E7%BB%AD-%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-The-%E2%80%9COld-School%E2%80%9D"><span class="nav-number">6.4.2.</span> <span class="nav-text">1. 路径 ①：单连续&#x2F;分区存储管理 (The “Old School”)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B7%AF%E5%BE%84-%E2%91%A1%EF%BC%9A%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-Paging-%E7%8E%B0%E4%BB%A3%E4%B8%BB%E6%B5%81%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">6.4.3.</span> <span class="nav-text">2. 路径 ②：页式存储管理 (Paging - 现代主流的基础)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%B7%AF%E5%BE%84-%E2%91%A2%EF%BC%9A%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-Segmentation-%E7%AC%A6%E5%90%88%E4%BA%BA%E7%B1%BB%E7%9B%B4%E8%A7%89"><span class="nav-number">6.4.4.</span> <span class="nav-text">3. 路径 ③：段式存储管理 (Segmentation - 符合人类直觉)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%B7%AF%E5%BE%84-%E2%91%A3%EF%BC%9A%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-Segmented-Paging-%E9%9B%86%E5%A4%A7%E6%88%90%E8%80%85"><span class="nav-number">6.4.5.</span> <span class="nav-text">4. 路径 ④：段页式存储管理 (Segmented Paging - 集大成者)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">6.5.</span> <span class="nav-text">存储管理的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-Continuous-Allocation"><span class="nav-number">6.6.</span> <span class="nav-text">连续分配管理方式 (Continuous Allocation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-number">6.6.1.</span> <span class="nav-text">核心定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D-Single-Continuous-Allocation"><span class="nav-number">6.6.2.</span> <span class="nav-text">第一阶段：单一连续分配 (Single Continuous Allocation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-Fixed-Partitioning"><span class="nav-number">6.6.3.</span> <span class="nav-text">第二阶段：固定分区分配 (Fixed Partitioning)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-Dynamic-Partitioning"><span class="nav-number">6.6.4.</span> <span class="nav-text">第三阶段：动态分区分配 (Dynamic Partitioning)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E7%B4%A7%E5%87%91%E2%80%9D%E6%8A%80%E6%9C%AF-Compaction"><span class="nav-number">6.6.5.</span> <span class="nav-text">“紧凑”技术 (Compaction)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">6.7.</span> <span class="nav-text">可变分区内存管理-分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">6.7.1.</span> <span class="nav-text">为什么需要分配算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9C%80%E5%85%88%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-First-Fit"><span class="nav-number">6.7.2.</span> <span class="nav-text">1. 最先适应算法 (First Fit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%8B%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-Next-Fit"><span class="nav-number">6.7.3.</span> <span class="nav-text">2. 下次适应算法 (Next Fit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9C%80%E4%BC%98%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-Best-Fit"><span class="nav-number">6.7.4.</span> <span class="nav-text">3. 最优适应算法 (Best Fit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-Worst-Fit"><span class="nav-number">6.7.5.</span> <span class="nav-text">4. 最坏适应算法 (Worst Fit)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-Paging-Storage-Management"><span class="nav-number">6.8.</span> <span class="nav-text">分页存储管理 (Paging Storage Management)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="nav-number">6.8.1.</span> <span class="nav-text">为什么要引入分页？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5"><span class="nav-number">6.8.2.</span> <span class="nav-text">三大概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E9%A1%B5%E6%A1%86-Page-Frame-%E2%80%94%E2%80%94-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E2%80%9C%E6%A0%BC%E5%AD%90%E2%80%9D"><span class="nav-number">6.8.3.</span> <span class="nav-text">A. 页框 (Page Frame) —— 物理内存的“格子”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E9%A1%B5%E9%9D%A2-Page-%E2%80%94%E2%80%94-%E7%A8%8B%E5%BA%8F%E7%9A%84%E2%80%9C%E5%88%87%E7%89%87%E2%80%9D"><span class="nav-number">6.8.4.</span> <span class="nav-text">B. 页面 (Page) —— 程序的“切片”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%A1%B5%E8%A1%A8-Page-Table-%E2%80%94%E2%80%94-%E5%AF%BB%E5%AE%9D%E5%9B%BE"><span class="nav-number">6.8.5.</span> <span class="nav-text">C. 页表 (Page Table) —— 寻宝图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="nav-number">6.8.6.</span> <span class="nav-text">分页是如何解决碎片问题的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.9.</span> <span class="nav-text">分页存储管理的地址转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB%EF%BC%88%E5%BF%AB%E8%A1%A8%EF%BC%89"><span class="nav-number">6.10.</span> <span class="nav-text">TLB（快表）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%97%9B%E7%82%B9%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%EF%BC%9F"><span class="nav-number">6.10.1.</span> <span class="nav-text">1. 核心痛点：为什么要引入快表？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ATLB-%E5%BF%AB%E8%A1%A8"><span class="nav-number">6.10.2.</span> <span class="nav-text">2. 解决方案：TLB (快表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8A%A0%E5%85%A5-TLB-%E5%90%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">6.10.3.</span> <span class="nav-text">3. 加入 TLB 后的工作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%8E%BB%E9%85%8D"><span class="nav-number">6.11.</span> <span class="nav-text">分页存储空间的分配与去配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A-%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E8%BF%9B%E7%A8%8B%E5%8E%BB%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%AE%83%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">6.11.1.</span> <span class="nav-text">安全性问题： 怎么防止进程去访问不属于它的内存？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.11.1.1.</span> <span class="nav-text">1. 机制详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E4%BE%8B%E5%AD%90%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">6.11.1.2.</span> <span class="nav-text">2. 图中的数学例子（非常重要）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98%EF%BC%9A-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E7%89%A9%E7%90%86%E6%A0%BC%E5%AD%90%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%9F"><span class="nav-number">6.11.2.</span> <span class="nav-text">管理问题： 操作系统怎么快速知道哪些物理格子是空的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">6.11.2.1.</span> <span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%8A%B6%E6%80%81%E8%A1%A8%E7%A4%BA"><span class="nav-number">6.11.2.2.</span> <span class="nav-text">2. 状态表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">6.11.2.3.</span> <span class="nav-text">3. 分配算法流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8-Multi-level-Page-Table"><span class="nav-number">6.12.</span> <span class="nav-text">多级页表 (Multi-level Page Table)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%9F-The-Problem"><span class="nav-number">6.12.1.</span> <span class="nav-text">1. 为什么要引入多级页表？(The Problem)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E9%87%8D%E6%96%B0%E5%88%92%E5%88%86"><span class="nav-number">6.12.2.</span> <span class="nav-text">2. 逻辑地址的重新划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B-The-Walk"><span class="nav-number">6.12.3.</span> <span class="nav-text">地址变换过程 (The Walk)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">6.13.</span> <span class="nav-text">分段存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F"><span class="nav-number">6.13.1.</span> <span class="nav-text">1. 为什么要分段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%8C%96-2D-Address"><span class="nav-number">6.13.2.</span> <span class="nav-text">2. 逻辑地址的变化 (2D Address)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%AE%B5%E8%A1%A8-Segment-Table"><span class="nav-number">6.13.3.</span> <span class="nav-text">3. 核心机制：段表 (Segment Table)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%B8%8E%E4%BF%9D%E6%8A%A4-The-Translation-amp-Safety"><span class="nav-number">6.13.4.</span> <span class="nav-text">4. 地址变换与保护 (The Translation &amp; Safety)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-Virtual-Memory"><span class="nav-number">7.</span> <span class="nav-text">虚拟内存 (Virtual Memory)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%97%9B%E7%82%B9%EF%BC%9A%E5%AE%9E%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">7.0.1.</span> <span class="nav-text">1. 痛点：实存管理的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">7.0.2.</span> <span class="nav-text">2. 解决方案：虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%9F%B3%EF%BC%9A%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">7.0.3.</span> <span class="nav-text">3. 理论基石：局部性原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-number">7.1.</span> <span class="nav-text">如何实现虚拟内存技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">7.1.1.</span> <span class="nav-text">1. 三种实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%A4%E4%B8%AA%E6%96%B0%E5%A2%9E%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="nav-number">7.1.2.</span> <span class="nav-text">2. 两个新增的核心功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5-%E8%B0%83%E6%AE%B5%E5%8A%9F%E8%83%BD-Demand-Paging-Segmentation"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">A. 请求调页&#x2F;调段功能 (Demand Paging&#x2F;Segmentation)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2-%E6%AE%B5%E7%BD%AE%E6%8D%A2%E5%8A%9F%E8%83%BD-Page-Segment-Replacement"><span class="nav-number">7.1.2.2.</span> <span class="nav-text">B. 页面置换&#x2F;段置换功能 (Page&#x2F;Segment Replacement)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">7.2.</span> <span class="nav-text">页式虚拟存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E6%8C%89%E9%9C%80%E8%B0%83%E5%85%A5-Demand-Paging"><span class="nav-number">7.2.1.</span> <span class="nav-text">1. 核心思想：按需调入 (Demand Paging)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%8D%87%E7%BA%A7%EF%BC%9A%E6%89%A9%E5%85%85%E9%A1%B5%E8%A1%A8-Expanded-Page-Table"><span class="nav-number">7.2.2.</span> <span class="nav-text">2. 基础设施升级：扩充页表 (Expanded Page Table)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-Page-Fault"><span class="nav-number">7.2.3.</span> <span class="nav-text">3. 核心机制：缺页中断 (Page Fault)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">虚存地址转换过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%86%E6%B5%81"><span class="nav-number">7.3.1.</span> <span class="nav-text">第一阶段：启动与分流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%91%BD%E8%BF%90"><span class="nav-number">7.3.2.</span> <span class="nav-text">第二阶段：三种可能的命运</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E8%BF%90%E4%B8%80%EF%BC%9A%E5%BF%AB%E8%A1%A8%E5%91%BD%E4%B8%AD-TLB-Hit-%E2%80%94%E2%80%94-%E6%9E%81%E9%80%9F%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">命运一：快表命中 (TLB Hit) —— 极速模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E8%BF%90%E4%BA%8C%EF%BC%9A%E5%BF%AB%E8%A1%A8%E6%9C%AA%E5%91%BD%E4%B8%AD%EF%BC%8C%E4%BD%86%E9%A1%B5%E8%A1%A8%E5%91%BD%E4%B8%AD-%E2%80%94%E2%80%94-%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">命运二：快表未命中，但页表命中 —— 普通模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E8%BF%90%E4%B8%89%EF%BC%9A%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-%E2%80%94%E2%80%94-%E9%BE%9F%E9%80%9F%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">命运三：缺页中断 —— 龟速模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%8E%87-Page-Fault-Rate"><span class="nav-number">7.4.</span> <span class="nav-text">缺页中断率 (Page Fault Rate)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.5.</span> <span class="nav-text">页面调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-OPT-OPTimal-replacement"><span class="nav-number">7.5.1.</span> <span class="nav-text">最佳页面调度算法(OPT, OPTimal replacement)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-FIFO-First-In-First-Out-replacement"><span class="nav-number">7.5.2.</span> <span class="nav-text">先进先出页面调度算法(FIFO, First-In First-Out replacement)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Belady%E5%BC%82%E5%B8%B8"><span class="nav-number">7.5.2.1.</span> <span class="nav-text">Belady异常</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-LRU-Least-Recently-Used-replacement"><span class="nav-number">7.5.3.</span> <span class="nav-text">最近最少使用页面调度算法(LRU, Least Recently Used replacement)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-LFU-least-frequently-used"><span class="nav-number">7.5.4.</span> <span class="nav-text">最不常用页面调度算法(LFU, least frequently used)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-Clock-Clock-policy-replacement"><span class="nav-number">7.5.5.</span> <span class="nav-text">时钟页面调度算法(Clock, Clock policy replacement)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E9%81%93%E5%85%B7-The-Setup"><span class="nav-number">7.5.5.1.</span> <span class="nav-text">1. 核心道具 (The Setup)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%AE%97%E6%B3%95%E8%A7%84%E5%88%99%EF%BC%9A%E7%BB%99%E4%B8%80%E6%AC%A1%E2%80%9C%E6%94%B9%E8%BF%87%E8%87%AA%E6%96%B0%E2%80%9D%E7%9A%84%E6%9C%BA%E4%BC%9A"><span class="nav-number">7.5.5.2.</span> <span class="nav-text">2. 算法规则：给一次“改过自新”的机会</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">7.6.</span> <span class="nav-text">段式虚拟存储管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">设备控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">8.1.1.</span> <span class="nav-text">为什么要有设备控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%B7%A8%E5%A4%A7%E7%9A%84%E9%80%9F%E5%BA%A6%E9%B8%BF%E6%B2%9F-The-Speed-Gap"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">1. 巨大的速度鸿沟 (The Speed Gap)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E2%80%9C%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C%E2%80%9D-Parallelism"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">2. 实现“并行操作” (Parallelism)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B1%8F%E8%94%BD%E8%AE%BE%E5%A4%87%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7-Abstraction"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">3. 屏蔽设备的复杂性 (Abstraction)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%EF%BC%88Polling%EF%BC%89"><span class="nav-number">8.1.2.</span> <span class="nav-text">轮询（Polling）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F-Interrupt-Driven-I-O"><span class="nav-number">8.1.3.</span> <span class="nav-text">中断驱动方式 (Interrupt-Driven I&#x2F;O)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%88DMA-Direct-Memory-Access%EF%BC%89"><span class="nav-number">8.1.4.</span> <span class="nav-text">直接存储器访问（DMA, Direct Memory Access）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%91%A8%E6%9C%9F%E7%AA%83%E5%8F%96%E2%80%9D%EF%BC%9F"><span class="nav-number">8.1.4.1.</span> <span class="nav-text">什么是“周期窃取”？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9C%E7%AA%83%E5%8F%96%E2%80%9D%E4%B8%8D%E4%BC%9A%E4%B8%A5%E9%87%8D%E6%8B%96%E6%85%A2-CPU%EF%BC%9F"><span class="nav-number">8.1.4.2.</span> <span class="nav-text">为什么“窃取”不会严重拖慢 CPU？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-number">8.1.5.</span> <span class="nav-text">三种方式对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-Channel-Control"><span class="nav-number">8.1.6.</span> <span class="nav-text">通道控制方式 (Channel Control)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E9%80%9A%E9%81%93%E2%80%9D%EF%BC%9F"><span class="nav-number">8.1.6.1.</span> <span class="nav-text">1. 核心定义：什么是“通道”？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%80%9A%E9%81%93%E7%A8%8B%E5%BA%8F-amp-%E5%9B%9B%E7%BA%A7%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.1.6.2.</span> <span class="nav-text">2. 核心机制：通道程序 &amp; 四级连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A%E9%AB%98%E5%BA%A6%E5%B9%B6%E8%A1%8C-High-Parallelism"><span class="nav-number">8.1.6.3.</span> <span class="nav-text">3. 工作流程：高度并行 (High Parallelism)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E4%B8%8EI-O"><span class="nav-number">8.2.</span> <span class="nav-text">总线与I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%BB%E7%BA%BF"><span class="nav-number">8.2.1.</span> <span class="nav-text">什么是总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-I-O-%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.2.</span> <span class="nav-text">解决 I&#x2F;O 速度不匹配问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.</span> <span class="nav-text">总线概念结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B-Single-Bus-Structure-Model"><span class="nav-number">8.3.1.</span> <span class="nav-text">单总线结构模型 (Single Bus Structure Model)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B-Three-level-Bus-Model"><span class="nav-number">8.3.2.</span> <span class="nav-text">三级总线模型 (Three-level Bus Model)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%EF%BC%9A%E5%B1%80%E9%83%A8%E6%80%BB%E7%BA%BF-Local-Bus-%E2%80%94%E2%80%94-%E2%80%9CVIP-%E4%B8%93%E7%94%A8%E9%80%9A%E9%81%93%E2%80%9D"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">第一级：局部总线 (Local Bus) —— “VIP 专用通道”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%EF%BC%9A%E4%B8%BB%E5%AD%98%E6%80%BB%E7%BA%BF-System-Bus-%E2%80%94%E2%80%94-%E2%80%9C%E5%9F%8E%E5%B8%82%E4%B8%BB%E5%B9%B2%E9%81%93%E2%80%9D"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">第二级：主存总线 (System Bus) —— “城市主干道”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%BA%A7%EF%BC%9A%E6%89%A9%E5%B1%95%E6%80%BB%E7%BA%BF-Expansion-Bus-%E2%80%94%E2%80%94-%E2%80%9C%E7%A4%BE%E5%8C%BA%E8%BE%85%E8%B7%AF%E2%80%9D"><span class="nav-number">8.3.2.3.</span> <span class="nav-text">第三级：扩展总线 (Expansion Bus) —— “社区辅路”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A%E5%90%84%E8%A1%8C%E5%85%B6%E9%81%93"><span class="nav-number">8.3.2.4.</span> <span class="nav-text">优点：各行其道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A%E6%9C%A8%E6%A1%B6%E6%95%88%E5%BA%94"><span class="nav-number">8.3.2.5.</span> <span class="nav-text">缺点：木桶效应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%97%E5%8C%97%E6%A1%A5%E6%9E%B6%E6%9E%84%E2%80%9D-Northbridge-and-Southbridge-Architecture"><span class="nav-number">8.3.3.</span> <span class="nav-text">南北桥架构” (Northbridge and Southbridge Architecture)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5%EF%BC%9A%E5%BF%AB%E6%85%A2%E5%BD%BB%E5%BA%95%E5%88%86%E5%AE%B6"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">核心理念：快慢彻底分家</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%97%E6%A1%A5-Northbridge-%E2%80%94%E2%80%94-%E9%80%9F%E5%BA%A6%E6%8B%85%E5%BD%93"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">北桥 (Northbridge) —— 速度担当</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%97%E6%A1%A5-Southbridge-%E2%80%94%E2%80%94-%E7%AE%A1%E5%AE%B6%E6%8B%85%E5%BD%93"><span class="nav-number">8.3.3.3.</span> <span class="nav-text">南桥 (Southbridge) —— 管家担当</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%A1%A5%E9%97%B4%E6%8E%A5%E5%8F%A3-Hub-Interface"><span class="nav-number">8.3.3.4.</span> <span class="nav-text">关键接口：桥间接口 (Hub Interface)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E9%80%9F%E7%8E%87-Heterogeneity"><span class="nav-number">8.3.3.5.</span> <span class="nav-text">优点：支持不同速率 (Heterogeneity)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">8.4.</span> <span class="nav-text">I&#x2F;O 软件的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-1-%E5%B1%82%EF%BC%9A%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84-I-O-%E8%BD%AF%E4%BB%B6-User-Space-I-O-Software"><span class="nav-number">8.4.1.</span> <span class="nav-text">第 1 层：用户空间的 I&#x2F;O 软件 (User-Space I&#x2F;O Software)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-2-%E5%B1%82%EF%BC%9A%E7%8B%AC%E7%AB%8B%E4%BA%8E%E8%AE%BE%E5%A4%87%E7%9A%84-I-O-%E8%BD%AF%E4%BB%B6-Device-Independent-I-O-Software"><span class="nav-number">8.4.2.</span> <span class="nav-text">第 2 层：独立于设备的 I&#x2F;O 软件 (Device-Independent I&#x2F;O Software)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-3-%E5%B1%82%EF%BC%9AI-O-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-Device-Drivers"><span class="nav-number">8.4.3.</span> <span class="nav-text">第 3 层：I&#x2F;O 设备驱动程序 (Device Drivers)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-4-%E5%B1%82%EF%BC%9AI-O-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F-Interrupt-Handlers"><span class="nav-number">8.4.4.</span> <span class="nav-text">第 4 层：I&#x2F;O 中断处理程序 (Interrupt Handlers)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.4.5.</span> <span class="nav-text">总结：数据流动的全过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">8.5.</span> <span class="nav-text">I&#x2F;O 缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-I-O-%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F"><span class="nav-number">8.5.1.</span> <span class="nav-text">1. 核心定义：什么是 I&#x2F;O 缓冲区？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%9F%EF%BC%88%E4%BA%94%E5%A4%A7%E7%9B%AE%E7%9A%84%EF%BC%89"><span class="nav-number">8.5.2.</span> <span class="nav-text">2. 为什么要引入缓冲？（五大目的）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E7%9A%84%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%88%E7%9C%8B%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%9B%BE%EF%BC%89"><span class="nav-number">8.5.3.</span> <span class="nav-text">3. 缓冲技术的进化史（看右边的图）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E6%97%A0%E7%BC%93%E5%86%B2-No-Buffering"><span class="nav-number">8.5.3.1.</span> <span class="nav-text">(a) 无缓冲 (No Buffering)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%8D%95%E7%BC%93%E5%86%B2-Single-Buffer"><span class="nav-number">8.5.3.2.</span> <span class="nav-text">(b) 单缓冲 (Single Buffer)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%8F%8C%E7%BC%93%E5%86%B2-Double-Buffering-%E2%80%94%E2%80%94-%E4%B9%9F%E5%8F%AB%E2%80%9C%E4%B9%92%E4%B9%93%E7%BC%93%E5%86%B2%E2%80%9D"><span class="nav-number">8.5.3.3.</span> <span class="nav-text">(c) 双缓冲 (Double Buffering) —— 也叫“乒乓缓冲”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E5%A4%9A%E7%BC%93%E5%86%B2-%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2-Circular-Buffering"><span class="nav-number">8.5.3.4.</span> <span class="nav-text">(d) 多缓冲&#x2F;循环缓冲 (Circular Buffering)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E5%8D%A0%E5%9E%8B%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">8.6.</span> <span class="nav-text">独占型外围设备的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7-Device-Independence"><span class="nav-number">8.6.1.</span> <span class="nav-text">设备独立性 (Device Independence)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%97%9B%E7%82%B9%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%8A%8A%E4%BB%A3%E7%A0%81%E5%86%99%E6%AD%BB%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="nav-number">8.6.1.1.</span> <span class="nav-text">1. 核心痛点：如果把代码写死会怎样？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%BC%95%E5%85%A5%E2%80%9C%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E2%80%9D"><span class="nav-number">8.6.1.2.</span> <span class="nav-text">2. 解决方案：引入“逻辑设备”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%98%A0%E5%B0%84%E8%A1%A8-The-Mapping-Table"><span class="nav-number">8.6.1.3.</span> <span class="nav-text">3. 实现机制：映射表 (The Mapping Table)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%B8%89%E5%A4%A7%E4%BC%98%E7%82%B9-%E8%80%83%E8%AF%95%E5%BF%85%E8%80%83"><span class="nav-number">8.6.1.4.</span> <span class="nav-text">4. 三大优点 (考试必考)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.6.1.5.</span> <span class="nav-text">设备分配的数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%9E%8B%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E9%A9%B1%E5%8A%A8"><span class="nav-number">8.7.</span> <span class="nav-text">共享型外围设备的驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%89%A9%E7%90%86%E7%BB%84%E4%BB%B6%EF%BC%9A%E6%90%AD%E5%BB%BA%E2%80%9C%E5%A4%9A%E5%B1%82%E8%9B%8B%E7%B3%95%E2%80%9D"><span class="nav-number">8.7.1.</span> <span class="nav-text">1. 物理组件：搭建“多层蛋糕”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86%EF%BC%9A%E7%94%BB%E5%9C%88%E5%9C%88"><span class="nav-number">8.7.2.</span> <span class="nav-text">2. 数据划分：画圈圈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%9F%B1%E9%9D%A2-Cylinder-%E2%80%94%E2%80%94-%E8%80%83%E8%AF%95%E5%BF%85%E8%80%83"><span class="nav-number">8.7.3.</span> <span class="nav-text">3. 核心概念：柱面 (Cylinder) —— 考试必考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%A3%81%E7%9B%98%E5%AF%BB%E5%9D%80%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%9D%97%EF%BC%9F"><span class="nav-number">8.7.4.</span> <span class="nav-text">4. 磁盘寻址：如何找到一个数据块？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%EF%BC%88%E6%89%87%E5%8C%BA%E7%BC%96%E5%8F%B7%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="nav-number">8.7.5.</span> <span class="nav-text">地址转换关系（扇区编号从0开始）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4"><span class="nav-number">8.8.</span> <span class="nav-text">磁盘存取时间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4-T-s-%E2%80%94%E2%80%94-%E2%80%9C%E6%9C%80%E8%80%97%E6%97%B6%E7%9A%84%E8%B5%B6%E8%B7%AF%E2%80%9D"><span class="nav-number">8.8.1.</span> <span class="nav-text">第一部分：寻道时间 ($T_s$) —— “最耗时的赶路”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%97%8B%E8%BD%AC%E5%BB%B6%E8%BF%9F-frac-1-2r-%E2%80%94%E2%80%94-%E2%80%9C%E5%B9%B3%E5%9D%87%E8%BF%90%E6%B0%94%E2%80%9D"><span class="nav-number">8.8.2.</span> <span class="nav-text">第二部分：旋转延迟 ($\frac{1}{2r}$) —— “平均运气”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4-frac-b-rN-%E2%80%94%E2%80%94-%E2%80%9C%E7%9C%9F%E6%AD%A3%E7%9A%84%E8%AF%BB%E5%86%99%E2%80%9D"><span class="nav-number">8.8.3.</span> <span class="nav-text">第三部分：传输时间 ($\frac{b}{rN}$) —— “真正的读写”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E8%87%82%E8%B0%83%E5%BA%A6%E5%8F%8A%E7%AE%97%E6%B3%95"><span class="nav-number">8.9.</span> <span class="nav-text">移臂调度及算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95"><span class="nav-number">8.9.1.</span> <span class="nav-text">先来先服务算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E6%9F%A5%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="nav-number">8.9.2.</span> <span class="nav-text">最短查找时间优先算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="nav-number">8.9.3.</span> <span class="nav-text">单向扫描算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="nav-number">8.9.4.</span> <span class="nav-text">双向扫描算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">8.9.5.</span> <span class="nav-text">电梯调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-number">8.10.</span> <span class="nav-text">旋转调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%BA%8F"><span class="nav-number">8.10.1.</span> <span class="nav-text">循环排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%88%86%E5%B8%83%EF%BC%88%E4%BA%A4%E6%9B%BF%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">8.10.2.</span> <span class="nav-text">优化分布（交替排序）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统 | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-23 20:47:14" itemprop="dateModified" datetime="2025-12-23T20:47:14+08:00">2025-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="本文总阅读量 far fa-eye 次"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h3><h4 id="并发性-Concurrency"><a href="#并发性-Concurrency" class="headerlink" title="并发性 (Concurrency)"></a><strong>并发性 (Concurrency)</strong></h4><p>🔍 核心定义</p>
<blockquote>
<p><strong>并发性</strong>是指两个或两个以上的事件或活动在<strong>同一时间间隔内</strong>发生。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：“同一时间间隔” ≠ “同一时刻”。它强调的是“看起来同时”，而不是“真正同时”。</li>
</ul>
<p>📌 操作系统中的体现</p>
<ol>
<li><p><strong>多个 I/O 设备同时工作</strong>：</p>
<ul>
<li>你的键盘在输入，打印机在打印，网卡在收发数据。这些设备都在“同时”工作。</li>
</ul>
</li>
<li><p><strong>I/O 和 CPU 计算同时进行</strong>：</p>
<ul>
<li>当 CPU 在计算时，I/O 设备可能在后台传输数据。CPU 不需要等待 I/O 完成，可以去处理其他任务。</li>
</ul>
</li>
<li><p><strong>内存中多个程序交替执行</strong>：</p>
<ul>
<li>这是最核心的体现。操作系统通过<strong>时间片轮转</strong>（Time-Slicing）等调度算法，让多个程序“轮流”使用 CPU，从而实现“宏观上的并发”。</li>
</ul>
</li>
</ol>
<p>🖼️ 并发 vs 并行</p>
<p>这是你 PPT 中提出的关键问题！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">并发 (Concurrency)</th>
<th style="text-align:left">并行 (Parallelism)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义</strong></td>
<td style="text-align:left">多个任务在<strong>同一时间间隔内</strong>交替执行。</td>
<td style="text-align:left">多个任务在<strong>同一时刻</strong>真正同时执行。</td>
</tr>
<tr>
<td style="text-align:left"><strong>物理基础</strong></td>
<td style="text-align:left">单 CPU 系统即可实现。</td>
<td style="text-align:left">需要多核 CPU 或多处理器系统。</td>
</tr>
<tr>
<td style="text-align:left"><strong>效果</strong></td>
<td style="text-align:left">“看起来”同时进行。</td>
<td style="text-align:left">“真正”同时进行。</td>
</tr>
<tr>
<td style="text-align:left"><strong>类比</strong></td>
<td style="text-align:left">一个人在厨房里，一会儿切菜，一会儿炒菜，一会儿洗碗。</td>
<td style="text-align:left">三个人在厨房里，一个人切菜，一个人炒菜，一个人洗碗。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>✅ <strong>一句话总结</strong>：<strong>并行是并发的一种特例</strong>。并发是“逻辑上的同时”，并行是“物理上的同时”。</p>
</blockquote>
<h4 id="共享性-Sharing"><a href="#共享性-Sharing" class="headerlink" title="共享性 (Sharing)"></a><strong>共享性 (Sharing)</strong></h4><p>🔍 核心定义</p>
<blockquote>
<p><strong>共享性</strong>指操作系统中的资源（包括硬件资源和软件资源）可被<strong>多个并发执行的进程共同使用</strong>，而不是被一个进程所独占。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：共享不等于“无限制访问”，它必须在<strong>操作系统管理下</strong>进行，以保证安全和有序。</li>
</ul>
<p>📌 资源共享的方式</p>
<p>1️⃣ 透明资源共享 / 同时共享方式</p>
<ul>
<li><strong>含义</strong>：允许多个进程在<strong>同一时间段内</strong>对资源进行访问，好像每个进程都独占资源一样。</li>
<li><strong>特点</strong>：<ul>
<li>访问的次序对结果无影响。</li>
<li>通常用于<strong>可重入</strong>或<strong>只读</strong>的资源。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li><strong>CPU</strong>：通过时间片轮转，让多个进程“同时”使用 CPU。</li>
<li><strong>主存 (RAM)</strong>：多个进程的代码和数据可以同时存在于内存中。</li>
<li><strong>磁盘</strong>：多个进程可以同时读取磁盘上的不同文件。</li>
<li><strong>打印机</strong>：虽然物理上一次只能打印一个任务，但操作系统可以通过“打印队列”实现逻辑上的“同时共享”。</li>
</ul>
</li>
</ul>
<p>2️⃣ 独占资源共享 / 互斥共享方式</p>
<ul>
<li><strong>含义</strong>：在<strong>同一时间段内</strong>只允许<strong>一个进程</strong>访问资源。</li>
<li><strong>特点</strong>：<ul>
<li>这类资源称为<strong>临界资源 (Critical Resource)</strong>。</li>
<li>必须通过<strong>互斥机制</strong>（如锁、信号量）来保护。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li><strong>磁带机</strong>：一次只能由一个进程控制。</li>
<li><strong>扫描仪</strong>：一次只能扫描一份文档。</li>
<li><strong>数据库中的某一行记录</strong>：如果两个事务同时修改同一行，会导致数据不一致。</li>
</ul>
</li>
</ul>
<p>🛠️ 操作系统如何管理共享？</p>
<ul>
<li><strong>提供显式资源共享机制</strong>：如 <code>fork()</code>, <code>semaphore</code>, <code>mutex</code>, <code>lock</code> 等系统调用。</li>
<li><strong>将互斥访问下放给用户决策</strong>：程序员需要自己负责加锁和解锁，操作系统提供工具。</li>
</ul>
<h4 id="异步性-Asynchrony"><a href="#异步性-Asynchrony" class="headerlink" title="异步性 (Asynchrony)"></a>异步性 (Asynchrony)</h4><p>🔍 核心定义</p>
<blockquote>
<p><strong>异步性</strong>指在多道程序环境中，由于资源有限而进程众多，多数情况下，进程的执行不是一气呵成，而是“走走停停”。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：进程的执行是不可预测的，它的推进速度取决于系统调度、I/O 等待、中断等多种因素。</li>
</ul>
<p>📌 异步性的表现</p>
<ol>
<li><p><strong>作业到达系统的时间和类型不确定</strong>：</p>
<ul>
<li>用户随时可能启动一个新程序。</li>
</ul>
</li>
<li><p><strong>操作员发出命令或操作的时间和类型不确定</strong>：</p>
<ul>
<li>用户可能随时按下键盘或点击鼠标。</li>
</ul>
</li>
<li><p><strong>程序运行发生错误或异常的类型和时刻不确定</strong>：</p>
<ul>
<li>程序可能因为除零、内存溢出等原因崩溃。</li>
</ul>
</li>
<li><p><strong>中断事件发生的时刻不确定</strong>：</p>
<ul>
<li>时钟中断、I/O 中断、硬件故障中断等都是随机发生的。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[并发性] --&gt; B[多个任务同时执行]</span><br><span class="line">    C[共享性] --&gt; D[资源被多个任务共同使用]</span><br><span class="line">    E[异步性] --&gt; F[任务执行“走走停停”]</span><br><span class="line"></span><br><span class="line">    B &amp; D &amp; F --&gt; G[现代操作系统的核心特征]</span><br><span class="line">    G --&gt; H[实现多任务、多用户环境]</span><br></pre></td></tr></table></figure>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><blockquote>
<p><strong>多道程序设计</strong>是指允许多个程序<strong>同时</strong>驻留在内存中，并由操作系统<strong>统一管理和调度</strong>，使它们<strong>交替</strong>（并发）地使用 CPU 和其他系统资源。 </p>
</blockquote>
<ul>
<li><strong>核心目的</strong>：<strong>掩盖 I/O 等待时间，提高 CPU 和系统资源的利用率</strong>。</li>
<li><strong>终极目标</strong>：让昂贵的 CPU <strong>永远不要闲着</strong>！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 单道程序 vs 多道程序</span><br><span class="line">    dateFormat  HH:mm:ss</span><br><span class="line">    axisFormat  %Ss</span><br><span class="line"></span><br><span class="line">    section 单道程序</span><br><span class="line">    作业A-CPU     :crit, a1, 00:00:00, 2s</span><br><span class="line">    作业A-I/O     :active, a2, after a1, 8s</span><br><span class="line">    作业A-CPU     :crit, a3, after a2, 2s</span><br><span class="line">    作业A-I/O     :active, a4, after a3, 8s</span><br><span class="line"></span><br><span class="line">    section 多道程序</span><br><span class="line">    作业A-CPU     :crit, b1, 00:00:00, 2s</span><br><span class="line">    作业B-CPU     :crit, b2, after b1, 2s</span><br><span class="line">    作业C-CPU     :crit, b3, after b2, 2s</span><br><span class="line">    作业A-I/O     :active, b4, after b1, 8s</span><br><span class="line">    作业B-I/O     :active, b5, after b2, 8s</span><br><span class="line">    作业C-I/O     :active, b6, after b3, 8s</span><br></pre></td></tr></table></figure>
<p><strong>对比</strong>：在多道程序中，当作业 A 在等待 I/O 时，CPU 立刻去执行作业 B 和 C。CPU 几乎没有空闲时间，利用率接近 100%！</p>
<h4 id="cpu利用率"><a href="#cpu利用率" class="headerlink" title="cpu利用率"></a>cpu利用率</h4><p><code>CPU利用率 = 1 - p^n</code> </p>
<p>🔍 假设条件</p>
<ol>
<li><strong>系统中有 <code>n</code> 个程序</strong> 同时在内存中。</li>
<li><strong>每个程序平均有 <code>p</code> 的概率在等待 I/O 操作</strong>。<ul>
<li>例如，<code>p = 0.8</code> 表示一个程序有 80% 的时间在等磁盘读写、键盘输入等，只有 20% 的时间在真正使用 CPU。</li>
</ul>
</li>
<li><strong>各个程序的等待操作是相互独立的</strong>。<ul>
<li>这是一个关键假设，意味着一个程序是否在等 I/O，不影响其他程序。</li>
</ul>
</li>
</ol>
<p>💡 公式推导</p>
<ul>
<li><strong>CPU 空闲的概率</strong>：当且仅当<strong>所有 <code>n</code> 个程序都在等待 I/O</strong> 时，CPU 才会空闲。</li>
<li>因为每个程序等待 I/O 的概率是 <code>p</code>，且它们相互独立，所以<strong>所有 <code>n</code> 个程序都等待 I/O 的概率是 <code>p^n</code></strong>。</li>
<li><strong>因此，CPU 空闲的概率 = <code>p^n</code></strong>。</li>
<li><strong>CPU 利用率 = 1 - CPU 空闲的概率 = <code>1 - p^n</code></strong>。</li>
</ul>
<p>若进程平均花费 80% 的时间等待 I/O，则为了使得 CPU 利用率不低于 80%，应至少有多少道程序在主存中运行？</p>
<h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>根据公式：</p>
<p>CPU利用率 = 1 - p^n ≥ 0.8</p>
<p>移项得：</p>
<p>p^n ≤ 0.2</p>
<p>代入 <code>p = 0.8</code>：</p>
<p>0.8^n ≤ 0.2</p>
<p>两边取对数（以 10 为底或自然对数均可）：</p>
<p>n * log(0.8) ≤ log(0.2)</p>
<p>注意：<code>log(0.8)</code> 是负数，所以在除的时候要<strong>反转不等号方向</strong>：</p>
<p>n ≥ log(0.2) / log(0.8)</p>
<p>计算数值：</p>
<ul>
<li><code>log(0.2) ≈ -0.69897</code></li>
<li><code>log(0.8) ≈ -0.09691</code></li>
<li><code>n ≥ (-0.69897) / (-0.09691) ≈ 7.21</code></li>
</ul>
<p>因为 <code>n</code> 必须是整数，且要满足 <code>n ≥ 7.21</code>，所以：</p>
<blockquote>
<p><strong><code>n = 8</code></strong> </p>
</blockquote>
<p>✅ 最终答案</p>
<p><strong>为了使得 CPU 利用率不低于 80%，应至少有 8 道程序在主存中运行。</strong></p>
<h4 id="是不是同时运行的程序越多越好？"><a href="#是不是同时运行的程序越多越好？" class="headerlink" title="是不是同时运行的程序越多越好？"></a>是不是同时运行的程序越多越好？</h4><p><strong>不是！同时运行的程序（道数）并不是越多越好。存在一个最优的“道数”，超过这个值，系统的整体效率反而会下降。</strong> </p>
<p>当道数 <code>n</code> 超过某个临界值后，系统性能会急剧下降。主要原因有：</p>
<p>1️⃣ <strong>上下文切换开销 (Context Switching Overhead)</strong></p>
<p><strong>什么是上下文切换？</strong></p>
<ul>
<li>当操作系统从一个进程切换到另一个进程时，它需要保存当前进程的状态（寄存器、内存映射、程序计数器等），并加载下一个进程的状态。</li>
</ul>
<p>2️⃣ <strong>内存压力 (Memory Pressure)</strong></p>
<ul>
<li><strong>每个进程都需要内存</strong>：代码段、数据段、堆、栈、页表等。</li>
</ul>
<p>3️⃣ <strong>资源竞争加剧 (Resource Contention)</strong></p>
<ul>
<li><strong>锁竞争</strong>：多个进程同时访问共享资源（如数据库连接池、文件锁），需要排队等待，增加了延迟。</li>
<li><strong>缓存失效</strong>：多个进程的指令和数据交替进入 CPU 缓存，导致缓存命中率降低，CPU 需要更频繁地从内存读取数据。</li>
</ul>
<h3 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h3><h4 id="为什么需要两种处理器状态？"><a href="#为什么需要两种处理器状态？" class="headerlink" title="为什么需要两种处理器状态？"></a>为什么需要两种处理器状态？</h4><p>现代计算机是一个多用户、多任务的环境。如果所有程序都能随意执行任何指令，那么一个不小心的 bug 或一个恶意程序就可能：</p>
<ul>
<li>格式化硬盘。</li>
<li>修改系统时间。</li>
<li>访问其他用户的隐私数据。</li>
<li>导致系统崩溃。</li>
</ul>
<p>为了避免这种情况，CPU 被设计成有两种工作模式：</p>
<ol>
<li><strong>用户态 (User Mode)</strong>：普通程序运行的状态，只能执行“安全”的指令。</li>
<li><strong>核心态 (Kernel Mode / Supervisor Mode)</strong>：操作系统内核运行的状态，可以执行所有指令，包括“危险”的特权指令。</li>
</ol>
<h4 id="程序状态字-PSW"><a href="#程序状态字-PSW" class="headerlink" title="程序状态字 (PSW)"></a>程序状态字 (PSW)</h4><p><strong>Program Status Word (PSW)</strong> 是一个非常重要的寄存器。</p>
<ul>
<li><strong>定义</strong>：PSW 是 CPU 内部的一个特殊寄存器，用于存储当前处理器的各种状态信息。</li>
<li><strong>关键作用</strong>：PSW 中有一个<strong>标志位</strong>（通常是最高位或某一位），用来标识当前 CPU 处于<strong>用户态还是核心态</strong>。<ul>
<li><code>PSW[bit] = 0</code> → 用户态</li>
<li><code>PSW[bit] = 1</code> → 核心态</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ <strong>这就是 CPU 判断当前是否可以执行特权指令的依据！</strong> </p>
</blockquote>
<p>当 CPU 执行一条指令时，它会检查 PSW 中的这个标志位：</p>
<ul>
<li>如果是<strong>用户态</strong>，并且指令是<strong>特权指令</strong>，则触发一个<strong>异常 (Exception)</strong>，操作系统会介入处理（通常是终止该程序）。</li>
<li>如果是<strong>核心态</strong>，则允许执行。</li>
</ul>
<h4 id="CPU-如何判断当前是否可以执行特权指令？"><a href="#CPU-如何判断当前是否可以执行特权指令？" class="headerlink" title="CPU 如何判断当前是否可以执行特权指令？"></a>CPU 如何判断当前是否可以执行特权指令？</h4><p><strong>答案</strong>：CPU 通过检查 <strong>程序状态字 (PSW)</strong> 中的一个特定标志位来判断。</p>
<ul>
<li>如果该标志位表示当前处于<strong>用户态</strong>，并且遇到的是<strong>特权指令</strong>，则 CPU 会触发一个<strong>异常</strong>（通常是“非法指令”或“特权指令违规”），并将控制权交给操作系统内核。</li>
<li>操作系统内核会根据情况决定是终止该程序，还是进行其他处理。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116191358137.png" alt="image-20251116191358137"></p>
<h2 id="进程控制和管理"><a href="#进程控制和管理" class="headerlink" title="进程控制和管理"></a>进程控制和管理</h2><h3 id="进程定义与属性"><a href="#进程定义与属性" class="headerlink" title="进程定义与属性"></a>进程定义与属性</h3><p>进程（Process）是<strong>程序在计算机上的一次执行</strong>实例，是<strong>操作系统进行资源分配、调度和保护的基本单位</strong>。</p>
<h4 id="为什么要引入“进程”？"><a href="#为什么要引入“进程”？" class="headerlink" title="为什么要引入“进程”？"></a>为什么要引入“进程”？</h4><p>1️⃣ <strong>刻画系统的动态性（Dynamic Nature）</strong></p>
<ul>
<li><strong>问题</strong>：程序是静态的代码，无法描述“执行中”的状态。</li>
<li><strong>解决方案</strong>：进程是一个<strong>动态实体</strong>，它有生命周期（创建 → 运行 → 阻塞 → 终止）。</li>
<li><strong>意义</strong>：操作系统可以精确跟踪每个任务的当前状态，做出调度决策。</li>
</ul>
<p>2️⃣ <strong>发挥系统的并发性（Concurrency）</strong></p>
<ul>
<li><strong>问题</strong>：CPU 和 I/O 设备速度不匹配。程序在等待 I/O（如读文件、网络请求）时，CPU 就空闲了。</li>
<li><strong>解决方案</strong>：通过<strong>进程切换</strong>，让 CPU 在等待期间去执行其他任务。</li>
<li><strong>意义</strong>：提高了 CPU 利用率和系统吞吐量。</li>
</ul>
<p>3️⃣ <strong>解决资源共享与隔离的矛盾</strong></p>
<ul>
<li><strong>问题</strong>：多个程序可能需要共享资源（如文件、打印机），但又不能互相干扰。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>共享性</strong>：进程可以通过合法机制（如共享内存、消息队列）共享资源。</li>
<li><strong>独立性/保护性</strong>：每个进程拥有独立的地址空间，操作系统通过内存管理单元（MMU）确保 A 进程不能访问 B 进程的内存。</li>
</ul>
</li>
<li><strong>意义</strong>：既实现了协作，又保证了安全和稳定。</li>
</ul>
<h4 id="进程的五大核心属性"><a href="#进程的五大核心属性" class="headerlink" title="进程的五大核心属性"></a>进程的五大核心属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 动态性</strong></td>
<td>进程是动态的，有生命周期（创建 → 运行 → 阻塞 → 终止）。</td>
<td><code>uvicorn</code> 启动时创建进程，<code>Ctrl+C</code> 终止时销毁进程。</td>
</tr>
<tr>
<td><strong>2. 并发性</strong></td>
<td>多个进程可以“同时”运行（宏观并发，微观交替）。</td>
<td>一台服务器同时处理成百上千个用户的 HTTP 请求。</td>
</tr>
<tr>
<td><strong>3. 独立性</strong></td>
<td>每个进程有独立的地址空间和资源，互不干扰。</td>
<td>一个 Python 进程崩溃，不会导致另一个 Python 进程退出。</td>
</tr>
<tr>
<td><strong>4. 制约性</strong></td>
<td>进程间可能存在同步或互斥关系（如竞争资源、等待结果）。</td>
<td>多个进程写同一个日志文件，需要用文件锁避免内容错乱。</td>
</tr>
<tr>
<td><strong>5. 共享性</strong></td>
<td>进程可以通过操作系统提供的机制共享资源（如内存、文件）。</td>
<td>多个 FastAPI worker 进程共享一个 Redis 缓存连接池。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><h4 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204410504.png" alt="image-20251115204410504"></p>
<h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204451732.png" alt="image-20251115204451732"></p>
<p>七态模型在五态模型的基础上，<strong>显式增加了“挂起（Suspend）”的概念</strong></p>
<blockquote>
<p>挂起 = 进程被换出到外存（Swap）</p>
<ul>
<li><strong>目的</strong>：当系统内存紧张时，操作系统会将一些<strong>暂时不活跃</strong>的进程（比如长时间阻塞的进程）从内存移到硬盘上的“交换区（Swap Space）”，以腾出内存给更紧急的任务。</li>
</ul>
</blockquote>
<p><strong>挂起就绪态 (Ready/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程具备运行条件（即它已经准备好执行），但目前在外存中。只有当它被换入内存后，才能被调度器选中运行。</strong> </p>
</blockquote>
<p><strong>挂起等待态 (Blocked/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程正在等待某一个事件发生（如 I/O 完成、用户输入、网络响应），并且目前在外存中。</strong> </p>
</blockquote>
<h3 id="进程描述和组成"><a href="#进程描述和组成" class="headerlink" title="进程描述和组成"></a>进程描述和组成</h3><h4 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h4><p><strong>进程映像（Process Image）是指进程在内存中的完整内容，包括代码、数据、堆、栈以及内核数据结构（如 PCB）等所有组成部分的集合。</strong></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210257885.png" alt="image-20251115210257885"></p>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210715693.png" alt="image-20251115210715693"></p>
<blockquote>
<p>寄存器上下文 (Register Context)<strong>存储在 PCB 中</strong><br><strong>包含：通用寄存器、程序计数器、栈指针、程序状态字</strong> </p>
<p>这是进程“灵魂”的一部分——CPU 执行时最直接依赖的状态。</p>
</blockquote>
<h4 id="PCB（Process-Control-Block，进程控制块）"><a href="#PCB（Process-Control-Block，进程控制块）" class="headerlink" title="PCB（Process Control Block，进程控制块）"></a><strong>PCB（Process Control Block，进程控制块）</strong></h4><p><strong>PCB 是操作系统为每个进程创建的一个数据结构，用来记录和刻画该进程的所有状态和相关信息。</strong></p>
<p>1️⃣ <strong>进程标识信息 (Identification Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PID (Process ID)</strong></td>
<td>进程的唯一数字标识，如 <code>12345</code>。</td>
</tr>
<tr>
<td><strong>PPID (Parent PID)</strong></td>
<td>父进程的 PID，用于构建进程树。</td>
</tr>
<tr>
<td><strong>UID/GID (User/Group ID)</strong></td>
<td>进程所属用户的 ID 和组 ID，用于权限控制。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🌰 <strong>你的例子</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前进程 PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;父进程 PID: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br>这些值就是从 PCB 中读取的！</p>
</blockquote>
<p>2️⃣ <strong>处理器状态信息 (Processor State Information)</strong> —— <strong>这就是“寄存器上下文”</strong></p>
<p>这是 PCB 最关键的部分，用于<strong>上下文切换</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>程序计数器 (PC)</strong></td>
<td>下一条要执行的指令地址。</td>
</tr>
<tr>
<td><strong>通用寄存器 (AX, BX, CX…)</strong></td>
<td>存放临时计算结果、变量地址等。</td>
</tr>
<tr>
<td><strong>程序状态字 (PSW)</strong></td>
<td>包含标志位（零标志 Z、进位标志 C、溢出标志 O 等）、中断允许位、特权级别。</td>
</tr>
<tr>
<td><strong>栈指针 (SP)</strong></td>
<td>指向当前函数调用栈的顶部。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>⚡ <strong>关键点</strong>：每次进程切换时，操作系统都会将当前 CPU 寄存器的值“倾倒”进 PCB，再从新进程的 PCB “倒回”寄存器。这就是“上下文切换”的核心开销。</p>
</blockquote>
<p>3️⃣ <strong>进程调度信息 (Scheduling Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程状态</strong></td>
<td>就绪、运行、阻塞、挂起等。</td>
</tr>
<tr>
<td><strong>进程优先级</strong></td>
<td>决定调度顺序。</td>
</tr>
<tr>
<td><strong>时间片剩余量</strong></td>
<td>用于时间片轮转调度。</td>
</tr>
<tr>
<td><strong>等待事件</strong></td>
<td>如等待键盘输入、网络数据包到达等。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🌰 <strong>你的例子</strong>：<br>在 FastAPI 中，当一个请求在 <code>await httpx.get(...)</code> 时，其对应协程/线程的状态会被标记为“阻塞”，并被放入等待队列。这就是 PCB 中“进程状态”字段的作用。</p>
</blockquote>
<p>4️⃣ <strong>内存管理信息 (Memory Management Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>页表基址 / 段表指针</strong></td>
<td>用于虚拟内存到物理内存的地址转换。</td>
</tr>
<tr>
<td><strong>内存分配情况</strong></td>
<td>代码段、数据段、堆、栈的起始地址和大小。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>💡 <strong>关键点</strong>：确保进程访问的是自己的内存空间，实现“内存保护”。</p>
</blockquote>
<p>5️⃣ <strong>I/O 状态信息 (I/O Status Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>打开的文件列表</strong></td>
<td>文件描述符（fd）、文件指针、访问模式等。</td>
</tr>
<tr>
<td><strong>分配的 I/O 设备</strong></td>
<td>如打印机、网卡等。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🌰 <strong>你的例子</strong>：<br>当你在 Python 中 <code>f = open(&quot;log.txt&quot;, &quot;a&quot;)</code> 时，操作系统会在 PCB 的“打开文件列表”中添加一条记录，记录这个文件句柄 <code>f</code> 对应的 fd。</p>
</blockquote>
<p>6️⃣ <strong>记账信息 (Accounting Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU 使用时间</strong></td>
<td>进程已使用的 CPU 时间总和。</td>
</tr>
<tr>
<td><strong>累计运行时间</strong></td>
<td>从创建到现在的总时间。</td>
</tr>
<tr>
<td><strong>最大内存使用量</strong></td>
<td>历史峰值。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>📊 <strong>用途</strong>：用于性能监控、计费、调试等。</p>
</blockquote>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><h4 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212223846.png" alt="image-20251115212223846"></p>
<h4 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212241091.png" alt="image-20251115212241091"></p>
<h3 id="进程切换和处理器状态转换"><a href="#进程切换和处理器状态转换" class="headerlink" title="进程切换和处理器状态转换"></a>进程切换和处理器状态转换</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212521578.png" alt="image-20251115212521578"></p>
<h4 id="模式切换-vs-进程切换"><a href="#模式切换-vs-进程切换" class="headerlink" title="模式切换 vs. 进程切换"></a>模式切换 vs. 进程切换</h4><ol>
<li>模式切换 (Mode Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：CPU 在“用户态（User Mode）”和“核心态（Kernel Mode）”之间的切换。 <strong>触发方式</strong>：由<strong>中断（Interrupt）或系统调用（System Call）</strong> 引起。 <strong>目的</strong>：让操作系统获得控制权，执行特权指令（如访问硬件、修改内存映射）。 </p>
</blockquote>
<ol>
<li>进程切换 (Process Switch / Context Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：操作系统暂停当前正在运行的进程，保存其状态，并加载另一个进程的状态，使其开始运行。 <strong>触发方式</strong>：通常发生在<strong>核心态</strong>下，由中断或系统调用引发。 <strong>目的</strong>：实现多任务并发，公平分配 CPU 时间。 </p>
</blockquote>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115215300054.png" alt="image-20251115215300054"></p>
<h4 id="当进程开始运行时，操作系统如何重新获得控制？"><a href="#当进程开始运行时，操作系统如何重新获得控制？" class="headerlink" title="当进程开始运行时，操作系统如何重新获得控制？"></a>当进程开始运行时，操作系统如何重新获得控制？</h4><p>果进程一直在运行，操作系统就永远没机会调度其他进程了，系统就会卡死。</p>
<p><strong>答案：中断 (Interrupt) 是关键！</strong></p>
<ul>
<li><strong>什么是中断？</strong> 中断就像一个“<strong>紧急电话</strong>”，它能打断 CPU 当前正在执行的程序，强制 CPU 去处理一个更高优先级的事情——通常是操作系统内核。<ul>
<li><strong>硬件中断</strong>：由外部设备触发，比如键盘敲击、鼠标移动、网络数据包到达、定时器到期。</li>
<li><strong>软件中断/异常</strong>：由程序自身触发，比如除零错误、访问非法内存地址、或者程序主动发起的<strong>系统调用</strong>（如 <code>open()</code>, <code>read()</code>）。</li>
</ul>
</li>
</ul>
<h4 id="进程需要保存哪些状态？"><a href="#进程需要保存哪些状态？" class="headerlink" title="进程需要保存哪些状态？"></a>进程需要保存哪些状态？</h4><p>当操作系统获得控制权后，它必须把当前正在运行的进程（比如进程0）的“工作状态”完整地记录下来，以便将来能恢复执行。这个过程叫做“<strong>保存现场 (Save Context)</strong>”。</p>
<p><strong>需要保存哪些状态？</strong></p>
<p>这些状态主要存储在一个叫做 <strong>PCB (Process Control Block, 进程控制块)</strong> 的数据结构里。PCB 就像是进程的“<strong>身份证 + 工作日志 + 资源清单</strong>”。</p>
<h4 id="如何选择下一个待执行的进程-线程？"><a href="#如何选择下一个待执行的进程-线程？" class="headerlink" title="如何选择下一个待执行的进程/线程？"></a>如何选择下一个待执行的进程/线程？</h4><p>当操作系统保存完当前进程的状态后，它需要决定“<strong>接下来该让谁干活</strong>”。这个决策过程叫做“<strong>进程调度 (Process Scheduling)</strong>”。</p>
<p><strong>如何选择？</strong></p>
<p>这取决于操作系统的<strong>调度算法 (Scheduling Algorithm)</strong>。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="为什么需要线程？——-引入线程的动机"><a href="#为什么需要线程？——-引入线程的动机" class="headerlink" title="为什么需要线程？—— 引入线程的动机"></a>为什么需要线程？—— 引入线程的动机</h4><p>❓ 问题：进程模型有什么不足？</p>
<ol>
<li><strong>切换开销大</strong>：进程切换需要保存/恢复整个内存空间（代码、数据、堆、栈）和 PCB，开销大。</li>
<li><strong>通信困难</strong>：进程间通信（IPC）需要管道、消息队列、共享内存等复杂机制，效率低。</li>
<li><strong>不适合细粒度并发</strong>：比如一个 Web 服务器，每个请求都创建一个进程，成本太高。</li>
</ol>
<p>✅ 解决方案：引入线程！</p>
<blockquote>
<p><strong>线程是进程内的一个执行单元，是 CPU 调度和分派的基本单位。</strong> </p>
</blockquote>
<ul>
<li><strong>同一个进程内的所有线程</strong>：<ul>
<li><strong>共享</strong>：代码段、数据段、堆、打开的文件等<strong>进程资源</strong>。</li>
<li><strong>私有</strong>：各自的<strong>栈</strong>和<strong>寄存器上下文</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 <strong>核心价值</strong>：<strong>实现进程内部的并发，降低切换和通信开销</strong>。 </p>
</blockquote>
<h4 id="什么是线程？——-核心定义"><a href="#什么是线程？——-核心定义" class="headerlink" title="什么是线程？—— 核心定义"></a>什么是线程？—— 核心定义</h4><blockquote>
<p><strong>线程（Thread）是进程中一个可并发执行的控制流，它拥有自己独立的栈和寄存器状态，但与其他线程共享进程的地址空间和资源。</strong> </p>
</blockquote>
<h4 id="线程如何工作？——-线程的生命周期与切换"><a href="#线程如何工作？——-线程的生命周期与切换" class="headerlink" title="线程如何工作？—— 线程的生命周期与切换"></a>线程如何工作？—— 线程的生命周期与切换</h4><ol>
<li><strong>线程的生命周期状态</strong></li>
</ol>
<p>和进程类似，线程也有状态：<strong>新建 → 就绪 → 运行 → 阻塞 → 终止</strong>。</p>
<ol>
<li><strong>线程切换（Thread Switching）</strong></li>
</ol>
<ul>
<li><strong>开销远小于进程切换</strong>！因为不需要切换地址空间（页表），只需要保存/恢复<strong>寄存器上下文和栈指针</strong>。</li>
<li>切换由<strong>线程调度器</strong>（在 OS 内核或用户态库中）管理。</li>
</ul>
<ol>
<li><strong>线程的实现方式</strong></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用户级线程 (User-Level Threads)</strong></td>
<td>由用户态线程库（如 Java Green Threads）管理，内核 unaware</td>
<td>Python 的 <code>greenlet</code>（非标准）</td>
</tr>
<tr>
<td><strong>内核级线程 (Kernel-Level Threads)</strong></td>
<td>由操作系统内核直接管理，每个线程对应一个内核调度实体</td>
<td>Python 的 <code>threading</code> 模块</td>
</tr>
<tr>
<td><strong>混合模式</strong></td>
<td>用户级线程映射到少量内核线程</td>
<td>Go 的 Goroutine</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>💡 <strong>Python 的 <code>threading</code> 是内核级线程</strong>，但受 GIL 限制，无法真正并行执行 Python 字节码。</p>
</blockquote>
<h2 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2><h3 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h3><p>1️⃣ 高级调度（High-Level Scheduling）—— 作业调度 / 长程调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪些“作业”被允许进入系统参与 CPU 竞争。 <strong>对象</strong>：作业（Job）→ 通常是一个完整的程序或任务（如编译一个文件、运行一个脚本）。 <strong>发生频率</strong>：<strong>低</strong>（几分钟到几小时一次）。 <strong>执行者</strong>：操作系统内核。 </p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选作业进内存</strong>：从后备队列中选择作业，将其加载到内存，创建进程。</li>
<li><strong>控制多道程序的道数</strong>：决定同时在内存中运行多少个作业（即并发度）。太多会耗尽内存，太少会浪费 CPU。</li>
</ul>
<p>2️⃣ 中级调度（Medium-Level Scheduling）—— 平衡调度 / 内存调度</p>
<blockquote>
<p><strong>目标</strong>：根据内存状态，决定哪些进程可以在内存中运行，哪些需要换出到外存。 <strong>对象</strong>：进程（Process）。 <strong>发生频率</strong>：<strong>中等</strong>（几秒到几分钟一次）。 <strong>执行者</strong>：操作系统内核。 </p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程进出内存</strong>：当内存紧张时，将一些不活跃的进程（如长时间阻塞的进程）换出到 Swap 分区；当内存空闲时，再换回。</li>
<li><strong>平衡系统负载</strong>：防止内存溢出，提高系统吞吐量。</li>
</ul>
<p>3️⃣ 低级调度（Low-Level Scheduling）—— 进程调度 / CPU 调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪个就绪队列中的进程/线程获得 CPU 执行权。 <strong>对象</strong>：进程或线程（内核级线程）。 <strong>发生频率</strong>：<strong>高</strong>（毫秒级，每几十到几百毫秒一次）。 <strong>执行者</strong>：操作系统内核 → <strong>这是操作系统最核心的部分</strong>！ </p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程分配 CPU</strong>：从就绪队列中选出下一个要运行的进程/线程。</li>
<li><strong>执行上下文切换</strong>：保存当前进程上下文，恢复新进程上下文。</li>
<li><strong>实现公平与效率</strong>：通过调度算法（如 RR、优先级、MLFQ）保证所有进程都能得到 CPU 时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[高级调度] --&gt;|选作业进内存| B[中级调度]</span><br><span class="line">    B --&gt;|选进程进出内存| C[低级调度]</span><br><span class="line">    C --&gt;|选进程分配 CPU| D[CPU 执行]</span><br><span class="line"></span><br><span class="line">    style A fill:#f9d5e5,stroke:#333</span><br><span class="line">    style B fill:#e3eaa7,stroke:#333</span><br><span class="line">    style C fill:#b2d3c2,stroke:#333</span><br></pre></td></tr></table></figure>
<h3 id="调度算法评价指标"><a href="#调度算法评价指标" class="headerlink" title="调度算法评价指标"></a>调度算法评价指标</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116131448708.png" alt="image-20251116131448708"></p>
<h3 id="七种调度策略"><a href="#七种调度策略" class="headerlink" title="七种调度策略"></a>七种调度策略</h3><h4 id="先来先服务-First-Come-First-Serverd-FCFS"><a href="#先来先服务-First-Come-First-Serverd-FCFS" class="headerlink" title="先来先服务 (First Come First Serverd, FCFS)"></a>先来先服务 (First Come First Serverd, FCFS)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132753390.png" alt="image-20251116132753390"></p>
<h4 id="短作业优先-Shortest-Job-First-SJF"><a href="#短作业优先-Shortest-Job-First-SJF" class="headerlink" title="短作业优先 (Shortest Job First, SJF)"></a>短作业优先 (Shortest Job First, SJF)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132925377.png" alt="image-20251116132925377"></p>
<h4 id="最短剩余时间优先-Shortest-Remaining-Time-First-SRTF"><a href="#最短剩余时间优先-Shortest-Remaining-Time-First-SRTF" class="headerlink" title="最短剩余时间优先 (Shortest Remaining Time First, SRTF)"></a>最短剩余时间优先 (Shortest Remaining Time First, SRTF)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133352988.png" alt="image-20251116133352988"></p>
<h4 id="最高响应比优先-Highest-Response-Ratio-First-HRRF"><a href="#最高响应比优先-Highest-Response-Ratio-First-HRRF" class="headerlink" title="最高响应比优先 (Highest Response Ratio First, HRRF)"></a>最高响应比优先 (Highest Response Ratio First, HRRF)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133432719.png" alt="image-20251116133432719"></p>
<h4 id="优先级调度-Priority-Scheduling"><a href="#优先级调度-Priority-Scheduling" class="headerlink" title="优先级调度 (Priority Scheduling)"></a>优先级调度 (Priority Scheduling)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141512909.png" alt="image-20251116141512909"></p>
<h4 id="轮转调度-Round-Robin-Scheduling-RR"><a href="#轮转调度-Round-Robin-Scheduling-RR" class="headerlink" title="轮转调度 (Round Robin Scheduling, RR)"></a>轮转调度 (Round Robin Scheduling, RR)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141611150.png" alt="image-20251116141611150"></p>
<h4 id="多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ"><a href="#多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ" class="headerlink" title="多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)"></a>多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116144745818.png" alt="image-20251116144745818"></p>
<h2 id="并发：互斥与同步"><a href="#并发：互斥与同步" class="headerlink" title="并发：互斥与同步"></a>并发：互斥与同步</h2><h3 id="进程交互"><a href="#进程交互" class="headerlink" title="进程交互"></a><strong>进程交互</strong></h3><h4 id="为什么需要“进程交互”？"><a href="#为什么需要“进程交互”？" class="headerlink" title="为什么需要“进程交互”？"></a>为什么需要“进程交互”？</h4><p>在单进程时代，程序是“独占”的——它不需要考虑别人。但在现代操作系统中：</p>
<ul>
<li>多个进程/线程同时运行。</li>
<li>它们可能共享资源（如内存、文件、数据库连接）。</li>
<li>它们可能需要协同完成一个复杂任务（如一个 Web 请求涉及多个微服务）。</li>
</ul>
<p>这就产生了两个根本性问题：</p>
<ol>
<li><strong>竞争（Competition）</strong>：多个进程争抢同一个资源，导致结果不可预测。</li>
<li><strong>协作（Cooperation）</strong>：多个进程需要按特定顺序执行，才能完成共同目标。</li>
</ol>
<blockquote>
<p>✅ <strong>进程交互就是解决这两个问题的机制</strong>。 </p>
</blockquote>
<h4 id="竞争关系（进程互斥）"><a href="#竞争关系（进程互斥）" class="headerlink" title="竞争关系（进程互斥）"></a>竞争关系（进程互斥）</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程互斥是指若干进程因相互争夺独占型资源而产生的竞争制约关系。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“相互争夺”</strong>：多个进程都想使用同一个资源。</li>
<li><strong>“独占型资源”</strong>：一次只能被一个进程使用的资源，如打印机、临界区代码、全局变量、数据库连接等。</li>
<li><strong>“竞争制约关系”</strong>：一个进程的执行会制约另一个进程的执行。</li>
</ul>
<p>🧱 两个核心控制问题：</p>
<ol>
<li><strong>死锁问题（Deadlock）</strong><ul>
<li><strong>定义</strong>：多个进程互相等待对方释放资源，导致所有进程都无法继续执行。</li>
<li><strong>经典例子</strong>：“哲学家就餐问题”——五个哲学家围坐圆桌，每人左右各有一根筷子。他们必须拿到两根筷子才能吃饭。如果每个人都拿起左边的筷子，然后等待右边的筷子，就会陷入死锁。</li>
<li><strong>四个必要条件</strong>：<ul>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
</li>
</ul>
</li>
<li><strong>饥饿问题（Starvation）</strong><ul>
<li><strong>定义</strong>：某个进程因为优先级低或资源分配策略不当，长时间得不到所需资源，导致无法执行。</li>
<li><strong>例子</strong>：在一个高优先级任务永远不结束的系统中，低优先级任务可能永远得不到 CPU。</li>
</ul>
</li>
</ol>
<h4 id="协作关系（进程同步）"><a href="#协作关系（进程同步）" class="headerlink" title="协作关系（进程同步）"></a>协作关系（进程同步）</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程同步是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“完成共同任务”</strong>：多个进程/线程需要合作才能达成目标。</li>
<li><strong>“协调活动”</strong>：它们需要按特定顺序执行。</li>
<li><strong>“排定执行先后次序”</strong>：比如 A 必须在 B 之前执行。</li>
<li><strong>“等待、传递信号或消息”</strong>：通过同步机制（如信号量、条件变量、管道）实现通信和协调。</li>
</ul>
<p>🧱 核心思想：</p>
<ul>
<li><strong>“生产者-消费者”模型</strong>：生产者生成数据，消费者消费数据，它们必须同步。</li>
<li><strong>“读者-写者”模型</strong>：读者可以同时读，但写者必须独占。</li>
<li><strong>“屏障（Barrier）”</strong>：所有进程到达某个点后才能继续执行。</li>
</ul>
<h3 id="临界区管理"><a href="#临界区管理" class="headerlink" title="临界区管理"></a>临界区管理</h3><h4 id="什么是“临界区”？"><a href="#什么是“临界区”？" class="headerlink" title="什么是“临界区”？"></a>什么是“临界区”？</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>并发进程中，与共享变量有关的程序段叫做“临界区”（Critical Section）。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“并发进程”</strong>：多个进程/线程同时运行。</li>
<li><strong>“共享变量”</strong>：多个进程都能访问和修改的变量（如全局变量、数据库连接、文件句柄）。</li>
<li><strong>“程序段”</strong>：一段代码，比如 <code>counter += 1</code> 这样的操作。</li>
</ul>
<blockquote>
<p>💡 <strong>简单说</strong>：<strong>临界区 = 操作共享资源的那一小段代码。</strong> </p>
</blockquote>
<p>🎯 为什么重要？</p>
<p>因为这段代码如果被多个进程同时执行，会导致<strong>竞态条件（Race Condition）</strong>，产生不可预测的结果。</p>
<h4 id="如何避免错误？——-互斥访问临界区"><a href="#如何避免错误？——-互斥访问临界区" class="headerlink" title="如何避免错误？—— 互斥访问临界区"></a>如何避免错误？—— 互斥访问临界区</h4><blockquote>
<p><strong>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误。</strong> </p>
</blockquote>
<p>这就是“<strong>进程互斥</strong>”的核心思想。</p>
<h4 id="临界区调度的三个原则（经典！）"><a href="#临界区调度的三个原则（经典！）" class="headerlink" title="临界区调度的三个原则（经典！）"></a>临界区调度的三个原则（经典！）</h4><p>这是解决临界区问题的黄金法则，任何同步机制都必须满足这三个条件：</p>
<p>✅ 原则 1：一次至多一个进程能够进入临界区内执行</p>
<blockquote>
<p><strong>互斥性（Mutual Exclusion）</strong> </p>
</blockquote>
<ul>
<li>这是最基本的要求。任何时候，最多只能有一个进程在临界区内。</li>
<li>如果 A 在临界区，B 就不能进入，必须等待。</li>
</ul>
<p>✅ 原则 2：如果已有进程在临界区，其他试图进入的进程应等待</p>
<blockquote>
<p><strong>忙则等待（Progress）</strong> </p>
</blockquote>
<ul>
<li>如果临界区空闲，想进入的进程可以立即进入。</li>
<li>如果临界区被占用，其他进程必须等待，不能“自旋”浪费 CPU（虽然有些实现会自旋，但理想情况下应该阻塞等待）。</li>
</ul>
<p>✅ 原则 3：进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</p>
<blockquote>
<p><strong>有限等待（Bounded Waiting）</strong> </p>
</blockquote>
<ul>
<li>防止“饥饿”。不能让某个进程永远等下去。</li>
<li>例如，使用队列来管理等待的进程，确保每个进程最终都能获得进入临界区的机会。</li>
</ul>
<h3 id="实现临界区管理的软件方法一Peterson方法"><a href="#实现临界区管理的软件方法一Peterson方法" class="headerlink" title="实现临界区管理的软件方法一Peterson方法"></a>实现临界区管理的软件方法一Peterson方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int turn;           // turn 表示轮到谁进入</span><br><span class="line">boolean flag[2];   // flag[i] 表示进程 i 想进入临界区</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">flag[0] = flag[1] = false;</span><br><span class="line"></span><br><span class="line">Process P0() &#123;</span><br><span class="line">    flag[0] = true;</span><br><span class="line">    turn = 1;       // 谦让给 P1</span><br><span class="line">    while (flag[1] &amp;&amp; turn == 1); // 等待 P1 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process P1() &#123;</span><br><span class="line">    flag[1] = true;</span><br><span class="line">    turn = 0;       // 谦让给 P0</span><br><span class="line">    while (flag[0] &amp;&amp; turn == 0); // 等待 P0 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[1] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 1. 互斥性 (Mutual Exclusion)</p>
<blockquote>
<p><strong>定义</strong>：一次至多一个进程能进入临界区。 </p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 和 P1 同时进入临界区。</li>
<li>那么 <code>flag[0] = true</code> 且 <code>flag[1] = true</code>。</li>
<li>根据算法，P0 在进入前设置了 <code>turn = 1</code>，P1 设置了 <code>turn = 0</code>。</li>
<li>由于 <code>turn</code> 只能取值 0 或 1，不可能同时为 0 和 1。</li>
<li>所以，当 P0 检查 <code>while (flag[1] &amp;&amp; turn == 1)</code> 时，如果 <code>turn == 0</code>，它就会阻塞。</li>
<li>同理，P1 也会被阻塞。</li>
<li><strong>结论</strong>：不可能同时进入。</li>
</ul>
<p>✅ 2. 空闲让进 (Progress)</p>
<blockquote>
<p><strong>定义</strong>：如果临界区空闲，且有进程想进入，则该进程应该能进入。 </p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>如果 P1 不想进入临界区，则 <code>flag[1] = false</code>。</li>
<li>此时，无论 <code>turn</code> 是多少，P0 的 <code>while (flag[1] &amp;&amp; turn == 1)</code> 条件都会失败（因为 <code>flag[1]</code> 是 <code>false</code>），所以 P0 可以立即进入临界区。</li>
</ul>
<p>✅ 3. 有限等待 (Bounded Waiting)</p>
<blockquote>
<p><strong>定义</strong>：一个进程最多等待另一个进程执行完临界区一次，就能获得进入的机会。 </p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 被阻塞，说明 <code>turn = 1</code> 且 <code>flag[1] = true</code>，即 P1 在临界区。</li>
<li>当 P1 执行完临界区后，它会设置 <code>flag[1] = false</code>。</li>
<li>此时，如果 P0 还想进入，它的 <code>while</code> 条件会失败，从而进入临界区。</li>
<li>如果 P1 在 <code>flag[1] = false</code> 后又想进入，则它会设置 <code>flag[1] = true</code> 和 <code>turn = 0</code>。</li>
<li>此时，P0 会被阻塞，但 P1 执行完后，P0 就能进入。</li>
<li><strong>结论</strong>：P0 最多等待 P1 执行一次临界区，就能进入。</li>
</ul>
<h3 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h3><h4 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>信号量是一种软件资源，用于表示物理资源的实体，是一个与队列有关的整型变量。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“表示物理资源”</strong>：比如打印机、数据库连接池、线程池中的可用线程数。</li>
<li><strong>“整型变量”</strong>：信号量的值代表当前<strong>可用资源的数量</strong>。</li>
<li><strong>“与队列有关”</strong>：当资源不足时，等待的进程会被放入一个<strong>等待队列</strong>。</li>
</ul>
<h4 id="P-V-操作：信号量的“原子操作”"><a href="#P-V-操作：信号量的“原子操作”" class="headerlink" title="P/V 操作：信号量的“原子操作”"></a>P/V 操作：信号量的“原子操作”</h4><p>✅ 定义：</p>
<blockquote>
<p><strong>P (Proberen, 尝试) 和 V (Verhogen, 增加) 是对信号量进行操作的原语。</strong> </p>
</blockquote>
<ul>
<li><strong>P 操作</strong>：尝试获取资源。如果资源可用（信号量 &gt; 0），则减 1；否则，进程进入等待队列。</li>
<li><strong>V 操作</strong>：释放资源。增加信号量值，并唤醒一个等待的进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// P 操作 (Wait)</span><br><span class="line">void P(semaphore s) &#123;</span><br><span class="line">    s.value = s.value - 1;</span><br><span class="line">    if (s.value &lt; 0) &#123;</span><br><span class="line">        // 资源不足，将当前进程加入等待队列并阻塞</span><br><span class="line">        block(current_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// V 操作 (Signal)</span><br><span class="line">void V(semaphore s) &#123;</span><br><span class="line">    s.value = s.value + 1;</span><br><span class="line">    if (s.value &lt;= 0) &#123;</span><br><span class="line">        // 有进程在等待，唤醒一个</span><br><span class="line">        wakeup(one_waiting_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ <strong>关键点</strong>：P/V 操作必须是<strong>原子操作（Atomic Operation）</strong>，即在执行过程中不能被中断。否则会导致竞态条件。 </p>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><h4 id="哲学家进餐问题：核心描述"><a href="#哲学家进餐问题：核心描述" class="headerlink" title="哲学家进餐问题：核心描述"></a>哲学家进餐问题：核心描述</h4><p>✅ 问题设定：</p>
<ul>
<li>有 <strong>5 位哲学家</strong> 围坐在一张圆桌旁。</li>
<li>每位哲学家面前有一盘<strong>意大利面</strong>。</li>
<li>桌子上有 <strong>5 把叉子</strong>，每两位哲学家之间放一把。</li>
<li>哲学家的生活只有两件事：<ul>
<li><strong>思考（Think）</strong>：什么都不做。</li>
<li><strong>吃饭（Eat）</strong>：必须同时拿到<strong>左右两边的叉子</strong>才能吃。</li>
</ul>
</li>
<li>吃完后，会放下叉子，继续思考。</li>
</ul>
<blockquote>
<p>💡 <strong>目标</strong>：设计一个算法，让所有哲学家都能吃饱，且不会发生死锁或饥饿。 </p>
</blockquote>
<h4 id="为什么会出现死锁？"><a href="#为什么会出现死锁？" class="headerlink" title="为什么会出现死锁？"></a>为什么会出现死锁？</h4><p>📌 死锁的四个必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：叉子一次只能被一个人使用。</li>
<li><strong>请求与保持条件</strong>：哲学家拿起一把叉子后，会继续等待另一把。</li>
<li><strong>不剥夺条件</strong>：不能强行从哲学家手中拿走叉子。</li>
<li><strong>环路等待条件</strong>：每位哲学家都在等右边的人放下叉子，形成一个循环等待链。</li>
</ol>
<h4 id="解决方案：打破死锁的四个条件之一"><a href="#解决方案：打破死锁的四个条件之一" class="headerlink" title="解决方案：打破死锁的四个条件之一"></a>解决方案：打破死锁的四个条件之一</h4><p>要避免死锁，只需破坏其中一个必要条件即可。以下是几种经典的解决方案：</p>
<p>✅ 解决方案 1：限制同时就餐的哲学家数量（破坏“环路等待”）</p>
<blockquote>
<p><strong>最多允许 4 位哲学家同时吃面。</strong> </p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>如果只有 4 个人尝试拿叉子，那么至少有一把叉子是空闲的。</li>
<li>这样，总会有一个人能拿到两把叉子并吃完，从而释放资源。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 5 把叉子（信号量）</span><br><span class="line">forks = [threading.Semaphore(1) for _ in range(5)]</span><br><span class="line"># 限制同时就餐人数为 4</span><br><span class="line">dining_room = threading.Semaphore(4)</span><br><span class="line"></span><br><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        dining_room.acquire()  # 进入餐厅（最多 4 人）</span><br><span class="line">        </span><br><span class="line">        forks[i].acquire()       # 拿起左边叉子</span><br><span class="line">        forks[(i + 1) % 5].acquire()  # 拿起右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()       # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()  # 放下右边叉子</span><br><span class="line">        </span><br><span class="line">        dining_room.release()    # 离开餐厅</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">def eat(i):</span><br><span class="line">    print(f&quot;Philosopher &#123;i&#125; is eating...&quot;)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line"># 创建 5 个哲学家线程</span><br><span class="line">threads = []</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=philosopher, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 2：奇偶号哲学家取叉子顺序不同（破坏“环路等待”）</p>
<blockquote>
<p><strong>奇数号哲学家先取左边叉子，再取右边；偶数号哲学家先取右边叉子，再取左边。</strong> </p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>这样就不会形成环路等待。</li>
<li>例如，哲学家 0（偶数）先拿右边叉子（叉子 1），哲学家 1（奇数）先拿左边叉子（叉子 1）→ 他们争抢同一把叉子，但最终只会有一个成功，另一个等待，从而打破环路。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        </span><br><span class="line">        if i % 2 == 0:  # 偶数号哲学家</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 先拿右边叉子</span><br><span class="line">            forks[i].acquire()             # 再拿左边叉子</span><br><span class="line">        else:  # 奇数号哲学家</span><br><span class="line">            forks[i].acquire()             # 先拿左边叉子</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 再拿右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()                 # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()      # 放下右边叉子</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 3：拿起两把叉子才开始吃（破坏“请求与保持”）</p>
<blockquote>
<p><strong>每位哲学家必须同时拿到两把叉子才能开始吃，否则一把也不拿。</strong> </p>
</blockquote>
<p>1️⃣ 全局变量定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"></span><br><span class="line">semaphore s[<span class="number">5</span>];     <span class="comment">// 用于阻塞哲学家的信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥锁，保护 state 和 s</span></span><br><span class="line"><span class="type">int</span> state[<span class="number">5</span>];      <span class="comment">// 哲学家的状态</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>s[i]</code> 初始值为 0，因为一开始没有人需要等待。</li>
<li><code>state[i]</code> 初始化为 <code>THINKING</code>。</li>
</ul>
<p>2️⃣ <code>take_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">take_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = HUNGRY;  <span class="comment">// 哲学家 i 变成饥饿状态</span></span><br><span class="line">    test(i);            <span class="comment">// 尝试让 i 吃饭</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">    P(s[i]);            <span class="comment">// 如果 test(i) 没有让 i 吃上饭，这里会阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = HUNGRY</code></strong>: 告诉“管家”，我饿了。</li>
<li><strong><code>test(i)</code></strong>: “管家”检查我是否能吃。<ul>
<li>如果能吃，<code>test(i)</code> 会执行 <code>V(s[i])</code>，唤醒我。</li>
<li>如果不能吃，<code>test(i)</code> 不做任何事。</li>
</ul>
</li>
<li><strong><code>P(s[i])</code></strong>: 如果我没被唤醒，我就在这里阻塞，等待邻居放叉子。</li>
</ul>
<blockquote>
<p>✅ <strong>这个函数是“非阻塞”的</strong>：它只负责声明“我饿了”，然后立即返回。真正的等待发生在 <code>P(s[i])</code>。</p>
</blockquote>
<p>3️⃣ <code>put_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = THINKING; <span class="comment">// 哲学家 i 变成思考状态</span></span><br><span class="line">    test((i + <span class="number">1</span>) % <span class="number">5</span>);  <span class="comment">// 检查右边邻居</span></span><br><span class="line">    test((i + <span class="number">4</span>) % <span class="number">5</span>);  <span class="comment">// 检查左边邻居（(i+4)%5 == (i-1)%5）</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = THINKING</code></strong>: 我吃饱了，不再占用叉子。</li>
<li><strong><code>test((i+1)%5)</code> 和 <code>test((i+4)%5)</code></strong>: 告诉“管家”，我的邻居们可能现在可以吃饭了。<ul>
<li>例如，哲学家 0 放下叉子后，哲学家 1 和 4 可能现在能拿到两把叉子了。</li>
<li>“管家”会检查他们是否处于 <code>HUNGRY</code> 状态，并且邻居都不在吃，如果是，就唤醒他们。</li>
</ul>
</li>
</ul>
<p>4️⃣ <code>test(int i)</code> 函数 —— 核心逻辑！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;  <span class="comment">// 可以吃了！</span></span><br><span class="line">        V(s[i]);            <span class="comment">// 唤醒哲学家 i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong>检查三个条件</strong>：<ol>
<li><code>state[i] == HUNGRY</code>: 我确实想吃饭。</li>
<li><code>state[(i+1)%5] != EATING</code>: 我右边的邻居没在吃。</li>
<li><code>state[(i+4)%5] != EATING</code>: 我左边的邻居没在吃。</li>
</ol>
</li>
<li><strong>如果都满足</strong>：说明我现在可以拿到两把叉子！<ul>
<li>设置 <code>state[i] = EATING</code>。</li>
<li>执行 <code>V(s[i])</code>，唤醒我自己（因为我在 <code>take_fork</code> 中 <code>P(s[i])</code> 阻塞了）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ <strong>这个函数是“原子”的</strong>：因为它在 <code>mutex</code> 保护下执行，不会被其他哲学家打断。</p>
</blockquote>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><code>mutex</code> 的作用就是：</p>
<blockquote>
<p><strong>保护对共享变量（或临界区）的访问</strong>，<br><strong>只在真正操作这些共享资源的前后“加锁”和“解锁”</strong>。</p>
</blockquote>
<p>（防死锁铁律）：</p>
<blockquote>
<p><strong>永远不要在持有互斥锁（mutex）的情况下，调用可能阻塞的操作（如 P(empty)、P(full)、sleep、wait 等）。</strong></p>
</blockquote>
<h3 id="什么是生产者-消费者问题？"><a href="#什么是生产者-消费者问题？" class="headerlink" title="什么是生产者-消费者问题？"></a>什么是生产者-消费者问题？</h3><p>这是一个经典的<strong>多线程同步问题</strong>，用于模拟现实中的“生产”与“消费”场景：</p>
<ul>
<li><strong>生产者 (Producer)</strong>：负责制造数据或产品。</li>
<li><strong>消费者 (Consumer)</strong>：负责处理或消费这些数据/产品。</li>
<li><strong>缓冲区 (Buffer)</strong>：一个有限大小的共享空间，用来暂存生产者的产品，供消费者取用。</li>
</ul>
<p>📌 核心挑战</p>
<ol>
<li><strong>互斥 (Mutual Exclusion)</strong>：多个生产者/消费者不能同时操作缓冲区的同一个位置，否则数据会错乱。</li>
<li><strong>同步 (Synchronization)</strong>：<ul>
<li>生产者不能在缓冲区满时继续生产（要等待）。</li>
<li>消费者不能在缓冲区空时继续消费（要等待）。</li>
</ul>
</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">item B[n];</span><br><span class="line">Semaphore empty;  /*可用的空缓冲区个数*/</span><br><span class="line">Semaphore full;   /*可用的产品数*/</span><br><span class="line">Semaphore mutex;  /*互斥信号量*/</span><br><span class="line">empty = n; full = 0; mutex = 1;</span><br><span class="line">int in = 0; out = 0;  /*in为放入缓冲区指针, out为取出缓冲区指针*/</span><br><span class="line"></span><br><span class="line">Process producer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        item product = produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        B[in] = product;</span><br><span class="line">        in = (in+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process consumer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Item product = B[out];</span><br><span class="line">        out = (out+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        consume(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题：如果将P操作的顺序交换，会出现什么情况？"><a href="#问题：如果将P操作的顺序交换，会出现什么情况？" class="headerlink" title="问题：如果将P操作的顺序交换，会出现什么情况？"></a>问题：如果将P操作的顺序交换，会出现什么情况？</h4><p><strong>生产者霸占着 <code>mutex</code> 锁，等待 <code>empty</code>，消费者等待 <code>mutex</code> 锁，导致死锁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Producer as 生产者 P1</span><br><span class="line">    participant Consumer as 消费者 C1</span><br><span class="line">    participant Mutex as 互斥锁 (mutex)</span><br><span class="line">    participant Empty as 空闲缓冲区 (empty)</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 初始状态: empty=0 (缓冲区满), mutex=1</span><br><span class="line"></span><br><span class="line">    Producer-&gt;&gt;Mutex: P(mutex) // 成功获取锁，mutex=0</span><br><span class="line">    Producer-&gt;&gt;Empty: P(empty) // empty=0，阻塞！等待空位...</span><br><span class="line">    Note over Producer: 生产者 P1 霸占 mutex 锁，等待 empty</span><br><span class="line"></span><br><span class="line">    Consumer-&gt;&gt;Full: P(full) // full=1，成功，full=0</span><br><span class="line">    Consumer-&gt;&gt;Mutex: P(mutex) // mutex=0，阻塞！等待锁...</span><br><span class="line">    Note over Consumer: 消费者 C1 等待 mutex 锁</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 💥 死锁！</span><br><span class="line">    Note right of Producer: 我要等 empty (需 C1 消费)</span><br><span class="line">    Note left of Consumer: 我要等 mutex (需 P1 释放)</span><br></pre></td></tr></table></figure>
<h4 id="问题：当前生产者消费者共用一个互斥锁会造成竞争"><a href="#问题：当前生产者消费者共用一个互斥锁会造成竞争" class="headerlink" title="问题：当前生产者消费者共用一个互斥锁会造成竞争"></a>问题：当前生产者消费者共用一个互斥锁会造成竞争</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore pmutex, cmutex; // 两个独立的互斥锁</span><br><span class="line">...</span><br><span class="line">P(pmutex); // 生产者只锁自己的写入区域</span><br><span class="line">P(cmutex); // 消费者只锁自己的读取区域</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>生产者之间</strong>：仍然需要 <code>pmutex</code> 来互斥，因为多个生产者可能同时想写入 <code>in</code> 指针指向的位置。</li>
<li><strong>消费者之间</strong>：仍然需要 <code>cmutex</code> 来互斥，因为多个消费者可能同时想读取 <code>out</code> 指针指向的位置。</li>
<li><strong>生产者 vs 消费者</strong>：<strong>它们可以并行！</strong> 只要生产者在写一个位置，消费者在读另一个位置，两者互不干扰，完全可以同时进行。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生"><a href="#死锁产生" class="headerlink" title="死锁产生"></a>死锁产生</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>在多进程/多线程系统中，<strong>死锁</strong>是指两个或多个进程因竞争资源而造成的一种互相等待的现象，若无外力作用，它们都将无法向前推进。</p>
<blockquote>
<p><strong>简单说：A 等 B，B 等 C，C 又等 A，大家谁也不让步，结果全都卡住。</strong> </p>
</blockquote>
<h4 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h4><p>只要系统发生死锁，以下4个条件<strong>必然同时成立</strong>。缺一不可！</p>
<p>1️⃣ 互斥访问 (Mutual Exclusion)</p>
<ul>
<li><strong>定义</strong>：系统中存在临界资源，进程应互斥地使用这些资源。</li>
<li><strong>通俗解释</strong>：资源一次只能被一个进程使用。比如，打印机、文件、数据库连接、内存中的某个变量等。</li>
<li><strong>为什么是必要条件</strong>？如果资源可以被多个进程同时共享（如只读文件），那就不存在竞争，也就不会死锁。</li>
</ul>
<p>2️⃣ 占有和等待 (Hold and Wait)</p>
<ul>
<li><strong>定义</strong>：进程在请求资源得不到满足而等待时，不释放已占有的资源。</li>
<li><strong>通俗解释</strong>：一个进程已经拿着一些资源，但它还需要其他资源才能完成工作，于是它一边等着新资源，一边还紧紧攥着自己手里的旧资源，不肯放手。</li>
<li><strong>为什么是必要条件</strong>？如果一个进程在等待新资源时能主动释放旧资源，那么它就不会阻塞别人，死锁也就不会形成。</li>
</ul>
<p>3️⃣ 不剥夺 (No Preemption)</p>
<ul>
<li><strong>定义</strong>：已被占用的资源只能由属主进程自愿释放，而不允许被其他进程剥夺。</li>
<li><strong>通俗解释</strong>：资源一旦被某个进程拿走，除非它自己愿意还回来，否则谁也不能强行抢走。这保证了进程的“自主性”，但也为死锁埋下了隐患。</li>
<li><strong>为什么是必要条件</strong>？如果系统能强行剥夺资源（比如操作系统强制回收），那么就可以打破死锁链。</li>
</ul>
<p>4️⃣ 循环等待 (Circular Wait)</p>
<ul>
<li><strong>定义</strong>：存在循环等待链，每个进程在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li>
<li><strong>通俗解释</strong>：这是一个闭环。A 等 B 的资源，B 等 C 的资源，C 又等 A 的资源，形成了一个“等待环”。</li>
<li><strong>为什么是必要条件</strong>？如果没有循环，等待链最终会指向一个“不等待”的进程，这个进程完成后会释放资源，从而解开整个等待链。</li>
</ul>
<h3 id="死锁防止"><a href="#死锁防止" class="headerlink" title="死锁防止"></a>死锁防止</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116173459401.png" alt="image-20251116173459401"></p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116181426684.png" alt="image-20251116181426684"></p>
<h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182605135.png" alt="image-20251116182605135"></p>
<ul>
<li><strong>阻塞节点 (Blocked Node)</strong>：一个进程，它<strong>正在请求一个或多个资源，但这些资源当前都被其他进程占用，且没有空闲实例可用</strong>。它必须等待。</li>
<li><strong>非阻塞节点 (Non-blocked Node)</strong>：一个进程，它<strong>要么没有请求任何资源，要么它请求的资源当前有空闲实例可以立即满足</strong>。它可以继续执行。</li>
</ul>
<h4 id="如何通过资源分配图判断死锁？"><a href="#如何通过资源分配图判断死锁？" class="headerlink" title="如何通过资源分配图判断死锁？"></a>如何通过资源分配图判断死锁？</h4><p>✅ 死锁的充分条件（当资源类型只有一个实例时）</p>
<blockquote>
<p><strong>如果资源分配图中存在一个环，则系统一定发生死锁。</strong> </p>
</blockquote>
<ul>
<li><strong>原因</strong>：在一个环中，每个进程都在等待下一个进程所持有的资源，而下一个进程又在等待再下一个……形成一个无限等待的闭环。</li>
</ul>
<p>⚠️ 当资源类型有多个实例时</p>
<blockquote>
<p><strong>环的存在是死锁的必要条件，但不是充分条件。</strong> </p>
</blockquote>
<ul>
<li><strong>原因</strong>：即使图中有环，但如果环中的某个资源类型有多个实例，那么可能还有空闲实例可以满足某个进程的需求，从而打破死锁。</li>
</ul>
<h4 id="资源分配图的简化"><a href="#资源分配图的简化" class="headerlink" title="资源分配图的简化"></a>资源分配图的简化</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182901353.png" alt="image-20251116182901353"></p>
<h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><p>与银行家算法的安全性检测类似</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116184516361.png" alt="image-20251116184516361"></p>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="内存是什么？"><a href="#内存是什么？" class="headerlink" title="内存是什么？"></a>内存是什么？</h3><p>从物理上讲，内存通常指的是<strong>随机存取存储器（RAM - Random Access Memory）</strong>。</p>
<p>从操作系统的角度来看，内存是<strong>CPU（大脑）和硬盘（仓库）之间的“高速中转站”</strong>。它是计算机暂时存放数据的地方，用来存储当前正在运行的程序和正在处理的数据。</p>
<h3 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h3><p>计算机的存储设备像一个金字塔，<strong>越往上速度越快、价格越贵、容量越小</strong>：</p>
<ol>
<li><strong>寄存器 (Registers):</strong> 在 CPU 内部，极快，容量极小（纳秒级）。</li>
<li><strong>高速缓存 (Cache):</strong> 在 CPU 旁边，非常快（L1/L2/L3）。</li>
<li><strong>内存 (Main Memory/RAM):</strong> 我们今天的主角，速度适中，容量适中。</li>
<li><strong>本地磁盘 (Local Disk):</strong> 机械硬盘或固态硬盘，慢，容量巨大（毫秒级）。</li>
</ol>
<p><strong>操作系统的任务：</strong> 主要是管理<strong>第3层（内存）</strong>，并负责在内存和磁盘之间搬运数据。</p>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><h4 id="逻辑地址-Logical-Address"><a href="#逻辑地址-Logical-Address" class="headerlink" title="逻辑地址 (Logical Address)"></a><strong>逻辑地址 (Logical Address)</strong></h4><ul>
<li><strong>别名：</strong> 虚拟地址 (Virtual Address)。</li>
<li><strong>谁生成的？</strong> CPU（在执行程序时）。</li>
<li><strong>是什么？</strong> 这是<strong>程序“眼中”的地址</strong>。<ul>
<li>当程序员写代码或者编译器编译程序时，它们看到的都是逻辑地址。</li>
<li>程序觉得：“我拥有从 <code>0</code> 到 <code>Max</code> 的一整块连续内存。”</li>
</ul>
</li>
</ul>
<h4 id="物理地址-Physical-Address"><a href="#物理地址-Physical-Address" class="headerlink" title="物理地址 (Physical Address)"></a><strong>物理地址 (Physical Address)</strong></h4><ul>
<li><strong>谁看到的？</strong> 内存条（硬件）。</li>
<li><strong>是什么？</strong> 这是<strong>数据在内存条上真正的“门牌号”</strong>。<ul>
<li>它对应着内存芯片中某个具体的存储单元。</li>
<li>只有操作系统和硬件知道数据真正藏在哪里。</li>
</ul>
</li>
</ul>
<h3 id="内存复用方式"><a href="#内存复用方式" class="headerlink" title="内存复用方式"></a>内存复用方式</h3><p>为了支持<strong>多道程序设计</strong>（让电脑同时跑微信、浏览器、游戏），内存必须被复用。复用只有两种基本手段：</p>
<ol>
<li><strong>切大块（按照分区复用）：</strong><ul>
<li>把内存切成几个大块（分区）。</li>
<li><strong>规矩：</strong> 一个程序必须完整地塞进<strong>一个</strong>分区里（连续存放）。</li>
</ul>
</li>
<li><strong>切碎块（按照页框复用）：</strong><ul>
<li>把内存切成无数个一样大的小格子（页框）。</li>
<li><strong>规矩：</strong> 一个程序可以被切碎，散落在<strong>多个</strong>页框里（离散存放）。</li>
</ul>
</li>
</ol>
<h4 id="四大具体方法"><a href="#四大具体方法" class="headerlink" title="四大具体方法"></a>四大具体方法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221140228398.png" alt="image-20251221140228398"></p>
<p>这张图非常精彩，它展示了从“逻辑空间”（你以为的样子）到“物理空间”（实际的样子）的四种映射路径。请看着图中的 <strong>①、②、③、④</strong>。</p>
<h4 id="1-路径-①：单连续-分区存储管理-The-“Old-School”"><a href="#1-路径-①：单连续-分区存储管理-The-“Old-School”" class="headerlink" title="1. 路径 ①：单连续/分区存储管理 (The “Old School”)"></a>1. 路径 ①：单连续/分区存储管理 (The “Old School”)</h4><ul>
<li><strong>逻辑上：</strong> 程序认为自己是一条连续的直路（单连续逻辑地址空间）。</li>
<li><strong>物理上：</strong> 放入“分区”（Partition）。</li>
<li><strong>解释：</strong><ul>
<li>这是最原始的方法。程序多大，就在内存里找个多大的坑填进去。</li>
<li><strong>缺点：</strong> 必须连续。如果你有 100MB 内存，中间断断续续空了 50MB，但没有一块连续的 50MB，那 50MB 的程序就跑不起来。这叫“外部碎片”。</li>
</ul>
</li>
</ul>
<h4 id="2-路径-②：页式存储管理-Paging-现代主流的基础"><a href="#2-路径-②：页式存储管理-Paging-现代主流的基础" class="headerlink" title="2. 路径 ②：页式存储管理 (Paging - 现代主流的基础)"></a>2. 路径 ②：页式存储管理 (Paging - 现代主流的基础)</h4><ul>
<li><strong>逻辑上：</strong> 程序依然认为自己是一条连续的直路（单连续逻辑地址空间）。</li>
<li><strong>物理上：</strong> 放入“页框”（Page Frames）。</li>
<li><strong>变化：</strong><ul>
<li>虽然程序觉得自己是连续的，但操作系统偷偷拿把剪刀，把程序切成标准大小的“页”，然后随便塞进内存里任意位置的“框”里。</li>
<li><strong>优点：</strong> 彻底解决了“必须连续”的问题。内存利用率极高。</li>
</ul>
</li>
</ul>
<h4 id="3-路径-③：段式存储管理-Segmentation-符合人类直觉"><a href="#3-路径-③：段式存储管理-Segmentation-符合人类直觉" class="headerlink" title="3. 路径 ③：段式存储管理 (Segmentation - 符合人类直觉)"></a>3. 路径 ③：段式存储管理 (Segmentation - 符合人类直觉)</h4><ul>
<li><strong>逻辑上：</strong> 程序认为自己是由不同的“功能块”组成的（多连续逻辑地址空间/段表）。<ul>
<li>比如：主程序段、数据段、栈段。</li>
</ul>
</li>
<li><strong>物理上：</strong> 放入“分区”。</li>
<li><strong>解释：</strong><ul>
<li>程序员喜欢这种方式。因为我们可以说：“把我的代码段设为只读，把数据段设为可写”。</li>
<li>但是，每个段在物理内存里还是要占一块连续的地盘，所以依然会有碎片问题。</li>
</ul>
</li>
</ul>
<h4 id="4-路径-④：段页式存储管理-Segmented-Paging-集大成者"><a href="#4-路径-④：段页式存储管理-Segmented-Paging-集大成者" class="headerlink" title="4. 路径 ④：段页式存储管理 (Segmented Paging - 集大成者)"></a>4. 路径 ④：段页式存储管理 (Segmented Paging - 集大成者)</h4><ul>
<li><strong>逻辑上：</strong> 先分段（符合程序员视角，便于管理和保护）。</li>
<li><strong>物理上：</strong> 再分页（符合硬件视角，便于内存利用）。</li>
<li><strong>解释：</strong><ul>
<li>这是<strong>最强形态</strong>。</li>
<li>先把程序按逻辑分成“段”（比如代码段）。</li>
<li>再把这个“段”切碎成“页”，丢进物理内存的“页框”里。</li>
<li><strong>结果：</strong> 既有了分段的逻辑优势（保护、共享），又有了分页的物理优势（没有碎片）。</li>
</ul>
</li>
</ul>
<h3 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h3><p><strong>地址转换 (Address Translation)</strong></p>
<ul>
<li><strong>核心：</strong> 将<strong>逻辑地址</strong>映射为<strong>物理地址</strong>（又称重定位）。</li>
<li><strong>方式：</strong> 分为静态重定位（装入时确定，不可动）和动态重定位（运行时确定，灵活）。</li>
</ul>
<p><strong>分配与去配 (Allocation &amp; Deallocation)</strong></p>
<ul>
<li><strong>核心：</strong> 掌管内存的“借”与“还”。</li>
<li><strong>动作：</strong> 进程装入时<strong>分配</strong>空间并记录；进程撤离时<strong>回收</strong>空间并去配。</li>
</ul>
<p><strong>存储保护 (Storage Protection)</strong></p>
<ul>
<li><strong>核心：</strong> 确保进程互不干扰，防止越界访问。</li>
<li><strong>规则：</strong> 自己的随便用，共享的按权限用，别人的<strong>严禁</strong>用。</li>
</ul>
<p><strong>内存共享 (Sharing)</strong></p>
<ul>
<li><strong>核心：</strong> 允许多个进程共同使用同一块内存区域（如公共代码库）。</li>
<li><strong>目的：</strong> 提高内存利用率，支持进程协作。</li>
</ul>
<p><strong>内存扩充 (Expansion)</strong></p>
<ul>
<li><strong>核心：</strong> 利用磁盘空间“欺骗”程序，实现<strong>虚拟内存</strong>。</li>
<li><strong>技术：</strong> <strong>对换</strong>（整进整出）与<strong>虚拟技术</strong>（部分装入，按需调页）。</li>
</ul>
<p><strong>一句话总结：</strong> 操作系统通过<strong>转换地址</strong>让程序能跑，通过<strong>分配回收</strong>管理空间，通过<strong>保护</strong>防止打架，通过<strong>共享</strong>节省资源，通过<strong>扩充</strong>让小内存跑大程序。</p>
<h3 id="连续分配管理方式-Continuous-Allocation"><a href="#连续分配管理方式-Continuous-Allocation" class="headerlink" title="连续分配管理方式 (Continuous Allocation)"></a>连续分配管理方式 (Continuous Allocation)</h3><h4 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h4><p>所谓“连续”，就是<strong>一个程序在物理内存中必须占据一块连在一起的地盘</strong>。</p>
<ul>
<li>就像一群人去电影院看电影，必须买<strong>连座票</strong>，中间不能断开。</li>
</ul>
<p>连续分配主要经历了三个阶段的进化，我们重点掌握后两个：</p>
<h4 id="第一阶段：单一连续分配-Single-Continuous-Allocation"><a href="#第一阶段：单一连续分配-Single-Continuous-Allocation" class="headerlink" title="第一阶段：单一连续分配 (Single Continuous Allocation)"></a>第一阶段：单一连续分配 (Single Continuous Allocation)</h4><ul>
<li><strong>这是什么：</strong> 整个内存只有<strong>你（操作系统）</strong>和<strong>我（用户程序）</strong>两个人。</li>
<li><strong>情况：</strong> 内存分为系统区和用户区。用户区一次只能跑<strong>一个</strong>程序。</li>
<li><strong>结局：</strong> 这种方式太浪费了（如果你只有 10MB 程序，却占用了 8GB 内存），现代通用操作系统已经不用了。<strong>我们直接跳过。</strong></li>
</ul>
<h4 id="第二阶段：固定分区分配-Fixed-Partitioning"><a href="#第二阶段：固定分区分配-Fixed-Partitioning" class="headerlink" title="第二阶段：固定分区分配 (Fixed Partitioning)"></a>第二阶段：固定分区分配 (Fixed Partitioning)</h4><p>为了能多道程序并行，我们开始切蛋糕。</p>
<ul>
<li><strong>做法：</strong> 系统启动时，就把内存切成<strong>若干个固定大小</strong>的区域（分区）。这些格子的大小一旦切好，就<strong>不能变了</strong>。</li>
<li><strong>两种切法：</strong><ol>
<li><strong>分区大小相等：</strong> 比如全是 10MB 的格子。</li>
<li><strong>分区大小不等：</strong> 有小的（4MB）、中等的（8MB）、大的（16MB），这样更灵活。</li>
</ol>
</li>
<li><strong>问题（致命伤）：内部碎片 (Internal Fragmentation)</strong><ul>
<li>假设有一个分区是 <strong>10MB</strong>。</li>
<li>你的程序只有 <strong>6MB</strong>。</li>
<li>虽然程序装进去了，但剩下的 <strong>4MB</strong> 被锁在这个分区里，别的程序进不来，你也用不了。这就叫<strong>内部碎片</strong>（在分区内部浪费的空间）。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221141919972.png" alt="image-20251221141919972"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221142102685.png" alt="image-20251221142102685"></p>
<h4 id="第三阶段：动态分区分配-Dynamic-Partitioning"><a href="#第三阶段：动态分区分配-Dynamic-Partitioning" class="headerlink" title="第三阶段：动态分区分配 (Dynamic Partitioning)"></a>第三阶段：动态分区分配 (Dynamic Partitioning)</h4><p>为了解决“内部碎片”，操作系统决定：<strong>现吃现切</strong>。</p>
<ul>
<li><strong>做法：</strong> 初始时内存是一整块。当程序 A 来了，它需要 5MB，我就切 5MB 给它；程序 B 来了要 10MB，我紧接着切 10MB 给它。</li>
<li><strong>优点：</strong> <strong>没有内部碎片</strong>！因为我是按需分配的，你需要多少我给多少。</li>
<li><strong>问题（致命伤）：外部碎片 (External Fragmentation)</strong><ul>
<li>随着时间推移，有的程序运行完走了（释放内存），内存里会留下一个个“坑”。</li>
<li>比如：程序 B 走了，留下了 10MB 的空坑。</li>
<li>这时来了一个 12MB 的新程序，它塞不进这个 10MB 的坑里。虽然内存里可能总共有 100MB 的空闲空间，但因为它们<strong>不连续</strong>（都是些碎小的坑），导致大程序跑不起来。这就叫<strong>外部碎片</strong>（在分区外部浪费的空间）。</li>
</ul>
</li>
</ul>
<h4 id="“紧凑”技术-Compaction"><a href="#“紧凑”技术-Compaction" class="headerlink" title="“紧凑”技术 (Compaction)"></a>“紧凑”技术 (Compaction)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221143811148.png" alt="image-20251221143811148"></p>
<p>操作系统不能看着这 16M 内存白白浪费。为了让 P5 跑起来，操作系统必须进行<strong>“内存搬家”</strong>，专业术语叫<strong>紧凑</strong>或<strong>拼接</strong>。</p>
<ul>
<li><strong>做法：</strong> 操作系统让现有的进程（P2, P4, P3）全部<strong>往上挪动</strong>，挤在一起。</li>
<li><strong>效果：</strong><ul>
<li>所有的空闲小坑（6M, 6M, 4M）会被“挤”到内存的最底部，汇合成一个 <strong>16M 的大坑</strong>。</li>
<li>这时候，<strong>10M 的 P5</strong> 就可以舒舒服服地住进去了！</li>
</ul>
</li>
</ul>
<p><strong>代价：</strong> “搬家”是非常耗时的。CPU 要暂停所有工作，疯狂地搬运数据（复制内存），这会严重拖慢电脑速度。这也解释了为什么以前的 Windows 98/XP 用久了要进行“磁盘碎片整理”（虽然那是磁盘，但原理类似，都是为了合并碎片）。</p>
<h3 id="可变分区内存管理-分配算法"><a href="#可变分区内存管理-分配算法" class="headerlink" title="可变分区内存管理-分配算法"></a>可变分区内存管理-分配算法</h3><h4 id="为什么需要分配算法？"><a href="#为什么需要分配算法？" class="headerlink" title="为什么需要分配算法？"></a>为什么需要分配算法？</h4><p>因为“紧凑”（内存搬家）的代价太高了，会让电脑变卡。所以我们尽量通过聪明的分配算法，减少碎片的产生，不到万不得已不搬家。</p>
<p>以下是四种算法的详细解析：</p>
<h4 id="1-最先适应算法-First-Fit"><a href="#1-最先适应算法-First-Fit" class="headerlink" title="1. 最先适应算法 (First Fit)"></a>1. 最先适应算法 (First Fit)</h4><p>这是最简单、最自然的策略。</p>
<ul>
<li><strong>核心思想：</strong> 不管别的，<strong>按地址从低到高</strong>挨个找，找到<strong>第一个</strong>能装下的坑，就立刻分给它。</li>
<li><strong>数据结构：</strong> 空闲分区表是按<strong>地址递增</strong>排列的。</li>
<li><strong>优点：</strong><ul>
<li><strong>保留了大空间：</strong> 因为它总是先填低地址的坑，所以高地址的大片连续空间通常会被保留下来，<strong>有利于以后装入大作业</strong>。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>忙闲不均：</strong> 低地址部分会被切得稀碎，用得很频繁；而查找时每次都从头开始，导致查找开销大，且低地址端充满了小碎片。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144426233.png" alt="image-20251221144426233"></p>
<h4 id="2-下次适应算法-Next-Fit"><a href="#2-下次适应算法-Next-Fit" class="headerlink" title="2. 下次适应算法 (Next Fit)"></a>2. 下次适应算法 (Next Fit)</h4><p>这是对“最先适应算法”的改良。</p>
<ul>
<li><strong>核心思想：</strong> 既然每次从头找太累，那就<strong>从上次分配结束的位置</strong>开始往下找。找到队尾如果还没找到，就绕回队头接着找（循环扫描）。</li>
<li><strong>优点：</strong><ul>
<li><strong>速度快：</strong> 缩短了平均查找时间。</li>
<li><strong>均衡：</strong> 内存里的每个坑被选中的概率差不多，空间利用更均衡。</li>
</ul>
</li>
<li><strong>缺点（致命）：</strong><ul>
<li>因为它把内存里的“大坑”都截断用了，导致<strong>缺乏大的连续空间</strong>。如果有大作业来了，可能反而找不到足够大的地盘了。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144511133.png" alt="image-20251221144511133"></p>
<h4 id="3-最优适应算法-Best-Fit"><a href="#3-最优适应算法-Best-Fit" class="headerlink" title="3. 最优适应算法 (Best Fit)"></a>3. 最优适应算法 (Best Fit)</h4><p>听名字觉得是最好的，其实通常是<strong>最烂</strong>的。</p>
<ul>
<li><strong>核心思想：</strong> 扫描整个内存，找到能装下该进程、且<strong>大小最接近</strong>（最小）的那个坑。<ul>
<li><em>比如你要 5MB，有一个 6MB 的坑和一个 20MB 的坑，它会选 6MB 的那个。</em></li>
</ul>
</li>
<li><strong>数据结构：</strong> 为了找得快，通常把空闲分区按<strong>大小递增</strong>顺序排列。</li>
<li><strong>优点：</strong><ul>
<li>它确实不想浪费大空间，尽量保留了大分区给大作业用。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>制造碎片：</strong> 每次切完后，剩下来的那点空间（比如 6MB 切走 5MB，剩 1MB）实在太小了，谁也用不了。日积月累，内存里全是这种微小的、无法利用的<strong>外部碎片</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144613218.png" alt="image-20251221144613218"></p>
<h4 id="4-最坏适应算法-Worst-Fit"><a href="#4-最坏适应算法-Worst-Fit" class="headerlink" title="4. 最坏适应算法 (Worst Fit)"></a>4. 最坏适应算法 (Worst Fit)</h4><p>这是“最优适应”的反面。</p>
<ul>
<li><strong>核心思想：</strong> 每次都挑<strong>最大</strong>的那个坑给进程。<ul>
<li><em>比如你要 5MB，它偏偏要把那个 100MB 的大坑切给你。</em></li>
</ul>
</li>
<li><strong>数据结构：</strong> 空闲分区按<strong>大小递减</strong>顺序排列，这样查表时只要看第一个满不满足就行了。</li>
<li><strong>优点：</strong><ul>
<li><strong>减少碎片：</strong> 切完剩下的一般还比较大（100MB 切走 5MB，剩 95MB），还可以继续给别的程序用。所以它<strong>对中小型作业非常有利</strong>。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>大作业哭了：</strong> 最大的坑很快就被消耗掉了，真来了个超级大的程序，往往就没地方放了。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144633595.png" alt="image-20251221144633595"></p>
<h3 id="分页存储管理-Paging-Storage-Management"><a href="#分页存储管理-Paging-Storage-Management" class="headerlink" title="分页存储管理 (Paging Storage Management)"></a>分页存储管理 (Paging Storage Management)</h3><h4 id="为什么要引入分页？"><a href="#为什么要引入分页？" class="headerlink" title="为什么要引入分页？"></a>为什么要引入分页？</h4><ul>
<li><strong>分区的痛：</strong> 程序必须完整地塞进连续的内存里。如果有 3 个 2MB 的小坑，想装一个 5MB 的程序，装不进去。</li>
<li><strong>分页的药：</strong> 允许程序<strong>“打散”</strong>。把 5MB 的程序切成很多小块，分别塞进那 3 个 2MB 的坑里（甚至更小的坑），只要总空间够，就能跑。</li>
</ul>
<blockquote>
<p><strong>核心思想：</strong> 逻辑上连续（程序看来是完整的），物理上不连续（内存里是散落的）。</p>
</blockquote>
<h4 id="三大概念"><a href="#三大概念" class="headerlink" title="三大概念"></a>三大概念</h4><h4 id="A-页框-Page-Frame-——-物理内存的“格子”"><a href="#A-页框-Page-Frame-——-物理内存的“格子”" class="headerlink" title="A. 页框 (Page Frame) —— 物理内存的“格子”"></a>A. 页框 (Page Frame) —— 物理内存的“格子”</h4><ul>
<li><strong>定义：</strong> 操作系统把<strong>物理内存</strong>切成一个个大小完全固定的块。</li>
<li><strong>大小：</strong> 通常较小且是 2 的幂，比如 4KB（4096字节）。</li>
<li><strong>编号：</strong> 从 0 开始编号，叫<strong>页框号</strong>或<strong>物理块号</strong>。</li>
<li><em>类比：</em> 就像是一个巨大的药柜，里面全是大小一样的标准小抽屉。</li>
</ul>
<h4 id="B-页面-Page-——-程序的“切片”"><a href="#B-页面-Page-——-程序的“切片”" class="headerlink" title="B. 页面 (Page) —— 程序的“切片”"></a>B. 页面 (Page) —— 程序的“切片”</h4><ul>
<li><strong>定义：</strong> 把<strong>用户的程序（逻辑地址空间）\</strong>也切成和页框*<em>一模一样大小*</em>的块。</li>
<li><strong>编号：</strong> 从 0 开始编号，叫<strong>页号</strong>。</li>
<li><em>类比：</em> 你把药材（程序）切成标准的小方块，每一块刚好能塞进一个抽屉。</li>
</ul>
<h4 id="C-页表-Page-Table-——-寻宝图"><a href="#C-页表-Page-Table-——-寻宝图" class="headerlink" title="C. 页表 (Page Table) —— 寻宝图"></a>C. 页表 (Page Table) —— 寻宝图</h4><ul>
<li><strong>定义：</strong>既然程序被切碎散落在内存的各个角落，CPU 怎么知道程序的“第 1 页”在哪个“抽屉”里？</li>
<li>我们需要一张映射表，这就是<strong>页表</strong>。</li>
<li><strong>内容：</strong> 记录了 <strong>逻辑页号 -&gt; 物理页框号</strong> 的对应关系。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221150141354.png" alt="image-20251221150141354"></p>
<h4 id="分页是如何解决碎片问题的？"><a href="#分页是如何解决碎片问题的？" class="headerlink" title="分页是如何解决碎片问题的？"></a>分页是如何解决碎片问题的？</h4><p><strong>没有“外部碎片”：</strong></p>
<ul>
<li>因为内存被切成了标准的 4KB 格子，程序也是 4KB 的块。只要内存里有空闲的格子，程序就能塞进去，完全不用担心“坑太小”的问题。</li>
</ul>
<p><strong>只有微小的“内部碎片”：</strong></p>
<ul>
<li><strong>产生原因：</strong> 程序的最后一部分可能填不满一页。</li>
<li><em>例子：</em> 页面大小是 4KB。你的程序是 4.1KB。<ul>
<li>第 1 页（4KB）填满。</li>
<li>第 2 页（0.1KB）只占了一点点，剩下的 3.9KB 就是浪费的。</li>
</ul>
</li>
<li><strong>结论：</strong> 这种浪费主要发生在<strong>程序的最后一页</strong>，平均只有半页大小，相比于固定分区的浪费，这简直可以忽略不计。</li>
</ul>
<h3 id="分页存储管理的地址转换"><a href="#分页存储管理的地址转换" class="headerlink" title="分页存储管理的地址转换"></a>分页存储管理的地址转换</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221151214942.png" alt="image-20251221151214942"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221151234013.png" alt="image-20251221151234013"></p>
<h3 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h3><h4 id="1-核心痛点：为什么要引入快表？"><a href="#1-核心痛点：为什么要引入快表？" class="headerlink" title="1. 核心痛点：为什么要引入快表？"></a>1. 核心痛点：为什么要引入快表？</h4><p>请看图，它指出了一个严重的问题：</p>
<ul>
<li><strong>页表放在哪里？</strong> 放在<strong>内存</strong>中。</li>
<li><strong>这就导致了一个尴尬的后果：</strong> 每次 CPU 想读取一个数据，必须访问<strong>两次内存</strong>。<ol>
<li><strong>第一次访问：</strong> 去查内存里的页表，把逻辑地址翻译成物理地址。</li>
<li><strong>第二次访问：</strong> 根据物理地址，真正去取数据。</li>
</ol>
</li>
</ul>
<h4 id="2-解决方案：TLB-快表"><a href="#2-解决方案：TLB-快表" class="headerlink" title="2. 解决方案：TLB (快表)"></a>2. 解决方案：TLB (快表)</h4><p>为了解决“慢”的问题，科学家发明了 <strong>TLB (Translation Look-aside Buffer)</strong>，中文叫<strong>快表</strong>或<strong>联想寄存器</strong>。</p>
<ul>
<li><strong>它是什么？</strong> CPU 内部的一种<strong>极其快速</strong>、但容量很小的高速缓存。</li>
<li><strong>它存什么？</strong> 它存放<strong>当前最常访问</strong>的那一小部分页表项（Page # 到 Frame # 的映射）。</li>
<li><strong>原理：</strong> 利用程序的“局部性原理”。如果你刚看了第 5 页，你很可能马上又要看第 5 页。</li>
</ul>
<blockquote>
<p><strong>升级后的比喻：</strong></p>
<ul>
<li>你在手边放了一张<strong>小纸条（TLB）</strong>。</li>
<li>每次找书前，先看小纸条。如果纸条上有位置信息（<strong>TLB 命中</strong>），直接去拿书，不用跑去查目录了！</li>
</ul>
</blockquote>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221154628477.png" alt="image-20251221154628477"></p>
<h4 id="3-加入-TLB-后的工作流程"><a href="#3-加入-TLB-后的工作流程" class="headerlink" title="3. 加入 TLB 后的工作流程"></a>3. 加入 TLB 后的工作流程</h4><p>请看图 的流程图，这是现在的标准动作：</p>
<ol>
<li><strong>CPU 发出请求：</strong> 逻辑地址（页号 $p$）。</li>
<li><strong>先查 TLB（快）：</strong><ul>
<li><strong>情况 A：命中 (Hit)</strong><ul>
<li>直接拿到物理块号。</li>
<li><strong>耗时：</strong> 仅需 1 次内存访问（取数据）。</li>
</ul>
</li>
<li><strong>情况 B：未命中 (Miss)</strong><ul>
<li>没办法，只能老老实实去访问内存里的页表（慢）。</li>
<li>拿到块号后，<strong>顺手把这一项存进 TLB</strong>（以备下次用）。</li>
<li><strong>耗时：</strong> 2 次内存访问。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="分页存储空间的分配与去配"><a href="#分页存储空间的分配与去配" class="headerlink" title="分页存储空间的分配与去配"></a>分页存储空间的分配与去配</h3><h4 id="安全性问题：-怎么防止进程去访问不属于它的内存？"><a href="#安全性问题：-怎么防止进程去访问不属于它的内存？" class="headerlink" title="安全性问题： 怎么防止进程去访问不属于它的内存？"></a><strong>安全性问题：</strong> 怎么防止进程去访问不属于它的内存？</h4><p>之前学的页表，只是告诉 CPU “第 X 页在第 Y 块”。但这里有个漏洞：如果一个程序只有 5 页，但恶意（或错误）代码试图去访问“第 6 页”，会发生什么？</p>
<p>为了防止这种越界访问，操作系统在页表的每一行后面加了一个小尾巴，叫 <strong>“有效-无效位” (Valid-invalid bit)</strong>。</p>
<h5 id="1-机制详解"><a href="#1-机制详解" class="headerlink" title="1. 机制详解"></a>1. 机制详解</h5><ul>
<li><strong>v (valid)：有效</strong>。表示这一页是合法的，确实在物理内存里，且属于当前进程。</li>
<li><strong>i (invalid)：无效</strong>。表示这一页不属于该进程（或者该页还在磁盘上没调入内存）。</li>
<li><strong>后果：</strong> 如果 CPU 试图访问一个标记为 <strong>i</strong> 的页面，硬件会立即触发一个<strong>异常 (Exception/Trap)</strong>，操作系统会终止该进程或进行处理。</li>
</ul>
<h5 id="2-图中的数学例子（非常重要）"><a href="#2-图中的数学例子（非常重要）" class="headerlink" title="2. 图中的数学例子（非常重要）"></a>2. 图中的数学例子（非常重要）</h5><p>让我们拆解一下图中的计算题，看看它是怎么判定“第 6 页”是非法的：</p>
<ul>
<li><strong>前提条件：</strong><ul>
<li>页大小 = 2KB ($2^{11} = 2048$ 字节)。</li>
<li>这意味着地址的低 11 位是偏移量。</li>
</ul>
</li>
<li><strong>进程需求：</strong><ul>
<li>进程实际使用的地址范围是 <strong>0 ~ 10468</strong>。</li>
</ul>
</li>
<li><strong>计算需要多少页：</strong><ul>
<li><script type="math/tex; mode=display">\frac{10468}{2048} \approx 5.11</script></li>
<li>这意味着填满了第 0, 1, 2, 3, 4 页，并且第 5 页占用了一点点（0.11的部分）。</li>
<li>所以，总共需要 <strong>0~5 号页</strong>（共 6 个页）。</li>
</ul>
</li>
<li><strong>查看页表状态：</strong><ul>
<li>你看右边的页表，<strong>页号 0~5</strong> 的状态位都是 <strong>v</strong>（允许访问）。</li>
<li><strong>页号 6, 7</strong> 的状态位是 <strong>i</strong>（禁止访问）。</li>
<li>如果程序试图访问地址 12287（属于第 6 页），MMU 检查到是 ‘i’，直接报错拦截。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221155409519.png" alt="image-20251221155409519"></p>
<h4 id="管理问题：-操作系统怎么快速知道哪些物理格子是空的？"><a href="#管理问题：-操作系统怎么快速知道哪些物理格子是空的？" class="headerlink" title="管理问题： 操作系统怎么快速知道哪些物理格子是空的？"></a><strong>管理问题：</strong> 操作系统怎么快速知道哪些物理格子是空的？</h4><p>操作系统手里握着几千几万个物理页框，当新程序来的时候，怎么快速找到哪里有空位？<strong>位图 (Bitmap)</strong> 是最常用的方法。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><ul>
<li>用<strong>一串二进制位 (0和1)</strong> 来代表物理内存的格局。</li>
<li><strong>每一位 (bit)</strong> 对应一个 <strong>物理页框</strong>。</li>
<li><strong>映射规则：</strong><ul>
<li>第 1 个 bit 对应 第 1 个页框。</li>
<li>第 2 个 bit 对应 第 2 个页框…以此类推。</li>
</ul>
</li>
</ul>
<h5 id="2-状态表示"><a href="#2-状态表示" class="headerlink" title="2. 状态表示"></a>2. 状态表示</h5><ul>
<li><p><strong>1：</strong> 表示该页框<strong>被占用</strong>。</p>
</li>
<li><p>0： 表示该页框空闲。</p>
<p>(注：有些系统可能反过来，但根据这张PPT的文字“找出为 0 的那些位”，说明这里 0 代表空闲)</p>
</li>
</ul>
<h5 id="3-分配算法流程"><a href="#3-分配算法流程" class="headerlink" title="3. 分配算法流程"></a>3. 分配算法流程</h5><p>当一个程序需要申请 3 个页框时：</p>
<ol>
<li><strong>扫描：</strong> 操作系统扫描这个位图，寻找哪里有 <strong>“0”</strong>。</li>
<li><strong>计算：</strong> 比如发现第 5、6、8 位是 0。</li>
<li><strong>计算页框号：</strong><ul>
<li>发现第 $i$ 位是 0，那么对应的物理页框号就是 $i$（或者基于基址计算）。</li>
</ul>
</li>
<li><strong>修改状态：</strong> 把这几位从 <strong>0 变成 1</strong>（标记为占用）。</li>
<li><strong>分配：</strong> 把算出来的物理页框号填到进程的页表里。</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221155532240.png" alt="image-20251221155532240"></p>
<h3 id="多级页表-Multi-level-Page-Table"><a href="#多级页表-Multi-level-Page-Table" class="headerlink" title="多级页表 (Multi-level Page Table)"></a><strong>多级页表 (Multi-level Page Table)</strong></h3><h4 id="1-为什么要引入多级页表？-The-Problem"><a href="#1-为什么要引入多级页表？-The-Problem" class="headerlink" title="1. 为什么要引入多级页表？(The Problem)"></a>1. 为什么要引入多级页表？(The Problem)</h4><p>让我们做一个简单的数学计算：</p>
<ul>
<li><p>在 32 位系统下，页面大小 4KB。</p>
</li>
<li><p>这意味着总共有 <strong>$2^{20}$ (约 100 万)</strong> 个页面。</p>
</li>
<li><p>如果每个页表项占 4 字节，那么一张完整的页表需要：</p>
<script type="math/tex; mode=display">100\text{万} \times 4\text{B} = \mathbf{4\text{MB}}</script></li>
</ul>
<p><strong>痛点：</strong></p>
<ol>
<li><strong>必须连续：</strong> 在单级页表中，这 4MB 的空间必须在物理内存中<strong>连续存放</strong>。</li>
<li><strong>难找：</strong> 在内存紧张时，很难找到一块完整的、连续的 4MB 空间给页表住。</li>
<li><strong>浪费：</strong> 很多程序其实只用了一点点内存，但为了维持结构，你不得不把这 100 万个坑位都建好（哪怕大部分是空的）。</li>
</ol>
<p>解决方案：</p>
<p>把这 4MB 的大页表，也切成小块（页），散落在内存里！既然切碎了，就需要再建立一张表来管理这些碎块——这就是二级页表（页表的页表）。</p>
<h4 id="2-逻辑地址的重新划分"><a href="#2-逻辑地址的重新划分" class="headerlink" title="2. 逻辑地址的重新划分"></a>2. 逻辑地址的重新划分</h4><p>请看图，为了支持二级页表，逻辑地址被切得更碎了：</p>
<ul>
<li><strong>旧模式（单级）：</strong> 20位页号 ($p$) + 12位偏移 ($d$)。</li>
<li><strong>新模式（二级）：</strong><ul>
<li><strong>$p_1$ (10位)：一级页号</strong>（外层页号）。用来找“目录的目录”。</li>
<li><strong>$p_2$ (10位)：二级页号</strong>（内层页号）。用来找“具体的页表”。</li>
<li><strong>$d$ (12位)：页内偏移</strong>。保持不变。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么是 10 位？</p>
<p>$2^{10} = 1024$。每个页表项 4 字节。</p>
<p>$1024 \times 4\text{B} = 4\text{KB}$。</p>
<p>妙处： 这样切割后，每一张二级页表的大小刚好是一个页面 (4KB)！这让页表本身也可以完美地塞进普通的内存页框里。</p>
</blockquote>
<h4 id="地址变换过程-The-Walk"><a href="#地址变换过程-The-Walk" class="headerlink" title="地址变换过程 (The Walk)"></a>地址变换过程 (The Walk)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221161021945.png" alt="image-20251221161021945"></p>
<p>请看图，这是一个<strong>“三步跳”</strong>的过程：</p>
<ol>
<li><strong>第一跳（查目录）：</strong><ul>
<li>CPU 拿着 <strong>$p_1$</strong>，去查<strong>一级页表</strong>。</li>
<li>得到结果：知道“这一段地址对应的<strong>二级页表</strong>”在内存的什么位置。</li>
</ul>
</li>
<li><strong>第二跳（查页表）：</strong><ul>
<li>CPU 拿着 <strong>$p_2$</strong>，去刚才找到的那张<strong>二级页表</strong>里查。</li>
<li>得到结果：终于拿到了真正的<strong>物理块号 (Frame #)</strong>。</li>
</ul>
</li>
<li><strong>第三跳（取数据）：</strong><ul>
<li>用物理块号 + <strong>偏移量 $d$</strong>，去访问<strong>物理内存</strong>，拿到真正的数据。</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>离散存储页表：</strong> 页表不需要 4MB 连续空间了，可以打散放在各种角落。</li>
<li><strong>节省空间：</strong> 如果一个程序只用了很小的内存，我们只需要建立“一级页表”和“少量二级页表”即可。其他的二级页表根本不用创建（或者可以留在磁盘上）。</li>
</ul>
<p><strong>缺点（如图片右上角文字所示）：</strong></p>
<ul>
<li><strong>变慢了！</strong><ul>
<li>单级页表：访存 2 次（查表+取数）。</li>
<li>二级页表：<strong>访存 3 次</strong>（查一级+查二级+取数）。</li>
<li><em>多级页表级数越多，访问越慢。</em></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>补救措施：</strong> 这就是为什么上一节讲的 <strong>TLB (快表)</strong> 极其重要！如果有 TLB，大部分时候我们直接能拿到结果，不需要走这漫长的三步跳。</p>
</blockquote>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><h4 id="1-为什么要分段？"><a href="#1-为什么要分段？" class="headerlink" title="1. 为什么要分段？"></a>1. 为什么要分段？</h4><p>请看图，这解释了分段的初衷：</p>
<ul>
<li><strong>程序员眼中的程序：</strong><ul>
<li>程序员写代码时，不会认为程序是一堆 4KB 的碎片。</li>
<li>我们认为程序是由<strong>不同的功能块</strong>组成的：比如 <strong>主程序 (main)</strong>、<strong>子程序 (subroutine)</strong>、<strong>栈 (stack)</strong>、<strong>变量数组 (array)</strong> 等。</li>
</ul>
</li>
<li><strong>分页的尴尬：</strong> 分页像碎纸机，可能把一个完整的函数切成两半，一半在第 1 页，一半在第 20 页。这让共享和保护变得很麻烦。</li>
<li><strong>分段的解决：</strong> 保持逻辑完整。<ul>
<li><strong>主程序</strong> 单独一段。</li>
<li><strong>栈</strong> 单独一段。</li>
<li><strong>数据表</strong> 单独一段。</li>
<li><strong>特点：</strong> 每个段的大小<strong>不固定</strong>（主程序可能 50KB，栈可能 1KB）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>黄金类比：</strong></p>
<ul>
<li><strong>分页</strong> 像是把一本书的每一页撕下来，胡乱塞进一个个一样大的信封里。</li>
<li><strong>分段</strong> 像是把书按<strong>“章”</strong>分开。第一章放一个文件夹，第二章放一个文件夹。有的章长，有的章短。</li>
</ul>
</blockquote>
<h4 id="2-逻辑地址的变化-2D-Address"><a href="#2-逻辑地址的变化-2D-Address" class="headerlink" title="2. 逻辑地址的变化 (2D Address)"></a>2. 逻辑地址的变化 (2D Address)</h4><p>在分段管理中，地址不再是一维的线性的，而是<strong>二维</strong>的。</p>
<p>请看图 的底部：</p>
<ul>
<li><strong>逻辑地址 = 段号 (Segment Number) + 段内偏移 (Offset)</strong></li>
<li><em>例子：</em> “第 1 段 的 第 500 行”。</li>
</ul>
<p><strong>关键区别：</strong></p>
<ul>
<li><strong>分页：</strong> 只要给出一个物理地址，机器自动切分。</li>
<li><strong>分段：</strong> 用户（编译器）必须显式地指定“段号”和“段内偏移”。</li>
</ul>
<h4 id="3-核心机制：段表-Segment-Table"><a href="#3-核心机制：段表-Segment-Table" class="headerlink" title="3. 核心机制：段表 (Segment Table)"></a>3. 核心机制：段表 (Segment Table)</h4><p>既然段的大小不固定，操作系统怎么管理呢？请看图。</p>
<p>我们需要一张<strong>段表</strong>，用来记录每个“章”在内存里的位置。因为每一章长度不一样，所以段表必须包含<strong>两列核心信息</strong>：</p>
<ol>
<li><strong>段起始地址 (Base)：</strong> 这个段在物理内存是从哪里开始的？（比如从 6300 开始）。</li>
<li><strong>段长度 (Limit/Length)：</strong> 这个段到底有多大？（比如只有 400 大小）。<ul>
<li><em>注意：页表不需要记录“长度”，因为页表默认全是 4KB。但在分段中，这个长度至关重要！</em></li>
</ul>
</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221162559750.png" alt="image-20251221162559750"></p>
<h4 id="4-地址变换与保护-The-Translation-amp-Safety"><a href="#4-地址变换与保护-The-Translation-amp-Safety" class="headerlink" title="4. 地址变换与保护 (The Translation &amp; Safety)"></a>4. 地址变换与保护 (The Translation &amp; Safety)</h4><p>这是分段管理最厉害的地方：<strong>越界保护</strong>。</p>
<p>我们模拟一次 CPU 访问（结合图 的数据）：</p>
<ul>
<li><strong>场景：</strong> CPU 要访问 <strong>段号 1</strong>，<strong>偏移量 500</strong> 的数据。</li>
</ul>
<p><strong>步骤：</strong></p>
<ol>
<li><strong>查表：</strong> 找到段表里的第 1 项。</li>
<li><strong>获取信息：</strong><ul>
<li>基址 (Base) = <strong>6300</strong></li>
<li>限长 (Length) = <strong>400</strong></li>
</ul>
</li>
<li><strong>越界检查 (Critical Step)：</strong><ul>
<li>CPU 会拿你的偏移量 <strong>500</strong> 和 限长 <strong>400</strong> 比较。</li>
<li><strong>500 &gt; 400</strong>，说明你试图访问这一段之外的地方！</li>
<li><strong>结果：</strong> 硬件直接拦截，抛出 <strong>“段错误” (Segmentation Fault)</strong>。这是编程时最常见的报错之一。</li>
</ul>
</li>
<li><strong>正常情况：</strong> 如果偏移量是 100（小于 400），则物理地址 = $6300 + 100 = 6400$。</li>
</ol>
<h2 id="虚拟内存-Virtual-Memory"><a href="#虚拟内存-Virtual-Memory" class="headerlink" title="虚拟内存 (Virtual Memory)"></a>虚拟内存 (Virtual Memory)</h2><h4 id="1-痛点：实存管理的问题"><a href="#1-痛点：实存管理的问题" class="headerlink" title="1. 痛点：实存管理的问题"></a>1. 痛点：实存管理的问题</h4><p>请看图，传统的<strong>实存管理</strong>（Real Memory Management）有一个硬性规定：</p>
<ul>
<li><strong>必须全部装入：</strong> 作业（程序）如果要运行，必须把它的<strong>全部信息</strong>一次性装入内存。</li>
<li><strong>后果：</strong><ol>
<li><strong>大程序跑不了：</strong> 程序的体积受限于物理内存的大小。</li>
<li><strong>浪费资源：</strong> 其实程序里很多代码是很少用到的（比如“异常处理代码”、“巨大的未填满的数组”）。把这些一辈子都不一定跑一次的代码一直放在昂贵的内存里，是极大的浪费。</li>
</ol>
</li>
</ul>
<h4 id="2-解决方案：虚拟内存"><a href="#2-解决方案：虚拟内存" class="headerlink" title="2. 解决方案：虚拟内存"></a>2. 解决方案：虚拟内存</h4><p>虚拟内存的核心思想就是<strong>“欺骗”</strong>。</p>
<ul>
<li><strong>核心动作：部分装入 (Partial Loading)</strong>。<ul>
<li>操作系统不再把整个程序塞进内存，而是<strong>只把当前立刻要用的那几页</strong>装进去，剩下的留在硬盘上。</li>
<li>程序运行到哪里，就动态地把哪里的数据从硬盘“拉”进内存（请求调页）。</li>
<li>如果内存满了，就把暂时不用的数据“踢”回硬盘（页面置换）。</li>
</ul>
</li>
<li><strong>效果：</strong><ul>
<li><strong>逻辑 &gt; 物理：</strong> 给用户提供一个<strong>比物理主存大得多</strong>的“虚拟主存”。</li>
<li><strong>以小博大：</strong> 8GB 的物理内存，可以流畅运行 20GB 的游戏，甚至可以同时运行总共 100GB 的多个程序。</li>
</ul>
</li>
</ul>
<h4 id="3-理论基石：局部性原理"><a href="#3-理论基石：局部性原理" class="headerlink" title="3. 理论基石：局部性原理"></a>3. 理论基石：局部性原理</h4><p>你可能会问：“这样频繁地在内存和硬盘之间倒腾数据，电脑不会卡死吗？” 答案是：<strong>通常不会</strong>。因为程序运行有一个神奇的规律，叫<strong>“局部性原理”</strong>。</p>
<p>请看图，它解释了为什么我们敢“只装入一部分”：</p>
<ol>
<li><strong>时间局部性 (Temporal Locality)：</strong><ul>
<li><strong>现象：</strong> 如果一条指令被执行了，那么不久之后它<strong>很有可能再次被执行</strong>。</li>
<li><strong>原因：</strong> 程序里充满了大量的<strong>循环 (Loop)</strong>。一旦进入循环，CPU 就会盯着这几行代码反复跑，完全不需要访问其他页面的代码。</li>
</ul>
</li>
<li><strong>空间局部性 (Spatial Locality)：</strong><ul>
<li><strong>现象：</strong> 如果一个存储单元被访问了，那么它<strong>附近的单元</strong>也很有可能马上被访问。</li>
<li><strong>原因：</strong> 指令通常是顺序执行的；数据通常是聚集成群的（比如<strong>数组</strong>、<strong>表</strong>）。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>结论：</strong> 在一段较短的时间内，程序实际上只需要访问<strong>极小一部分</strong>内存就能正常工作。所以我们完全可以把剩下的 90% 扔在硬盘里睡觉，而不影响运行速度。</p>
</blockquote>
<h3 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h3><p>要实现虚拟内存，<strong>不能</strong>使用我们最早学的“连续分配方式”（因为要频繁地把一大块程序搬进搬出，效率太低且不仅能保证连续空间）。</p>
<p>因此，虚拟内存必须建立在<strong>离散分配（非连续分配）</strong>的基础上。</p>
<p>根据课件，实现虚拟内存主要有以下三个流派和两个核心“新技能”：</p>
<h4 id="1-三种实现方式"><a href="#1-三种实现方式" class="headerlink" title="1. 三种实现方式"></a>1. 三种实现方式</h4><p>其实就是把你之前学的“基本款”升级为“虚拟款”：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>基础版本 (全部装入)</strong></th>
<th><strong>虚拟版本 (部分装入，按需调页)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>基本分页存储管理</td>
<td><strong>页式虚拟存储管理</strong> (最主流)</td>
</tr>
<tr>
<td>基本分段存储管理</td>
<td><strong>段式虚拟存储管理</strong></td>
</tr>
<tr>
<td>基本段页式存储管理</td>
<td><strong>段页式虚拟存储管理</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-两个新增的核心功能"><a href="#2-两个新增的核心功能" class="headerlink" title="2. 两个新增的核心功能"></a>2. 两个新增的核心功能</h4><p>这是“虚拟系统”和“普通系统”最本质的区别。为了实现“空手套白狼”，操作系统必须具备两项新能力：</p>
<h5 id="A-请求调页-调段功能-Demand-Paging-Segmentation"><a href="#A-请求调页-调段功能-Demand-Paging-Segmentation" class="headerlink" title="A. 请求调页/调段功能 (Demand Paging/Segmentation)"></a>A. 请求调页/调段功能 (Demand Paging/Segmentation)</h5><ul>
<li><strong>动作：</strong> <strong>“缺了就拿”</strong>。</li>
<li><strong>描述：</strong> 在程序执行过程中，当 CPU 发现要访问的数据<strong>不在内存</strong>时（缺页），操作系统负责把所需的信息从硬盘（外存）<strong>调入内存</strong>，然后让程序继续执行。</li>
</ul>
<h5 id="B-页面置换-段置换功能-Page-Segment-Replacement"><a href="#B-页面置换-段置换功能-Page-Segment-Replacement" class="headerlink" title="B. 页面置换/段置换功能 (Page/Segment Replacement)"></a>B. 页面置换/段置换功能 (Page/Segment Replacement)</h5><ul>
<li><strong>动作：</strong> <strong>“满了就扔”</strong>。</li>
<li><strong>描述：</strong> 当内存空间<strong>不够</strong>的时候，操作系统负责利用某种算法，把内存中暂时<strong>用不到</strong>的信息（页面或段）<strong>换出</strong>到硬盘上，腾出地方给新进来的页面用。</li>
</ul>
<h3 id="页式虚拟存储管理"><a href="#页式虚拟存储管理" class="headerlink" title="页式虚拟存储管理"></a>页式虚拟存储管理</h3><h4 id="1-核心思想：按需调入-Demand-Paging"><a href="#1-核心思想：按需调入-Demand-Paging" class="headerlink" title="1. 核心思想：按需调入 (Demand Paging)"></a>1. 核心思想：按需调入 (Demand Paging)</h4><ul>
<li><strong>启动时：</strong> 操作系统<strong>只把进程的第一页</strong>（或者极少量的几页）装入内存，然后就让 CPU 开始跑。</li>
<li><strong>运行时：</strong><ul>
<li>CPU 执行着执行着，发现要访问的下一行代码在“第 5 页”。</li>
<li>一查页表，发现第 5 页不在内存里。</li>
<li><strong>动作：</strong> 暂停程序，去硬盘把第 5 页抓进来，然后继续跑。</li>
</ul>
</li>
<li><strong>地位：</strong> 这是现代 OS 的<strong>主流存储管理技术</strong>。</li>
</ul>
<h4 id="2-基础设施升级：扩充页表-Expanded-Page-Table"><a href="#2-基础设施升级：扩充页表-Expanded-Page-Table" class="headerlink" title="2. 基础设施升级：扩充页表 (Expanded Page Table)"></a>2. 基础设施升级：扩充页表 (Expanded Page Table)</h4><p>为了支持这种“有的在内存，有的在硬盘”的复杂情况，原来的页表（只记录页号-&gt;块号）已经不够用了。我们需要给页表加很多“状态栏”。</p>
<p>请看图，现在的页表项变得很宽，包含了以下关键信息：</p>
<ol>
<li><strong>驻留标识 (Present/Resident bit)：</strong> <strong>最重要的一位</strong>。<ul>
<li><code>1</code>: 表示该页<strong>在内存中</strong>（可以直接访问）。</li>
<li><code>0</code>: 表示该页<strong>在磁盘上</strong>（需要触发中断去调入）。</li>
</ul>
</li>
<li><strong>写回标志 (Dirty/Modify bit)：</strong><ul>
<li>记录这一页在内存里有没有被<strong>修改</strong>过。</li>
<li><strong>作用：</strong> 当这一页要被踢出内存时，如果是“脏”的（被改过），必须写回硬盘保存；如果是“干净”的，直接扔掉就行（硬盘里有原版），省了一次磁盘 IO。</li>
</ul>
</li>
<li><strong>引用标志 (Reference bit)：</strong><ul>
<li>记录这一页最近有没有被访问过。</li>
<li><strong>作用：</strong> 给<strong>置换算法</strong>参考。最近刚被用过的，最好别踢它（LRU 算法的基础）。</li>
</ul>
</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170033104.png" alt="image-20251221170033104"></p>
<h4 id="3-核心机制：缺页中断-Page-Fault"><a href="#3-核心机制：缺页中断-Page-Fault" class="headerlink" title="3. 核心机制：缺页中断 (Page Fault)"></a>3. 核心机制：缺页中断 (Page Fault)</h4><p>当 CPU 想要访问一个<strong>“驻留标识为 0”</strong>（不在内存）的页面时，就会触发<strong>缺页中断</strong>。这是虚拟内存运转的“引擎”。</p>
<ol>
<li><strong>CPU 访问：</strong> 给出逻辑地址。</li>
<li><strong>硬件检查：</strong> 发现页表里这一项显示“不在内存”。</li>
<li><strong>产生中断：</strong> 硬件立刻产生<strong>缺页中断</strong>，CPU 暂停当前进程，把控制权交给操作系统。</li>
<li><strong>OS 处理 (关键分支)：</strong><ul>
<li><strong>情况 A（内存有空位）：</strong><ul>
<li>直接从磁盘找到该页，读入空闲的页框。</li>
<li>修改页表（把驻留位置 1，填入块号）。</li>
</ul>
</li>
<li><strong>情况 B（内存满了）：</strong><ul>
<li>执行<strong>页面置换算法</strong>，挑一个倒霉蛋（淘汰页）踢出去。</li>
<li>如果那个倒霉蛋被修改过，先把它写回磁盘。</li>
<li>把腾出来的空位给新页面用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>恢复执行：</strong> 操作系统更新完页表后，<strong>重新执行</strong>刚才那条导致中断的指令。这一次，CPU 就能顺利找到数据了。</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170552446.png" alt="image-20251221170552446"></p>
<h3 id="虚存地址转换过程"><a href="#虚存地址转换过程" class="headerlink" title="虚存地址转换过程"></a>虚存地址转换过程</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170856192.png" alt="image-20251221170856192"></p>
<h4 id="第一阶段：启动与分流"><a href="#第一阶段：启动与分流" class="headerlink" title="第一阶段：启动与分流"></a>第一阶段：启动与分流</h4><p><strong>1. 地址分解 (Step 1)</strong></p>
<ul>
<li><strong>动作：</strong> CPU 发出指令，MMU（内存管理单元）截获逻辑地址，自动把它切成两半：<strong>页号 ($p$)</strong> 和 <strong>页内偏移 ($d$)</strong>。</li>
</ul>
<p><strong>2. 查快表 (Step 2)</strong></p>
<ul>
<li><strong>动作：</strong> 以页号 $p$ 为索引，先去查 CPU 内部的 <strong>快表 (TLB)</strong>。</li>
<li><strong>耗时：</strong> $t_1$（非常短，纳秒级）。</li>
</ul>
<h4 id="第二阶段：三种可能的命运"><a href="#第二阶段：三种可能的命运" class="headerlink" title="第二阶段：三种可能的命运"></a>第二阶段：三种可能的命运</h4><h5 id="命运一：快表命中-TLB-Hit-——-极速模式"><a href="#命运一：快表命中-TLB-Hit-——-极速模式" class="headerlink" title="命运一：快表命中 (TLB Hit) —— 极速模式"></a>命运一：快表命中 (TLB Hit) —— 极速模式</h5><p>这是图中 <strong>(3)</strong> 的路径。</p>
<ul>
<li><strong>情况：</strong> 在 TLB 里直接找到了页号对应的物理块号。</li>
<li><strong>结果：</strong><ul>
<li>直接取出块号。</li>
<li><strong>拼接：</strong> 块号 + 偏移量 = 物理地址。</li>
<li><strong>访问数据：</strong> 去访问主存（耗时 $t_2$）。</li>
</ul>
</li>
<li><strong>总耗时：</strong> $t_1 (\text{查TLB}) + t_2 (\text{取数据})$。</li>
</ul>
<h5 id="命运二：快表未命中，但页表命中-——-普通模式"><a href="#命运二：快表未命中，但页表命中-——-普通模式" class="headerlink" title="命运二：快表未命中，但页表命中 —— 普通模式"></a>命运二：快表未命中，但页表命中 —— 普通模式</h5><p>这是图中 <strong>(4) -&gt; (5)</strong> 的路径。</p>
<ul>
<li><p><strong>情况：</strong> TLB 里没找到（Miss），但MMU 去查内存里的 <strong>页表</strong> 时，发现该页<strong>在内存中</strong>（驻留位为 1）。</p>
</li>
<li><p><strong>动作：</strong></p>
<ol>
<li>从页表中读出物理块号。</li>
<li><strong>关键动作：装入快表 (Load TLB)</strong>。为了下次能快点，把这一项复制到 TLB 里。</li>
<li>形成物理地址，访问数据。</li>
</ol>
</li>
<li><p>总耗时： $t_1 (\text{查TLB}) + t_2 (\text{查页表}) + t_2 (\text{取数据})$。</p>
<p>(比命运一多了一次访存的时间)</p>
</li>
</ul>
<h5 id="命运三：缺页中断-——-龟速模式"><a href="#命运三：缺页中断-——-龟速模式" class="headerlink" title="命运三：缺页中断 —— 龟速模式"></a>命运三：缺页中断 —— 龟速模式</h5><p>这是图中 <strong>(6) -&gt; (7) -&gt; (8)</strong> 的路径（红色箭头）。</p>
<ul>
<li><strong>情况：</strong> TLB 没找到，查内存页表发现<strong>也不在内存中</strong>（驻留位为 0，失效）。</li>
<li><strong>动作：</strong><ol>
<li><strong>Step (6) 缺页中断：</strong> MMU 发出信号，CPU 暂停，操作系统接管。</li>
<li><strong>Step (7) 调页：</strong> 操作系统去 <strong>辅助存储器 (磁盘)</strong> 里把这一页找出来，读入内存。<ul>
<li><em>注意：这一步耗时是 $t_3$，通常是毫秒级，比前两种慢几万倍。</em></li>
</ul>
</li>
<li><strong>Step (8) 装入/改表：</strong> 数据读进内存后，操作系统更新 <strong>页表</strong> 和 <strong>快表</strong>，把状态改为“在内存”。</li>
</ol>
</li>
<li><strong>结局：</strong> 重启指令，这次就会走“命运一”或“命运二”了。</li>
</ul>
<h3 id="缺页中断率-Page-Fault-Rate"><a href="#缺页中断率-Page-Fault-Rate" class="headerlink" title="缺页中断率 (Page Fault Rate)"></a>缺页中断率 (Page Fault Rate)</h3><p>怎么衡量虚拟内存效率高不高？就看<strong>缺页中断率 ($f$)</strong>。</p>
<ul>
<li><p>公式：</p>
<script type="math/tex; mode=display">f = \frac{F}{S + F}</script><ul>
<li>$F$: 缺页次数（去磁盘拿的次数）。</li>
<li>$S$: 成功在内存找到的次数。</li>
<li><strong>目标：</strong> 我们希望 $f$ 无限接近于 0。</li>
</ul>
</li>
<li><p><strong>影响 $f$ 的四大因素：</strong></p>
<ol>
<li><strong>内存页框数：</strong> 给进程分的“房间”越多，缺页率越低。</li>
<li><strong>页面大小：</strong> 页面越大，缺页率通常越低（因为一次拉进来更多数据），但浪费也可能变大。</li>
<li><strong>页面替换算法：</strong> 算法越聪明（踢得越准），缺页率越低。</li>
<li><strong>程序特性：</strong> <strong>这不仅是 OS 的事，也是程序员的事！</strong></li>
</ol>
</li>
</ul>
<h3 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h3><h4 id="最佳页面调度算法-OPT-OPTimal-replacement"><a href="#最佳页面调度算法-OPT-OPTimal-replacement" class="headerlink" title="最佳页面调度算法(OPT, OPTimal replacement)"></a>最佳页面调度算法(OPT, OPTimal replacement)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221173735698.png" alt="image-20251221173735698"></p>
<h4 id="先进先出页面调度算法-FIFO-First-In-First-Out-replacement"><a href="#先进先出页面调度算法-FIFO-First-In-First-Out-replacement" class="headerlink" title="先进先出页面调度算法(FIFO, First-In First-Out replacement)"></a>先进先出页面调度算法(FIFO, First-In First-Out replacement)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221173753487.png" alt="image-20251221173753487"></p>
<h5 id="Belady异常"><a href="#Belady异常" class="headerlink" title="Belady异常"></a>Belady异常</h5><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174117271-1766310078350-1.png" alt="image-20251221174117271"></p>
<p><strong>为什么会发生这种事？</strong></p>
<p>Belady 异常的根本原因在于 <strong>FIFO 算法的“无脑”</strong>。</p>
<ul>
<li><strong>FIFO 的逻辑：</strong> 只看<strong>进入内存的时间</strong>，谁来得早谁滚蛋。</li>
<li><strong>问题所在：</strong> 它完全不考虑页面的<strong>使用频率</strong>或<strong>访问模式</strong>。<ul>
<li>在上面的 4 页框例子中，<code>4</code> 和 <code>3</code> 是经常要被访问的热门页面。</li>
<li>但是因为它们进来得早，FIFO 总是优先把它们踢出去。</li>
<li>当页框变多时，页面的驻留时间变长了，队列的结构变了，导致原本能“巧合”命中的页面（比如在3页框时，踢出的顺序刚好避开了马上要用的页），在4页框时反而被“精准”地踢出去了。</li>
</ul>
</li>
</ul>
<h4 id="最近最少使用页面调度算法-LRU-Least-Recently-Used-replacement"><a href="#最近最少使用页面调度算法-LRU-Least-Recently-Used-replacement" class="headerlink" title="最近最少使用页面调度算法(LRU, Least Recently Used replacement)"></a>最近最少使用页面调度算法(LRU, Least Recently Used replacement)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174219298.png" alt="image-20251221174219298"></p>
<h4 id="最不常用页面调度算法-LFU-least-frequently-used"><a href="#最不常用页面调度算法-LFU-least-frequently-used" class="headerlink" title="最不常用页面调度算法(LFU, least frequently used)"></a>最不常用页面调度算法(LFU, least frequently used)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174254213.png" alt="image-20251221174254213"></p>
<h4 id="时钟页面调度算法-Clock-Clock-policy-replacement"><a href="#时钟页面调度算法-Clock-Clock-policy-replacement" class="headerlink" title="时钟页面调度算法(Clock, Clock policy replacement)"></a>时钟页面调度算法(Clock, Clock policy replacement)</h4><h5 id="1-核心道具-The-Setup"><a href="#1-核心道具-The-Setup" class="headerlink" title="1. 核心道具 (The Setup)"></a>1. 核心道具 (The Setup)</h5><p>要玩转这个算法，需要三个关键道具：</p>
<ol>
<li><strong>环形队列 (Circular Queue)：</strong><ul>
<li>把内存里的所有页面首尾相连，排成一个圆圈，就像<strong>钟面</strong>一样。</li>
</ul>
</li>
<li><strong>表针 (Pointer)：</strong><ul>
<li>有一个指针，指向当前要检查的那个页面（下一号淘汰候选人）。</li>
</ul>
</li>
<li><strong>引用标志位 (Reference/Use Bit)：</strong><ul>
<li>每个页面都有一个标志位。</li>
<li><strong>1</strong> = 最近被访问过（免死金牌）。</li>
<li><strong>0</strong> = 最近没被访问（可以杀）。</li>
</ul>
</li>
</ol>
<h5 id="2-算法规则：给一次“改过自新”的机会"><a href="#2-算法规则：给一次“改过自新”的机会" class="headerlink" title="2. 算法规则：给一次“改过自新”的机会"></a>2. 算法规则：给一次“改过自新”的机会</h5><p>Clock 算法的核心逻辑就是<strong>“二次机会” (Second Chance)</strong>。</p>
<p>当内存满了，需要踢人时，指针开始顺时针扫描：</p>
<ul>
<li><strong>情况 A：遇到标志位是 1 的页面</strong><ul>
<li><strong>动作：</strong> 操作系统心软了。它把标志位<strong>改为 0</strong>（没收免死金牌），然后指针<strong>移向下一页</strong>。</li>
<li><strong>潜台词：</strong> “我看你最近刚被用过，这次先不杀你，但我把你的牌子没收了。如果下次我转回来你还没被访问，那你就在劫难逃了。”</li>
</ul>
</li>
<li><strong>情况 B：遇到标志位是 0 的页面</strong><ul>
<li><strong>动作：</strong> 操作系统不客气了。<strong>直接淘汰</strong>这个页面！</li>
<li><strong>后续：</strong> 把新页面装进这个坑位，把标志位<strong>置为 1</strong>，指针<strong>移向下一页</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221193222438.png" alt="image-20251221193222438"></p>
<h3 id="段式虚拟存储管理"><a href="#段式虚拟存储管理" class="headerlink" title="段式虚拟存储管理"></a>段式虚拟存储管理</h3><p>如果有需要再学</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="设备控制方式"><a href="#设备控制方式" class="headerlink" title="设备控制方式"></a>设备控制方式</h3><h4 id="为什么要有设备控制方式"><a href="#为什么要有设备控制方式" class="headerlink" title="为什么要有设备控制方式"></a>为什么要有设备控制方式</h4><h5 id="1-巨大的速度鸿沟-The-Speed-Gap"><a href="#1-巨大的速度鸿沟-The-Speed-Gap" class="headerlink" title="1. 巨大的速度鸿沟 (The Speed Gap)"></a>1. 巨大的速度鸿沟 (The Speed Gap)</h5><p>这是最根本的原因。</p>
<ul>
<li><strong>CPU</strong>：是电子设备，运算速度以<strong>纳秒 (ns)</strong> 计，一秒钟能执行几十亿次指令。</li>
<li><strong>I/O设备</strong>：大多包含机械部件（如硬盘磁头转动、打印机喷墨），速度以<strong>毫秒 (ms)</strong> 甚至秒计。</li>
</ul>
<p><strong>差距有多大？</strong> 如果把 CPU 比作一列<strong>高铁</strong>（时速 300公里），那 I/O 设备就像是一只<strong>蜗牛</strong>。 如果没有优化的“控制方式”（比如让 CPU 傻等的轮询方式），就相当于<strong>让高铁停下来等蜗牛爬过铁轨</strong>。这简直是暴殄天物，极大地浪费了昂贵的 CPU 资源。</p>
<p><strong>所以，设备控制方式的演进，本质上就是为了不让高铁等蜗牛。</strong></p>
<h5 id="2-实现“并行操作”-Parallelism"><a href="#2-实现“并行操作”-Parallelism" class="headerlink" title="2. 实现“并行操作” (Parallelism)"></a>2. 实现“并行操作” (Parallelism)</h5><p>操作系统的核心目标之一是<strong>效率</strong>。我们希望计算机能同时做多件事。</p>
<ul>
<li><strong>没有好的控制方式时</strong>：CPU 必须亲自指挥设备每一个动作。CPU 在忙 I/O 的时候，就不能做计算；做计算的时候，就不能管 I/O。这是<strong>串行</strong>的。</li>
<li><strong>有了好的控制方式（如 DMA、通道）</strong>：<ul>
<li>CPU 说：“你去把电影拷贝一下。”（发指令）</li>
<li>CPU 转头去运行游戏逻辑。（做计算）</li>
<li>设备控制器自己在旁边慢慢拷贝电影。（做 I/O）</li>
</ul>
</li>
</ul>
<p>这就是<strong>CPU 与设备的并行</strong>。只有通过先进的设备控制方式，才能把 CPU 从繁琐的搬运工作中解放出来，让它去处理更有价值的逻辑运算。</p>
<h5 id="3-屏蔽设备的复杂性-Abstraction"><a href="#3-屏蔽设备的复杂性-Abstraction" class="headerlink" title="3. 屏蔽设备的复杂性 (Abstraction)"></a>3. 屏蔽设备的复杂性 (Abstraction)</h5><p>世界上的设备千奇百怪：鼠标、键盘、显卡、网卡、打印机、VR眼镜……</p>
<ul>
<li>它们的物理原理完全不同。</li>
<li>它们的数据格式完全不同。</li>
</ul>
<p>如果让 CPU 直接去控制每一个物理细节（比如控制硬盘电机转几圈、控制打印机喷头往哪喷），CPU 的指令集会变得无比复杂，且操作系统无法通用。</p>
<p><strong>设备控制方式（配合硬件控制器）起到了一层“翻译”和“管家”的作用：</strong></p>
<ul>
<li>CPU 只需要下达统一的命令（读、写）。</li>
<li>具体的脏活累活（如何控制电压、如何校验数据、如何按顺序传输）交给<strong>设备控制器</strong>和<strong>控制逻辑</strong>（如 DMA 控制器）去完成。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>谁在搬运数据？</strong></th>
<th><strong>CPU 干预频率</strong></th>
<th><strong>传输单位</strong></th>
<th><strong>效率 (并行程度)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>轮询</strong></td>
<td>CPU</td>
<td>极高 (时刻在检查)</td>
<td>字/字节</td>
<td>低</td>
</tr>
<tr>
<td><strong>中断</strong></td>
<td>CPU</td>
<td>高 (每单位数据一次)</td>
<td>字/字节</td>
<td>中</td>
</tr>
<tr>
<td><strong>DMA</strong></td>
<td>DMA控制器</td>
<td>低 (每块数据一次)</td>
<td><strong>数据块</strong></td>
<td>高</td>
</tr>
<tr>
<td><strong>通道</strong></td>
<td>通道处理器</td>
<td>极低 (每组任务一次)</td>
<td><strong>多组数据块</strong></td>
<td>极高</td>
</tr>
</tbody>
</table>
</div>
<p>四者之间差异在于：CPU和设备并行工作的方式和程度不同。</p>
<h4 id="轮询（Polling）"><a href="#轮询（Polling）" class="headerlink" title="轮询（Polling）"></a>轮询（Polling）</h4><p><strong>流程解析</strong>：</p>
<ol>
<li><strong>发出命令</strong>：CPU 告诉设备（控制器）“我要读数据”。</li>
<li><strong>读状态</strong>：CPU 紧接着去读设备的状态寄存器。</li>
<li><strong>检查状态（关键点）</strong>：<ul>
<li>如果设备<strong>“未就绪”</strong>（还在忙着准备数据），CPU <strong>顺着红色箭头</strong>跳回去，再次读取状态。</li>
<li>CPU 会一直在“读状态 -&gt; 检查 -&gt; 未就绪 -&gt; 读状态”这个圈里打转。</li>
</ul>
</li>
<li><strong>读写数据</strong>：只有当设备终于显示“就绪”了，CPU 才会跳出循环，亲自把数据读进来。</li>
</ol>
<p><strong>核心特点：CPU 全程陪跑 (CPU 全程参与)</strong></p>
<p><strong>忙等 (Busy Waiting)</strong>：</p>
<ul>
<li>这就是上面说的那个“死循环”。在设备准备数据的这段时间（对于 CPU 来说极其漫长），CPU 没有去干别的更有意义的事，而是像个复读机一样一直问“好了没？”。</li>
<li><strong>结果</strong>：CPU 的利用率被严重拉低。</li>
</ul>
<p><strong>串行工作</strong>：</p>
<ul>
<li>PPT 文字提到：“在设备接受 I/O 命令之前处理器不能执行其他操作”。</li>
<li>这意味着 <strong>计算任务</strong> 和 <strong>I/O 任务</strong> 是完全<strong>串行</strong>的（排队做）。CPU 不能在设备忙的时候去算别的题。</li>
</ul>
<h4 id="中断驱动方式-Interrupt-Driven-I-O"><a href="#中断驱动方式-Interrupt-Driven-I-O" class="headerlink" title="中断驱动方式 (Interrupt-Driven I/O)"></a>中断驱动方式 (Interrupt-Driven I/O)</h4><p>当设备准备好了（状态变为“就绪”），控制器会向 CPU 发送一个电信号，这个信号就叫<strong>中断</strong>。</p>
<p><strong>CPU 的反应</strong>：</p>
<ol>
<li>收到信号，<strong>暂停</strong>当前正在做的工作（保存现场）。</li>
<li>跳到 <strong>“中断处理程序”</strong>（流程图中的黄色框）。</li>
<li><strong>传送数据</strong>：CPU 亲自把数据从设备搬运到内存。</li>
<li><strong>恢复</strong>：搬运完后，CPU 回到刚才暂停的地方继续工作。</li>
</ol>
<h4 id="直接存储器访问（DMA-Direct-Memory-Access）"><a href="#直接存储器访问（DMA-Direct-Memory-Access）" class="headerlink" title="直接存储器访问（DMA, Direct Memory Access）"></a>直接存储器访问（DMA, Direct Memory Access）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223153957188.png" alt="image-20251223153957188"></p>
<p>图展示了 DMA 模块的内部结构，这解释了它是如何独立工作的：</p>
<ul>
<li><strong>地址寄存器</strong>：记住了数据要搬到内存的哪个位置。</li>
<li><strong>数据计数</strong>：记住了还有多少数据要搬。</li>
<li><strong>控制逻辑</strong>：负责指挥总线进行读写。</li>
<li><strong>关键点</strong>：CPU 一旦把这些寄存器填好，DMA 就拥有了工作的全部信息，不再需要 CPU 指导。</li>
</ul>
<p><strong>CPU -&gt; DMA（下达命令）</strong>：</p>
<ul>
<li>CPU 告诉 DMA：“把硬盘里这 1MB 数据搬到内存地址 X。”</li>
</ul>
<p><strong>继续执行后续指令（红色虚线）</strong>：</p>
<ul>
<li><strong>关键时刻</strong>：CPU 下完命令直接走人，去处理其他进程。</li>
<li>与此同时，DMA 控制器接管总线，一车一车地往内存搬数据。<strong>这是真正的并行！</strong></li>
</ul>
<p><strong>中断（最后一步）</strong>：</p>
<ul>
<li>只有当这 1MB 数据<strong>全部搬完</strong>了，DMA 才会发一个中断信号告诉 CPU：“老板，活干完了。”</li>
</ul>
<h5 id="什么是“周期窃取”？"><a href="#什么是“周期窃取”？" class="headerlink" title="什么是“周期窃取”？"></a>什么是“周期窃取”？</h5><p>“DMA 和 CPU 同时通过<strong>总线</strong>访问内存，CPU 会把总线的占有权让给 DMA 一个/几个主存周期”。</p>
<p><strong>形象理解</strong>：</p>
<ul>
<li><strong>总线 (Bus)</strong> 就像是一条<strong>独木桥</strong>。内存是桥对面的仓库。</li>
<li><strong>CPU</strong> 是一个一直在过桥搬东西的人。</li>
<li><strong>DMA</strong> 是另一个也要过桥搬东西的人。</li>
<li><strong>“周期窃取”</strong>：当 DMA 需要搬运一个数据字时，它不会把 CPU 彻底赶走，而是趁着 CPU 正在思考（译码）或者还没上桥的<strong>间隙</strong>，<strong>“偷”</strong> 用一下这个桥（总线周期），快速搬运一个字，然后立马把桥还给 CPU。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223155431045.png" alt="image-20251223155431045"></p>
<p>图中的方框（取指令、译码、取操作数…）代表 CPU 执行一条指令的各个微步骤。</p>
<p><strong>中断断点 (最右侧)</strong>：请看最右边的箭头。<strong>中断</strong>是非常“讲礼貌”的。它必须等到 CPU 把当前这条指令<strong>完全执行完</strong>（存结果之后），才会去响应中断。</p>
<p><strong>DMA 断点 (中间的箭头)</strong>：请看指向“译码”和“取操作数”之间的那个箭头。<strong>DMA</strong> 是“急脾气”。它<strong>不需要</strong>等指令执行完。只要 CPU 当前这个微操作（比如译码）不占用总线，DMA 就可以见缝插针地插入进来，偷一个周期传数据。</p>
<p>结论：DMA 的响应速度比中断快得多，因为它不需要等指令结束。</p>
<h5 id="为什么“窃取”不会严重拖慢-CPU？"><a href="#为什么“窃取”不会严重拖慢-CPU？" class="headerlink" title="为什么“窃取”不会严重拖慢 CPU？"></a>为什么“窃取”不会严重拖慢 CPU？</h5><p><strong>Cache 的功劳</strong>：PPT 最后一行提到“CPU 大部分情况下与 Cache 进行数据交换”。CPU 也就是在这一瞬间不能访问<strong>主存</strong>（内存），但它依然可以访问<strong>Cache</strong>（高速缓存）。只要 Cache 里有数据，CPU 就算没了总线也能继续干活，完全感觉不到 DMA 在偷东西。</p>
<p><strong>不连续性</strong>：DMA 只是偶尔偷一个周期，而不是长时间霸占，所以对 CPU 的宏观影响很小。</p>
<h4 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h4><ul>
<li><strong>① 轮询方式</strong>: CPU需要主动等待设备就绪，并且全程参与内存数据的交换。</li>
<li><strong>② 中断方式</strong>: CPU无需主动等待设备就绪。当设备准备好后，会向CPU发送一个中断信号，CPU响应中断后再参与内存数据交换。</li>
<li><strong>③ DMA方式</strong>: CPU只在I/O操作开始前和结束后参与（例如，初始化DMA控制器），在实际的数据传输过程中，由DMA控制器直接在内存和设备间搬运数据，CPU完全不参与主存数据交换。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">CPU作用</th>
<th style="text-align:left">等待设备</th>
<th style="text-align:left">内存数据交换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>轮询方式</strong></td>
<td style="text-align:left">需要</td>
<td style="text-align:left">参与</td>
</tr>
<tr>
<td style="text-align:left"><strong>中断方式</strong></td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">参与</td>
</tr>
<tr>
<td style="text-align:left"><strong>DMA方式</strong></td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">不参与</td>
</tr>
</tbody>
</table>
</div>
<p>从轮询到中断再到DMA，CPU的效率越来越高，它能更早地从I/O等待中解放出来去执行其他任务，从而提高了系统的并行处理能力。然而，这种并行仅限于物理层面的I/O操作，即CPU和I/O设备可以同时工作，而不是指CPU内部或软件层面的并行计算。</p>
<h4 id="通道控制方式-Channel-Control"><a href="#通道控制方式-Channel-Control" class="headerlink" title="通道控制方式 (Channel Control)"></a>通道控制方式 (Channel Control)</h4><h5 id="1-核心定义：什么是“通道”？"><a href="#1-核心定义：什么是“通道”？" class="headerlink" title="1. 核心定义：什么是“通道”？"></a>1. 核心定义：什么是“通道”？</h5><ul>
<li><strong>别名</strong>：它又被称为 <strong>I/O 处理器 (I/O Processor)</strong>。</li>
<li><strong>地位</strong>：它不再是一个简单的硬件控制器，而是一个<strong>“弱智版 CPU”</strong>。</li>
<li><strong>能力</strong>：它拥有执行<strong>逻辑独立 I/O 任务</strong>的能力。这意味着它不仅仅能“搬运”，还能做简单的“决策”（比如：先读这个，再写那个，如果错了重试）。</li>
</ul>
<h5 id="2-核心机制：通道程序-amp-四级连接"><a href="#2-核心机制：通道程序-amp-四级连接" class="headerlink" title="2. 核心机制：通道程序 &amp; 四级连接"></a>2. 核心机制：通道程序 &amp; 四级连接</h5><p>这里有两个关键概念需要理解：</p>
<p><strong>A. 通道程序 (Channel Program)</strong></p>
<p>PPT 提到，处理器不再执行具体的 I/O 指令，而是<strong>“在主存中组织通道程序”</strong>。</p>
<ul>
<li><strong>DMA 方式</strong>：CPU 给的是<strong>参数</strong>（源地址、目的地址、数据量）。</li>
<li><strong>通道方式</strong>：CPU 给的是<strong>一段代码</strong>（通道程序）。<ul>
<li><strong>比喻</strong>：<ul>
<li><strong>DMA</strong>：老板说“把这堆砖搬到后院”。</li>
<li><strong>通道</strong>：老板写了一张<strong>任务清单</strong>：“1. 先把砖搬到后院；2. 然后去买水泥；3. 最后把墙砌好。” 通道拿着这张清单，自己去执行一系列复杂的动作，不需要老板再插手。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>B. 四级连接 (Four-level Connection)</strong></p>
<p>PPT 中提到了 <strong>“处理器、通道、控制器、设备”</strong> 的四级连接。</p>
<ul>
<li>这是一个层级管理结构：<ul>
<li><strong>CPU</strong> 指挥 <strong>通道</strong>。</li>
<li><strong>通道</strong> 指挥 <strong>设备控制器</strong>。</li>
<li><strong>设备控制器</strong> 控制 <strong>设备</strong>。</li>
</ul>
</li>
<li><strong>目的</strong>：一个通道可以控制多台设备，大大节省了 CPU 的接口资源。</li>
</ul>
<h5 id="3-工作流程：高度并行-High-Parallelism"><a href="#3-工作流程：高度并行-High-Parallelism" class="headerlink" title="3. 工作流程：高度并行 (High Parallelism)"></a>3. 工作流程：高度并行 (High Parallelism)</h5><p>详细展示了工作步骤，这里有几个<strong>考试常考的缩写</strong>：</p>
<ol>
<li><strong>CPU 启动</strong>：<ul>
<li>CPU 遇到 I/O 任务。</li>
<li>OS 组织好通道程序，把这个程序的地址放在 <strong>CAW (Channel Address Word，通道地址字)</strong> 中。</li>
<li>CPU 启动通道，然后<strong>立即走人</strong>（去干别的事）。</li>
</ul>
</li>
<li><strong>通道执行</strong>：<ul>
<li>通道从 CAW 里拿到清单（通道程序），开始指挥设备干活。</li>
<li>此时，<strong>CPU 和 通道 真正实现了“高度并行”</strong>。</li>
</ul>
</li>
<li><strong>结束汇报</strong>：<ul>
<li>活干完了，通道发出中断。</li>
<li>CPU 响应中断，从 <strong>CSW (Channel Status Word，通道状态字)</strong> 中读取执行情况（比如是成功了还是出错了）。</li>
</ul>
</li>
</ol>
<h3 id="总线与I-O"><a href="#总线与I-O" class="headerlink" title="总线与I/O"></a>总线与I/O</h3><h4 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h4><p>从慢吞吞的键盘到快如闪电的显卡，它们都需要和 CPU 或内存交换数据。<strong>总线</strong>就是它们共同行走的通道。</p>
<p>想象计算机的主板是一个繁忙的<strong>城市</strong>。</p>
<ul>
<li><strong>CPU、内存、硬盘、网卡</strong> 就是城市里的<strong>建筑物</strong>。</li>
<li><strong>总线</strong> 就是连接这些建筑物的<strong>主干道</strong>。</li>
<li><strong>数据</strong> 就是路上跑的<strong>车辆</strong>。</li>
</ul>
<p><strong>总线的三大组成部分</strong>：</p>
<ol>
<li><strong>数据总线 (Data Bus)</strong> —— <strong>运货车</strong><ul>
<li><strong>作用</strong>：用来传输实际的数据（比如你的文档内容、游戏画面）。</li>
<li><em>特点</em>：是双向的（能发能收）。路越宽（比如 32位、64位），一次能拉的货就越多。</li>
</ul>
</li>
<li><strong>地址总线 (Address Bus)</strong> —— <strong>导航员</strong><ul>
<li><strong>作用</strong>：用来告诉大家“我要去哪里”。比如 CPU 要读内存，必须先通过地址总线广播：“我要找 0x0012 号房间的数据”。</li>
<li><em>特点</em>：通常是单向的（由 CPU 发出）。</li>
</ul>
</li>
<li><strong>控制总线 (Control Bus)</strong> —— <strong>红绿灯/交警</strong><ul>
<li><strong>作用</strong>：用来指挥交通。比如发送“读”、“写”、“中断”或“请求占用总线”的信号。</li>
<li><em>关联</em>：刚才我们学的 <strong>“DMA 周期窃取”</strong>，其实就是 DMA 通过控制总线向 CPU 申请：“把路权借我用一下”。</li>
</ul>
</li>
</ol>
<h4 id="解决-I-O-速度不匹配问题"><a href="#解决-I-O-速度不匹配问题" class="headerlink" title="解决 I/O 速度不匹配问题"></a>解决 I/O 速度不匹配问题</h4><p>这里的“不匹配”体现在两个维度：</p>
<ul>
<li><strong>I/O 和 CPU 的不匹配</strong>：CPU 是光速运行的，而 I/O 设备相对较慢。</li>
<li><strong>各设备之间的不匹配</strong>：这是这张图的重点。键盘和显卡虽然都是 I/O 设备，但它们的速度简直是云泥之别。</li>
</ul>
<h3 id="总线概念结构"><a href="#总线概念结构" class="headerlink" title="总线概念结构"></a>总线概念结构</h3><h4 id="单总线结构模型-Single-Bus-Structure-Model"><a href="#单总线结构模型-Single-Bus-Structure-Model" class="headerlink" title="单总线结构模型 (Single Bus Structure Model)"></a>单总线结构模型 (Single Bus Structure Model)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223162354483.png" alt="image-20251223162354483"></p>
<ul>
<li><strong>一条总线</strong>：中间那根橙色的双向大箭头。</li>
<li><strong>全员接入</strong>：<strong>CPU</strong>、<strong>主存（内存）</strong> 和所有的 <strong>I/O 模块</strong> 都直接挂在这同一根线上。</li>
</ul>
<p><strong>这意味着什么？</strong> 这意味着 CPU 想和内存说话，要走这条路；硬盘想把数据传给内存，也要走这条路。大家共享这一条通信通道。</p>
<p><strong>优点：简单粗暴</strong></p>
<ol>
<li><strong>结构简单</strong>：硬件设计非常容易，成本低。</li>
<li><strong>易于扩充</strong>：这是最大的好处。如果你想加一台打印机，只需要把它“挂”在总线上就行，不需要改动 CPU 或内存的架构。就像在路边盖新房子一样容易。</li>
</ol>
<p><strong>缺点：致命的“堵车”</strong></p>
<p>这种设计在早期计算机中很流行，但随着设备越来越多，它的弊端完全暴露出来：</p>
<ul>
<li><strong>共用总线导致压力大</strong>：<ul>
<li>因为只有一条路，同一时刻只能有一组对话。如果硬盘正在传电影，CPU 就不能读内存，必须干等。这就构成了<strong>瓶颈</strong>。</li>
</ul>
</li>
<li><strong>传输时延长</strong>：<ul>
<li>设备多了，大家都要申请路权，排队时间自然变长。</li>
</ul>
</li>
<li><strong>最痛的点：慢速外设占用带宽多</strong>：<ul>
<li>这是单总线最大的硬伤。</li>
<li><strong>比喻</strong>：想象这是一条单车道高速公路。如果前面有一辆<strong>拖拉机（慢速 I/O 设备）</strong>在慢慢开，后面性能再好的<strong>法拉利（CPU/内存）</strong>也得跟在屁股后面慢慢爬。</li>
<li>这就导致了高速设备的性能被低速设备严重拖累。</li>
</ul>
</li>
</ul>
<h4 id="三级总线模型-Three-level-Bus-Model"><a href="#三级总线模型-Three-level-Bus-Model" class="headerlink" title="三级总线模型 (Three-level Bus Model)"></a>三级总线模型 (Three-level Bus Model)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223162608032.png" alt="image-20251223162608032"></p>
<h5 id="第一级：局部总线-Local-Bus-——-“VIP-专用通道”"><a href="#第一级：局部总线-Local-Bus-——-“VIP-专用通道”" class="headerlink" title="第一级：局部总线 (Local Bus) —— “VIP 专用通道”"></a>第一级：局部总线 (Local Bus) —— <strong>“VIP 专用通道”</strong></h5><ul>
<li><strong>位置</strong>：最上方，连接 <strong>CPU</strong> 和 <strong>Cache (高速缓存)</strong>。</li>
<li><strong>作用</strong>：这是系统中最快的一条路。</li>
<li><strong>意义</strong>：CPU 和 Cache 之间的交互极其频繁且速度极快。把它们单独划在这个“小圈子”里，让 CPU 能全速运行，完全不受外界打扰。</li>
</ul>
<h5 id="第二级：主存总线-System-Bus-——-“城市主干道”"><a href="#第二级：主存总线-System-Bus-——-“城市主干道”" class="headerlink" title="第二级：主存总线 (System Bus) —— “城市主干道”"></a>第二级：主存总线 (System Bus) —— <strong>“城市主干道”</strong></h5><ul>
<li><strong>位置</strong>：中间层，连接 <strong>主存 (Main Memory)</strong>、<strong>Cache</strong> 和 <strong>局部 I/O 控制器</strong>。</li>
<li><strong>作用</strong>：负责内存数据的吞吐。</li>
<li><strong>意义</strong>：当 Cache 没命中时，需要从主存调数据，就走这条路。它比局部总线慢一点，但依然很快。</li>
</ul>
<h5 id="第三级：扩展总线-Expansion-Bus-——-“社区辅路”"><a href="#第三级：扩展总线-Expansion-Bus-——-“社区辅路”" class="headerlink" title="第三级：扩展总线 (Expansion Bus) —— “社区辅路”"></a>第三级：扩展总线 (Expansion Bus) —— <strong>“社区辅路”</strong></h5><ul>
<li><strong>位置</strong>：最下方，连接各种 <strong>I/O 设备</strong>（如 LAN网卡、SCSI设备、打印机等）。</li>
<li><strong>作用</strong>：专门用来挂载各种速度参差不齐的外设。</li>
<li><strong>关键组件</strong>：<strong>扩展总线接口 (Expansion Bus Interface)</strong>。它是连接“主干道”和“辅路”的<strong>立交桥/收费站</strong>。它不仅负责传递数据，还起到<strong>缓冲</strong>的作用，防止慢速设备的信号干扰高速总线。</li>
</ul>
<h5 id="优点：各行其道"><a href="#优点：各行其道" class="headerlink" title="优点：各行其道"></a>优点：各行其道</h5><p><strong>分流 (Isolation)</strong>：</p>
<ul>
<li><strong>“主存与 I/O 之间的数据传送”</strong> 和 <strong>“处理器的内存活动”</strong> 被分离开了。</li>
<li>简单说：硬盘往内存传数据（走扩展总线 -&gt; 主存总线）的时候，CPU 依然可以在局部总线上和 Cache 玩得很开心，互不影响。</li>
</ul>
<p><strong>扩展性强</strong>：</p>
<ul>
<li><strong>“支持更多的 I/O 设备”</strong>。因为有了扩展总线这一层，你可以挂很多慢速设备，而不会增加主存总线的负载（电容负载）。</li>
</ul>
<h5 id="缺点：木桶效应"><a href="#缺点：木桶效应" class="headerlink" title="缺点：木桶效应"></a>缺点：木桶效应</h5><p>PPT 也提到了一个缺点：<strong>“不适用于 I/O 设备数据速率相差太大的情形”</strong>。</p>
<ul>
<li><strong>解读</strong>：你看最下面的“扩展总线”，上面既挂了高速的 <strong>LAN (网卡)</strong>、<strong>SCSI (高速硬盘接口)</strong>，又可能挂慢速的 <strong>字符设备 (键盘/鼠标)</strong>。</li>
<li>如果所有外设都挤在这一根扩展总线上，高速设备（如千兆网卡）可能会觉得这条路太慢，或者被慢速设备抢占时隙，导致性能发挥不出来。</li>
<li><strong>解决思路</strong>：这就是为什么现代电脑（如你现在的 PC）其实演进到了更高级的结构（如 <strong>桥接芯片组架构</strong>，分为北桥和南桥，或者现在的 PCH），把高速 I/O (PCIe) 和低速 I/O (USB) 进一步分开。</li>
</ul>
<h4 id="南北桥架构”-Northbridge-and-Southbridge-Architecture"><a href="#南北桥架构”-Northbridge-and-Southbridge-Architecture" class="headerlink" title="南北桥架构” (Northbridge and Southbridge Architecture)"></a>南北桥架构” (Northbridge and Southbridge Architecture)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223163719210.png" alt="image-20251223163719210"></p>
<h5 id="核心理念：快慢彻底分家"><a href="#核心理念：快慢彻底分家" class="headerlink" title="核心理念：快慢彻底分家"></a>核心理念：快慢彻底分家</h5><p>PPT 顶部的文字点出了核心思路：<strong>“通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速I/O设备和低速I/O设备”</strong>。</p>
<ul>
<li><strong>为什么要分南北？</strong><ul>
<li>有些设备太快（内存、显卡），必须贴着 CPU 跑。</li>
<li>有些设备太慢（鼠标、键盘），离 CPU 远点没关系。</li>
<li>于是，主板芯片组被劈成了两半：<strong>北桥</strong>负责快，<strong>南桥</strong>负责慢</li>
</ul>
</li>
</ul>
<h5 id="北桥-Northbridge-——-速度担当"><a href="#北桥-Northbridge-——-速度担当" class="headerlink" title="北桥 (Northbridge) —— 速度担当"></a>北桥 (Northbridge) —— 速度担当</h5><p><strong>地位</strong>：它是离 CPU 最近的芯片（通常在主板上方，故称北桥）。</p>
<ul>
<li><strong>别名</strong>：PPT 中标注为 <strong>“主存控制器” (Memory Controller)</strong>。</li>
<li><strong>连接对象（贵族圈）</strong>：<ol>
<li><strong>CPU</strong>：通过“处理器总线”直接连接，带宽最高。</li>
<li><strong>主存 (RAM)</strong>：通过“存储总线”连接。这是北桥最重要的任务——管理内存读写。</li>
<li><strong>高速 I/O 设备</strong>：PPT 中展示了 <strong>图形设备 (显卡)</strong>、<strong>SCSI (服务器硬盘)</strong>、<strong>LAN (网卡)</strong> 挂接在 <strong>PCI 总线</strong> 上。虽然 PCI 总线在物理上通常由南桥管理或作为南北桥的桥梁，但逻辑上它们属于高速区，需要通过北桥与 CPU 高速交换数据。</li>
</ol>
</li>
</ul>
<h5 id="南桥-Southbridge-——-管家担当"><a href="#南桥-Southbridge-——-管家担当" class="headerlink" title="南桥 (Southbridge) —— 管家担当"></a>南桥 (Southbridge) —— 管家担当</h5><p><strong>地位</strong>：离 CPU 较远（通常在主板下方，故称南桥）。</p>
<ul>
<li><strong>别名</strong>：PPT 中标注为 <strong>“I/O 控制器”</strong>。</li>
<li><strong>连接对象（平民圈）</strong>：<ol>
<li><strong>低速 I/O 设备</strong>：PPT 下方展示的 <strong>COM 口</strong>、<strong>鼠标</strong>、<strong>键盘</strong>。</li>
<li><strong>慢速总线</strong>：这些设备挂在 <strong>E(ISA) 总线</strong> 上。这是一种非常古老且缓慢的总线标准。</li>
</ol>
</li>
<li><strong>职责</strong>：南桥负责处理这些琐碎、慢速的输入输出，整理好之后，再通过“桥间接口”统一汇报给北桥。</li>
</ul>
<h5 id="关键接口：桥间接口-Hub-Interface"><a href="#关键接口：桥间接口-Hub-Interface" class="headerlink" title="关键接口：桥间接口 (Hub Interface)"></a>关键接口：桥间接口 (Hub Interface)</h5><p>请看图中连接北桥和南桥的那根竖线——<strong>“桥间接口”</strong>。</p>
<ul>
<li>这是连接“CBD”和“郊区”的高速公路。</li>
<li>所有的鼠标点击、键盘输入，都要先汇聚到南桥，通过这个接口传给北桥，最后才能到达 CPU。</li>
</ul>
<p><strong>北桥</strong>：负责 <strong>CPU总线</strong>、<strong>存储总线</strong>（内存）以及 <strong>PCI总线</strong>（高速 I/O，如显卡、网卡）。</p>
<p><strong>南桥</strong>：负责 <strong>E(ISA)总线</strong>（慢速 I/O，如键盘、鼠标），并通过桥间接口与北桥通信。</p>
<h5 id="优点：支持不同速率-Heterogeneity"><a href="#优点：支持不同速率-Heterogeneity" class="headerlink" title="优点：支持不同速率 (Heterogeneity)"></a>优点：支持不同速率 (Heterogeneity)</h5><p>PPT 明确指出了这种架构的优点：<strong>“可以支持不同数据速率的 I/O 设备”</strong>。</p>
<ul>
<li><strong>各司其职</strong>：<ul>
<li>CPU 想读内存，直接找北桥，路径极短，速度极快。</li>
<li>CPU 想读鼠标，指令传给南桥，南桥慢慢去读，不会占用北桥的高速通道。</li>
</ul>
</li>
<li><strong>消除瓶颈</strong>：慢速的 ISA 设备再多，也不会拖慢 CPU 访问内存的速度，因为它们在物理上被隔绝在南桥下面了。</li>
</ul>
<p><strong>第一梯队（最快）：北桥负责</strong></p>
<ul>
<li><strong>不仅仅是内存</strong>：你说得对，北桥不仅连接主存，还连接了 <strong>图形设备 (显卡)</strong>。显卡是 I/O 设备中对速度要求最高的（比如打游戏时的数据吞吐量极大），所以它被提拔到了“北桥”这个 VIP 区域，直接和 CPU、内存享受高速通道。</li>
</ul>
<p><strong>第二梯队（较快）：PCI 总线</strong></p>
<ul>
<li><strong>LAN (网卡)</strong> 和 <strong>SCSI (硬盘)</strong> 挂在 <strong>PCI 总线</strong> 上。这是一条高速公路，专门给这些吞吐量大的设备跑。</li>
</ul>
<p><strong>第三梯队（慢速）：南桥负责</strong></p>
<ul>
<li><strong>鼠标、键盘</strong> 被赶到了最下面的 <strong>E(ISA) 总线</strong>，由 <strong>南桥</strong> 统一管理。</li>
<li>南桥像一个过滤器，把这些慢速设备的琐碎请求整理好，再通过中间的接口汇报上去。</li>
</ul>
<h3 id="I-O-软件的层次结构"><a href="#I-O-软件的层次结构" class="headerlink" title="I/O 软件的层次结构"></a>I/O 软件的层次结构</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223165755764.png" alt="image-20251223165755764"></p>
<h4 id="第-1-层：用户空间的-I-O-软件-User-Space-I-O-Software"><a href="#第-1-层：用户空间的-I-O-软件-User-Space-I-O-Software" class="headerlink" title="第 1 层：用户空间的 I/O 软件 (User-Space I/O Software)"></a>第 1 层：用户空间的 I/O 软件 (User-Space I/O Software)</h4><p><strong>“我要打印一份文件”</strong></p>
<ul>
<li><strong>位置</strong>：最顶层，直接和用户打交道。</li>
<li><strong>是谁</strong>：你写的 C 语言代码（<code>printf</code>, <code>scanf</code>），或者具体的应用程序（Word, 浏览器）。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>I/O 系统调用</strong>：发起请求。</li>
<li><strong>SPOOLing</strong>：比如你点打印时，电脑没卡死，而是把任务放到了后台队列里，这就是 SPOOLing 技术（后面会细讲）。</li>
<li><strong>I/O 格式化</strong>：比如把你的数字 <code>100</code> 转换成字符 <code>&#39;1&#39;, &#39;0&#39;, &#39;0&#39;</code> 显示在屏幕上。</li>
</ul>
</li>
<li><strong>特点</strong>：它根本不知道硬盘是圆的还是方的，它只知道“我要读/写数据”。</li>
</ul>
<h4 id="第-2-层：独立于设备的-I-O-软件-Device-Independent-I-O-Software"><a href="#第-2-层：独立于设备的-I-O-软件-Device-Independent-I-O-Software" class="headerlink" title="第 2 层：独立于设备的 I/O 软件 (Device-Independent I/O Software)"></a>第 2 层：独立于设备的 I/O 软件 (Device-Independent I/O Software)</h4><p><strong>“好的，不管你是存到 U 盘还是硬盘，逻辑都一样”</strong></p>
<ul>
<li><strong>位置</strong>：第二层，这是操作系统的<strong>核心通逻辑</strong>。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>设备的命名</strong>：把物理设备映射成逻辑名（比如 <code>/dev/sda</code> 或 <code>C:</code> 盘）。</li>
<li><strong>设备保护</strong>：检查你有没有权限读这个文件。</li>
<li><strong>缓冲 (Buffering)</strong>：非常关键！为了解决速度差异，数据会先暂存在这里。</li>
<li><strong>设备分配与释放</strong>：决定这个打印机现在归谁用。</li>
</ul>
</li>
<li><strong>特点</strong>：这一层<strong>抹平了硬件差异</strong>。对于它来说，所有设备都是“文件”。</li>
</ul>
<h4 id="第-3-层：I-O-设备驱动程序-Device-Drivers"><a href="#第-3-层：I-O-设备驱动程序-Device-Drivers" class="headerlink" title="第 3 层：I/O 设备驱动程序 (Device Drivers)"></a>第 3 层：I/O 设备驱动程序 (Device Drivers)</h4><p><strong>“收到，正在指挥西部数据硬盘的磁头移动”</strong></p>
<ul>
<li><strong>位置</strong>：第三层，这是<strong>最懂硬件</strong>的软件。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>翻译</strong>：把上层的“读第 5 个块”这种抽象命令，翻译成具体的硬件指令（如“设置寄存器 X 为 1，向端口 Y 发送数据”）。</li>
<li><strong>检查状态</strong>：看设备是不是忙，是不是出错了。</li>
</ul>
</li>
<li><strong>特点</strong>：<strong>每一类设备都有专门的驱动</strong>。显卡有显卡驱动，网卡有网卡驱动。它是操作系统和硬件之间的“翻译官”。</li>
</ul>
<h4 id="第-4-层：I-O-中断处理程序-Interrupt-Handlers"><a href="#第-4-层：I-O-中断处理程序-Interrupt-Handlers" class="headerlink" title="第 4 层：I/O 中断处理程序 (Interrupt Handlers)"></a>第 4 层：I/O 中断处理程序 (Interrupt Handlers)</h4><p><strong>“老板，活干完了！(叫醒 CPU)”</strong></p>
<ul>
<li><strong>位置</strong>：最底层软件，紧贴硬件。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>处理中断</strong>：当硬件干完活（比如 DMA 搬运完了），会发个电信号触发中断，这层软件负责响应。</li>
<li><strong>唤醒驱动</strong>：告诉上面的驱动程序“数据到了，你可以继续往下跑了”。</li>
</ul>
</li>
<li><strong>特点</strong>：它是在硬件事件发生后<strong>被动触发</strong>的“急救员”。</li>
</ul>
<h4 id="总结：数据流动的全过程"><a href="#总结：数据流动的全过程" class="headerlink" title="总结：数据流动的全过程"></a>总结：数据流动的全过程</h4><p>想象你在 Word 里点击“保存”（写硬盘）：</p>
<ol>
<li><strong>用户层</strong>：Word 调用系统函数 <code>write()</code>。</li>
<li><strong>独立层</strong>：OS 检查权限，分配缓存，找到文件对应的逻辑地址。</li>
<li><strong>驱动层</strong>：驱动程序把逻辑地址算出具体的磁道和扇区，向硬盘控制器发指令。</li>
<li><strong>硬件层</strong>：硬盘疯狂转动，磁头写入数据。</li>
<li><strong>中断层</strong>：硬盘写完，发中断。中断程序告诉驱动“搞定”，驱动告诉上层“搞定”，最后 Word 提示你“保存成功”。</li>
</ol>
<h3 id="I-O-缓冲区"><a href="#I-O-缓冲区" class="headerlink" title="I/O 缓冲区"></a>I/O 缓冲区</h3><h4 id="1-核心定义：什么是-I-O-缓冲区？"><a href="#1-核心定义：什么是-I-O-缓冲区？" class="headerlink" title="1. 核心定义：什么是 I/O 缓冲区？"></a>1. 核心定义：什么是 I/O 缓冲区？</h4><p>给出了明确定义：<strong>“在内存中开辟的存储区，专门用于临时存放 I/O 操作的数据”</strong>。</p>
<ul>
<li><strong>通俗理解</strong>：<ul>
<li><strong>没有缓冲</strong>：CPU 直接伸手向硬盘要数据，硬盘没给，CPU 就手悬在半空等着。</li>
<li><strong>有了缓冲</strong>：在内存里放一个<strong>“快递柜”</strong>。硬盘把数据慢慢填进柜子，填满了通知 CPU 来取。CPU 取数据的时候，硬盘可以继续往下一个柜子里填。</li>
</ul>
</li>
</ul>
<h4 id="2-为什么要引入缓冲？（五大目的）"><a href="#2-为什么要引入缓冲？（五大目的）" class="headerlink" title="2. 为什么要引入缓冲？（五大目的）"></a>2. 为什么要引入缓冲？（五大目的）</h4><p>PPT 左侧详细列出了目的，每一条都直击痛点：</p>
<ol>
<li><strong>解决速度不匹配</strong>：这是最核心的。CPU 是跑车，I/O 是拖拉机。缓冲让跑车不用停车等拖拉机。</li>
<li><strong>协调记录大小不一致</strong>：<ul>
<li><strong>逻辑记录</strong>：你的代码可能想读一行字（10个字节）。</li>
<li><strong>物理记录</strong>：硬盘一次只能读一个扇区（4KB）。</li>
<li><strong>缓冲的作用</strong>：把 4KB 读到缓冲区，然后把其中的 10个字节 拿给你的程序。</li>
</ul>
</li>
<li><strong>提高并行性</strong>：CPU 算它的，设备传它的，互不干扰。</li>
<li><strong>减少中断次数</strong>：<ul>
<li>如果没有缓冲，每来一个字符就要中断 CPU 一次。</li>
<li>有了缓冲，填满一整个缓冲区（比如 4KB）才中断一次。CPU 舒服多了。</li>
</ul>
</li>
<li><strong>放宽响应时间要求</strong>：数据来了先进缓冲区待着，CPU 忙完手头的事再来取，不用秒回。</li>
</ol>
<h4 id="3-缓冲技术的进化史（看右边的图）"><a href="#3-缓冲技术的进化史（看右边的图）" class="headerlink" title="3. 缓冲技术的进化史（看右边的图）"></a>3. 缓冲技术的进化史（看右边的图）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171004487.png" alt="image-20251223171004487"></p>
<p>PPT 右侧的四张小图展示了缓冲技术是如何一步步变强的。</p>
<h5 id="a-无缓冲-No-Buffering"><a href="#a-无缓冲-No-Buffering" class="headerlink" title="(a) 无缓冲 (No Buffering)"></a>(a) 无缓冲 (No Buffering)</h5><ul>
<li><strong>状态</strong>：CPU 和设备直接对接。</li>
<li><strong>后果</strong>：完全串行。设备忙，CPU 就要等；CPU 忙，设备就要停。<strong>效率最低</strong>。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171623306.png" alt="image-20251223171623306"></p>
<p><strong>1. 三个关键变量 (T, M, C)</strong></p>
<p>首先，你要搞清楚这三个字母代表什么，它们是一个数据块处理流程的三个步骤：</p>
<ul>
<li><strong>$T$ (Time for Input)</strong>：<strong>输入时间</strong>。从磁盘把一块数据读到缓冲区。这是 I/O 设备的活。</li>
<li><strong>$M$ (Time for Move)</strong>：<strong>传送时间</strong>。系统把数据从缓冲区“搬”到用户的内存区。这是内存复制的操作。</li>
<li><strong>$C$ (Time for Computation)</strong>：<strong>计算时间</strong>。CPU 对这块数据进行处理。这是 CPU 的活。</li>
</ul>
<p><strong>核心逻辑</strong>：</p>
<ul>
<li><strong>没有缓冲时</strong>：这三步是串行的，总时间 = $T + C$。</li>
<li><strong>有了单缓冲</strong>：<strong>$T$（I/O）</strong> 和 <strong>$C$（CPU计算）</strong> 可以<strong>并行</strong>了（同时进行）。</li>
</ul>
<p><strong>2. 两种场景分析</strong></p>
<p>PPT 下方展示了两种可能的情况，取决于<strong>“谁更慢”</strong>。</p>
<p><strong>情况一：T &gt; C (I/O 慢，CPU 快)</strong></p>
<p>这是左边的图。</p>
<ul>
<li><strong>场景</strong>：硬盘读得很慢 ($T$ 长)，CPU 算得很快 ($C$ 短)。</li>
<li><strong>过程</strong>：<ul>
<li>CPU 很快算完了上一块数据 ($C$)，但是下一块数据还没传完 ($T$)。</li>
<li><strong>结果</strong>：CPU 必须<strong>等待</strong>硬盘。</li>
</ul>
</li>
<li><strong>瓶颈</strong>：在于 $T$。</li>
<li><strong>处理一块数据的总时间</strong>：<strong>$T + M$</strong>。<ul>
<li><em>(注：虽然也有 C，但 C 包含在 T 的时间段里并行做完了，没有增加额外耗时，所以只算长的那段 T，加上必须要做的搬运 M。)</em></li>
</ul>
</li>
</ul>
<p><strong>情况二：T &lt; C (I/O 快，CPU 慢)</strong></p>
<p>这是右边的图。</p>
<ul>
<li><strong>场景</strong>：硬盘读得飞快 ($T$ 短)，但 CPU 计算很复杂，算得很慢 ($C$ 长)。</li>
<li><strong>过程</strong>：<ul>
<li>硬盘很快把缓冲区填满了 ($T$)，但是 CPU 还在算上一块 ($C$)，没空来取。</li>
<li><strong>结果</strong>：硬盘必须<strong>等待</strong> CPU 腾出缓冲区。</li>
</ul>
</li>
<li><strong>瓶颈</strong>：在于 $C$。</li>
<li><strong>处理一块数据的总时间</strong>：<strong>$C + M$</strong>。</li>
</ul>
<h5 id="b-单缓冲-Single-Buffer"><a href="#b-单缓冲-Single-Buffer" class="headerlink" title="(b) 单缓冲 (Single Buffer)"></a>(b) 单缓冲 (Single Buffer)</h5><ul>
<li><strong>原理</strong>：操作系统在内存里建<strong>一个</strong>仓库。<ul>
<li><strong>设备 -&gt; 仓库</strong>：设备把数据搬进仓库（CPU 此时可以干别的）。</li>
<li><strong>仓库 -&gt; 用户进程</strong>：仓库满了，CPU 把数据从仓库挪走。</li>
</ul>
</li>
<li><strong>局限</strong>：<strong>不能同时进出</strong>。当 CPU 正在从仓库取货时，设备不能往里面送货（因为只有一个门），设备必须暂停等待仓库腾空。</li>
</ul>
<h5 id="c-双缓冲-Double-Buffering-——-也叫“乒乓缓冲”"><a href="#c-双缓冲-Double-Buffering-——-也叫“乒乓缓冲”" class="headerlink" title="(c) 双缓冲 (Double Buffering) —— 也叫“乒乓缓冲”"></a>(c) 双缓冲 (Double Buffering) —— 也叫“乒乓缓冲”</h5><ul>
<li><strong>原理</strong>：建<strong>两个</strong>仓库（1号和2号）。</li>
<li><strong>玩法</strong>：<ul>
<li>设备往 <strong>1号</strong> 装货。</li>
<li>与此同时，CPU 从 <strong>2号</strong> 取货。</li>
<li>大家都不用停！等 1号满了、2号空了，交换一下。</li>
</ul>
</li>
<li><strong>优点</strong>：实现了<strong>极致的并行</strong>。除非 CPU 处理太慢或者设备太慢导致一方严重积压，否则数据流几乎是连续的。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171959180.png" alt="image-20251223171959180"></p>
<p>答案是：<strong>Max(C + M, T)</strong></p>
<p>这里的逻辑是：</p>
<ul>
<li><strong>T (Input)</strong>：设备往“缓冲区1”里送货的时间。</li>
<li><strong>C + M (Compute + Move)</strong>：CPU 从“缓冲区2”取货 ($M$) 并处理 ($C$) 的时间。</li>
<li>因为有两个缓冲区，这两件事是<strong>完全并行</strong>的。谁慢（时间长），整体速度就取决于谁。</li>
</ul>
<h5 id="d-多缓冲-循环缓冲-Circular-Buffering"><a href="#d-多缓冲-循环缓冲-Circular-Buffering" class="headerlink" title="(d) 多缓冲/循环缓冲 (Circular Buffering)"></a>(d) 多缓冲/循环缓冲 (Circular Buffering)</h5><ul>
<li><strong>原理</strong>：建<strong>很多个</strong>仓库，连成一个圈。</li>
<li><strong>场景</strong>：适用于<strong>阵发性</strong>的大量数据传输（比如看高清视频，网速忽快忽慢）。</li>
<li><strong>玩法</strong>：<ul>
<li>设备拼命往空仓库里填（生产者）。</li>
<li>CPU 拼命追着满仓库取（消费者）。</li>
<li>只要圈里还有空位，设备就不用停；只要圈里还有满位，CPU 就不用停。这是弹性最大的方案。</li>
</ul>
</li>
</ul>
<h3 id="独占型外围设备的分配"><a href="#独占型外围设备的分配" class="headerlink" title="独占型外围设备的分配"></a>独占型外围设备的分配</h3><h4 id="设备独立性-Device-Independence"><a href="#设备独立性-Device-Independence" class="headerlink" title="设备独立性 (Device Independence)"></a>设备独立性 (Device Independence)</h4><h5 id="1-核心痛点：如果把代码写死会怎样？"><a href="#1-核心痛点：如果把代码写死会怎样？" class="headerlink" title="1. 核心痛点：如果把代码写死会怎样？"></a>1. 核心痛点：如果把代码写死会怎样？</h5><p><strong>以前的做法 (物理设备绑定)</strong>：</p>
<ul>
<li>你在写程序时，如果直接写死：“我要用<strong>编号为 001 的那台惠普打印机</strong>”。</li>
<li><strong>后果</strong>：如果这台 001 号打印机坏了，或者被搬走了，你的程序就直接报错崩溃了，即使旁边还有一台一模一样的 002 号打印机空闲着，你也用不了。</li>
</ul>
<p><strong>总结</strong>：绑定具体物理设备虽然简单，但<strong>灵活性极差</strong>，一坏就瘫痪。</p>
<h5 id="2-解决方案：引入“逻辑设备”"><a href="#2-解决方案：引入“逻辑设备”" class="headerlink" title="2. 解决方案：引入“逻辑设备”"></a>2. 解决方案：引入“逻辑设备”</h5><p>为了解决这个问题，操作系统引入了<strong>设备独立性</strong>。</p>
<ul>
<li><strong>核心思想</strong>：<ul>
<li><strong>用户（程序员）</strong>：只负责说“我要用<strong>一台</strong>打印机”（这就是<strong>逻辑设备</strong>）。</li>
<li><strong>操作系统</strong>：负责去仓库看哪台打印机是好的、空闲的（比如 003 号），然后把它分配给你（这就是<strong>物理设备</strong>）。</li>
</ul>
</li>
<li><strong>PPT 定义</strong>：用户不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来。</li>
</ul>
<h5 id="3-实现机制：映射表-The-Mapping-Table"><a href="#3-实现机制：映射表-The-Mapping-Table" class="headerlink" title="3. 实现机制：映射表 (The Mapping Table)"></a>3. 实现机制：映射表 (The Mapping Table)</h5><p>操作系统是怎么把你的“空头支票”（逻辑设备）兑现成“真金白银”（物理设备）的呢？</p>
<ul>
<li>PPT 中间红字提到：系统需要提供<strong>逻辑设备名到物理设备名的映射表</strong>。</li>
<li><strong>类比</strong>：<ul>
<li>你打车时输入“我要去机场”（逻辑请求）。</li>
<li>打车软件（操作系统）查一下数据库（映射表），指派了“京B·12345”这辆车（物理设备）给你。</li>
<li>这一层映射关系，就是设备独立性的核心。</li>
</ul>
</li>
</ul>
<h5 id="4-三大优点-考试必考"><a href="#4-三大优点-考试必考" class="headerlink" title="4. 三大优点 (考试必考)"></a>4. 三大优点 (考试必考)</h5><p><strong>代码不用改 (应用程序与具体物理设备无关)</strong>：</p>
<ul>
<li>你换了个新鼠标，不需要去改你的游戏代码。因为游戏只调用“逻辑鼠标”，操作系统会自动把新鼠标映射上去。系统增减或变更设备时不需要修改源程序。</li>
</ul>
<p><strong>系统更可靠 (易于应对故障)</strong>：</p>
<ul>
<li>如果打印机 A 坏了，操作系统自动把任务导向打印机 B。用户根本感觉不到故障的存在。</li>
</ul>
<p><strong>资源分配更灵活</strong>：</p>
<ul>
<li>谁闲着就给谁用，实现了多道程序设计，不再出现“旱的旱死，涝的涝死”的情况。</li>
</ul>
<h5 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h5><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223173127932-1766482289243-1.png" alt="image-20251223173127932"></p>
<h3 id="共享型外围设备的驱动"><a href="#共享型外围设备的驱动" class="headerlink" title="共享型外围设备的驱动"></a>共享型外围设备的驱动</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223192427585.png" alt="image-20251223192427585"></p>
<h4 id="1-物理组件：搭建“多层蛋糕”"><a href="#1-物理组件：搭建“多层蛋糕”" class="headerlink" title="1. 物理组件：搭建“多层蛋糕”"></a>1. 物理组件：搭建“多层蛋糕”</h4><p>请看右上角的 3D 图：</p>
<ul>
<li><strong>盘片 (Platters)</strong>：磁盘里不只有一张盘，而是有多张盘片叠在一起，穿在中间的<strong>轴</strong>上高速旋转。</li>
<li><strong>盘面 (Surfaces)</strong>：每个盘片就像硬币一样，有<strong>正反两面</strong>。通常每一面都可以存数据，所以 2 个盘片就有 4 个盘面。</li>
<li><strong>磁头 (Heads)</strong>：看那个像梳子一样的<strong>移动臂</strong>，它的每一个齿尖上都有一个磁头。<ul>
<li><strong>关键点</strong>：所有磁头是<strong>共进退</strong>的。移动臂一动，所有磁头一起动。</li>
</ul>
</li>
</ul>
<h4 id="2-数据划分：画圈圈"><a href="#2-数据划分：画圈圈" class="headerlink" title="2. 数据划分：画圈圈"></a>2. 数据划分：画圈圈</h4><p>请看右下角的平面图：</p>
<ul>
<li><strong>磁道 (Track)</strong>：盘面被划分成无数个同心圆，每一个圈就是一个<strong>磁道</strong>。<ul>
<li><em>比喻：</em> 就像操场上的跑道。</li>
</ul>
</li>
<li><strong>扇区 (Sector)</strong>：每个磁道又像切披萨一样，被切分成很多小块，每一块叫<strong>扇区</strong>。<ul>
<li><strong>地位</strong>：扇区是磁盘读写的<strong>最小物理单位</strong>（通常是 512 字节或 4KB）。</li>
</ul>
</li>
</ul>
<h4 id="3-核心概念：柱面-Cylinder-——-考试必考"><a href="#3-核心概念：柱面-Cylinder-——-考试必考" class="headerlink" title="3. 核心概念：柱面 (Cylinder) —— 考试必考"></a>3. 核心概念：柱面 (Cylinder) —— 考试必考</h4><p>这是最抽象但最重要的概念。请看右上角图中标注红色的虚线圆柱体。</p>
<ul>
<li><strong>定义</strong>：所有盘面上，<strong>半径相同</strong>的那些磁道，在垂直方向上叠在一起，就构成了一个<strong>柱面</strong>。</li>
<li><strong>为什么要有这个概念？</strong><ul>
<li>因为所有磁头是固定在同一个移动臂上的。</li>
<li>当你把磁头移动到最外圈（磁道 0）时，<strong>所有盘面</strong>的磁头都同时停在了磁道 0 上。</li>
<li><strong>性能秘诀</strong>：如果不移动机械臂，只通过<strong>电子切换</strong>磁头来读写不同盘面上的数据，速度是极快的。</li>
<li><strong>结论</strong>：<strong>柱面</strong>是操作系统优化读写速度的关键。把相关联的数据存在同一个柱面上，就能减少机械臂的移动。</li>
</ul>
</li>
</ul>
<h4 id="4-磁盘寻址：如何找到一个数据块？"><a href="#4-磁盘寻址：如何找到一个数据块？" class="headerlink" title="4. 磁盘寻址：如何找到一个数据块？"></a>4. 磁盘寻址：如何找到一个数据块？</h4><p>PPT 左下角红字列出了<strong>物理块地址</strong>的编码方法，最经典的是 <strong>CHS 寻址法</strong>：</p>
<p><strong>1. 柱面号 (Cylinder)</strong> —— <strong>找圈</strong></p>
<ul>
<li>首先，操作系统指挥移动臂，把磁头移动到指定的半径位置（比如第 100 号柱面）。</li>
<li><em>动作：机械移动（最慢，叫“寻道时间”）。</em></li>
</ul>
<p><strong>2. 磁头号 (Head)</strong> —— <strong>找面</strong></p>
<ul>
<li>磁头臂到了位置，但有 4 个盘面，我要读哪一个？通过激活具体的磁头来选择盘面。</li>
<li><em>动作：电子切换（极快）。</em></li>
</ul>
<p><strong>3. 扇区号 (Sector)</strong> —— <strong>找块</strong></p>
<ul>
<li>盘面在疯狂旋转，磁头不动，等着指定的那个扇区（披萨块）转到磁头底下。</li>
<li><em>动作：机械旋转等待（较慢，叫“旋转延迟”）。</em></li>
</ul>
<h4 id="地址转换关系（扇区编号从0开始）"><a href="#地址转换关系（扇区编号从0开始）" class="headerlink" title="地址转换关系（扇区编号从0开始）"></a>地址转换关系（扇区编号从0开始）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223194324624.png" alt="image-20251223194324624"></p>
<h3 id="磁盘存取时间"><a href="#磁盘存取时间" class="headerlink" title="磁盘存取时间"></a>磁盘存取时间</h3><script type="math/tex; mode=display">T_a = T_s + \frac{1}{2r} + \frac{b}{rN}</script><p>公式左边的 <strong>$T_a$</strong> 代表 <strong>磁盘一次存取的总时间 (Total Access Time)</strong>。它由三部分组成：</p>
<h4 id="第一部分：寻道时间-T-s-——-“最耗时的赶路”"><a href="#第一部分：寻道时间-T-s-——-“最耗时的赶路”" class="headerlink" title="第一部分：寻道时间 ($T_s$) —— “最耗时的赶路”"></a>第一部分：寻道时间 ($T_s$) —— “最耗时的赶路”</h4><ul>
<li><strong>对应变量</strong>：<strong>$T_s$ (Seek Time)</strong>。</li>
<li><strong>含义</strong>：机械臂把磁头移动到指定柱面（磁道）所花的时间。</li>
<li><strong>特点</strong>：<ul>
<li>这是<strong>物理机械运动</strong>。</li>
<li>在计算题中，通常会直接给你一个平均值（比如 “平均寻道时间为 10ms”），或者让你根据移动了多少个磁道来算。</li>
<li><strong>它是性能杀手</strong>：通常占总时间的大头。</li>
</ul>
</li>
</ul>
<h4 id="第二部分：旋转延迟-frac-1-2r-——-“平均运气”"><a href="#第二部分：旋转延迟-frac-1-2r-——-“平均运气”" class="headerlink" title="第二部分：旋转延迟 ($\frac{1}{2r}$) —— “平均运气”"></a>第二部分：旋转延迟 ($\frac{1}{2r}$) —— “平均运气”</h4><ul>
<li><strong>对应变量</strong>：图中蓝色的 <strong>$\frac{1}{2r}$</strong>。</li>
<li><strong>含义</strong>：<strong>平均旋转等待时间</strong>。</li>
<li><strong>推导逻辑</strong>（非常重要）：<ul>
<li><strong>$r$</strong>：磁盘旋转速度（单位：转/秒）。比如 7200转/分 = 120转/秒。</li>
<li><strong>$1/r$</strong>：转一整圈需要的时间。</li>
<li><strong>为什么是 $1/2$？</strong>：因为当你磁头到了磁道时，目标扇区可能刚过去（要等一整圈），也可能正好就在下面（不用等）。<strong>平均来看，你需要等半圈</strong>。</li>
<li>这就是 <strong>$\frac{1}{2} \times (\text{转一圈的时间})$</strong> 的由来。</li>
</ul>
</li>
</ul>
<h4 id="第三部分：传输时间-frac-b-rN-——-“真正的读写”"><a href="#第三部分：传输时间-frac-b-rN-——-“真正的读写”" class="headerlink" title="第三部分：传输时间 ($\frac{b}{rN}$) —— “真正的读写”"></a>第三部分：传输时间 ($\frac{b}{rN}$) —— “真正的读写”</h4><ul>
<li><strong>对应变量</strong>：图中橙色的 <strong>$\frac{b}{rN}$</strong>。</li>
<li><strong>含义</strong>：<strong>平均传输时间</strong>。也就是磁头扫过数据块并读取内容的时间。</li>
<li><strong>变量详解</strong>：<ul>
<li><strong>$b$</strong>：你要读写的字节数 (Bytes to transfer)。</li>
<li><strong>$N$</strong>：一个磁道上总共有多少字节 (Bytes per track)。</li>
<li><strong>$r$</strong>：转速。</li>
</ul>
</li>
<li><strong>推导逻辑</strong>：<ul>
<li><strong>$r \times N$</strong> = 磁盘一秒钟能扫过多少数据（数据传输率）。</li>
<li><strong>时间 = 总量 / 速度</strong> = $b / (r \times N)$。</li>
<li><em>或者另一种理解：</em> $\frac{b}{N}$ 表示你要读的数据占了这一圈的百分之多少（比如占了 1/10 圈），然后乘以转一圈的时间 ($1/r$)。结果是一样的。</li>
</ul>
</li>
</ul>
<h3 id="移臂调度及算法"><a href="#移臂调度及算法" class="headerlink" title="移臂调度及算法"></a>移臂调度及算法</h3><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195351262.png" alt="image-20251223195351262"></p>
<h4 id="最短查找时间优先算法"><a href="#最短查找时间优先算法" class="headerlink" title="最短查找时间优先算法"></a>最短查找时间优先算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195424991.png" alt="image-20251223195424991"></p>
<h4 id="单向扫描算法"><a href="#单向扫描算法" class="headerlink" title="单向扫描算法"></a>单向扫描算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195452951.png" alt="image-20251223195452951"></p>
<h4 id="双向扫描算法"><a href="#双向扫描算法" class="headerlink" title="双向扫描算法"></a>双向扫描算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195516927.png" alt="image-20251223195516927"></p>
<h4 id="电梯调度算法"><a href="#电梯调度算法" class="headerlink" title="电梯调度算法"></a>电梯调度算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195602421.png" alt="image-20251223195602421"></p>
<h3 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h3><h4 id="循环排序"><a href="#循环排序" class="headerlink" title="循环排序"></a>循环排序</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223201528047.png" alt="image-20251223201528047"></p>
<h4 id="优化分布（交替排序）"><a href="#优化分布（交替排序）" class="headerlink" title="优化分布（交替排序）"></a>优化分布（交替排序）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223204707858.png" alt="image-20251223204707858"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2025/">操作系统原理 (2025 春季学期)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XZAbeqEyt/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">01 - AI 时代的操作系统课2025 南京大学操作系统原理]_哔哩哔哩_bilibili</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="张熙浚 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="张熙浚 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag"># 大学</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="prev" title="计算机组成原理">
                  <i class="fa fa-angle-left"></i> 计算机组成原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/" rel="next" title="计算机组成原理作业">
                  计算机组成原理作业 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
