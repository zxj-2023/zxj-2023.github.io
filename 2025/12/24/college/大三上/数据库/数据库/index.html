<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数据库系统三级模式结构 1. 最外层：外模式 (External Schema)—— 用户看数据的视角（“我要看什么”）  别名：也称为子模式或用户模式。 定义：它是数据库用户（包括应用程序）能够看见和使用的局部数据的逻辑结构和特征的描述。 通俗理解：就像在这个系统中，财务只看“工资表”，HR 只看“人事表”。每个人只关心和自己有关的那一小部分数据，这就是外模式。   数量关系： 一个数据库可以有">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="数据库系统三级模式结构 1. 最外层：外模式 (External Schema)—— 用户看数据的视角（“我要看什么”）  别名：也称为子模式或用户模式。 定义：它是数据库用户（包括应用程序）能够看见和使用的局部数据的逻辑结构和特征的描述。 通俗理解：就像在这个系统中，财务只看“工资表”，HR 只看“人事表”。每个人只关心和自己有关的那一小部分数据，这就是外模式。   数量关系： 一个数据库可以有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235942961.png">
<meta property="og:image" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20251225162135184.png">
<meta property="og:image" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20251225162530664.png">
<meta property="og:image" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235719915.png">
<meta property="og:image" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235032775.png">
<meta property="article:published_time" content="2025-12-23T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-01T15:59:43.995Z">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="大学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235942961.png">


<link rel="canonical" href="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/","path":"2025/12/24/college/大三上/数据库/数据库/","title":"数据库"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据库 | Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhang XiJun</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据库系统三级模式结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9C%80%E5%A4%96%E5%B1%82%EF%BC%9A%E5%A4%96%E6%A8%A1%E5%BC%8F-External-Schema"><span class="nav-number">1.1.</span> <span class="nav-text">1. 最外层：外模式 (External Schema)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%AD%E9%97%B4%E5%B1%82%EF%BC%9A%E6%A8%A1%E5%BC%8F-Schema"><span class="nav-number">1.2.</span> <span class="nav-text">2. 中间层：模式 (Schema)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%80%E5%86%85%E5%B1%82%EF%BC%9A%E5%86%85%E6%A8%A1%E5%BC%8F-Internal-Schema"><span class="nav-number">1.3.</span> <span class="nav-text">3. 最内层：内模式 (Internal Schema)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%EF%BC%88DDL%EF%BC%89%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80-%EF%BC%88DML%EF%BC%89%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%EF%BC%88DCL%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">集数据定义语言（DDL），数据操纵语言 （DML），数据控制语言（DCL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-DDL-Data-Definition-Language-%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80"><span class="nav-number">2.0.1.</span> <span class="nav-text">1. DDL (Data Definition Language) —— 数据定义语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-DML-Data-Manipulation-Language-%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80"><span class="nav-number">2.0.2.</span> <span class="nav-text">2. DML (Data Manipulation Language) —— 数据操纵语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-DCL-Data-Control-Language-%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80"><span class="nav-number">2.0.3.</span> <span class="nav-text">3. DCL (Data Control Language) —— 数据控制语言</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%97%E7%BA%A7%E7%BA%A6%E6%9D%9F%EF%BC%8C%E8%A1%A8%E7%BA%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">3.</span> <span class="nav-text">数据类型，列级约束，表级约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Common-Data-Types"><span class="nav-number">3.1.</span> <span class="nav-text">一、 常见的数据类型 (Common Data Types)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B-Numbers"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. 数值类型 (Numbers)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-Strings"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. 字符串类型 (Strings)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4-Date-amp-Time"><span class="nav-number">3.1.3.</span> <span class="nav-text">3. 日期与时间 (Date &amp; Time)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.4.</span> <span class="nav-text">4. 其他重要类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E5%88%97%E7%BA%A7%E7%BA%A6%E6%9D%9F-vs-%E8%A1%A8%E7%BA%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">3.2.</span> <span class="nav-text">二、 列级约束 vs 表级约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%97%E7%BA%A7%E7%BA%A6%E6%9D%9F-Column-level-Constraints"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 列级约束 (Column-level Constraints)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A1%A8%E7%BA%A7%E7%BA%A6%E6%9D%9F-Table-level-Constraints"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 表级约束 (Table-level Constraints)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CREATE-TABLE"><span class="nav-number">4.</span> <span class="nav-text">CREATE TABLE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%AD%A6%E7%94%9F%E9%80%89%E8%AF%BE%E8%A1%A8-SC-%E4%BE%8B-3-7"><span class="nav-number">4.0.1.</span> <span class="nav-text">建立学生选课表 SC (例 3.7)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ALTER-TABLE"><span class="nav-number">5.</span> <span class="nav-text">ALTER TABLE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E9%AA%A8%E6%9E%B6"><span class="nav-number">5.1.</span> <span class="nav-text">1. 核心语法骨架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.2.</span> <span class="nav-text">2. 三大核心操作详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%A2%9E%E5%8A%A0-ADD-%E2%80%94%E2%80%94-%E7%BB%99%E6%88%BF%E5%AD%90%E5%8A%A0%E4%B8%AA%E6%88%BF%E9%97%B4"><span class="nav-number">5.2.1.</span> <span class="nav-text">A. 增加 (ADD) —— 给房子加个房间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E4%BF%AE%E6%94%B9-ALTER-COLUMN-%E2%80%94%E2%80%94-%E7%BB%99%E6%88%BF%E9%97%B4%E6%8D%A2%E4%B8%AA%E5%9C%B0%E6%9D%BF"><span class="nav-number">5.2.2.</span> <span class="nav-text">B. 修改 (ALTER COLUMN) —— 给房间换个地板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%88%A0%E9%99%A4-DROP-%E2%80%94%E2%80%94-%E6%8A%8A%E6%88%BF%E9%97%B4%E6%8B%86%E4%BA%86"><span class="nav-number">5.2.3.</span> <span class="nav-text">C. 删除 (DROP) —— 把房间拆了</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%9ACASCADE-vs-RESTRICT-%E7%BA%A7%E8%81%94%E4%B8%8E%E9%99%90%E5%88%B6"><span class="nav-number">5.3.</span> <span class="nav-text">3. 重难点：CASCADE vs RESTRICT (级联与限制)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DROP-TABLE"><span class="nav-number">6.</span> <span class="nav-text">DROP TABLE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">1. 核心语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E7%A7%8D%E5%88%A0%E9%99%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.2.</span> <span class="nav-text">2. 两种删除模式详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-RESTRICT-%E9%BB%98%E8%AE%A4-%E4%BF%9D%E5%AE%88%E6%A8%A1%E5%BC%8F-%E2%80%94%E2%80%94-%E2%80%9C%E6%9C%89%E7%89%B5%E6%8C%82%E5%B0%B1%E4%B8%8D%E8%B5%B0%E2%80%9D"><span class="nav-number">6.2.1.</span> <span class="nav-text">A. RESTRICT (默认&#x2F;保守模式) —— “有牵挂就不走”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-CASCADE-%E7%BA%A7%E8%81%94-%E5%BC%BA%E5%88%B6%E6%A8%A1%E5%BC%8F-%E2%80%94%E2%80%94-%E2%80%9C%E8%BF%9E%E6%A0%B9%E6%8B%94%E8%B5%B7%E2%80%9D"><span class="nav-number">6.2.2.</span> <span class="nav-text">B. CASCADE (级联&#x2F;强制模式) —— “连根拔起”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#schema"><span class="nav-number">7.</span> <span class="nav-text">schema</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Schema%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">1. 什么是 Schema？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Schema-%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">2. Schema 的三大核心作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-Namespace-%E2%80%94%E2%80%94-%E9%98%B2%E6%AD%A2%E6%89%93%E6%9E%B6"><span class="nav-number">7.2.1.</span> <span class="nav-text">A. 命名空间 (Namespace) —— 防止打架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-Security-%E2%80%94%E2%80%94-%E5%AE%89%E5%85%A8%E5%9B%B4%E6%A0%8F"><span class="nav-number">7.2.2.</span> <span class="nav-text">B. 权限管理 (Security) —— 安全围栏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%80%BB%E8%BE%91%E5%88%86%E7%B1%BB-Organization-%E2%80%94%E2%80%94-%E6%B2%BB%E6%84%88%E5%BC%BA%E8%BF%AB%E7%97%87"><span class="nav-number">7.2.3.</span> <span class="nav-text">C. 逻辑分类 (Organization) —— 治愈强迫症</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CREATE-SCHEMA"><span class="nav-number">8.</span> <span class="nav-text">CREATE SCHEMA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%80%8E%E4%B9%88%E5%BB%BA%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">1. 核心语法：怎么建？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9B%E9%98%B6%E7%8E%A9%E6%B3%95%EF%BC%9A%E2%80%9C%E6%89%93%E5%8C%85%E5%88%9B%E5%BB%BA%E2%80%9D-Combo"><span class="nav-number">8.2.</span> <span class="nav-text">2. 进阶玩法：“打包创建” (Combo)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E5%AE%9A%E4%B9%89%E5%AD%90%E5%8F%A5"><span class="nav-number">9.</span> <span class="nav-text">授权定义子句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-GRANT%EF%BC%9F"><span class="nav-number">9.1.</span> <span class="nav-text">一、 核心概念：什么是 GRANT？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E6%9D%83%E9%99%90%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%88%E6%8C%89%E5%B1%82%E7%BA%A7%E5%88%92%E5%88%86%EF%BC%89"><span class="nav-number">9.2.</span> <span class="nav-text">二、 权限的种类（按层级划分）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A8%A1%E5%BC%8F%E7%BA%A7%E5%88%AB%E6%9D%83%E9%99%90-Schema-Level-%E2%80%94%E2%80%94-%E8%BF%9B%E5%85%A5%E4%B8%8E%E5%88%9B%E5%BB%BA"><span class="nav-number">9.2.1.</span> <span class="nav-text">1. 模式级别权限 (Schema Level) —— 进入与创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%BA%A7%E5%88%AB%E6%9D%83%E9%99%90-Object-Level-%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">9.2.2.</span> <span class="nav-text">2. 对象级别权限 (Object Level) —— 数据读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8E%88%E6%9D%83%E6%9D%83%E5%8A%9B-WITH-GRANT-OPTION-%E2%80%94%E2%80%94-%E2%80%9C%E8%BD%AC%E6%8E%88%E6%9D%83%E2%80%9D"><span class="nav-number">9.2.3.</span> <span class="nav-text">3. 授权权力 (WITH GRANT OPTION) —— “转授权”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DROP-SCHEMA"><span class="nav-number">10.</span> <span class="nav-text">DROP SCHEMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%9F%BA%E6%9C%AC%E8%A1%A8%E6%97%B6%E8%AE%BE%E5%AE%9A%E6%89%80%E5%B1%9E%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">如何在定义基本表时设定所属模式？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%90%8C%E6%97%B6%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">11.1.</span> <span class="nav-text">1. 在创建模式语句中同时创建表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%A8%E8%A1%A8%E5%90%8D%E4%B8%AD%E6%98%BE%E5%BC%8F%E7%BB%99%E5%87%BA%E6%A8%A1%E5%BC%8F%E5%90%8D"><span class="nav-number">11.2.</span> <span class="nav-text">2. 在表名中显式给出模式名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%EF%BC%88Search-Path%EF%BC%89"><span class="nav-number">11.3.</span> <span class="nav-text">3. 设置搜索路径（Search Path）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="nav-number">12.</span> <span class="nav-text">模式的搜索路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-number">12.0.1.</span> <span class="nav-text">1. 核心概念：为什么要用搜索路径？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-number">12.0.2.</span> <span class="nav-text">2. 如何查看当前的搜索路径？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E4%B8%8E%E2%80%9C%E5%88%9B%E5%BB%BA%E8%A1%A8%E2%80%9D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">12.0.3.</span> <span class="nav-text">3. 搜索路径与“创建表”的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93"><span class="nav-number">12.1.</span> <span class="nav-text">💡 核心总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95-Index"><span class="nav-number">13.</span> <span class="nav-text">索引 (Index)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%9B%AE%E7%9A%84%EF%BC%9A%E4%BB%A5%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="nav-number">13.1.</span> <span class="nav-text">1. 核心目的：以空间换时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">13.2.</span> <span class="nav-text">2. 索引的本质是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.3.</span> <span class="nav-text">3. 常见的索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-B-%E6%A0%91%E7%B4%A2%E5%BC%95-B-Tree-Index"><span class="nav-number">13.3.1.</span> <span class="nav-text">1. B+树索引 (B+Tree Index)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%A3%E5%88%97-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-Hash-Index"><span class="nav-number">13.3.2.</span> <span class="nav-text">2. 散列&#x2F;哈希索引 (Hash Index)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95-Indexed-Sequential-File"><span class="nav-number">13.3.3.</span> <span class="nav-text">3. 顺序文件上的索引 (Indexed Sequential File)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95-Bitmap-Index"><span class="nav-number">13.3.4.</span> <span class="nav-text">4. 位图索引 (Bitmap Index)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="nav-number">14.</span> <span class="nav-text">建立索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%84%E4%BB%B6"><span class="nav-number">14.1.</span> <span class="nav-text">1. 基础语法组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90"><span class="nav-number">14.2.</span> <span class="nav-text">2. 核心关键字解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UNIQUE-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.1.</span> <span class="nav-text">UNIQUE (唯一索引)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLUSTER-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.2.</span> <span class="nav-text">CLUSTER (聚簇索引)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%AC%A1%E5%BA%8F-Order"><span class="nav-number">14.3.</span> <span class="nav-text">3. 次序 (Order)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">15.</span> <span class="nav-text">修改索引与删除索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95-ALTER-INDEX"><span class="nav-number">15.1.</span> <span class="nav-text">一、 修改索引 (ALTER INDEX)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95-DROP-INDEX"><span class="nav-number">15.2.</span> <span class="nav-text">二、 删除索引 (DROP INDEX)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E5%90%8C%E5%90%8D%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">15.2.1.</span> <span class="nav-text">特殊情况：同名索引的处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="nav-number">16.</span> <span class="nav-text">数据查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="nav-number">16.1.</span> <span class="nav-text">1. 查询语句的标准格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%90%84%E4%B8%AA%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8A%9F%E8%83%BD%E6%8B%86%E8%A7%A3"><span class="nav-number">16.2.</span> <span class="nav-text">2. 各个子句的功能拆解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%9D%E5%AD%A6%E8%80%85%E6%9C%80%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%82%B9"><span class="nav-number">16.3.</span> <span class="nav-text">3. 初学者最容易混淆的两个点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-ALL-vs-DISTINCT"><span class="nav-number">16.3.1.</span> <span class="nav-text">A. ALL vs DISTINCT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-WHERE-vs-HAVING"><span class="nav-number">16.3.2.</span> <span class="nav-text">B. WHERE vs HAVING</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88WHERE%E5%AD%90%E5%8F%A5%E4%B8%AD%E6%98%AF%E4%B8%8D%E8%83%BD%E7%94%A8%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">为什么WHERE子句中是不能用聚集函数作为条件表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%9F%9B%E7%9B%BE%EF%BC%88%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%9B%A0%EF%BC%89"><span class="nav-number">17.1.</span> <span class="nav-text">1. 执行顺序的矛盾（核心原因）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%9C%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">17.2.</span> <span class="nav-text">2. 作用对象的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8-HAVING"><span class="nav-number">17.3.</span> <span class="nav-text">3. 正确的解决办法：使用 HAVING</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LIMIT-%E5%AD%90%E5%8F%A5"><span class="nav-number">18.</span> <span class="nav-text">LIMIT 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-number">18.1.</span> <span class="nav-text">1. 核心语法格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E7%BB%84%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">18.2.</span> <span class="nav-text">2. 参数组合的使用语义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%EF%BC%88%E5%8F%AA%E9%99%90%E5%88%B6%E6%95%B0%E9%87%8F%EF%BC%89"><span class="nav-number">18.2.1.</span> <span class="nav-text">A. 基础用法（只限制数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%EF%BC%88%E8%B7%B3%E8%BF%87-%E9%99%90%E5%88%B6%EF%BC%89"><span class="nav-number">18.2.2.</span> <span class="nav-text">B. 进阶用法（跳过 + 限制）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%BB%84%E9%87%91%E6%90%AD%E6%A1%A3%EF%BC%9ALIMIT-ORDER-BY"><span class="nav-number">18.3.</span> <span class="nav-text">3. 黄金搭档：LIMIT + ORDER BY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="nav-number">19.</span> <span class="nav-text">连接查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-number">19.1.</span> <span class="nav-text">1. 核心概念：什么是连接？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F"><span class="nav-number">19.2.</span> <span class="nav-text">2. 连接条件的两种表达方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">19.2.1.</span> <span class="nav-text">A. 使用比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E4%BD%BF%E7%94%A8-BETWEEN-%E2%80%A6-AND"><span class="nav-number">19.2.2.</span> <span class="nav-text">B. 使用 BETWEEN … AND</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E2%80%9C%E5%A4%A7%E9%A4%90%E2%80%9D%EF%BC%9A%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">19.3.</span> <span class="nav-text">3. 连接查询的执行“大餐”：等值连接与自然连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5-Equijoin"><span class="nav-number">19.3.1.</span> <span class="nav-text">等值连接 (Equijoin)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5-Natural-Join"><span class="nav-number">19.3.2.</span> <span class="nav-text">自然连接 (Natural Join)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%9E%E6%88%98%E6%BC%94%E7%A4%BA%EF%BC%9A%E6%9F%A5%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%AD%A6%E7%94%9F%E5%8F%8A%E5%85%B6%E9%80%89%E4%BF%AE%E8%AF%BE%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">19.4.</span> <span class="nav-text">4. 实战演示：查出每个学生及其选修课程的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"><span class="nav-number">20.</span> <span class="nav-text">嵌套查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A%E7%88%B6%E4%B8%8E%E5%AD%90"><span class="nav-number">20.1.</span> <span class="nav-text">1. 嵌套查询的结构：父与子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%9F%A5%E8%AF%A2%E9%80%89%E4%BF%AE%E4%BA%86-2-%E5%8F%B7%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%AD%A6%E7%94%9F%E5%A7%93%E5%90%8D"><span class="nav-number">20.2.</span> <span class="nav-text">2. 经典案例解析：查询选修了 2 号课程的学生姓名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%87%8D%E8%A6%81%E9%99%90%E5%88%B6%EF%BC%9A%E4%B8%8D%E8%83%BD%E7%94%A8-ORDER-BY"><span class="nav-number">20.3.</span> <span class="nav-text">3. 子查询的重要限制：不能用 ORDER BY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-number">20.4.</span> <span class="nav-text">4. 嵌套查询的灵活性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">21.</span> <span class="nav-text">插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E5%85%A5%E5%85%83%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">21.1.</span> <span class="nav-text">1. 插入元组的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E5%85%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">21.2.</span> <span class="nav-text">2. 插入子查询结果的语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">22.</span> <span class="nav-text">修改数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">22.1.</span> <span class="nav-text">一、 修改数据的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%AE%E6%94%B9%E6%96%B9%E5%BC%8F"><span class="nav-number">22.2.</span> <span class="nav-text">二、 三种常见的修改方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BF%AE%E6%94%B9%E5%8D%95%E4%B8%AA%E5%85%83%E7%BB%84%EF%BC%88%E7%B2%BE%E5%87%86%E6%89%93%E5%87%BB%EF%BC%89"><span class="nav-number">22.2.1.</span> <span class="nav-text">1. 修改单个元组（精准打击）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%EF%BC%88%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="nav-number">22.2.2.</span> <span class="nav-text">2. 修改多个元组（批量操作）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BF%AE%E6%94%B9%EF%BC%88%E5%8A%A8%E6%80%81%E5%85%B3%E8%81%94%EF%BC%89"><span class="nav-number">22.2.3.</span> <span class="nav-text">3. 带子查询的修改（动态关联）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">22.3.</span> <span class="nav-text">三、 修改数据时的注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">23.</span> <span class="nav-text">删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">23.1.</span> <span class="nav-text">1. 删除数据的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A0%E9%99%A4%E6%96%B9%E5%BC%8F"><span class="nav-number">23.2.</span> <span class="nav-text">2. 三种常见的删除方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%88%A0%E9%99%A4%E5%8D%95%E4%B8%AA%E5%85%83%E7%BB%84%EF%BC%88%E7%B2%BE%E5%87%86%E5%88%A0%E9%99%A4%EF%BC%89"><span class="nav-number">23.2.1.</span> <span class="nav-text">A. 删除单个元组（精准删除）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%EF%BC%88%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%EF%BC%89"><span class="nav-number">23.2.2.</span> <span class="nav-text">B. 删除多个元组（批量删除）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E5%85%B3%E8%81%94%E5%88%A0%E9%99%A4%EF%BC%89"><span class="nav-number">23.2.3.</span> <span class="nav-text">C. 带子查询的删除（关联删除）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%87%8D%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9ADELETE-vs-DROP"><span class="nav-number">23.3.</span> <span class="nav-text">3. 重要区别：DELETE vs DROP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E2%9A%A0-%E5%AE%89%E5%85%A8%E8%AD%A6%E5%91%8A%EF%BC%9A%E5%88%A0%E9%99%A4%E5%89%8D%E7%9A%84%E2%80%9C%E6%BD%9C%E8%A7%84%E5%88%99%E2%80%9D"><span class="nav-number">23.4.</span> <span class="nav-text">4. ⚠ 安全警告：删除前的“潜规则”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93-1"><span class="nav-number">23.5.</span> <span class="nav-text">💡 核心总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7-Data-Integrity"><span class="nav-number">24.</span> <span class="nav-text">数据库完整性 (Data Integrity)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BB%B4%E5%BA%A6"><span class="nav-number">24.1.</span> <span class="nav-text">1. 完整性的两个核心维度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%8C%E6%95%B4%E6%80%A7-vs-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9%E6%8B%A8"><span class="nav-number">24.2.</span> <span class="nav-text">2. 完整性 vs. 安全性：易混淆点拨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-DBMS-%E7%BB%B4%E6%8A%A4%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E4%B8%89%E5%A5%97%E6%9C%BA%E5%88%B6"><span class="nav-number">24.3.</span> <span class="nav-text">3. DBMS 维护完整性的三套机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0-%E6%8F%90%E4%BE%9B%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">24.3.1.</span> <span class="nav-text">① 提供定义完整性约束条件的机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1-%E6%8F%90%E4%BE%9B%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">24.3.2.</span> <span class="nav-text">② 提供完整性检查的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2-%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"><span class="nav-number">24.3.3.</span> <span class="nav-text">③ 违约处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7-Entity-Integrity"><span class="nav-number">25.</span> <span class="nav-text">实体完整性 (Entity Integrity)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99"><span class="nav-number">25.0.1.</span> <span class="nav-text">1. 实体完整性的核心规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">25.0.2.</span> <span class="nav-text">2. 如何定义实体完整性？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-%E5%8D%95%E5%B1%9E%E6%80%A7%E4%B8%BB%E9%94%AE%EF%BC%88%E7%A0%81%E7%94%B1%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%9E%84%E6%88%90%EF%BC%89"><span class="nav-number">25.0.2.1.</span> <span class="nav-text">A. 单属性主键（码由一个属性构成）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-%E5%A4%9A%E5%B1%9E%E6%80%A7%E4%B8%BB%E9%94%AE%EF%BC%88%E7%A0%81%E7%94%B1%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%9E%84%E6%88%90%EF%BC%89"><span class="nav-number">25.0.2.2.</span> <span class="nav-text">B. 多属性主键（码由多个属性构成）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"><span class="nav-number">25.0.3.</span> <span class="nav-text">3. 实体完整性检查与违约处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7-Referential-Integrity"><span class="nav-number">26.</span> <span class="nav-text">参照完整性 (Referential Integrity)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">26.1.</span> <span class="nav-text">1. 什么是参照完整性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">26.2.</span> <span class="nav-text">2. 如何定义参照完整性？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%AE%9A%E4%B9%89%E9%80%89%E8%AF%BE%E8%A1%A8-SC"><span class="nav-number">26.2.1.</span> <span class="nav-text">语法实例：定义选课表 (SC)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E6%A3%80%E6%9F%A5%E9%80%BB%E8%BE%91"><span class="nav-number">26.3.</span> <span class="nav-text">3. 参照完整性的检查逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86-Violation-Handling"><span class="nav-number">26.4.</span> <span class="nav-text">4. 违约处理 (Violation Handling)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7-User-defined-Integrity"><span class="nav-number">27.</span> <span class="nav-text">用户定义的完整性 (User-defined Integrity)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">27.1.</span> <span class="nav-text">1. 为什么需要用户定义的完整性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="nav-number">27.2.</span> <span class="nav-text">2. 属性上的约束条件定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="nav-number">27.3.</span> <span class="nav-text">3. 元组上的约束条件定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"><span class="nav-number">27.4.</span> <span class="nav-text">4. 违约处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%91%BD%E5%90%8D%E5%AD%90%E5%8F%A5"><span class="nav-number">28.</span> <span class="nav-text">完整性约束命名子句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%99%E7%BA%A6%E6%9D%9F%E8%B5%B7%E5%90%8D%E5%AD%97%EF%BC%9F"><span class="nav-number">28.1.</span> <span class="nav-text">1. 为什么要给约束起名字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%EF%BC%9ACONSTRAINT"><span class="nav-number">28.2.</span> <span class="nav-text">2. 核心语法：CONSTRAINT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="nav-number">28.3.</span> <span class="nav-text">3. 实战案例解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%82%B9%E6%8B%A8%EF%BC%9A"><span class="nav-number">28.3.1.</span> <span class="nav-text">逻辑点拨：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%99%E7%A7%8D%E5%91%BD%E5%90%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%8E%E7%BB%AD%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">28.4.</span> <span class="nav-text">4. 这种命名有什么后续好处？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">29.</span> <span class="nav-text">触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9F"><span class="nav-number">29.1.</span> <span class="nav-text">1. 什么是触发器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E2%80%9C%E4%B8%89%E8%A6%81%E7%B4%A0%E2%80%9D%EF%BC%9A%E4%BA%8B%E4%BB%B6-%E6%9D%A1%E4%BB%B6-%E5%8A%A8%E4%BD%9C"><span class="nav-number">29.2.</span> <span class="nav-text">2. 触发器的“三要素”：事件-条件-动作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.</span> <span class="nav-text">定义触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%A7%A6%E5%8F%91%E5%99%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="nav-number">30.1.</span> <span class="nav-text">1. 触发器定义的语法核心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%E6%8B%86%E8%A7%A3%EF%BC%9A"><span class="nav-number">30.1.1.</span> <span class="nav-text">关键参数拆解：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89%E6%97%B6%E7%9A%84%E9%87%8D%E8%A6%81%E9%99%90%E5%88%B6"><span class="nav-number">30.2.</span> <span class="nav-text">2. 定义时的重要限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%9E%E6%88%98%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.3.</span> <span class="nav-text">3. 实战模拟：定义一个简单的触发器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%EF%BC%88Relational-Schema%EF%BC%89"><span class="nav-number">31.</span> <span class="nav-text">关系模式（Relational Schema）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89"><span class="nav-number">31.1.</span> <span class="nav-text">1. 关系模式的数学定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-F-%EF%BC%88%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%EF%BC%89%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">31.2.</span> <span class="nav-text">2. 为什么 $F$（数据依赖）最重要？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="nav-number">32.</span> <span class="nav-text">完全函数依赖与部分函数依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96-Full-Functional-Dependency"><span class="nav-number">32.1.</span> <span class="nav-text">1. 完全函数依赖 (Full Functional Dependency)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96-Partial-Functional-Dependency"><span class="nav-number">32.2.</span> <span class="nav-text">2. 部分函数依赖 (Partial Functional Dependency)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%86%E5%AE%83%E4%BB%AC%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">32.3.</span> <span class="nav-text">3. 为什么区分它们很重要？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="nav-number">33.</span> <span class="nav-text">传递函数依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="nav-number">33.1.</span> <span class="nav-text">1. 严格定义与前提条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%9A%E5%AD%A6%E7%94%9F%E3%80%81%E7%B3%BB%E4%B8%8E%E7%B3%BB%E4%B8%BB%E4%BB%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">33.2.</span> <span class="nav-text">2. 实例分析：学生、系与系主任的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E8%AD%A6%E6%83%95%E2%80%9C%E4%BC%A0%E9%80%92%E4%BE%9D%E8%B5%96%E2%80%9D%EF%BC%9F"><span class="nav-number">33.3.</span> <span class="nav-text">3. 为什么我们要警惕“传递依赖”？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A0%81%EF%BC%88Key%EF%BC%89"><span class="nav-number">34.</span> <span class="nav-text">码（Key）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%80%99%E9%80%89%E7%A0%81-Candidate-Key"><span class="nav-number">34.1.</span> <span class="nav-text">1. 候选码 (Candidate Key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B6%85%E7%A0%81-Superkey"><span class="nav-number">34.2.</span> <span class="nav-text">2. 超码 (Superkey)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%BB%E7%A0%81-Primary-Key"><span class="nav-number">34.3.</span> <span class="nav-text">3. 主码 (Primary Key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%96%E7%A0%81%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89"><span class="nav-number">34.4.</span> <span class="nav-text">1. 外码的严格定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A%E4%B8%BB%E5%B1%9E%E6%80%A7-vs-%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7"><span class="nav-number">34.5.</span> <span class="nav-text">4. 属性的分类：主属性 vs 非主属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F%EF%BC%88Normal-Form-NF%EF%BC%89"><span class="nav-number">35.</span> <span class="nav-text">范式（Normal Form, NF）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%8C%83%E5%BC%8F%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%B8%8E%E5%85%B3%E7%B3%BB"><span class="nav-number">35.1.</span> <span class="nav-text">1. 范式的种类与关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E8%A7%84%E8%8C%83%E5%8C%96%EF%BC%88Normalization%EF%BC%89%E2%80%9D%EF%BC%9F"><span class="nav-number">35.2.</span> <span class="nav-text">2. 什么是“规范化（Normalization）”？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF%EF%BC%89"><span class="nav-number">36.</span> <span class="nav-text">第一范式（1NF）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1NF-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-number">36.1.</span> <span class="nav-text">1. 1NF 的核心定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%9D%E5%8F%8D%E4%BA%86-1NF%EF%BC%9F"><span class="nav-number">36.2.</span> <span class="nav-text">2. 什么样的设计违反了 1NF？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%B0%86%E5%85%B6%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%BA-1NF%EF%BC%9F"><span class="nav-number">36.3.</span> <span class="nav-text">3. 如何将其规范化为 1NF？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1NF-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%BD%E6%B1%82%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E8%8C%83%E5%BC%8F%EF%BC%9F%EF%BC%89"><span class="nav-number">36.4.</span> <span class="nav-text">4. 1NF 存在的问题（为什么要追求更高级的范式？）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89"><span class="nav-number">37.</span> <span class="nav-text">第二范式（2NF）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">37.1.</span> <span class="nav-text">1. 第二范式（2NF）的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81-2NF%EF%BC%9F%EF%BC%88%E9%80%9A%E8%BF%87%E2%80%9C%E5%8F%8D%E9%9D%A2%E6%95%99%E6%9D%90%E2%80%9D%E7%90%86%E8%A7%A3%EF%BC%89"><span class="nav-number">37.2.</span> <span class="nav-text">2. 为什么要 2NF？（通过“反面教材”理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8D%E6%BB%A1%E8%B6%B3-2NF-%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E6%81%B6%E6%9E%9C%EF%BC%9F"><span class="nav-number">37.3.</span> <span class="nav-text">3. 不满足 2NF 会有什么恶果？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%A7%84%E8%8C%83%E5%8C%96%EF%BC%9A%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90-2NF%EF%BC%9F"><span class="nav-number">37.4.</span> <span class="nav-text">4. 规范化：如何变成 2NF？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89"><span class="nav-number">38.</span> <span class="nav-text">第三范式（3NF）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89"><span class="nav-number">38.1.</span> <span class="nav-text">1. 第三范式（3NF）的严格定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-S-L-%E4%B8%8D%E7%AC%A6%E5%90%88-3NF%EF%BC%9F"><span class="nav-number">38.2.</span> <span class="nav-text">2. 实例分析：为什么 S-L 不符合 3NF？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%A7%84%E8%8C%83%E5%8C%96%E5%A4%84%E7%90%86%EF%BC%9A%E8%BF%88%E5%90%91-3NF"><span class="nav-number">38.3.</span> <span class="nav-text">3. 规范化处理：迈向 3NF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2NF-%E5%8D%87%E7%BA%A7%E5%88%B0-3NF%E4%B8%BE%E4%BE%8B"><span class="nav-number">39.</span> <span class="nav-text">2NF 升级到 3NF举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%8E%B0%E7%8A%B6%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2NF-%E4%BD%86%E4%B8%8D%E6%98%AF-3NF%EF%BC%9F"><span class="nav-number">39.1.</span> <span class="nav-text">1. 现状分析：为什么是 2NF 但不是 3NF？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%8D%E8%A7%84%E8%8C%83%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="nav-number">39.2.</span> <span class="nav-text">2. 存在的问题：不规范带来的麻烦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%EF%BC%88%E8%BF%88%E5%90%91-3NF%EF%BC%89"><span class="nav-number">39.3.</span> <span class="nav-text">3. 解决方案：模式分解（迈向 3NF）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BCNF%EF%BC%88Boyce-Codd-Normal-Form%EF%BC%8CBC-%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">40.</span> <span class="nav-text">BCNF（Boyce Codd Normal Form，BC 范式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-BCNF-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-number">40.1.</span> <span class="nav-text">1. BCNF 的核心定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-BCNF%EF%BC%9F%EF%BC%88%E5%AF%B9%E6%AF%94-3NF%EF%BC%89"><span class="nav-number">40.2.</span> <span class="nav-text">2. 为什么需要 BCNF？（对比 3NF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-BCNF-%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">40.3.</span> <span class="nav-text">3. BCNF 的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%A4%E5%AE%9A-BCNF-%E7%9A%84%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7"><span class="nav-number">40.4.</span> <span class="nav-text">4. 判定 BCNF 的实战技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="nav-number">41.</span> <span class="nav-text">多值依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%9B%B4%E8%A7%89%EF%BC%9A%E7%8B%AC%E7%AB%8B%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="nav-number">41.1.</span> <span class="nav-text">1. 核心直觉：独立的一对多</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E2%80%9C%E4%BE%9D%E8%B5%96%E2%80%9D%EF%BC%9F"><span class="nav-number">41.2.</span> <span class="nav-text">2. 为什么会有“依赖”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="nav-number">41.3.</span> <span class="nav-text">3. 多值依赖带来的麻烦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%A4%E5%AE%9A%E4%B8%8E%E8%A7%A3%E5%86%B3-%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F-4NF"><span class="nav-number">41.4.</span> <span class="nav-text">4. 判定与解决 (第四范式 4NF)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F%EF%BC%884NF%EF%BC%89"><span class="nav-number">42.</span> <span class="nav-text">第四范式（4NF）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-4NF%EF%BC%9F%EF%BC%88%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="nav-number">42.1.</span> <span class="nav-text">1. 什么是 4NF？（核心定义）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%9E%E5%87%BA-4NF%EF%BC%9F%EF%BC%88BCNF-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%89"><span class="nav-number">42.2.</span> <span class="nav-text">2. 为什么要搞出 4NF？（BCNF 的局限性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%90%86%E8%A7%A3%E2%80%9C%E9%9D%9E%E5%B9%B3%E5%87%A1%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96%E2%80%9D"><span class="nav-number">42.3.</span> <span class="nav-text">3. 理解“非平凡多值依赖”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4NF-%E7%9A%84%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89%EF%BC%9A%E6%B6%88%E9%99%A4%E2%80%9C%E7%8B%AC%E7%AB%8B%E7%BB%84%E5%90%88%E2%80%9D"><span class="nav-number">42.4.</span> <span class="nav-text">4. 4NF 的实际意义：消除“独立组合”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93-4NF-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">42.5.</span> <span class="nav-text">5. 总结 4NF 的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%EF%BC%88Conceptual-Model%EF%BC%89"><span class="nav-number">43.</span> <span class="nav-text">概念模型（Conceptual Model）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">43.1.</span> <span class="nav-text">1. 什么是概念模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="nav-number">43.2.</span> <span class="nav-text">2. 概念模型的核心特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%8F%E8%BF%B0%E5%B7%A5%E5%85%B7%EF%BC%9AE-R-%E6%A8%A1%E5%9E%8B"><span class="nav-number">43.3.</span> <span class="nav-text">3. 描述工具：E-R 模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-R%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">44.</span> <span class="nav-text">E-R模型的实体之间的联系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BD%93%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">44.1.</span> <span class="nav-text">1. 两个实体型之间的联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A%E5%AE%9E%E4%BD%93%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">44.2.</span> <span class="nav-text">2. 两个以上实体型之间的联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%95%E4%B8%AA%E5%AE%9E%E4%BD%93%E5%9E%8B%E5%86%85%E7%9A%84%E8%81%94%E7%B3%BB%EF%BC%88%E8%87%AA%E8%81%94%E7%B3%BB%EF%BC%89"><span class="nav-number">44.3.</span> <span class="nav-text">3. 单个实体型内的联系（自联系）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">44.4.</span> <span class="nav-text">学习小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">45.</span> <span class="nav-text">逻辑结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D"><span class="nav-number">45.1.</span> <span class="nav-text">1. 逻辑结构设计的核心定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="nav-number">45.2.</span> <span class="nav-text">2. 逻辑结构设计的主要任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%BD%AC%E6%8D%A2-Transformation"><span class="nav-number">45.2.1.</span> <span class="nav-text">第一步：转换 (Transformation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%8E%E4%BC%98%E5%8C%96-Normalization-amp-Optimization"><span class="nav-number">45.2.2.</span> <span class="nav-text">第二步：规范化与优化 (Normalization &amp; Optimization)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BA%A7%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="nav-number">45.3.</span> <span class="nav-text">3. 逻辑结构设计的产出结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%EF%BC%88Relational-Algebra%EF%BC%89"><span class="nav-number">46.</span> <span class="nav-text">关系代数（Relational Algebra）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">46.1.</span> <span class="nav-text">1. 五种基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%AF%B9%E2%80%9C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E2%80%9D%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">46.2.</span> <span class="nav-text">2. 为什么学习关系代数对“查询优化”至关重要？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%B1%82%E9%80%89%E4%BF%AE%E4%BA%86-2-%E5%8F%B7%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%AD%A6%E7%94%9F%E5%A7%93%E5%90%8D"><span class="nav-number">46.2.1.</span> <span class="nav-text">场景：求选修了 2 号课程的学生姓名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">47.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F-Definition"><span class="nav-number">47.1.</span> <span class="nav-text">1. 什么是事务？(Definition)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%A4%E6%9D%A1%E8%B7%AF%EF%BC%9A%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%9B%9E%E6%BB%9A"><span class="nav-number">47.2.</span> <span class="nav-text">2. 事务的两条路：提交与回滚</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E5%B1%80-A%EF%BC%9A%E6%AD%A3%E5%B8%B8%E7%BB%93%E6%9D%9F-%E2%80%94%E2%80%94-%E6%8F%90%E4%BA%A4-COMMIT"><span class="nav-number">47.2.1.</span> <span class="nav-text">结局 A：正常结束 —— 提交 (COMMIT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E5%B1%80-B%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2-%E2%80%94%E2%80%94-%E5%9B%9E%E6%BB%9A-ROLLBACK"><span class="nav-number">47.2.2.</span> <span class="nav-text">结局 B：异常终止 —— 回滚 (ROLLBACK)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%BA%8B%E5%8A%A1%EF%BC%9F-Explicit-vs-Implicit"><span class="nav-number">47.3.</span> <span class="nav-text">3. 如何定义事务？(Explicit vs Implicit)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%AE%9A%E4%B9%89-Explicit"><span class="nav-number">47.3.1.</span> <span class="nav-text">显式定义 (Explicit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E6%96%B9%E5%BC%8F-Implicit"><span class="nav-number">47.3.2.</span> <span class="nav-text">隐式方式 (Implicit)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">47.4.</span> <span class="nav-text">4. 为什么要引入事务？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%88ACID%E7%89%B9%E6%80%A7%EF%BC%89"><span class="nav-number">48.</span> <span class="nav-text">事务的特性（ACID特性）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7-Atomicity"><span class="nav-number">48.1.</span> <span class="nav-text">1. 原子性 (Atomicity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%80%E8%87%B4%E6%80%A7-Consistency"><span class="nav-number">48.2.</span> <span class="nav-text">2. 一致性 (Consistency)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9A%94%E7%A6%BB%E6%80%A7-Isolation"><span class="nav-number">48.3.</span> <span class="nav-text">3. 隔离性 (Isolation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8C%81%E7%BB%AD%E6%80%A7-Durability"><span class="nav-number">48.4.</span> <span class="nav-text">4. 持续性 (Durability)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">48.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D%E6%AD%A5%E9%AA%A4"><span class="nav-number">49.</span> <span class="nav-text">事务故障的恢复步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%EF%BC%9F"><span class="nav-number">49.1.</span> <span class="nav-text">1. 什么是事务故障？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%81%A2%E5%A4%8D%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">49.2.</span> <span class="nav-text">2. 恢复的核心机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%B7%E4%BD%93%E6%81%A2%E5%A4%8D%E6%AD%A5%E9%AA%A4-4%E6%AD%A5%E8%B5%B0"><span class="nav-number">49.3.</span> <span class="nav-text">3. 具体恢复步骤 (4步走)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">50.</span> <span class="nav-text">系统故障的恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="nav-number">50.1.</span> <span class="nav-text">1. 为什么系统故障会导致数据不一致？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%81%A2%E5%A4%8D%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%EF%BC%88%E4%B8%89%E9%81%8D%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%89"><span class="nav-number">50.2.</span> <span class="nav-text">2. 恢复的具体步骤（三遍扫描法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%AD%A3%E5%90%91%E6%89%AB%E6%8F%8F%EF%BC%8C%E5%88%92%E5%88%86%E9%98%B5%E8%90%A5"><span class="nav-number">50.2.1.</span> <span class="nav-text">第一步：正向扫描，划分阵营</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%8F%8D%E5%90%91%E6%89%AB%E6%8F%8F%EF%BC%8C%E6%92%A4%E9%94%80%E5%9D%8F%E4%BA%BA-Undo"><span class="nav-number">50.2.2.</span> <span class="nav-text">第二步：反向扫描，撤销坏人 (Undo)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E6%AD%A3%E5%90%91%E6%89%AB%E6%8F%8F%EF%BC%8C%E9%87%8D%E5%81%9A%E5%A5%BD%E4%BA%BA-Redo"><span class="nav-number">50.2.3.</span> <span class="nav-text">第三步：正向扫描，重做好人 (Redo)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="nav-number">51.</span> <span class="nav-text">利用检查点的恢复策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%A3%80%E6%9F%A5%E7%82%B9%EF%BC%9F"><span class="nav-number">51.1.</span> <span class="nav-text">1. 核心思想：为什么要用检查点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9AT1-T5-%E7%9A%84%E5%91%BD%E8%BF%90-%E5%85%B3%E9%94%AE%E5%9B%BE%E8%A7%A3"><span class="nav-number">51.2.</span> <span class="nav-text">2. 场景解析：T1-T5 的命运 (关键图解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">51.3.</span> <span class="nav-text">3. 恢复算法的具体步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%89%BE%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="nav-number">51.3.1.</span> <span class="nav-text">第一步：找到最近的检查点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97"><span class="nav-number">51.3.2.</span> <span class="nav-text">第二步：初始化队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E6%AD%A3%E5%90%91%E6%89%AB%E6%8F%8F-%E4%BB%8E-T-c-%E6%89%AB%E5%88%B0-T-f"><span class="nav-number">51.3.3.</span> <span class="nav-text">第三步：正向扫描 (从 $T_c$ 扫到 $T_f$)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">51.3.4.</span> <span class="nav-text">第四步：执行恢复</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据库 | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-24 00:00:00" itemprop="dateCreated datePublished" datetime="2025-12-24T00:00:00+08:00">2025-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-01 23:59:43" itemprop="dateModified" datetime="2026-01-01T23:59:43+08:00">2026-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="本文总阅读量 far fa-eye 次"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="数据库系统三级模式结构"><a href="#数据库系统三级模式结构" class="headerlink" title="数据库系统三级模式结构"></a>数据库系统三级模式结构</h2><p><img src="/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235942961.png" alt="image-20260101235942961"></p>
<h3 id="1-最外层：外模式-External-Schema"><a href="#1-最外层：外模式-External-Schema" class="headerlink" title="1. 最外层：外模式 (External Schema)"></a>1. 最外层：外模式 (External Schema)</h3><p><strong>—— 用户看数据的视角（“我要看什么”）</strong></p>
<ul>
<li><strong>别名</strong>：也称为<strong>子模式</strong>或<strong>用户模式</strong>。</li>
<li><strong>定义</strong>：它是数据库<strong>用户</strong>（包括应用程序）能够看见和使用的<strong>局部</strong>数据的逻辑结构和特征的描述。<ul>
<li><em>通俗理解</em>：就像在这个系统中，财务只看“工资表”，HR 只看“人事表”。每个人只关心和自己有关的那一小部分数据，这就是外模式。</li>
</ul>
</li>
<li><strong>数量关系</strong>：<ul>
<li>一个数据库可以有<strong>多个</strong>外模式。</li>
<li>一个外模式可以被<strong>多个</strong>应用系统使用。</li>
</ul>
</li>
<li><strong>作用</strong>：<ol>
<li><strong>定制化</strong>：反映了不同用户对数据的不同需求和看待方式。</li>
<li><strong>安全性</strong>：用户只能访问对应的外模式中的数据，以此保证数据安全。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-中间层：模式-Schema"><a href="#2-中间层：模式-Schema" class="headerlink" title="2. 中间层：模式 (Schema)"></a>2. 中间层：模式 (Schema)</h3><p><strong>—— 数据库的全局逻辑视角（“数据到底是什么”）</strong></p>
<ul>
<li><strong>别名</strong>：也称为<strong>逻辑模式</strong>。</li>
<li><strong>定义</strong>：它是数据库中<strong>全体</strong>数据的逻辑结构和特征的描述。它定义了数据的名字、类型、取值范围以及数据之间的联系。<ul>
<li><em>通俗理解</em>：这是数据库的“本体”。它不关心你是哪个部门的（不分局部），也不关心数据具体存在哪个硬盘扇区（不分物理），它只关心数据本身的逻辑完整性。</li>
</ul>
</li>
<li><strong>地位</strong>：它是数据库系统模式结构的<strong>中心</strong>。</li>
<li><strong>数量关系</strong>：一个数据库只有<strong>一个</strong>模式。</li>
<li><strong>特点</strong>：<ul>
<li>与数据的物理存储细节无关。</li>
<li>与具体的应用程序无关。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-最内层：内模式-Internal-Schema"><a href="#3-最内层：内模式-Internal-Schema" class="headerlink" title="3. 最内层：内模式 (Internal Schema)"></a>3. 最内层：内模式 (Internal Schema)</h3><p><strong>—— 数据的物理存储视角（“数据怎么存”）</strong></p>
<ul>
<li><strong>别名</strong>：也称为<strong>存储模式</strong>。</li>
<li><strong>定义</strong>：它是数据<strong>物理结构</strong>和<strong>存储方式</strong>的描述。</li>
<li><strong>具体内容</strong>：它决定了数据在硬盘上怎么躺着。例如：<ul>
<li>记录是顺序存储还是哈希存储？</li>
<li>索引是怎么组织的（B+树、Bitmap）？</li>
<li>数据是否压缩、是否加密？</li>
</ul>
</li>
<li><strong>数量关系</strong>：一个数据库只有<strong>一个</strong>内模式。</li>
</ul>
<h2 id="集数据定义语言（DDL），数据操纵语言-（DML），数据控制语言（DCL）"><a href="#集数据定义语言（DDL），数据操纵语言-（DML），数据控制语言（DCL）" class="headerlink" title="集数据定义语言（DDL），数据操纵语言 （DML），数据控制语言（DCL）"></a>集数据定义语言（DDL），数据操纵语言 （DML），数据控制语言（DCL）</h2><p>这三个概念（DDL, DML, DCL）是 SQL（结构化查询语言）的基石。你可以把 SQL 想象成一套用于管理数据的“瑞士军刀”，而这三者就是刀上不同的工具组件，分别负责不同的任务。</p>
<p>我们可以用<strong>“盖房子”</strong>和<strong>“住房子”</strong>的类比来理解它们：</p>
<h4 id="1-DDL-Data-Definition-Language-——-数据定义语言"><a href="#1-DDL-Data-Definition-Language-——-数据定义语言" class="headerlink" title="1. DDL (Data Definition Language) —— 数据定义语言"></a>1. DDL (Data Definition Language) —— 数据定义语言</h4><p><strong>角色：建筑师/装修队</strong></p>
<ul>
<li><strong>核心功能</strong>：用来定义数据库的<strong>骨架和结构</strong>。它不涉及具体的数据内容，而是决定“这里要有一张表”、“这张表有几列”、“那一列是什么类型”。</li>
<li><strong>特点</strong>：一旦执行，通常无法回滚（Auto-commit），结构立马改变。</li>
<li><strong>常用命令</strong>：<ul>
<li><code>CREATE</code>：新建。比如建库（CREATE DATABASE）、建表（CREATE TABLE）、建索引。</li>
<li><code>ALTER</code>：修改结构。比如给表增加一列字段，或者修改字段类型。</li>
<li><code>DROP</code>：彻底删除。把表连同结构直接炸毁。</li>
<li><code>TRUNCATE</code>：清空表。保留表结构，但把里面所有数据一次性清空（效率比逐行删除高）。</li>
</ul>
</li>
</ul>
<p>举个栗子（建房子）：</p>
<p>DDL 就像是你在工地上喊：“这里建一面墙（Create Table）”，“把这扇窗户改大一点（Alter）”，“把那个旧仓库拆了（Drop）”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- DDL 示例</span><br><span class="line">CREATE TABLE Students (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(50)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="2-DML-Data-Manipulation-Language-——-数据操纵语言"><a href="#2-DML-Data-Manipulation-Language-——-数据操纵语言" class="headerlink" title="2. DML (Data Manipulation Language) —— 数据操纵语言"></a>2. DML (Data Manipulation Language) —— 数据操纵语言</h4><p><strong>角色：住户/搬运工</strong></p>
<ul>
<li><strong>核心功能</strong>：用来对数据库里的<strong>具体数据</strong>进行操作。这是开发人员日常写代码用得最多的部分（增删改查）。</li>
<li><strong>特点</strong>：可以被事务（Transaction）控制，如果你操作错了，在提交之前通常可以回滚（Rollback/Undo）。</li>
<li><strong>常用命令</strong>：<ul>
<li><code>INSERT</code>：插入。往表里放一条新数据。</li>
<li><code>UPDATE</code>：更新。修改表里已有的数据。</li>
<li><code>DELETE</code>：删除。删掉表里的某一行数据。</li>
<li><em>(注：<code>SELECT</code> 查询语句有时被单独归为 DQL - Data Query Language，但在广义上常被归入 DML，因为它也是在操作/处理数据)</em></li>
</ul>
</li>
</ul>
<p>举个栗子（搬家具）：</p>
<p>房子建好了（DDL完成），现在 DML 进场：“往卧室搬一张床（Insert）”，“把沙发换个位置（Update）”，“把坏掉的椅子扔出去（Delete）”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- DML 示例</span><br><span class="line">INSERT INTO Students (id, name) VALUES (1, &#x27;张三&#x27;);</span><br><span class="line">UPDATE Students SET name = &#x27;李四&#x27; WHERE id = 1;</span><br><span class="line">DELETE FROM Students WHERE id = 1;</span><br></pre></td></tr></table></figure>
<h4 id="3-DCL-Data-Control-Language-——-数据控制语言"><a href="#3-DCL-Data-Control-Language-——-数据控制语言" class="headerlink" title="3. DCL (Data Control Language) —— 数据控制语言"></a>3. DCL (Data Control Language) —— 数据控制语言</h4><p><strong>角色：保安/物业</strong></p>
<ul>
<li><strong>核心功能</strong>：用来定义数据库的<strong>访问权限</strong>和<strong>安全级别</strong>。决定谁能进来，进来了能干什么。</li>
<li><strong>特点</strong>：通常由数据库管理员（DBA）使用。</li>
<li><strong>常用命令</strong>：<ul>
<li><code>GRANT</code>：授权。给某个用户赋予权限（比如允许他查询，但不允许他删除）。</li>
<li><code>REVOKE</code>：撤销。收回之前赋予的权限。</li>
</ul>
</li>
</ul>
<p>举个栗子（发钥匙）：</p>
<p>DCL 就像是房东给租客配钥匙：“给你一把大门钥匙，你可以进屋（Grant Select）”，“但不给你保险柜钥匙，你不能拿里面的钱（Revoke/Deny）”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- DCL 示例</span><br><span class="line">GRANT SELECT ON Students TO user_xiaoming; -- 允许小明查询学生表</span><br><span class="line">REVOKE DELETE ON Students FROM user_xiaoming; -- 禁止小明删除学生表数据</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>全称 (英文)</strong></th>
<th><strong>全称 (中文)</strong></th>
<th><strong>包含的具体语句 (Keywords)</strong></th>
<th><strong>作用描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DDL</strong></td>
<td>Data Definition Language</td>
<td><strong>数据定义语言</strong></td>
<td><strong><code>CREATE</code></strong> (创建) <strong><code>ALTER</code></strong> (修改) <strong><code>DROP</code></strong> (删除) <strong><code>TRUNCATE</code></strong> (截断/清空) <code>RENAME</code> (重命名) <code>COMMENT</code> (注释)</td>
<td>用来定义数据库对象（表、视图、索引等）的<strong>结构</strong>。一旦执行，<strong>立即生效，无法回滚</strong>。</td>
</tr>
<tr>
<td><strong>DML</strong></td>
<td>Data Manipulation Language</td>
<td><strong>数据操纵语言</strong></td>
<td><strong><code>SELECT</code></strong> (查询)<em> <strong><code>INSERT</code></strong> (插入) <strong><code>UPDATE</code></strong> (更新) <em>*<code>DELETE</code></em></em> (删除) <code>MERGE</code> (合并)</td>
<td>用来对数据库表中的<strong>数据</strong>进行增、删、改、查。<strong>可以回滚</strong>（需要配合事务）。</td>
</tr>
<tr>
<td><strong>DCL</strong></td>
<td>Data Control Language</td>
<td><strong>数据控制语言</strong></td>
<td><strong><code>GRANT</code></strong> (授权) <strong><code>REVOKE</code></strong> (撤销)</td>
<td>用来定义数据库的访问权限和安全级别。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据类型，列级约束，表级约束"><a href="#数据类型，列级约束，表级约束" class="headerlink" title="数据类型，列级约束，表级约束"></a>数据类型，列级约束，表级约束</h2><h3 id="一、-常见的数据类型-Common-Data-Types"><a href="#一、-常见的数据类型-Common-Data-Types" class="headerlink" title="一、 常见的数据类型 (Common Data Types)"></a>一、 常见的数据类型 (Common Data Types)</h3><p>数据库的数据类型远比课件里讲的要丰富。我们按<strong>使用场景</strong>来分类：</p>
<h4 id="1-数值类型-Numbers"><a href="#1-数值类型-Numbers" class="headerlink" title="1. 数值类型 (Numbers)"></a>1. 数值类型 (Numbers)</h4><ul>
<li><strong><code>INT</code> / <code>INTEGER</code></strong>：最常用的整数。<ul>
<li><em>场景</em>：ID、年龄、库存数量。</li>
</ul>
</li>
<li><strong><code>BIGINT</code></strong>：超大整数。<ul>
<li><em>场景</em>：Twitter 的推文 ID、银行流水号（当 <code>INT</code> 不够存时，这在互联网大厂很常见）。</li>
</ul>
</li>
<li><strong><code>DECIMAL(M, D)</code></strong>：<strong>定点数（高精度）</strong>。这是金融核心！<ul>
<li><em>区别</em>：<code>FLOAT</code> 和 <code>DOUBLE</code> 是浮点数，存 “0.1 + 0.2” 可能会变成 “0.300000004”。</li>
<li><em>场景</em>：<strong>存钱</strong>。涉及金额必须用 <code>DECIMAL</code>，绝对不能用 <code>FLOAT</code>。</li>
</ul>
</li>
<li><strong><code>FLOAT</code> / <code>DOUBLE</code></strong>：浮点数。<ul>
<li><em>场景</em>：科学计算、经纬度、物理测量值（允许微小误差）。</li>
</ul>
</li>
</ul>
<h4 id="2-字符串类型-Strings"><a href="#2-字符串类型-Strings" class="headerlink" title="2. 字符串类型 (Strings)"></a>2. 字符串类型 (Strings)</h4><ul>
<li><strong><code>CHAR(n)</code></strong>：<strong>定长</strong>字符串。<ul>
<li><em>原理</em>：不管存多少，都占 n 个字节。</li>
<li><em>场景</em>：身份证号、手机号、哈希值（MD5）、国家代码（CN, US）。</li>
</ul>
</li>
<li><strong><code>VARCHAR(n)</code></strong>：<strong>变长</strong>字符串。<ul>
<li><em>原理</em>：存多少占多少 + 额外 1-2 字节记录长度。</li>
<li><em>场景</em>：姓名、地址、邮箱、绝大多数文本字段。</li>
</ul>
</li>
<li><strong><code>TEXT</code> / <code>LONGTEXT</code></strong>：长文本。<ul>
<li><em>场景</em>：文章正文、商品详情描述、用户评论（超过 255 或 65535 字符时使用）。</li>
</ul>
</li>
</ul>
<h4 id="3-日期与时间-Date-amp-Time"><a href="#3-日期与时间-Date-amp-Time" class="headerlink" title="3. 日期与时间 (Date &amp; Time)"></a>3. 日期与时间 (Date &amp; Time)</h4><ul>
<li><strong><code>DATE</code></strong>：只存日期（YYYY-MM-DD）。<ul>
<li><em>场景</em>：生日、入职日期。</li>
</ul>
</li>
<li><strong><code>DATETIME</code></strong>：日期 + 时间（YYYY-MM-DD HH:MM:SS）。<ul>
<li><em>场景</em>：发布时间、下单时间。</li>
</ul>
</li>
<li><strong><code>TIMESTAMP</code></strong>：时间戳。<ul>
<li><em>特点</em>：会随着时区变化，通常用于记录“最后修改时间”。</li>
</ul>
</li>
</ul>
<h4 id="4-其他重要类型"><a href="#4-其他重要类型" class="headerlink" title="4. 其他重要类型"></a>4. 其他重要类型</h4><ul>
<li><strong><code>BOOLEAN</code> / <code>TINYINT(1)</code></strong>：布尔值。<ul>
<li><em>场景</em>：是否删除（is_deleted）、是否激活（is_active）。</li>
</ul>
</li>
<li><strong><code>BLOB</code></strong>：二进制大对象。<ul>
<li><em>场景</em>：虽然可以存图片/文件，但工业界通常只存文件路径（URL），不直接把文件塞进数据库。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、-列级约束-vs-表级约束"><a href="#二、-列级约束-vs-表级约束" class="headerlink" title="二、 列级约束 vs 表级约束"></a>二、 列级约束 vs 表级约束</h3><p>这两个概念的区别主要在于<strong>“写的位置”</strong>和<strong>“能管的范围”</strong>。</p>
<h4 id="1-列级约束-Column-level-Constraints"><a href="#1-列级约束-Column-level-Constraints" class="headerlink" title="1. 列级约束 (Column-level Constraints)"></a>1. 列级约束 (Column-level Constraints)</h4><p><strong>“单兵作战”</strong>。定义在列的屁股后面，只管这一列。</p>
<ul>
<li><strong><code>NOT NULL</code></strong>：<strong>非空</strong>。<ul>
<li><em>作用</em>：必须要填。</li>
<li><em>例子</em>：<code>username VARCHAR(50) NOT NULL</code></li>
</ul>
</li>
<li><strong><code>DEFAULT</code></strong>：<strong>默认值</strong>。<ul>
<li><em>作用</em>：如果你不填，我就给你个默认的。</li>
<li><em>例子</em>：<code>is_active BOOLEAN DEFAULT TRUE</code> (注册默认激活)。</li>
</ul>
</li>
<li><strong><code>UNIQUE</code></strong>：<strong>唯一</strong>（单列）。<ul>
<li><em>作用</em>：这列的值不能重复。</li>
<li><em>例子</em>：<code>email VARCHAR(100) UNIQUE</code>。</li>
</ul>
</li>
<li><strong><code>PRIMARY KEY</code></strong>：<strong>主键</strong>（单列）。<ul>
<li><em>作用</em>：身份证，唯一且非空。</li>
</ul>
</li>
<li><strong><code>AUTO_INCREMENT</code></strong> (MySQL特有) / <strong><code>SERIAL</code></strong> (PostgreSQL)：<ul>
<li><em>作用</em>：自增。你不用填，数据库自动 1, 2, 3… 往下排。</li>
</ul>
</li>
</ul>
<h4 id="2-表级约束-Table-level-Constraints"><a href="#2-表级约束-Table-level-Constraints" class="headerlink" title="2. 表级约束 (Table-level Constraints)"></a>2. 表级约束 (Table-level Constraints)</h4><p><strong>“团队协作”</strong>。定义在所有列写完之后，可以管多列，也可以管跨表关系。</p>
<ul>
<li><strong><code>PRIMARY KEY (列A, 列B)</code></strong>：<strong>联合主键</strong>。<ul>
<li><em>场景</em>：比如“关注列表”，你是 UserA，你关注了 UserB。UserA 可以出现多次，UserB 也可以出现多次，但 <strong>(UserA, UserB)</strong> 这个组合只能出现一次。</li>
</ul>
</li>
<li><strong><code>FOREIGN KEY</code></strong>：<strong>外键</strong>。<ul>
<li><em>场景</em>：订单表里的 <code>user_id</code> 必须引用用户表里存在的 <code>id</code>。</li>
<li><em>写法</em>：<code>FOREIGN KEY (user_id) REFERENCES Users(id)</code></li>
</ul>
</li>
<li><strong><code>UNIQUE (列A, 列B)</code></strong>：<strong>联合唯一</strong>。<ul>
<li><em>场景</em>：在这个班级（ClassID）里，这个座位号（SeatID）只能有一个人。单独看班级或座位号都可重复，合起来必须唯一。</li>
</ul>
</li>
<li><strong><code>CHECK</code></strong>：<strong>复杂检查</strong>。<ul>
<li><em>场景</em>：跨列检查。比如 <code>CHECK (end_time &gt; start_time)</code>（结束时间必须晚于开始时间）。</li>
</ul>
</li>
</ul>
<h2 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">    列名1  数据类型  [列级约束],</span><br><span class="line">    列名2  数据类型  [列级约束],</span><br><span class="line">    ...</span><br><span class="line">    [表级约束] </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="建立学生选课表-SC-例-3-7"><a href="#建立学生选课表-SC-例-3-7" class="headerlink" title="建立学生选课表 SC (例 3.7)"></a>建立学生选课表 SC (例 3.7)</h4><p>这里展示了<strong>多对多关系</strong>的实现，以及<strong>联合主码</strong>（表级约束）的写法。</p>
<ul>
<li><strong>Sno, Cno</strong>：由两个属性构成主码，必须作为<strong>表级完整性</strong>进行定义。</li>
<li><strong>Sno</strong>：外键，指向 Student 表。</li>
<li><strong>Cno</strong>：外键，指向 Course 表。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC (</span><br><span class="line">    Sno   CHAR(9),</span><br><span class="line">    Cno   CHAR(4),</span><br><span class="line">    Grade SMALLINT,</span><br><span class="line">    </span><br><span class="line">    /* 主码由两个属性构成，必须作为表级完整性进行定义 */</span><br><span class="line">    PRIMARY KEY (Sno, Cno),  </span><br><span class="line">    </span><br><span class="line">    /* 表级完整性约束条件，Sno是外键，被参照表是Student */</span><br><span class="line">    FOREIGN KEY (Sno) REFERENCES Student(Sno), </span><br><span class="line">    </span><br><span class="line">    /* 表级完整性约束条件，Cno是外键，被参照表是Course */</span><br><span class="line">    FOREIGN KEY (Cno) REFERENCES Course(Cno)   </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h2><h3 id="1-核心语法骨架"><a href="#1-核心语法骨架" class="headerlink" title="1. 核心语法骨架"></a>1. 核心语法骨架</h3><p>先看一眼这张语法图，它的通用公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; </span><br><span class="line">[ 修改动作 ];</span><br></pre></td></tr></table></figure>
<p>所有的操作都必须以 <code>ALTER TABLE</code> 开头，告诉数据库你要动哪张表。</p>
<hr>
<h3 id="2-三大核心操作详解"><a href="#2-三大核心操作详解" class="headerlink" title="2. 三大核心操作详解"></a>2. 三大核心操作详解</h3><h4 id="A-增加-ADD-——-给房子加个房间"><a href="#A-增加-ADD-——-给房子加个房间" class="headerlink" title="A. 增加 (ADD) —— 给房子加个房间"></a>A. 增加 (ADD) —— 给房子加个房间</h4><p>你可以增加新的<strong>列</strong>，或者增加新的<strong>约束</strong>（比如给某列补一个唯一约束）。</p>
<ul>
<li><p><strong>语法</strong>： <code>ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]</code></p>
</li>
<li><p><strong>场景举例</strong>： 之前建立的 <code>Student</code> 表忘了记“入学时间”，现在补上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Student </span><br><span class="line">ADD S_entrance DATE; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>课件说明</strong>：<code>ADD</code> 子句既可以加新列，也可以加新的列级/表级完整性约束。</p>
</li>
</ul>
<h4 id="B-修改-ALTER-COLUMN-——-给房间换个地板"><a href="#B-修改-ALTER-COLUMN-——-给房间换个地板" class="headerlink" title="B. 修改 (ALTER COLUMN) —— 给房间换个地板"></a>B. 修改 (ALTER COLUMN) —— 给房间换个地板</h4><p>你可以修改现有列的<strong>数据类型</strong>。</p>
<ul>
<li><p><strong>语法</strong>： <code>ALTER COLUMN &lt;列名&gt; TYPE &lt;数据类型&gt;</code></p>
</li>
<li><p><strong>场景举例</strong>： 之前 <code>Sage</code> (年龄) 用的是 <code>SMALLINT</code>，现在觉得不够用（虽然不太可能），想改成更大的 <code>INT</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Student </span><br><span class="line">ALTER COLUMN Sage TYPE INT;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：有些数据库（如 Oracle）修改类型的关键字是 <code>MODIFY</code>，但你的课件是标准的 SQL 或 PostgreSQL 风格，使用的是 <code>ALTER COLUMN ... TYPE</code>。</p>
</li>
</ul>
<h4 id="C-删除-DROP-——-把房间拆了"><a href="#C-删除-DROP-——-把房间拆了" class="headerlink" title="C. 删除 (DROP) —— 把房间拆了"></a>C. 删除 (DROP) —— 把房间拆了</h4><p>这是最需要小心的操作！你可以删除某个<strong>列</strong>，或者删除某个<strong>约束</strong>。</p>
<ul>
<li><p><strong>语法</strong>： <code>DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]</code></p>
</li>
<li><p><strong>场景举例</strong>： 现在的学生都不用填“籍贯”了，把这一列删掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Student </span><br><span class="line">DROP COLUMN S_native;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-重难点：CASCADE-vs-RESTRICT-级联与限制"><a href="#3-重难点：CASCADE-vs-RESTRICT-级联与限制" class="headerlink" title="3. 重难点：CASCADE vs RESTRICT (级联与限制)"></a>3. 重难点：CASCADE vs RESTRICT (级联与限制)</h3><p>在删除 (<code>DROP</code>) 操作中，你会在课件里看到这两个关键词，这是<strong>考试必考</strong>的概念：</p>
<p>假设你想删除 <code>Student</code> 表里的 <code>Sno</code> (学号) 列。</p>
<ul>
<li><strong><code>RESTRICT</code> (限制/拒绝)</strong>：<ul>
<li><strong>含义</strong>：<strong>“如果有别人依赖我，那我就不准你删我。”</strong></li>
<li><strong>例子</strong>：如果你想删 <code>Sno</code>，但 <code>Sno</code> 被这一张视图（View）或者索引引用了，数据库会直接报错，拒绝执行删除命令。这是默认的安全选项。</li>
</ul>
</li>
<li><strong><code>CASCADE</code> (级联)</strong>：<ul>
<li><strong>含义</strong>：<strong>“斩草除根。”</strong></li>
<li><strong>例子</strong>：如果你删了 <code>Sno</code>，数据库会自动把所有引用了 <code>Sno</code> 的视图、索引、触发器<strong>全部一起删掉</strong>。</li>
<li><strong>警告</strong>：这是一个很危险的操作，除非你非常清楚自己在做什么，否则慎用。</li>
</ul>
</li>
</ul>
<h2 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h2><h3 id="1-核心语法"><a href="#1-核心语法" class="headerlink" title="1. 核心语法"></a>1. 核心语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &lt;表名&gt; [ RESTRICT | CASCADE ];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>&lt;表名&gt;</code></strong>：你要删掉的那张表的名字。</li>
<li><strong><code>[ RESTRICT | CASCADE ]</code></strong>：这是可选参数，但在有复杂关系的数据库中（比如我们的学生-选课系统），这个参数决定了你能不能删成功。</li>
</ul>
<hr>
<h3 id="2-两种删除模式详解"><a href="#2-两种删除模式详解" class="headerlink" title="2. 两种删除模式详解"></a>2. 两种删除模式详解</h3><h4 id="A-RESTRICT-默认-保守模式-——-“有牵挂就不走”"><a href="#A-RESTRICT-默认-保守模式-——-“有牵挂就不走”" class="headerlink" title="A. RESTRICT (默认/保守模式) —— “有牵挂就不走”"></a>A. <code>RESTRICT</code> (默认/保守模式) —— “有牵挂就不走”</h4><ul>
<li><p><strong>含义</strong>：<strong>有限制的删除</strong>。</p>
</li>
<li><p><strong>规则</strong>：</p>
<ul>
<li>如果你想删的这张表，被其他的表<strong>引用</strong>了（比如做了别人的外键），或者被视图（View）、触发器等依赖了。</li>
<li>那么，数据库会<strong>拒绝执行</strong>删除操作，直接报错。</li>
</ul>
</li>
<li><p><strong>场景演示</strong>： 还记得我们的 <strong><code>SC</code> (选课表)</strong> 吗？它的 <code>Sno</code> 列是外键，引用了 <strong><code>Student</code> (学生表)</strong>。</p>
<p>如果你执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE Student RESTRICT;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：❌ <strong>报错！</strong> <strong>原因</strong>：数据库会说：“不行啊，<code>SC</code> 表里的数据还指望着 <code>Student</code> 表活呢，你把 <code>Student</code> 删了，<code>SC</code> 表怎么办？”</p>
</li>
</ul>
<h4 id="B-CASCADE-级联-强制模式-——-“连根拔起”"><a href="#B-CASCADE-级联-强制模式-——-“连根拔起”" class="headerlink" title="B. CASCADE (级联/强制模式) —— “连根拔起”"></a>B. <code>CASCADE</code> (级联/强制模式) —— “连根拔起”</h4><ul>
<li><p><strong>含义</strong>：<strong>没有限制的删除</strong>。</p>
</li>
<li><p><strong>规则</strong>：</p>
<ul>
<li>不管有没有人引用我，强制删除。</li>
<li><strong>关键点</strong>：在删除这张表的同时，<strong>相关的依赖对象</strong>（比如引用它的外键约束、基于它的视图）都会被<strong>一起删掉</strong>。</li>
</ul>
</li>
<li><p><strong>场景演示</strong>： 如果你执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE Student CASCADE;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：✅ <strong>成功删除。</strong> <strong>后果</strong>：</p>
<ol>
<li><code>Student</code> 表没了，数据也没了。</li>
<li><code>SC</code> 表<strong>不会</strong>被删掉（表还在），但是 <code>SC</code> 表里那个指向 Student 的<strong>外键约束</strong>会被自动剥离/删除。从此 <code>SC</code> 表就变成了一张没有外键约束的普通表。</li>
</ol>
</li>
</ul>
<h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><h3 id="1-什么是-Schema？"><a href="#1-什么是-Schema？" class="headerlink" title="1. 什么是 Schema？"></a>1. 什么是 Schema？</h3><p>在数据库教科书里，Schema 被定义为 <strong>“数据库对象的集合”</strong>。 但在我们脑海里，它就是 <strong>“数据库内部的逻辑分组容器”</strong>。</p>
<ul>
<li><strong>物理上</strong>：数据库文件（如 <code>.mdf</code>, <code>.db</code>）可能存在硬盘的同一个地方。</li>
<li><strong>逻辑上</strong>：通过 Schema 把它们隔离开，互不干扰。</li>
</ul>
<h3 id="2-Schema-的三大核心作用"><a href="#2-Schema-的三大核心作用" class="headerlink" title="2. Schema 的三大核心作用"></a>2. Schema 的三大核心作用</h3><p>除了你已经知道的“防止重名”，Schema 还有两个非常重要的功能，这在企业级开发中至关重要。</p>
<h4 id="A-命名空间-Namespace-——-防止打架"><a href="#A-命名空间-Namespace-——-防止打架" class="headerlink" title="A. 命名空间 (Namespace) —— 防止打架"></a>A. 命名空间 (Namespace) —— 防止打架</h4><p>这就是你总结的“文件夹”功能。</p>
<ul>
<li><strong>场景</strong>：你们公司开发一个电商系统。<ul>
<li><strong>销售部</strong>需要一个 <code>User</code> 表（存客户信息）。</li>
<li><strong>人力部</strong>也需要一个 <code>User</code> 表（存员工信息）。</li>
</ul>
</li>
<li><strong>解决</strong>：<ul>
<li><code>Sales.User</code> (销售部的用户表)</li>
<li><code>HR.User</code> (人力部的用户表)</li>
<li><strong>结果</strong>：它们和平共处，互不冲突。</li>
</ul>
</li>
</ul>
<h4 id="B-权限管理-Security-——-安全围栏"><a href="#B-权限管理-Security-——-安全围栏" class="headerlink" title="B. 权限管理 (Security) —— 安全围栏"></a>B. 权限管理 (Security) —— 安全围栏</h4><p>Schema 是权限控制的<strong>天然边界</strong>。</p>
<ul>
<li><strong>场景</strong>：财务部的表非常敏感，不能让IT部的实习生看到。</li>
<li><strong>做法</strong>：你不需要给财务部的 100 张表一张一张地设置权限。你只需要设置：<ul>
<li><code>GRANT SELECT ON SCHEMA Finance TO Manager;</code> (给经理看财务文件夹的权限)</li>
<li><code>REVOKE ALL ON SCHEMA Finance FROM Intern;</code> (禁止实习生进财务文件夹)</li>
</ul>
</li>
<li><strong>比喻</strong>：Schema 就像办公楼里的<strong>“部门办公室”</strong>。你有大楼的门禁卡（连上了数据库），但你进不去“财务部”的办公室（没有 Schema 权限）。</li>
</ul>
<h4 id="C-逻辑分类-Organization-——-治愈强迫症"><a href="#C-逻辑分类-Organization-——-治愈强迫症" class="headerlink" title="C. 逻辑分类 (Organization) —— 治愈强迫症"></a>C. 逻辑分类 (Organization) —— 治愈强迫症</h4><p>当一个数据库里有 2000 张表时，如果全堆在一起，找表会疯掉的。</p>
<ul>
<li>把报表相关的放 <code>Report</code> 模式。</li>
<li>把历史归档的放 <code>Archive</code> 模式。</li>
<li>把系统自带的放 <code>System</code> 模式。</li>
</ul>
<h2 id="CREATE-SCHEMA"><a href="#CREATE-SCHEMA" class="headerlink" title="CREATE SCHEMA"></a>CREATE SCHEMA</h2><h3 id="1-核心语法：怎么建？"><a href="#1-核心语法：怎么建？" class="headerlink" title="1. 核心语法：怎么建？"></a>1. 核心语法：怎么建？</h3><p>图片中给出的标准语法是这样的： <code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; ...</code></p>
<p>这里有两个关键部分：</p>
<ol>
<li><strong><code>&lt;模式名&gt;</code></strong>：你想给这个“文件夹”起什么名字？（比如 <code>Sales</code>, <code>HR</code>, <code>School</code>）。</li>
<li><strong><code>AUTHORIZATION &lt;用户名&gt;</code></strong>：<strong>谁是这个文件夹的主人？</strong><ul>
<li>这非常重要。通常 DBA（管理员）在创建 Schema 时，会将它的所有权直接赋给具体的业务用户（比如张三）。</li>
<li><em>比喻</em>：你是盖楼的包工头（DBA），你盖了一个叫“财务室”的房间（Schema），然后把钥匙直接交给“财务经理”（User），而不是自己拿着。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-进阶玩法：“打包创建”-Combo"><a href="#2-进阶玩法：“打包创建”-Combo" class="headerlink" title="2. 进阶玩法：“打包创建” (Combo)"></a>2. 进阶玩法：“打包创建” (Combo)</h3><p>注意看图片语法的第二行： <code>[ &lt;表定义子句&gt; | &lt;视图定义子句&gt; | &lt;授权定义子句&gt; ]</code></p>
<p>这意味着：<strong>你可以在创建 Schema 的同时，顺便把里面的表、视图都一起建好！</strong></p>
<ul>
<li><strong>普通做法</strong>：先建 Schema -&gt; 结束语句 -&gt; 切换进 Schema -&gt; 建表 -&gt; 建视图。</li>
<li><strong>高手做法 (打包)</strong>：一条语句搞定所有。</li>
</ul>
<p><strong>实战示例：</strong> 假设你要为“教务处”建一个模式，并直接在里面建好“学生表”，且把所有权交给用户 <code>ZhangSan</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA School AUTHORIZATION ZhangSan</span><br><span class="line">    -- 顺便建个表</span><br><span class="line">    CREATE TABLE Student (</span><br><span class="line">        Sno CHAR(9) PRIMARY KEY,</span><br><span class="line">        Sname CHAR(20)</span><br><span class="line">    )</span><br><span class="line">    -- 顺便再建个视图</span><br><span class="line">    CREATE VIEW V_Student AS SELECT * FROM Student;</span><br></pre></td></tr></table></figure>
<p><em>注意：在这种“打包写法”中，里面的 <code>CREATE TABLE</code> 语句通常不需要写分号，直到最后整个 Schema 定义结束才写分号（具体视数据库产品而定，标准SQL是这样的）。</em></p>
<h2 id="授权定义子句"><a href="#授权定义子句" class="headerlink" title="授权定义子句"></a>授权定义子句</h2><h3 id="一、-核心概念：什么是-GRANT？"><a href="#一、-核心概念：什么是-GRANT？" class="headerlink" title="一、 核心概念：什么是 GRANT？"></a>一、 核心概念：什么是 GRANT？</h3><p><strong>GRANT</strong> 的本质是 <strong>“权力的分发”</strong>。在数据库中，除非你是数据库管理员（DBA）或对象的所有者，否则你默认没有权限访问任何不属于你的数据。</p>
<ul>
<li><strong>执行者</strong>：通常是 DBA 或拥有相应对象所有权的用户。</li>
<li><strong>语法结构</strong>：<code>GRANT &lt;权限列表&gt; ON &lt;对象类型&gt; &lt;对象名&gt; TO &lt;用户/角色&gt; [WITH GRANT OPTION];</code></li>
</ul>
<hr>
<h3 id="二、-权限的种类（按层级划分）"><a href="#二、-权限的种类（按层级划分）" class="headerlink" title="二、 权限的种类（按层级划分）"></a>二、 权限的种类（按层级划分）</h3><p>根据你提供的课件以及标准 SQL 规范，权限可以分为以下三个维度：</p>
<h4 id="1-模式级别权限-Schema-Level-——-进入与创建"><a href="#1-模式级别权限-Schema-Level-——-进入与创建" class="headerlink" title="1. 模式级别权限 (Schema Level) —— 进入与创建"></a>1. 模式级别权限 (Schema Level) —— 进入与创建</h4><p>这是管理“文件夹”（Schema）的钥匙，是访问数据的第一道关卡。</p>
<ul>
<li><strong><code>USAGE</code> (使用权)</strong>：<ul>
<li><strong>作用</strong>：允许用户访问、穿过某个模式。</li>
<li><strong>重要性</strong>：它是<strong>最基础的权限</strong>。如果用户没有 <code>USAGE</code> 权限，即使拥有该模式下某张表的 <code>SELECT</code> 权限，也无法进行查询，因为他连“房间门”都进不去。</li>
</ul>
</li>
<li><strong><code>CREATE</code> (创建权)</strong>：<ul>
<li><strong>作用</strong>：允许用户在非其拥有的模式中创建新对象（如建表、建视图）。</li>
</ul>
</li>
</ul>
<h4 id="2-对象级别权限-Object-Level-——-数据读写"><a href="#2-对象级别权限-Object-Level-——-数据读写" class="headerlink" title="2. 对象级别权限 (Object Level) —— 数据读写"></a>2. 对象级别权限 (Object Level) —— 数据读写</h4><p>针对具体的<strong>表（Table）</strong>、<strong>视图（View）</strong>或<strong>序列（Sequence）</strong>等对象。</p>
<ul>
<li><strong><code>SELECT</code></strong>：读取/查询数据的权限。</li>
<li><strong><code>INSERT</code></strong>：向表中添加新记录的权限。</li>
<li><strong><code>UPDATE</code></strong>：修改表中现有记录的权限。</li>
<li><strong><code>DELETE</code></strong>：删除表中记录的权限。</li>
<li><strong><code>REFERENCES</code></strong>：允许在创建其他表时，定义外键来引用该表的主键。</li>
<li><strong><code>ALL PRIVILEGES</code></strong>：授予该对象上的所有可用权限。</li>
</ul>
<h4 id="3-授权权力-WITH-GRANT-OPTION-——-“转授权”"><a href="#3-授权权力-WITH-GRANT-OPTION-——-“转授权”" class="headerlink" title="3. 授权权力 (WITH GRANT OPTION) —— “转授权”"></a>3. 授权权力 (WITH GRANT OPTION) —— “转授权”</h4><p>这是一种特殊的权力附加选项。</p>
<ul>
<li>如果用户在获得权限时带有 <code>WITH GRANT OPTION</code>，他不仅自己可以使用该权限，还可以将该权限<strong>再次授予</strong>给其他用户。</li>
</ul>
<h2 id="DROP-SCHEMA"><a href="#DROP-SCHEMA" class="headerlink" title="DROP SCHEMA"></a>DROP SCHEMA</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA &lt;模式名&gt; &lt;CASCADE | RESTRICT&gt;</span><br></pre></td></tr></table></figure>
<h2 id="如何在定义基本表时设定所属模式？"><a href="#如何在定义基本表时设定所属模式？" class="headerlink" title="如何在定义基本表时设定所属模式？"></a>如何在定义基本表时设定所属模式？</h2><h3 id="1-在创建模式语句中同时创建表"><a href="#1-在创建模式语句中同时创建表" class="headerlink" title="1. 在创建模式语句中同时创建表"></a>1. 在创建模式语句中同时创建表</h3><p>这是最直接的“打包”方式。在执行 <code>CREATE SCHEMA</code> 语句时，可以紧接着编写 <code>CREATE TABLE</code> 子句。</p>
<ul>
<li><p><strong>逻辑</strong>：在该模式被创建的同时，其内部的表也会被一并定义，这些表自动归属于该模式。</p>
</li>
<li><p><strong>语法示例</strong>（参考课件）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</span><br><span class="line">    CREATE TABLE &lt;表名&gt; (...);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-在表名中显式给出模式名"><a href="#2-在表名中显式给出模式名" class="headerlink" title="2. 在表名中显式给出模式名"></a>2. 在表名中显式给出模式名</h3><p>如果在已经存在的模式中创建表，可以在 <code>CREATE TABLE</code> 语句中通过“点号”连接的方式明确指定模式。</p>
<ul>
<li><strong>格式</strong>：<code>&quot;模式名&quot;.表名</code>。</li>
<li><strong>课件示例</strong>（模式名为 <code>S-T</code>）：<ul>
<li><code>CREATE TABLE &quot;S-T&quot;.Student(......);</code></li>
<li><code>CREATE TABLE &quot;S-T&quot;.Course(......);</code></li>
<li><code>CREATE TABLE &quot;S-T&quot;.SC(......);</code></li>
</ul>
</li>
</ul>
<h3 id="3-设置搜索路径（Search-Path）"><a href="#3-设置搜索路径（Search-Path）" class="headerlink" title="3. 设置搜索路径（Search Path）"></a>3. 设置搜索路径（Search Path）</h3><p>这是一种隐式关联的方法，通过设置数据库系统的环境参数来决定新建表的去向。</p>
<ul>
<li><strong>原理</strong>：当你在 <code>CREATE TABLE</code> 中只写表名而没有指定模式名时，系统会根据当前的<strong>搜索路径</strong>（Search Path）按顺序查找，并通常将新表创建在搜索路径中的第一个模式下。</li>
</ul>
<h2 id="模式的搜索路径"><a href="#模式的搜索路径" class="headerlink" title="模式的搜索路径"></a>模式的搜索路径</h2><h4 id="1-核心概念：为什么要用搜索路径？"><a href="#1-核心概念：为什么要用搜索路径？" class="headerlink" title="1. 核心概念：为什么要用搜索路径？"></a>1. 核心概念：为什么要用搜索路径？</h4><ul>
<li><strong>简化书写</strong>：虽然可以使用“全称定位”（模式名 + 对象名）来访问数据，但名称太长会导致书写繁琐。</li>
<li><strong>环境变量类比</strong>：它类似于 Windows 系统中的 <code>path</code> 变量或 Java 中的 <code>classpath</code>。当你输入一个命令时，系统会按顺序在这些路径下查找对应的文件。</li>
</ul>
<h4 id="2-如何查看当前的搜索路径？"><a href="#2-如何查看当前的搜索路径？" class="headerlink" title="2. 如何查看当前的搜索路径？"></a>2. 如何查看当前的搜索路径？</h4><p>你可以通过 SQL 命令查看系统当前的查找顺序：</p>
<ul>
<li><strong>命令</strong>：<code>SHOW search_path;</code></li>
<li><strong>缺省设置（默认值）</strong>：通常显示为 <code>&quot;$user&quot;, public</code>。<ul>
<li><strong><code>$user</code></strong>：代表与当前登录用户名同名的模式。</li>
<li><strong><code>public</code></strong>：代表默认的公共模式。</li>
<li><strong>查找逻辑</strong>：系统优先查找 <code>$user</code> 模式，如果没有找到，再查找 <code>public</code>。</li>
</ul>
</li>
</ul>
<h4 id="3-搜索路径与“创建表”的关系"><a href="#3-搜索路径与“创建表”的关系" class="headerlink" title="3. 搜索路径与“创建表”的关系"></a>3. 搜索路径与“创建表”的关系</h4><p>当你定义一张新表且<strong>没有显式指定模式名</strong>时，搜索路径决定了这张表的“落户地址”：</p>
<ul>
<li><strong>第一个原则</strong>：系统会将新对象创建在搜索路径列表中的 <strong>第一个存在</strong> 的模式中。</li>
<li><strong>设置方法</strong>：数据库管理员可以使用 <code>SET search_path TO ...</code> 来更改路径。<ul>
<li><strong>实例</strong>：执行 <code>SET search_path TO &quot;S-T&quot;, public;</code> 后再执行 <code>Create table Student(...);</code>，结果会建立 <code>S-T.Student</code> 基本表。</li>
</ul>
</li>
<li><strong>错误处理</strong>：如果路径中列出的所有模式都不存在，系统将直接报错。</li>
</ul>
<hr>
<h3 id="💡-核心总结"><a href="#💡-核心总结" class="headerlink" title="💡 核心总结"></a>💡 核心总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>操作目的</strong></th>
<th><strong>SQL 命令示例</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>查看路径</strong></td>
<td><code>SHOW search_path;</code></td>
<td>确认当前的查找顺序</td>
</tr>
<tr>
<td><strong>修改路径</strong></td>
<td><code>SET search_path TO schema1, schema2;</code></td>
<td>改变默认的对象查找和创建位置</td>
</tr>
<tr>
<td><strong>全称调用</strong></td>
<td><code>SELECT * FROM &quot;S-T&quot;.Student;</code></td>
<td>绕过搜索路径，直接定位对象</td>
</tr>
<tr>
<td><strong>隐式调用</strong></td>
<td><code>SELECT * FROM Student;</code></td>
<td>依靠搜索路径自动匹配模式</td>
</tr>
</tbody>
</table>
</div>
<h2 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引 (Index)"></a>索引 (Index)</h2><h3 id="1-核心目的：以空间换时间"><a href="#1-核心目的：以空间换时间" class="headerlink" title="1. 核心目的：以空间换时间"></a>1. 核心目的：以空间换时间</h3><ul>
<li><strong>加快查询速度</strong>：这是建立索引最主要的目的。</li>
<li><strong>代价</strong>：索引本身需要占用物理存储空间，且在数据更新（增、删、改）时，数据库还需要维护索引，因此会略微增加写操作的开销。</li>
<li><strong>备注</strong>：虽然它增加了空间负担，但由于数据的“删、改”操作通常也需要先通过“查询”定位目标，所以索引在整体上能显著提升性能。</li>
</ul>
<hr>
<h3 id="2-索引的本质是什么？"><a href="#2-索引的本质是什么？" class="headerlink" title="2. 索引的本质是什么？"></a>2. 索引的本质是什么？</h3><ul>
<li><strong>逻辑指针清单</strong>：索引存储了表中某一列或多列的值，以及这些值对应的数据库页（Data Page）的物理地址。</li>
<li><strong>排序结构</strong>：索引会对这些值进行<strong>排序</strong>，从而允许数据库使用更高效的算法（如二分查找）来快速定位。</li>
</ul>
<hr>
<h3 id="3-常见的索引类型"><a href="#3-常见的索引类型" class="headerlink" title="3. 常见的索引类型"></a>3. 常见的索引类型</h3><h4 id="1-B-树索引-B-Tree-Index"><a href="#1-B-树索引-B-Tree-Index" class="headerlink" title="1. B+树索引 (B+Tree Index)"></a>1. B+树索引 (B+Tree Index)</h4><p>这是最常用、最典型的索引类型。</p>
<ul>
<li><strong>组织形式</strong>：索引属性以 <strong>B+树</strong> 的形式进行组织，这种树形结构具有 <strong>动态平衡</strong> 的优点。</li>
<li><strong>结构层次</strong>：<ul>
<li><strong>根节点与内部节点</strong>：存储索引值，用于引导查找方向。</li>
<li><strong>叶子节点</strong>：存储具体的索引值及其对应的 <strong>数据指针</strong>。同时，叶子节点之间有指针相连，方便进行范围查找。</li>
</ul>
</li>
<li><strong>优势</strong>：非常适合精确查找和范围查询（Range Scan）。</li>
</ul>
<p><img src="/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20251225162135184.png" alt="image-20251225162135184"></p>
<h4 id="2-散列-哈希索引-Hash-Index"><a href="#2-散列-哈希索引-Hash-Index" class="headerlink" title="2. 散列/哈希索引 (Hash Index)"></a>2. 散列/哈希索引 (Hash Index)</h4><p>一种基于键值对（key-value）的极速查找方案。</p>
<ul>
<li><strong>存储结构</strong>：它将索引列的值作为“键”，通过哈希算法映射到特定的存储位置。</li>
<li><strong>特点</strong>：<ul>
<li>具有 <strong>查找速度快</strong> 的显著优点。</li>
<li><strong>局限性</strong>：只适合 <strong>等值查询</strong>（即 <code>WHERE column = &#39;value&#39;</code>）。由于哈希值是无序的，它无法处理“大于”或“小于”的范围查找。</li>
</ul>
</li>
</ul>
<h4 id="3-顺序文件上的索引-Indexed-Sequential-File"><a href="#3-顺序文件上的索引-Indexed-Sequential-File" class="headerlink" title="3. 顺序文件上的索引 (Indexed Sequential File)"></a>3. 顺序文件上的索引 (Indexed Sequential File)</h4><p>这是一种较为传统的物理索引方式。</p>
<ul>
<li><strong>核心逻辑</strong>：建立一个独立的 <strong>索引文件</strong>，其中包含 <strong>[属性值, 元组指针]</strong> 的对应关系。</li>
<li><strong>排序方式</strong>：索引属性可以按照 <strong>升序或降序</strong> 排列。</li>
<li><strong>灵活性</strong>：可以选择非主属性（即不是主键的列）作为索引属性来建立索引。</li>
</ul>
<h4 id="4-位图索引-Bitmap-Index"><a href="#4-位图索引-Bitmap-Index" class="headerlink" title="4. 位图索引 (Bitmap Index)"></a>4. 位图索引 (Bitmap Index)</h4><p>适用于特定数据分布的索引方式。</p>
<ul>
<li><strong>适用场景</strong>：当某列的取值范围（基数）非常有限时效果最好，例如“性别”（男/女）或“婚姻状况”。</li>
<li><strong>原理</strong>：用二进制的“位”（0 或 1）来标记每一行是否包含某个特定的值。</li>
<li><strong>优势</strong>：节省空间，且在处理多个条件的逻辑运算（AND/OR）时速度极快。</li>
</ul>
<h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>在数据库中，建立索引是提高查询效率的关键操作。根据课件图片，该语句的完整格式如下：</p>
<script type="math/tex; mode=display">\text{CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名>(<列名>[<次序>][,<列名>[<次序>]]...); }</script><p>我们可以从<strong>基础语法</strong>、<strong>核心关键字</strong>以及<strong>排序次序</strong>三个维度来深度拆解：</p>
<hr>
<h3 id="1-基础语法组件"><a href="#1-基础语法组件" class="headerlink" title="1. 基础语法组件"></a>1. 基础语法组件</h3><ul>
<li><strong><code>&lt;索引名&gt;</code></strong>：由用户自定义，用于唯一标识该索引。</li>
<li><strong><code>&lt;表名&gt;</code></strong>：指定要在哪张基本表上建立索引。</li>
<li><strong><code>&lt;列名&gt;</code></strong>：可以建立在<strong>一列或多列</strong>（即复合索引）上，多个列名之间用逗号分隔。</li>
</ul>
<hr>
<h3 id="2-核心关键字解析"><a href="#2-核心关键字解析" class="headerlink" title="2. 核心关键字解析"></a>2. 核心关键字解析</h3><h4 id="UNIQUE-唯一索引"><a href="#UNIQUE-唯一索引" class="headerlink" title="UNIQUE (唯一索引)"></a><strong>UNIQUE (唯一索引)</strong></h4><ul>
<li><strong>含义</strong>：指定此索引的每一个索引值只能对应一条唯一的数据库记录。</li>
<li><strong>作用</strong>：除了加速查询，它还起到<strong>约束</strong>作用，确保该列不会出现重复数据。</li>
</ul>
<h4 id="CLUSTER-聚簇索引"><a href="#CLUSTER-聚簇索引" class="headerlink" title="CLUSTER (聚簇索引)"></a><strong>CLUSTER (聚簇索引)</strong></h4><ul>
<li><strong>含义</strong>：表示要建立的是<strong>聚簇索引</strong>。</li>
<li><strong>原理</strong>：将具有相同或相近索引值的元组（记录）在物理上存放在连续的磁盘块中。</li>
<li><strong>注意</strong>：由于数据在物理上只能有一种排列顺序，因此一张表通常只能有一个聚簇索引。</li>
</ul>
<p><img src="/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20251225162530664.png" alt="image-20251225162530664"></p>
<hr>
<h3 id="3-次序-Order"><a href="#3-次序-Order" class="headerlink" title="3. 次序 (Order)"></a>3. 次序 (Order)</h3><p>在定义索引列时，可以指定数据的排列方式：</p>
<ul>
<li><strong><code>ASC</code></strong>：升序排列（默认值）。</li>
<li><strong><code>DESC</code></strong>：降序排列。</li>
</ul>
<h2 id="修改索引与删除索引"><a href="#修改索引与删除索引" class="headerlink" title="修改索引与删除索引"></a>修改索引与删除索引</h2><h3 id="一、-修改索引-ALTER-INDEX"><a href="#一、-修改索引-ALTER-INDEX" class="headerlink" title="一、 修改索引 (ALTER INDEX)"></a>一、 修改索引 (ALTER INDEX)</h3><p>修改索引的主要操作是<strong>重命名</strong>。由于索引的物理结构通常比较复杂，直接“修改”索引内部逻辑并不常见，通常是通过更名来使其符合新的命名规范。</p>
<ul>
<li>语法格式：</li>
</ul>
<script type="math/tex; mode=display">ALTER\ INDEX\ <旧索引名>\ RENAME\ TO\ <新索引名>;</script><ul>
<li><p>实例演示：</p>
<p>如果你想将 SC 表上原有的 SCno 索引更名为 SCSno，可以使用：</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER INDEX SCno RENAME TO SCSno;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="二、-删除索引-DROP-INDEX"><a href="#二、-删除索引-DROP-INDEX" class="headerlink" title="二、 删除索引 (DROP INDEX)"></a>二、 删除索引 (DROP INDEX)</h3><p>当某些索引不再能提高查询速度，或者因为维护索引（如在插入/删除数据时同步更新索引）带来的负担超过了它的价值时，就需要将其删除。</p>
<ul>
<li><p><strong>核心逻辑</strong>：删除索引时，系统会从数据库的“数据字典”中删去有关该索引的描述。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<script type="math/tex; mode=display">DROP\ INDEX\ <索引名>;</script><ul>
<li><em>例子</em>：删除 <code>Student</code> 表上的 <code>Stusname</code> 索引：<code>DROP INDEX Stusname;</code></li>
</ul>
<h4 id="特殊情况：同名索引的处理"><a href="#特殊情况：同名索引的处理" class="headerlink" title="特殊情况：同名索引的处理"></a><strong>特殊情况：同名索引的处理</strong></h4><p>如果不同的表（如 <code>Student</code> 表和 <code>Course</code> 表）都有一个同名的索引 <code>index1</code>，为了避免误删，通常需要指定表名：</p>
<ol>
<li><strong>方式一</strong>：<code>ALTER TABLE Student DROP INDEX index1;</code></li>
<li><strong>方式二</strong>：<code>DROP INDEX index1 ON Student;</code></li>
</ol>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="1-查询语句的标准格式"><a href="#1-查询语句的标准格式" class="headerlink" title="1. 查询语句的标准格式"></a>1. 查询语句的标准格式</h3><p>一个完整的 <code>SELECT</code> 语句由多个子句组成，它们的<strong>书写顺序</strong>是固定的：</p>
<script type="math/tex; mode=display">\text{SELECT [ALL|DISTINCT] <目标列>}</script><script type="math/tex; mode=display">\text{FROM <表名/视图名>}</script><script type="math/tex; mode=display">\text{[WHERE <条件表达式>]}</script><script type="math/tex; mode=display">\text{[GROUP BY <列名> [HAVING <条件表达式>]]}</script><script type="math/tex; mode=display">\text{[ORDER BY <列名> [ASC|DESC]];}</script><hr>
<h3 id="2-各个子句的功能拆解"><a href="#2-各个子句的功能拆解" class="headerlink" title="2. 各个子句的功能拆解"></a>2. 各个子句的功能拆解</h3><p>我们按照执行逻辑，来看看每个部分是干什么的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>子句关键字</strong></th>
<th><strong>功能描述</strong></th>
<th><strong>通俗比喻</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SELECT</strong></td>
<td>指定要显示的属性列（可以选全部或部分）。</td>
<td>“我要看哪几列？”</td>
</tr>
<tr>
<td><strong>FROM</strong></td>
<td>指定查询的对象（基本表、视图或另一个查询结果）。</td>
<td>“去哪张表里找？”</td>
</tr>
<tr>
<td><strong>WHERE</strong></td>
<td>指定元组（行）的筛选条件。</td>
<td>“哪些行是我想要的？”</td>
</tr>
<tr>
<td><strong>GROUP BY</strong></td>
<td>将查询结果按指定列的值进行分组。</td>
<td>“把相同特征的人凑成一堆。”</td>
</tr>
<tr>
<td><strong>HAVING</strong></td>
<td><strong>仅用于分组后</strong>，筛选满足特定条件的组。</td>
<td>“在分好的组里再挑一遍。”</td>
</tr>
<tr>
<td><strong>ORDER BY</strong></td>
<td>对查询结果进行升序（<code>ASC</code>）或降序（<code>DESC</code>）排序。</td>
<td>“按高矮顺序排好队。”</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-初学者最容易混淆的两个点"><a href="#3-初学者最容易混淆的两个点" class="headerlink" title="3. 初学者最容易混淆的两个点"></a>3. 初学者最容易混淆的两个点</h3><p>根据课件内容，有两对概念需要特别注意：</p>
<h4 id="A-ALL-vs-DISTINCT"><a href="#A-ALL-vs-DISTINCT" class="headerlink" title="A. ALL vs DISTINCT"></a>A. <code>ALL</code> vs <code>DISTINCT</code></h4><ul>
<li><strong><code>ALL</code></strong>（缺省值）：显示所有查询结果，哪怕有重复行。</li>
<li><strong><code>DISTINCT</code></strong>：自动去掉结果中重复的行。<ul>
<li><em>例子</em>：你想查“有哪些系的学生选了课”，用 <code>DISTINCT</code> 就能保证每个系只出现一次。</li>
</ul>
</li>
</ul>
<h4 id="B-WHERE-vs-HAVING"><a href="#B-WHERE-vs-HAVING" class="headerlink" title="B. WHERE vs HAVING"></a>B. <code>WHERE</code> vs <code>HAVING</code></h4><ul>
<li><strong><code>WHERE</code></strong>：是在<strong>分组前</strong>过滤每一行数据。</li>
<li><strong><code>HAVING</code></strong>：是在 <strong><code>GROUP BY</code> 分组后</strong>过滤整个组。<ul>
<li><em>关键点</em>：通常 <code>HAVING</code> 会配合“集计函数”（如 <code>COUNT</code>, <code>AVG</code>, <code>SUM</code>）使用。例如：“筛选平均分大于 80 的小组”。</li>
</ul>
</li>
</ul>
<h2 id="为什么WHERE子句中是不能用聚集函数作为条件表达式"><a href="#为什么WHERE子句中是不能用聚集函数作为条件表达式" class="headerlink" title="为什么WHERE子句中是不能用聚集函数作为条件表达式"></a>为什么WHERE子句中是不能用聚集函数作为条件表达式</h2><p><strong><code>WHERE</code> 子句和聚集函数（如 <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>）处于不同的“时空”</strong>，它们的执行先后顺序决定了它们无法直接配合。</p>
<p>根据你提供的课件逻辑，原因可以拆解为以下三点：</p>
<h3 id="1-执行顺序的矛盾（核心原因）"><a href="#1-执行顺序的矛盾（核心原因）" class="headerlink" title="1. 执行顺序的矛盾（核心原因）"></a>1. 执行顺序的矛盾（核心原因）</h3><p>数据库在处理查询语句时，并不是按照我们书写的顺序执行的，而是遵循以下逻辑顺序：</p>
<ol>
<li><strong><code>FROM</code></strong>：先找到表。</li>
<li><strong><code>WHERE</code></strong>：<strong>进行行过滤</strong>。此时数据库是一行一行检查数据，决定哪些行该留，哪些行该丢。</li>
<li><strong><code>GROUP BY</code></strong>：将剩下的行分堆。</li>
<li><strong><code>聚集函数</code>计算</strong>：在分好堆后，才开始计算总和或平均值。</li>
</ol>
<p><strong>矛盾点在于</strong>：当你写 <code>WHERE AVG(Grade) &gt; 60</code> 时，数据库正在过滤每一行，它还没把数据聚在一起，根本不知道“平均分”是多少。</p>
<h3 id="2-作用对象的不同"><a href="#2-作用对象的不同" class="headerlink" title="2. 作用对象的不同"></a>2. 作用对象的不同</h3><ul>
<li><strong><code>WHERE</code> 子句</strong>：它的作用对象是<strong>元组（行）</strong>。它在判断“某一个学生”的成绩是否合格。</li>
<li><strong>聚集函数</strong>：它的作用对象是<strong>元组集（多行）</strong>。它在判断“一群学生”的平均分。 由于 <code>WHERE</code> 的本质是筛选“个体”，而聚集函数处理的是“群体”，所以两者在逻辑上不兼容。</li>
</ul>
<hr>
<h3 id="3-正确的解决办法：使用-HAVING"><a href="#3-正确的解决办法：使用-HAVING" class="headerlink" title="3. 正确的解决办法：使用 HAVING"></a>3. 正确的解决办法：使用 <code>HAVING</code></h3><p>如果你想针对聚集函数的结果进行筛选（比如筛选平均分大于 60 的系），必须使用专门为分组后设计的 <strong><code>HAVING</code> 短语</strong>。</p>
<h2 id="LIMIT-子句"><a href="#LIMIT-子句" class="headerlink" title="LIMIT 子句"></a>LIMIT 子句</h2><p><strong><code>LIMIT</code> 子句</strong> 是 SQL 查询中非常实用的一个工具，主要用于<strong>限制查询结果返回的行数（元组数量）</strong>。当你面对成千上万条数据，却只想看前几名（比如“查询成绩前三的学生”）或者需要进行分页显示时，它就是不可或缺的。</p>
<p>以下是根据课件内容的深度拆解：</p>
<hr>
<h3 id="1-核心语法格式"><a href="#1-核心语法格式" class="headerlink" title="1. 核心语法格式"></a>1. 核心语法格式</h3><p>LIMIT 通常放在整个查询语句的最后面，其完整格式如下：</p>
<script type="math/tex; mode=display">\text{LIMIT <行数1> [ OFFSET <行数2> ];}</script><ul>
<li><strong><code>&lt;行数1&gt;</code></strong>：指定最多返回多少行数据。</li>
<li><strong><code>OFFSET &lt;行数2&gt;</code></strong>：<strong>可选参数</strong>。表示在返回结果之前，先<strong>跳过（忽略）</strong>前多少行。</li>
</ul>
<hr>
<h3 id="2-参数组合的使用语义"><a href="#2-参数组合的使用语义" class="headerlink" title="2. 参数组合的使用语义"></a>2. 参数组合的使用语义</h3><h4 id="A-基础用法（只限制数量）"><a href="#A-基础用法（只限制数量）" class="headerlink" title="A. 基础用法（只限制数量）"></a>A. 基础用法（只限制数量）</h4><p>如果你省略 <code>OFFSET</code>，则代表不忽略任何行，直接从第一行开始取。</p>
<ul>
<li><strong>例子</strong>：<code>LIMIT 5;</code> —— 取结果集的前 5 行。</li>
</ul>
<h4 id="B-进阶用法（跳过-限制）"><a href="#B-进阶用法（跳过-限制）" class="headerlink" title="B. 进阶用法（跳过 + 限制）"></a>B. 进阶用法（跳过 + 限制）</h4><p>当你同时使用两个参数时，它能实现<strong>精准截取</strong>。</p>
<ul>
<li><strong>语义</strong>：忽略前 <code>&lt;行数2&gt;</code> 行，然后取接下来的 <code>&lt;行数1&gt;</code> 行作为结果。</li>
<li><strong>例子</strong>：<code>LIMIT 10 OFFSET 20;</code> —— 跳过前 20 条，从第 21 条开始取 10 条数据。</li>
</ul>
<hr>
<h3 id="3-黄金搭档：LIMIT-ORDER-BY"><a href="#3-黄金搭档：LIMIT-ORDER-BY" class="headerlink" title="3. 黄金搭档：LIMIT + ORDER BY"></a>3. 黄金搭档：LIMIT + ORDER BY</h3><p>课件特别提到：<strong><code>LIMIT</code> 子句经常和 <code>ORDER BY</code> 子句一起使用</strong>。</p>
<p>为什么？</p>
<p>因为如果不进行排序，数据库返回的行顺序可能是随机的。只有先排好序，LIMIT 才有意义。</p>
<ul>
<li><p><strong>场景</strong>：查询全校成绩最好的前 3 名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname, Grade</span><br><span class="line">FROM   SC</span><br><span class="line">ORDER BY Grade DESC  -- 先按成绩降序排</span><br><span class="line">LIMIT 3;             -- 再取前3名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="1-核心概念：什么是连接？"><a href="#1-核心概念：什么是连接？" class="headerlink" title="1. 核心概念：什么是连接？"></a>1. 核心概念：什么是连接？</h3><p>根据你的课件定义：</p>
<ul>
<li><strong>连接查询</strong>：同时涉及两个以上的表的查询。</li>
<li><strong>连接条件（连接谓词）</strong>：用来连接两个表的条件，它决定了表 A 的哪一行应该和表 B 的哪一行配对。</li>
<li><strong>连接字段</strong>：连接谓词中涉及的列名。<ul>
<li><strong>注意</strong>：连接字段的类型必须是<strong>可比的</strong>（例如都是数字或都是字符），但名字不必相同。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-连接条件的两种表达方式"><a href="#2-连接条件的两种表达方式" class="headerlink" title="2. 连接条件的两种表达方式"></a>2. 连接条件的两种表达方式</h3><p>课件中给出了连接条件的通用格式：</p>
<h4 id="A-使用比较运算符"><a href="#A-使用比较运算符" class="headerlink" title="A. 使用比较运算符"></a>A. 使用比较运算符</h4><p>这是最常见的写法，通常用于“外键 = 主键”。</p>
<ul>
<li><strong>格式</strong>：<code>[表名1.]列名1 &lt;比较运算符&gt; [表名2.]列名2</code></li>
<li><strong>例</strong>：<code>Student.Sno = SC.Sno</code> （将学生表和选课表通过学号关联起来）。</li>
</ul>
<h4 id="B-使用-BETWEEN-…-AND"><a href="#B-使用-BETWEEN-…-AND" class="headerlink" title="B. 使用 BETWEEN … AND"></a>B. 使用 BETWEEN … AND</h4><p>用于范围类的连接。</p>
<ul>
<li><strong>格式</strong>：<code>[表名1.]列名1 BETWEEN [表名2.]列名2 AND [表名2.]列名3</code></li>
</ul>
<hr>
<h3 id="3-连接查询的执行“大餐”：等值连接与自然连接"><a href="#3-连接查询的执行“大餐”：等值连接与自然连接" class="headerlink" title="3. 连接查询的执行“大餐”：等值连接与自然连接"></a>3. 连接查询的执行“大餐”：等值连接与自然连接</h3><p>虽然连接有很多种，但你最先需要掌握的是最基础的两种：</p>
<h4 id="等值连接-Equijoin"><a href="#等值连接-Equijoin" class="headerlink" title="等值连接 (Equijoin)"></a><strong>等值连接 (Equijoin)</strong></h4><ul>
<li><strong>特点</strong>：连接运算符为 <code>=</code>。</li>
<li><strong>结果</strong>：把所有满足条件的行拼在一起，如果两个表有同名的列，结果集中会<strong>保留两列</strong>（哪怕它们的值完全一样）。</li>
</ul>
<h4 id="自然连接-Natural-Join"><a href="#自然连接-Natural-Join" class="headerlink" title="自然连接 (Natural Join)"></a><strong>自然连接 (Natural Join)</strong></h4><ul>
<li><strong>特点</strong>：它是等值连接的一种特殊形式。</li>
<li><strong>区别</strong>：它会自动寻找两个表中<strong>名称相同</strong>的列进行连接，并且在结果中<strong>去掉重复的列</strong>。</li>
</ul>
<hr>
<h3 id="4-实战演示：查出每个学生及其选修课程的情况"><a href="#4-实战演示：查出每个学生及其选修课程的情况" class="headerlink" title="4. 实战演示：查出每个学生及其选修课程的情况"></a>4. 实战演示：查出每个学生及其选修课程的情况</h3><p>我们需要把 <code>Student</code> 表和 <code>SC</code> 表连接起来：</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Student.*, SC.*</span><br><span class="line">FROM   Student, SC</span><br><span class="line">WHERE  Student.Sno = SC.Sno; -- 连接条件</span><br></pre></td></tr></table></figure>
<p><strong>执行逻辑解析：</strong></p>
<ol>
<li><strong>FROM</strong>：告诉数据库我要用到 <code>Student</code> 和 <code>SC</code> 两张表。</li>
<li><strong>WHERE</strong>：这是关键！如果没有 <code>Student.Sno = SC.Sno</code> 这个条件，数据库会把每一名学生和<strong>所有</strong>选课记录强行配对（产生笛卡尔积），结果会一团糟。</li>
<li><strong>结果</strong>：你现在能看到张三选了数据库、李四选了数学，所有信息一目了然。</li>
</ol>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><h3 id="1-嵌套查询的结构：父与子"><a href="#1-嵌套查询的结构：父与子" class="headerlink" title="1. 嵌套查询的结构：父与子"></a>1. 嵌套查询的结构：父与子</h3><p>嵌套查询通常由两部分组成，它们的关系就像“父子”一样：</p>
<ul>
<li><strong>外层查询（父查询）</strong>：最外面的查询块，它接收内层查询的结果作为自己的筛选条件。</li>
<li><strong>内层查询（子查询）</strong>：被嵌入在括号内的查询块，它先执行并返回一个集合给外层。</li>
</ul>
<h3 id="2-经典案例解析：查询选修了-2-号课程的学生姓名"><a href="#2-经典案例解析：查询选修了-2-号课程的学生姓名" class="headerlink" title="2. 经典案例解析：查询选修了 2 号课程的学生姓名"></a>2. 经典案例解析：查询选修了 2 号课程的学生姓名</h3><p>这是一个非常典型的利用嵌套查询解决问题的例子：</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname              /* 外层查询：我要查的是姓名 */</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno IN</span><br><span class="line">      (SELECT Sno         /* 内层查询：先查出选了2号课的学生学号 */</span><br><span class="line">       FROM SC</span><br><span class="line">       WHERE Cno = &#x27;2&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>执行逻辑：</strong></p>
<ol>
<li><strong>子查询先跑</strong>：数据库先去 <code>SC</code> 表里找到所有选修了 <code>&#39;2&#39;</code> 号课的学号集合，比如 <code>&#123;201215121, 201215122&#125;</code>。</li>
<li><strong>父查询接力</strong>：父查询拿着这个集合，回到 <code>Student</code> 表中找学号在这个集合里的学生，最后吐出他们的姓名 <code>Sname</code>。</li>
</ol>
<hr>
<h3 id="3-子查询的重要限制：不能用-ORDER-BY"><a href="#3-子查询的重要限制：不能用-ORDER-BY" class="headerlink" title="3. 子查询的重要限制：不能用 ORDER BY"></a>3. 子查询的重要限制：不能用 ORDER BY</h3><p>课件中特别强调了一个考点：<strong>子查询中不能使用 <code>ORDER BY</code> 子句</strong>。</p>
<ul>
<li><strong>原因</strong>：<code>ORDER BY</code> 是用来对<strong>最终查询结果</strong>进行排序展示的。</li>
<li><strong>逻辑</strong>：子查询只是给父查询提供一个中间数据集合（就像原材料），对中间数据进行排序是没有意义且浪费性能的。</li>
</ul>
<hr>
<h3 id="4-嵌套查询的灵活性"><a href="#4-嵌套查询的灵活性" class="headerlink" title="4. 嵌套查询的灵活性"></a>4. 嵌套查询的灵活性</h3><ul>
<li><strong>多层嵌套</strong>：SQL 允许子查询中再嵌套子查询，形成多层结构。</li>
<li><strong>连接 vs 嵌套</strong>：很多嵌套查询可以用我们之前学的“连接查询”来实现。嵌套查询的优点是符合人的逻辑思维（先找学号，再找姓名），而连接查询在某些数据库系统中的执行效率可能更高。</li>
</ul>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="1-插入元组的基本语法"><a href="#1-插入元组的基本语法" class="headerlink" title="1. 插入元组的基本语法"></a>1. 插入元组的基本语法</h3><p>这是最常用的方式，用于手动向表中添加新记录。</p>
<p>语法格式：</p>
<script type="math/tex; mode=display">\text{INSERT INTO <表名> [(<属性列1>[, <属性列2>]...)]}</script><script type="math/tex; mode=display">\text{VALUES (<常量1>[, <常量2>]...);}</script><p><strong>要点解析：</strong></p>
<ul>
<li><strong>INTO 子句</strong>：指定目标表名。你可以选择性地列出属性列名。<ul>
<li>如果<strong>不指定属性列</strong>：<code>VALUES</code> 中提供的数据必须包含该表<strong>所有</strong>字段的值，且顺序必须与表定义时完全一致。</li>
<li>如果<strong>指定部分属性列</strong>：没被提到的列会自动取<strong>空值（NULL）</strong>。</li>
</ul>
</li>
<li><strong>VALUES 子句</strong>：提供具体的数据内容。<ul>
<li><strong>匹配规则</strong>：提供的值在<strong>个数</strong>和<strong>数据类型</strong>上必须与 <code>INTO</code> 子句中的属性列一一对应。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-插入子查询结果的语法"><a href="#2-插入子查询结果的语法" class="headerlink" title="2. 插入子查询结果的语法"></a>2. 插入子查询结果的语法</h3><p>这种方式用于将一个查询的结果批量“搬运”到另一个表中。</p>
<p>语法格式：</p>
<script type="math/tex; mode=display">\text{INSERT INTO <表名> [(<属性列1>[, <属性列2>]...)]}</script><script type="math/tex; mode=display">\text{子查询;}</script><p><strong>要点解析：</strong></p>
<ul>
<li><strong>无需 VALUES 关键字</strong>：直接在 <code>INTO</code> 子句后写 <code>SELECT</code> 语句即可。</li>
<li><strong>批量性</strong>：可以一次性插入多个元组，非常适合做数据备份或生成汇总报表。</li>
</ul>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>在掌握了如何插入数据后，接下来我们学习如何对数据库中已有的信息进行更新。这就是 <strong>数据修改（UPDATE）</strong> 操作。</p>
<p>修改数据的核心逻辑是：<strong>找到它，然后改掉它</strong>。</p>
<hr>
<h3 id="一、-修改数据的基本语法"><a href="#一、-修改数据的基本语法" class="headerlink" title="一、 修改数据的基本语法"></a>一、 修改数据的基本语法</h3><p>SQL 使用 <code>UPDATE</code> 语句来改变表中元组（行）的属性值：</p>
<script type="math/tex; mode=display">\text{UPDATE <表名>}</script><script type="math/tex; mode=display">\text{SET <列名>=<表达式>[, <列名>=<表达式>]...}</script><script type="math/tex; mode=display">\text{[WHERE <条件>];}</script><ul>
<li><strong>UPDATE 子句</strong>：指定要修改哪张表。</li>
<li><strong>SET 子句</strong>：指定要修改哪些列，以及赋予它们的新值。</li>
<li><strong>WHERE 子句（最关键）</strong>：指定哪些行需要被修改。<strong>如果省略 WHERE 子句，则表示要修改表中的所有元组</strong>。</li>
</ul>
<hr>
<h3 id="二、-三种常见的修改方式"><a href="#二、-三种常见的修改方式" class="headerlink" title="二、 三种常见的修改方式"></a>二、 三种常见的修改方式</h3><p>根据你提供的课件，修改操作可以根据“锁定范围”分为以下三类：</p>
<h4 id="1-修改单个元组（精准打击）"><a href="#1-修改单个元组（精准打击）" class="headerlink" title="1. 修改单个元组（精准打击）"></a>1. 修改单个元组（精准打击）</h4><p>通常利用“候选码（如学号）=”作为条件，锁定唯一的一行。</p>
<ul>
<li><p><strong>例子</strong>：将学号为 ‘201215121’ 的学生年龄改为 22 岁。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Student SET Sage=22 WHERE Sno=&#x27;201215121&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-修改多个元组（批量操作）"><a href="#2-修改多个元组（批量操作）" class="headerlink" title="2. 修改多个元组（批量操作）"></a>2. 修改多个元组（批量操作）</h4><p>通过满足特定条件的 WHERE 子句，一次性修改多行。</p>
<ul>
<li><p><strong>例子</strong>：将所有学生的年龄限制增加 1 岁。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Student SET Sage=Sage+1; -- 不带WHERE，全体生效</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-带子查询的修改（动态关联）"><a href="#3-带子查询的修改（动态关联）" class="headerlink" title="3. 带子查询的修改（动态关联）"></a>3. 带子查询的修改（动态关联）</h4><p><code>WHERE</code> 子句中可以包含子查询，根据另一张表的状态来决定修改哪些行。</p>
<ul>
<li><p><strong>例子</strong>：将计算机系（CS）所有学生的成绩置为 0。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SC SET Grade=0</span><br><span class="line">WHERE Sno IN (SELECT Sno FROM Student WHERE Sdept=&#x27;CS&#x27;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="三、-修改数据时的注意事项"><a href="#三、-修改数据时的注意事项" class="headerlink" title="三、 修改数据时的注意事项"></a>三、 修改数据时的注意事项</h3><ol>
<li><strong>备份意识</strong>：在执行不带 <code>WHERE</code> 条件的 <code>UPDATE</code> 前，务必确认你真的想修改全表数据，否则后果很严重。</li>
<li><strong>约束检查</strong>：修改后的值必须仍然满足表的完整性约束（例如：不能把主键改重复，不能把非空列改为 NULL）。</li>
<li><strong>表达式计算</strong>：<code>SET</code> 子句中可以使用表达式（如 <code>Sage = Sage + 1</code>），数据库会先计算出新值再更新。</li>
</ol>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><h3 id="1-删除数据的基本语法"><a href="#1-删除数据的基本语法" class="headerlink" title="1. 删除数据的基本语法"></a>1. 删除数据的基本语法</h3><p>SQL 使用 <code>DELETE</code> 语句来删除表中的一个或多个元组（行）：</p>
<script type="math/tex; mode=display">\text{DELETE FROM <表名>}</script><script type="math/tex; mode=display">\text{[WHERE <条件>];}</script><ul>
<li><strong>DELETE FROM 子句</strong>：指定要从哪张表中删除数据。</li>
<li><strong>WHERE 子句（极其关键）</strong>：指定删除的条件。<ul>
<li><strong>如果省略 WHERE 子句</strong>：意味着<strong>删除表中的所有元组</strong>（但表结构本身还在，只是变成了一个空表）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-三种常见的删除方式"><a href="#2-三种常见的删除方式" class="headerlink" title="2. 三种常见的删除方式"></a>2. 三种常见的删除方式</h3><p>根据你提供的课件，删除操作通常分为以下三类：</p>
<h4 id="A-删除单个元组（精准删除）"><a href="#A-删除单个元组（精准删除）" class="headerlink" title="A. 删除单个元组（精准删除）"></a>A. 删除单个元组（精准删除）</h4><p>通常通过主键来锁定唯一的一行。</p>
<ul>
<li><p><strong>例子</strong>：删除学号为 ‘201215128’ 的学生记录。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Student</span><br><span class="line">WHERE Sno = &#x27;201215128&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="B-删除多个元组（批量删除）"><a href="#B-删除多个元组（批量删除）" class="headerlink" title="B. 删除多个元组（批量删除）"></a>B. 删除多个元组（批量删除）</h4><p>删除满足某一特定条件的所有行。</p>
<ul>
<li><p><strong>例子</strong>：删除所有学生的选课记录（即清空 SC 表）。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM SC; -- 省略 WHERE，全表清空</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="C-带子查询的删除（关联删除）"><a href="#C-带子查询的删除（关联删除）" class="headerlink" title="C. 带子查询的删除（关联删除）"></a>C. 带子查询的删除（关联删除）</h4><p>根据另一张表的信息来决定删除哪些行。</p>
<ul>
<li><p><strong>例子</strong>：删除计算机科学系（CS）所有学生的选课记录。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM SC</span><br><span class="line">WHERE Sno IN (</span><br><span class="line">    SELECT Sno FROM Student WHERE Sdept = &#x27;CS&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-重要区别：DELETE-vs-DROP"><a href="#3-重要区别：DELETE-vs-DROP" class="headerlink" title="3. 重要区别：DELETE vs DROP"></a>3. 重要区别：DELETE vs DROP</h3><p>很多初学者会把这两个命令搞混，它们的区别非常巨大：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>操作对象</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>DELETE</code></strong></td>
<td>表中的<strong>数据（行）</strong></td>
<td><strong>“房子还在，家具搬走了”</strong>。表结构依然存在，你可以继续插入数据。</td>
</tr>
<tr>
<td><strong><code>DROP</code></strong></td>
<td>整个<strong>表（结构）</strong></td>
<td><strong>“房子拆了”</strong>。表结构、索引、数据全部消失，数据库里不再有这张表。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="4-⚠-安全警告：删除前的“潜规则”"><a href="#4-⚠-安全警告：删除前的“潜规则”" class="headerlink" title="4. ⚠ 安全警告：删除前的“潜规则”"></a>4. ⚠ 安全警告：删除前的“潜规则”</h3><p>在执行 <code>DELETE</code> 尤其是带条件的删除时，建议遵循以下职业规范：</p>
<ol>
<li><strong>先查后删</strong>：在把 <code>SELECT *</code> 改成 <code>DELETE</code> 之前，先运行一遍查询，看看选出来的行是不是你真的想删掉的那些。</li>
<li><strong>检查外键约束</strong>：如果你尝试删除 <code>Student</code> 表中的张三，但 <code>SC</code> 表里还有张三的成绩，数据库可能会因为<strong>参照完整性约束</strong>而拒绝你的删除请求（除非设置了级联删除）。</li>
</ol>
<hr>
<h3 id="💡-核心总结-1"><a href="#💡-核心总结-1" class="headerlink" title="💡 核心总结"></a>💡 核心总结</h3><ul>
<li><code>DELETE</code> 删除的是<strong>行</strong>，不是列。</li>
<li>不带 <code>WHERE</code> 的 <code>DELETE</code> 是清空整张表的“大杀器”。</li>
<li>可以使用嵌套查询来实现跨表关联删除。</li>
</ul>
<h2 id="数据库完整性-Data-Integrity"><a href="#数据库完整性-Data-Integrity" class="headerlink" title="数据库完整性 (Data Integrity)"></a>数据库完整性 (Data Integrity)</h2><h3 id="1-完整性的两个核心维度"><a href="#1-完整性的两个核心维度" class="headerlink" title="1. 完整性的两个核心维度"></a>1. 完整性的两个核心维度</h3><p>根据课件定义，完整性主要包含以下两方面：</p>
<ul>
<li><strong>正确性</strong>：指数据符合现实世界语义，反映当前实际状况。<ul>
<li><em>例子</em>：学号必须是唯一的；学生的性别只能是“男”或“女”。</li>
</ul>
</li>
<li><strong>相容性</strong>：指数据库同一对象在不同关系表中的数据是符合逻辑的。<ul>
<li><em>例子</em>：学生选的课必须是学校确实开设的课程；学生所在的院系必须是已成立的院系。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-完整性-vs-安全性：易混淆点拨"><a href="#2-完整性-vs-安全性：易混淆点拨" class="headerlink" title="2. 完整性 vs. 安全性：易混淆点拨"></a>2. 完整性 vs. 安全性：易混淆点拨</h3><p>虽然两者都关乎数据质量，但防范的对象截然不同：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>数据完整性</strong></th>
<th><strong>数据安全性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>防范对象</strong></td>
<td><strong>不合语义、不正确的数据</strong></td>
<td><strong>恶意破坏和非法存取</strong></td>
</tr>
<tr>
<td><strong>根源</strong></td>
<td>来自不当的数据库操作（如输入错误）</td>
<td>来自非法用户和非法操作</td>
</tr>
<tr>
<td><strong>目标</strong></td>
<td>确保数据是“对”的</td>
<td>确保数据是“保密且安全”的</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-DBMS-维护完整性的三套机制"><a href="#3-DBMS-维护完整性的三套机制" class="headerlink" title="3. DBMS 维护完整性的三套机制"></a>3. DBMS 维护完整性的三套机制</h3><p>为了保证数据不出乱子，数据库管理系统（DBMS）必须提供以下三项功能：</p>
<h4 id="①-提供定义完整性约束条件的机制"><a href="#①-提供定义完整性约束条件的机制" class="headerlink" title="① 提供定义完整性约束条件的机制"></a>① 提供定义完整性约束条件的机制</h4><p>通过 SQL 的<strong>数据定义语言（DDL）</strong>，DBA 可以描述数据必须满足的“完整性规则”。</p>
<ul>
<li><strong>实体完整性</strong>：主键不能为空且唯一。</li>
<li><strong>参照完整性</strong>：外键必须引用已存在的主键值。</li>
<li><strong>用户定义完整性</strong>：针对具体数据的自定义限制（如年龄必须在 0-120 之间）。</li>
</ul>
<h4 id="②-提供完整性检查的方法"><a href="#②-提供完整性检查的方法" class="headerlink" title="② 提供完整性检查的方法"></a>② 提供完整性检查的方法</h4><p>DBMS 会在特定的时间点（一般是在执行 <strong>INSERT、UPDATE、DELETE</strong> 语句后，或事务提交时）检查数据是否违反了定义的规则。</p>
<h4 id="③-违约处理"><a href="#③-违约处理" class="headerlink" title="③ 违约处理"></a>③ 违约处理</h4><p>如果发现用户的操作违反了完整性约束，DBMS 会采取一定的动作：</p>
<ul>
<li><strong>拒绝 (NO ACTION)</strong>：直接报错并撤销该操作。</li>
<li><strong>级联 (CASCADE)</strong>：为了维持完整性，自动执行其他关联操作（如删除一个班级时，自动删除该班级下的所有学生记录）。</li>
</ul>
<h2 id="实体完整性-Entity-Integrity"><a href="#实体完整性-Entity-Integrity" class="headerlink" title="实体完整性 (Entity Integrity)"></a>实体完整性 (Entity Integrity)</h2><h4 id="1-实体完整性的核心规则"><a href="#1-实体完整性的核心规则" class="headerlink" title="1. 实体完整性的核心规则"></a>1. 实体完整性的核心规则</h4><p>在关系模型中，实体完整性通过 <strong>主键 (Primary Key)</strong> 来实现，其规则如下：</p>
<ul>
<li><strong>唯一性</strong>：主键的值必须是唯一的，不能出现重复。</li>
<li><strong>非空性</strong>：主键列（或构成主键的所有属性列）不能取空值（NULL）。</li>
</ul>
<hr>
<h4 id="2-如何定义实体完整性？"><a href="#2-如何定义实体完整性？" class="headerlink" title="2. 如何定义实体完整性？"></a>2. 如何定义实体完整性？</h4><p>根据课件，在创建表（<code>CREATE TABLE</code>）时，我们可以使用 <code>PRIMARY KEY</code> 关键字来定义主键。</p>
<h5 id="A-单属性主键（码由一个属性构成）"><a href="#A-单属性主键（码由一个属性构成）" class="headerlink" title="A. 单属性主键（码由一个属性构成）"></a>A. 单属性主键（码由一个属性构成）</h5><p>有两种说明方法：</p>
<ol>
<li><p><strong>列级约束条件</strong>：直接在属性定义后加上关键字。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student (</span><br><span class="line">    Sno CHAR(9) PRIMARY KEY, /* 列级定义 */</span><br><span class="line">    Sname CHAR(20) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表级约束条件</strong>：在所有列定义完后单独说明。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student (</span><br><span class="line">    Sno CHAR(9),</span><br><span class="line">    Sname CHAR(20),</span><br><span class="line">    PRIMARY KEY (Sno) /* 表级定义 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="B-多属性主键（码由多个属性构成）"><a href="#B-多属性主键（码由多个属性构成）" class="headerlink" title="B. 多属性主键（码由多个属性构成）"></a>B. 多属性主键（码由多个属性构成）</h5><p>当主键由多个列共同组成时（联合主键），<strong>只能使用表级约束条件</strong>来定义。</p>
<ul>
<li><p><strong>例子</strong>：选课表 <code>SC</code> 的主键由学号 <code>Sno</code> 和课程号 <code>Cno</code> 共同组成。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC (</span><br><span class="line">    Sno CHAR(9),</span><br><span class="line">    Cno CHAR(4),</span><br><span class="line">    Grade SMALLINT,</span><br><span class="line">    PRIMARY KEY (Sno, Cno) /* 只能用表级定义 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="3-实体完整性检查与违约处理"><a href="#3-实体完整性检查与违约处理" class="headerlink" title="3. 实体完整性检查与违约处理"></a>3. 实体完整性检查与违约处理</h4><p>当你尝试执行 <code>INSERT</code> 或 <code>UPDATE</code> 操作时，数据库管理系统（DBMS）会自动按照以下逻辑进行检查：</p>
<ol>
<li><strong>检查主键是否为空</strong>：如果为空，拒绝插入/修改。</li>
<li><strong>检查主键值是否唯一</strong>：DBMS 会通过主键索引快速查找是否存在相同的值。如果已存在，则拒绝操作。</li>
</ol>
<h2 id="参照完整性-Referential-Integrity"><a href="#参照完整性-Referential-Integrity" class="headerlink" title="参照完整性 (Referential Integrity)"></a>参照完整性 (Referential Integrity)</h2><h3 id="1-什么是参照完整性？"><a href="#1-什么是参照完整性？" class="headerlink" title="1. 什么是参照完整性？"></a>1. 什么是参照完整性？</h3><p>参照完整性用于定义外码（Foreign Key）与主码（Primary Key）之间的引用规则。它确保了：<strong>在一个表中引用的数据，必须在另一个表中确实存在</strong>。</p>
<ul>
<li><strong>例子</strong>：如果选课表 <code>SC</code> 中记录学号为 <code>201215121</code> 的学生选了课，那么这个学号必须在学生表 <code>Student</code> 中能查到，不能凭空出现。</li>
</ul>
<hr>
<h3 id="2-如何定义参照完整性？"><a href="#2-如何定义参照完整性？" class="headerlink" title="2. 如何定义参照完整性？"></a>2. 如何定义参照完整性？</h3><p>在 SQL 中，我们通过 <code>FOREIGN KEY</code> 和 <code>REFERENCES</code> 两个短语来共同实现这一约束：</p>
<ul>
<li><strong><code>FOREIGN KEY</code></strong>：指明本表中的哪些列是<strong>外码</strong>。</li>
<li><strong><code>REFERENCES</code></strong>：指明这个外码参照了哪张表的<strong>主码</strong>。</li>
</ul>
<h4 id="语法实例：定义选课表-SC"><a href="#语法实例：定义选课表-SC" class="headerlink" title="语法实例：定义选课表 (SC)"></a>语法实例：定义选课表 (SC)</h4><p>在创建 <code>SC</code> 表时，我们需要通过参照完整性将其与 <code>Student</code> 表和 <code>Course</code> 表挂钩：</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC (</span><br><span class="line">    Sno   CHAR(9)  NOT NULL,</span><br><span class="line">    Cno   CHAR(4)  NOT NULL,</span><br><span class="line">    Grade SMALLINT,</span><br><span class="line">    PRIMARY KEY (Sno, Cno),                     /* 实体完整性：定义主码 */</span><br><span class="line">    FOREIGN KEY (Sno) REFERENCES Student(Sno),  /* 参照完整性：Sno参照Student表 */</span><br><span class="line">    FOREIGN KEY (Cno) REFERENCES Course(Cno)   /* 参照完整性：Cno参照Course表 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-参照完整性的检查逻辑"><a href="#3-参照完整性的检查逻辑" class="headerlink" title="3. 参照完整性的检查逻辑"></a>3. 参照完整性的检查逻辑</h3><p>每当你执行涉及外码的操作时，DBMS 都会进行严格检查：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>检查逻辑</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>向 SC 插入数据</strong></td>
<td>检查该学号是否已在 <code>Student</code> 表中。如果没有，拒绝插入。</td>
</tr>
<tr>
<td><strong>修改 SC 的 Sno</strong></td>
<td>检查新学号是否在 <code>Student</code> 表中。如果没有，拒绝修改。</td>
</tr>
<tr>
<td><strong>删除 Student 记录</strong></td>
<td><strong>最危险操作</strong>。如果要删除的学生在 <code>SC</code> 里还有选课记录，DBMS 会根据“违约处理”决定是拒绝删除还是连带删除。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="4-违约处理-Violation-Handling"><a href="#4-违约处理-Violation-Handling" class="headerlink" title="4. 违约处理 (Violation Handling)"></a>4. 违约处理 (Violation Handling)</h3><p>如果操作违反了规则，DBMS 允许设置不同的动作：</p>
<ul>
<li><strong>拒绝 (NO ACTION)</strong>：默认操作，报错并撤销。</li>
<li><strong>级联 (CASCADE)</strong>：比如删除一个学生时，自动把他所有的选课记录也删掉。</li>
<li><strong>置空值 (SET-NULL)</strong>：比如删除一个院系时，把该系下所有学生的“所在系”字段设为 NULL。</li>
</ul>
<h2 id="用户定义的完整性-User-defined-Integrity"><a href="#用户定义的完整性-User-defined-Integrity" class="headerlink" title="用户定义的完整性 (User-defined Integrity)"></a>用户定义的完整性 (User-defined Integrity)</h2><h3 id="1-为什么需要用户定义的完整性？"><a href="#1-为什么需要用户定义的完整性？" class="headerlink" title="1. 为什么需要用户定义的完整性？"></a>1. 为什么需要用户定义的完整性？</h3><p>虽然主键和外键能保证数据的基本逻辑，但现实业务往往有更细致的要求：</p>
<ul>
<li><strong>语义要求</strong>：例如，学生的年龄不能是负数，成绩必须在 0 到 100 之间。</li>
<li><strong>业务逻辑</strong>：关系数据库管理系统（RDBMS）提供了定义和检验这些规则的机制，这样就不必由应用程序来承担这些繁重的检查工作。</li>
</ul>
<hr>
<h3 id="2-属性上的约束条件定义"><a href="#2-属性上的约束条件定义" class="headerlink" title="2. 属性上的约束条件定义"></a>2. 属性上的约束条件定义</h3><p>当你使用 <code>CREATE TABLE</code> 创建表时，可以针对<strong>单个列（属性）</strong>设置以下三种限制：</p>
<ul>
<li><strong>列值非空 (<code>NOT NULL</code>)</strong>：强制该列必须有值，不能留白。</li>
<li><strong>列值唯一 (<code>UNIQUE</code>)</strong>：保证该列的值在全表中不重复。</li>
<li><strong>检查条件 (<code>CHECK</code>)</strong>：使用特定的逻辑表达式来限制取值范围。<ul>
<li><em>例子</em>：<code>Ssex CHAR(2) CHECK (Ssex IN (&#39;男&#39;, &#39;女&#39;))</code> —— 限制性别只能填这两项。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-元组上的约束条件定义"><a href="#3-元组上的约束条件定义" class="headerlink" title="3. 元组上的约束条件定义"></a>3. 元组上的约束条件定义</h3><p>有时，限制条件并不只针对某一列，而是涉及<strong>多个属性之间的相互关系</strong>，这时就需要在<strong>元组级（行级）</strong>设置限制。</p>
<ul>
<li><strong>实现方式</strong>：同样在 <code>CREATE TABLE</code> 时使用 <code>CHECK</code> 短语定义。</li>
<li><strong>核心优势</strong>：它可以设置不同属性之间取值的相互约束条件。<ul>
<li><em>例子</em>：在一个员工表中，你可以设置“基本工资 + 奖金 &gt; 3000”的约束。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-违约处理"><a href="#4-违约处理" class="headerlink" title="4. 违约处理"></a>4. 违约处理</h3><p>与参照完整性不同，用户定义完整性的违约处理通常非常简单直接：</p>
<ul>
<li><strong>拒绝操作</strong>：如果 <code>INSERT</code> 或 <code>UPDATE</code> 的数据不满足 <code>CHECK</code>、<code>NOT NULL</code> 或 <code>UNIQUE</code> 条件，DBMS 会直接报错并<strong>拒绝执行该操作</strong>。</li>
</ul>
<h2 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h2><h3 id="1-为什么要给约束起名字？"><a href="#1-为什么要给约束起名字？" class="headerlink" title="1. 为什么要给约束起名字？"></a>1. 为什么要给约束起名字？</h3><p>在大型数据库中，一张表可能有几十个约束。如果你发现某条规则不再适用（比如学生年龄上限从 30 岁改成了 35 岁），如果你没有给它起名，你就很难单独删掉它，只能把整张表删掉重建。</p>
<p>通过命名子句，你可以实现：</p>
<ul>
<li><strong>精准定位</strong>：明确知道报错信息是指向哪一条具体规则。</li>
<li><strong>动态修改</strong>：可以在表创建好之后，通过名字随时删除或修改特定的约束。</li>
</ul>
<hr>
<h3 id="2-核心语法：CONSTRAINT"><a href="#2-核心语法：CONSTRAINT" class="headerlink" title="2. 核心语法：CONSTRAINT"></a>2. 核心语法：CONSTRAINT</h3><p>在 <code>CREATE TABLE</code> 语句中，你可以在具体的约束条件前加上 <code>CONSTRAINT</code> 关键字：</p>
<script type="math/tex; mode=display">\text{CONSTRAINT <完整性约束条件名> <完整性约束条件>}</script><p>这里的 <strong>“完整性约束条件”</strong> 包括我们学过的：</p>
<ul>
<li><code>NOT NULL</code>（非空）</li>
<li><code>UNIQUE</code>（唯一）</li>
<li><code>PRIMARY KEY</code> 短语（主码）</li>
<li><code>FOREIGN KEY</code> 短语（外码）</li>
<li><code>CHECK</code> 短语（检查条件）</li>
</ul>
<hr>
<h3 id="3-实战案例解析"><a href="#3-实战案例解析" class="headerlink" title="3. 实战案例解析"></a>3. 实战案例解析</h3><p>我们来看课件中的这个典型例子：建立学生登记表 <code>Student</code>，并为每个限制命名。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student (</span><br><span class="line">    Sno   NUMERIC(6) </span><br><span class="line">          CONSTRAINT C1 CHECK (Sno BETWEEN 000 AND 999), /* 约束命名为 C1 */</span><br><span class="line">    Sname CHAR(20) </span><br><span class="line">          CONSTRAINT C2 NOT NULL,                       /* 约束命名为 C2 */</span><br><span class="line">    Sage  NUMERIC(3) </span><br><span class="line">          CONSTRAINT C3 CHECK (Sage &lt; 30),              /* 约束命名为 C3 */</span><br><span class="line">    Ssex  CHAR(2) </span><br><span class="line">          CONSTRAINT C4 CHECK (Ssex IN (&#x27;男&#x27;, &#x27;女&#x27;)),   /* 约束命名为 C4 */</span><br><span class="line">    CONSTRAINT StudentKey PRIMARY KEY(Sno)              /* 主码约束命名为 StudentKey */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="逻辑点拨："><a href="#逻辑点拨：" class="headerlink" title="逻辑点拨："></a>逻辑点拨：</h4><ol>
<li><strong>学号范围</strong>：通过 <code>C1</code> 确保学号在 000 到 999 之间。</li>
<li><strong>姓名必填</strong>：通过 <code>C2</code> 确保姓名不为空。</li>
<li><strong>年龄限制</strong>：通过 <code>C3</code> 强制要求学生必须小于 30 岁。</li>
<li><strong>性别限制</strong>：通过 <code>C4</code> 限制性别只能在“男”和“女”中二选一。</li>
<li><strong>主键标识</strong>：通过 <code>StudentKey</code> 唯一标识每一条学生记录。</li>
</ol>
<hr>
<h3 id="4-这种命名有什么后续好处？"><a href="#4-这种命名有什么后续好处？" class="headerlink" title="4. 这种命名有什么后续好处？"></a>4. 这种命名有什么后续好处？</h3><p>如果你以后想取消“年龄必须小于 30 岁”这个限制，你不需要大动干戈，只需一条命令：</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Student DROP CONSTRAINT C3;</span><br></pre></td></tr></table></figure>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="1-什么是触发器？"><a href="#1-什么是触发器？" class="headerlink" title="1. 什么是触发器？"></a>1. 什么是触发器？</h3><p>触发器是用户定义在关系表上的一类由<strong>事件驱动</strong>的特殊过程。</p>
<ul>
<li><strong>自动激活</strong>：任何用户对表进行的“增（INSERT）、删（DELETE）、改（UPDATE）”操作，都会由服务器自动激活相应的触发器。</li>
<li><strong>功能强大</strong>：它可以实施比普通 <code>CHECK</code> 约束更复杂的检查和操作，具有更精细的数据控制能力。</li>
<li><strong>存储位置</strong>：触发器保存在数据库服务器中。</li>
</ul>
<hr>
<h3 id="2-触发器的“三要素”：事件-条件-动作"><a href="#2-触发器的“三要素”：事件-条件-动作" class="headerlink" title="2. 触发器的“三要素”：事件-条件-动作"></a>2. 触发器的“三要素”：事件-条件-动作</h3><p>触发器也被称为 <strong>事件-条件-动作（event-condition-action）规则</strong>。</p>
<ul>
<li><strong>事件（Event）</strong>：触发的开关。包括 <code>INSERT</code>、<code>DELETE</code> 或 <code>UPDATE</code>。</li>
<li><strong>条件（Condition）</strong>：触发的门槛。由 <code>WHEN &lt;触发条件&gt;</code> 指定，只有满足该条件时，动作才会执行。</li>
<li><strong>动作（Action）</strong>：触发的结果。由 <code>&lt;触发动作体&gt;</code> 指定，通常是一段 SQL 程序段。</li>
</ul>
<h2 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h2><h3 id="1-触发器定义的语法核心"><a href="#1-触发器定义的语法核心" class="headerlink" title="1. 触发器定义的语法核心"></a>1. 触发器定义的语法核心</h3><p>根据语法格式，一个完整的触发器定义包含以下核心要素：</p>
<script type="math/tex; mode=display">\text{CREATE TRIGGER <触发器名>}</script><script type="math/tex; mode=display">\text{\{BEFORE | AFTER\} <触发事件> ON <表名>}</script><script type="math/tex; mode=display">\text{REFERENCING corr\_name\_def}</script><script type="math/tex; mode=display">\text{FOR EACH \{ROW | STATEMENT\}}</script><script type="math/tex; mode=display">\text{[WHEN <触发条件>] <触发动作体>}</script><h4 id="关键参数拆解："><a href="#关键参数拆解：" class="headerlink" title="关键参数拆解："></a>关键参数拆解：</h4><ul>
<li><strong>触发器名</strong>：在同一模式下必须是唯一的。</li>
<li><strong>触发时机</strong>：<ul>
<li><strong><code>BEFORE</code></strong>：在操作执行<strong>之前</strong>激活，常用于检查或修改即将插入的数据。</li>
<li><strong><code>AFTER</code></strong>：在操作执行<strong>之后</strong>激活，常用于跨表同步或日志记录。</li>
</ul>
</li>
<li><strong>触发事件</strong>：可以是 <code>INSERT</code>、<code>DELETE</code> 或 <code>UPDATE</code>，也可以是它们的组合。</li>
<li><strong>触发频率</strong>：<ul>
<li><strong><code>FOR EACH ROW</code>（行级）</strong>：每影响一行，触发器就执行一次。</li>
<li><strong><code>FOR EACH STATEMENT</code>（语句级）</strong>：无论影响多少行，整个 SQL 语句只触发一次。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-定义时的重要限制"><a href="#2-定义时的重要限制" class="headerlink" title="2. 定义时的重要限制"></a>2. 定义时的重要限制</h3><p>在动手编写之前，有几个“红线”需要遵守：</p>
<ol>
<li><strong>对象限制</strong>：触发器只能定义在<strong>基本表</strong>上，不能定义在视图（View）上。</li>
<li><strong>权限要求</strong>：只有表的<strong>拥有者</strong>才有权在该表上创建触发器。</li>
<li><strong>引用变量</strong>：可以使用 <code>REFERENCING</code> 来引用修改前的数据（OLD）和修改后的数据（NEW），以便在动作体中使用。</li>
</ol>
<hr>
<h3 id="3-实战模拟：定义一个简单的触发器"><a href="#3-实战模拟：定义一个简单的触发器" class="headerlink" title="3. 实战模拟：定义一个简单的触发器"></a>3. 实战模拟：定义一个简单的触发器</h3><p>假设我们要定义一个触发器：<strong>当有新学生插入 <code>Student</code> 表时，如果他的年龄超过 100 岁，则自动将其改为 18 岁（防止异常数据）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER Check_Age_Trigger</span><br><span class="line">BEFORE INSERT ON Student            /* 触发时机：插入前 */</span><br><span class="line">FOR EACH ROW                        /* 触发频率：行级 */</span><br><span class="line">BEGIN</span><br><span class="line">    IF (NEW.Sage &gt; 100) THEN        /* 触发条件 */</span><br><span class="line">        SET NEW.Sage = 18;          /* 触发动作 */</span><br><span class="line">    END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h2 id="关系模式（Relational-Schema）"><a href="#关系模式（Relational-Schema）" class="headerlink" title="关系模式（Relational Schema）"></a>关系模式（Relational Schema）</h2><h3 id="1-关系模式的数学定义"><a href="#1-关系模式的数学定义" class="headerlink" title="1. 关系模式的数学定义"></a>1. 关系模式的数学定义</h3><p>根据课件，关系模式由五部分组成，数学上可以用一个五元组来表示：</p>
<script type="math/tex; mode=display">R(U, D, DOM, F)</script><p>这五个符号分别代表了设计一张表时需要考虑的核心维度：</p>
<ul>
<li><strong>$R$ (关系名)</strong>：符号化的<strong>元组语义</strong>，即给这张表起个名字（如 <code>Student</code> 或 <code>Teacher</code>）。</li>
<li><strong>$U$ (属性组)</strong>：该关系包含的一组<strong>属性</strong>（列名），比如学生表里的学号、姓名、年龄。</li>
<li><strong>$D$ (域)</strong>：属性组 $U$ 中的属性所来自的<strong>域</strong>（即数据类型的取值范围）。</li>
<li><strong>$DOM$ (映射)</strong>：属性到域的<strong>映射</strong>，即指定每一列具体属于哪个数据类型。</li>
<li><strong>$F$ (数据依赖)</strong>：属性组 $U$ 上的一组<strong>数据依赖</strong>。这是进行<strong>逻辑设计和数据库规范化（范式理论）的关键</strong>。</li>
</ul>
<hr>
<h3 id="2-为什么-F-（数据依赖）最重要？"><a href="#2-为什么-F-（数据依赖）最重要？" class="headerlink" title="2. 为什么 $F$（数据依赖）最重要？"></a>2. 为什么 $F$（数据依赖）最重要？</h3><p>在定义中特别强调了：<strong>“如何进行逻辑设计的关键”在于 $F$</strong>。</p>
<ul>
<li><strong>数据依赖</strong>描述了属性之间内在的逻辑联系。</li>
<li>最常见的是<strong>函数依赖（Functional Dependency）</strong>。例如：在学生表中，一旦知道了“学号”，就能唯一确定“姓名”。这种“学号 $\rightarrow$ 姓名”的关系就是一种依赖。</li>
<li>如果 $F$ 设计得不好，数据库就会出现<strong>数据冗余、更新异常、删除异常</strong>等一系列问题。</li>
</ul>
<h2 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h2><h3 id="1-完全函数依赖-Full-Functional-Dependency"><a href="#1-完全函数依赖-Full-Functional-Dependency" class="headerlink" title="1. 完全函数依赖 (Full Functional Dependency)"></a>1. 完全函数依赖 (Full Functional Dependency)</h3><p><strong>定义</strong>：在关系模式 $R(U)$ 中，如果 $X \rightarrow Y$，并且对于 $X$ 的<strong>任何一个真子集</strong> $X’$，都有 $X’ \nrightarrow Y$，则称 $Y$ 对 $X$ 完全函数依赖。</p>
<ul>
<li><strong>记作</strong>：$X \xrightarrow{F} Y$。</li>
<li><strong>直白解释</strong>：$Y$ 的确定必须依靠 $X$ 中的<strong>所有</strong>属性，缺一不可。</li>
<li><strong>例子</strong>：在选课表 <code>(学号, 课名, 成绩)</code> 中：<ul>
<li><code>(学号, 课名) → 成绩</code> 是完全函数依赖。</li>
<li>因为只知道“学号”不能定成绩，只知道“课名”也不能定成绩，必须两者结合。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-部分函数依赖-Partial-Functional-Dependency"><a href="#2-部分函数依赖-Partial-Functional-Dependency" class="headerlink" title="2. 部分函数依赖 (Partial Functional Dependency)"></a>2. 部分函数依赖 (Partial Functional Dependency)</h3><p><strong>定义</strong>：如果 $X \rightarrow Y$，但 $Y$ <strong>不完全</strong>函数依赖于 $X$，则称 $Y$ 对 $X$ 部分函数依赖。</p>
<ul>
<li><strong>条件</strong>：这意味着存在 $X$ 的某个真子集 $X’$，使得 $X’ \rightarrow Y$ 成立。</li>
<li><strong>记作</strong>：$X \xrightarrow{P} Y$。</li>
<li><strong>直白解释</strong>：$Y$ 虽然名义上由组合 $X$ 决定，但实际上只需要 $X$ 里的<strong>一部分</strong>属性就能定下来。</li>
<li><strong>例子</strong>：在选课表 <code>(学号, 课名, 学生姓名)</code> 中：<ul>
<li><code>(学号, 课名) → 学生姓名</code> 是部分函数依赖。</li>
<li>因为只要知道“学号”就能确定“学生姓名”了，那个“课名”在决定姓名时是多余的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么区分它们很重要？"><a href="#3-为什么区分它们很重要？" class="headerlink" title="3. 为什么区分它们很重要？"></a>3. 为什么区分它们很重要？</h3><p><strong>部分函数依赖是导致数据库“病态”的元凶</strong>：</p>
<ul>
<li><strong>数据冗余</strong>：如果在选课表里有部分依赖，那么每选一门课，就要重复存一次学生姓名。</li>
<li><strong>逻辑设计目标</strong>：逻辑设计的关键就是通过模式分解，<strong>消除非主属性对码的部分函数依赖</strong>。</li>
</ul>
<h2 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h2><h3 id="1-严格定义与前提条件"><a href="#1-严格定义与前提条件" class="headerlink" title="1. 严格定义与前提条件"></a>1. 严格定义与前提条件</h3><p>在关系模式 $R(U)$ 中，如果满足以下三个条件，则称 <strong>$Z$ 对 $X$ 传递函数依赖</strong>，记为 $X \xrightarrow{T} Z$：</p>
<ol>
<li><strong>$X \rightarrow Y$ 且 $Y \not\subseteq X$</strong>：$X$ 能唯一确定 $Y$，且这是一个非平凡依赖。</li>
<li><strong>$Y \nrightarrow X$</strong>：这是<strong>关键前提</strong>。$Y$ 不能反向唯一确定 $X$（即它们不互为函数依赖）。</li>
<li><strong>$Y \rightarrow Z$ 且 $Z \not\subseteq Y$</strong>：$Y$ 又能唯一确定 $Z$。</li>
</ol>
<p><strong>⚠️ 特别注意：</strong> 如果 $Y \rightarrow X$ 成立（即 $X \longleftrightarrow Y$），那么根据逻辑推导，$Z$ 实际上是<strong>直接</strong>依赖于 $X$ 的，这种情况下就不算“传递”依赖了。</p>
<hr>
<h3 id="2-实例分析：学生、系与系主任的关系"><a href="#2-实例分析：学生、系与系主任的关系" class="headerlink" title="2. 实例分析：学生、系与系主任的关系"></a>2. 实例分析：学生、系与系主任的关系</h3><p>通过关系模式 <code>Std(Sno, Sdept, Mname)</code>（学号, 系名, 系主任姓名）来理解：</p>
<ul>
<li><strong>第一步</strong>：<strong>$Sno \rightarrow Sdept$</strong>。一个学号唯一对应一个系。</li>
<li><strong>第二步</strong>：<strong>$Sdept \nrightarrow Sno$</strong>。一个系有很多学生，仅凭系名查不到唯一的学号。</li>
<li><strong>第三步</strong>：<strong>$Sdept \rightarrow Mname$</strong>。假设一个系只有一个系主任，那么系名决定了系主任姓名。</li>
<li><strong>结论</strong>：因为学号定了系，系又定了主任，所以 <strong>$Mname$ 传递函数依赖于 $Sno$</strong>。</li>
</ul>
<hr>
<h3 id="3-为什么我们要警惕“传递依赖”？"><a href="#3-为什么我们要警惕“传递依赖”？" class="headerlink" title="3. 为什么我们要警惕“传递依赖”？"></a>3. 为什么我们要警惕“传递依赖”？</h3><p>传递依赖是导致数据库<strong>冗余</strong>和<strong>更新异常</strong>的另一个元凶：</p>
<ul>
<li><strong>数据冗余</strong>：同一个系的 500 个学生，在表里就要重复记录 500 次该系的系主任姓名。</li>
<li><strong>更新异常</strong>：如果该系换了主任，你需要修改 500 条记录，否则数据就会不一致。</li>
<li><strong>设计规范</strong>：逻辑设计的进阶目标是进入 <strong>3NF（第三范式）</strong>，其核心要求就是：<strong>消除非主属性对码的传递函数依赖</strong>。</li>
</ul>
<h2 id="码（Key）"><a href="#码（Key）" class="headerlink" title="码（Key）"></a>码（Key）</h2><h3 id="1-候选码-Candidate-Key"><a href="#1-候选码-Candidate-Key" class="headerlink" title="1. 候选码 (Candidate Key)"></a>1. 候选码 (Candidate Key)</h3><p>这是最基础的“码”定义。</p>
<ul>
<li><strong>定义</strong>：设 $K$ 为关系模式 $R<U,F>$ 中的属性或属性组合。若 $U$ 对 $K$ <strong>完全函数依赖</strong> ($K \xrightarrow{F} U$)，则称 $K$ 为候选码。</U,F></li>
<li><strong>通俗理解</strong>：<ul>
<li><strong>唯一性</strong>：通过 $K$ 能确定表中所有的其他属性。</li>
<li><strong>最小性</strong>：$K$ 中没有任何一个属性是多余的。如果去掉其中任何一个属性，它就无法再唯一确定所有属性了。</li>
</ul>
</li>
<li><strong>例子</strong>：在选课表 $SC$ 中，<code>(Sno, Cno)</code>（学号和课号组合）就是一个候选码。</li>
</ul>
<h3 id="2-超码-Superkey"><a href="#2-超码-Superkey" class="headerlink" title="2. 超码 (Superkey)"></a>2. 超码 (Superkey)</h3><ul>
<li><strong>定义</strong>：如果 $U$ 对 $K$ 只是<strong>部分函数依赖</strong> ($K \xrightarrow{P} U$)，则 $K$ 称为超码。</li>
<li><strong>理解</strong>：超码包含候选码，但可能含有多余的属性。<ul>
<li>候选码的任意超集一定是超码。</li>
<li>但候选码的真子集一定不是超码，也不是候选码。</li>
</ul>
</li>
</ul>
<h3 id="3-主码-Primary-Key"><a href="#3-主码-Primary-Key" class="headerlink" title="3. 主码 (Primary Key)"></a>3. 主码 (Primary Key)</h3><ul>
<li><strong>定义</strong>：若一个关系模式 $R$ 有多个候选码，则选定其中的<strong>一个</strong>作为主码。</li>
<li><strong>作用</strong>：在实际数据库操作（如 SQL 编程）中，主码是系统用来区分不同记录的首要依据。</li>
</ul>
<h3 id="1-外码的严格定义"><a href="#1-外码的严格定义" class="headerlink" title="1. 外码的严格定义"></a>1. 外码的严格定义</h3><p>根据定义 6.5，如果关系模式 $R$ 中的属性或属性组 $X$ 满足以下两个条件，则称 $X$ 是 $R$ 的<strong>外码</strong>：</p>
<ol>
<li>$X$ <strong>不是</strong>当前关系模式 $R$ 的码。</li>
<li>$X$ 是<strong>另一个</strong>关系模式的码。</li>
</ol>
<hr>
<h3 id="4-属性的分类：主属性-vs-非主属性"><a href="#4-属性的分类：主属性-vs-非主属性" class="headerlink" title="4. 属性的分类：主属性 vs 非主属性"></a>4. 属性的分类：主属性 vs 非主属性</h3><p>根据属性是否包含在码中，我们可以对表中的列进行归类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>定义</strong></th>
<th><strong>形象理解</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>主属性 (Prime attribute)</strong></td>
<td>包含在<strong>任何一个</strong>候选码中的属性。</td>
<td>它是“身份证号”的组成部分。</td>
</tr>
<tr>
<td><strong>非主属性 (Nonprime attribute)</strong></td>
<td>不包含在任何码中的属性。又称非码属性。</td>
<td>它是被身份证号决定的“姓名、地址”等。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="范式（Normal-Form-NF）"><a href="#范式（Normal-Form-NF）" class="headerlink" title="范式（Normal Form, NF）"></a>范式（Normal Form, NF）</h2><h3 id="1-范式的种类与关系"><a href="#1-范式的种类与关系" class="headerlink" title="1. 范式的种类与关系"></a>1. 范式的种类与关系</h3><p>关系数据库中的关系必须满足一定的要求。满足不同程度要求的被称为不同范式。主要分为以下六个级别：</p>
<ul>
<li><strong>第一范式 (1NF)</strong>：最基础的要求。</li>
<li><strong>第二范式 (2NF)</strong></li>
<li><strong>第三范式 (3NF)</strong></li>
<li><strong>BC范式 (BCNF)</strong></li>
<li><strong>第四范式 (4NF)</strong></li>
<li><strong>第五范式 (5NF)</strong></li>
</ul>
<p>这些范式之间存在包含关系，就像俄罗斯套娃一样：</p>
<script type="math/tex; mode=display">1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF</script><p>这意味着：如果一个关系模式是 3NF，那它一定也是 2NF 和 1NF。</p>
<hr>
<h3 id="2-什么是“规范化（Normalization）”？"><a href="#2-什么是“规范化（Normalization）”？" class="headerlink" title="2. 什么是“规范化（Normalization）”？"></a>2. 什么是“规范化（Normalization）”？</h3><p>规范化是一个将低一级范式的关系模式，通过<strong>模式分解</strong>，转换为若干个高一级范式的关系模式的集合的过程。</p>
<ul>
<li><strong>目的</strong>：消除数据冗余、更新异常、插入异常和删除异常。</li>
<li><strong>手段</strong>：利用我们之前学的函数依赖（如消除部分函数依赖、传递函数依赖）来拆分表格。</li>
</ul>
<h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><h3 id="1-1NF-的核心定义"><a href="#1-1NF-的核心定义" class="headerlink" title="1. 1NF 的核心定义"></a>1. 1NF 的核心定义</h3><p><strong>第一范式（1NF）</strong>规定：<strong>关系中的每一个属性（列）都必须是不可再分的原子项</strong>。</p>
<p>通俗地说，就是：<strong>每一个格子（单元格）里只能放一个单一的值，不能再套一个小表，也不能放一组数据。</strong></p>
<hr>
<h3 id="2-什么样的设计违反了-1NF？"><a href="#2-什么样的设计违反了-1NF？" class="headerlink" title="2. 什么样的设计违反了 1NF？"></a>2. 什么样的设计违反了 1NF？</h3><p>让我们看一个典型的反面教材。假设我们设计一张“学生联系方式表”：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>学号</strong></th>
<th><strong>姓名</strong></th>
<th><strong>联系方式 (违反 1NF)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>张三</td>
<td>电话: 138…; 邮箱: zhang@…</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>电话: 139…; 邮箱: li@…</td>
</tr>
</tbody>
</table>
</div>
<p><strong>为什么它不符合 1NF？</strong></p>
<ul>
<li>因为“联系方式”这一列<strong>可再分</strong>。它同时包含了电话和邮箱两个信息。</li>
<li>如果你想查询所有使用“138”号段的学生，数据库引擎会非常痛苦，因为它得去解析这个字符串内部的逻辑。</li>
</ul>
<hr>
<h3 id="3-如何将其规范化为-1NF？"><a href="#3-如何将其规范化为-1NF？" class="headerlink" title="3. 如何将其规范化为 1NF？"></a>3. 如何将其规范化为 1NF？</h3><p>我们需要把“联系方式”拆解开，确保每一列都是纯粹、单一的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>学号</strong></th>
<th><strong>姓名</strong></th>
<th><strong>电话</strong></th>
<th><strong>邮箱</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>张三</td>
<td>138…</td>
<td>zhang@…</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>139…</td>
<td>li@…</td>
</tr>
</tbody>
</table>
</div>
<p>此时，每一个属性都是<strong>原子性</strong>的，满足了 1NF 的要求。</p>
<hr>
<h3 id="4-1NF-存在的问题（为什么要追求更高级的范式？）"><a href="#4-1NF-存在的问题（为什么要追求更高级的范式？）" class="headerlink" title="4. 1NF 存在的问题（为什么要追求更高级的范式？）"></a>4. 1NF 存在的问题（为什么要追求更高级的范式？）</h3><p>虽然 1NF 解决了“数据能不能存”的问题，但它还没有解决“存得好不好”的问题。正如你之前看过的例子：</p>
<ul>
<li><strong>数据冗余</strong>：如果学号、姓名、课程、成绩都在一张 1NF 表里，姓名会重复出现很多次。</li>
<li><strong>异常风险</strong>：修改一个人的姓名可能要改几十行。</li>
</ul>
<h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><h3 id="1-第二范式（2NF）的定义"><a href="#1-第二范式（2NF）的定义" class="headerlink" title="1. 第二范式（2NF）的定义"></a>1. 第二范式（2NF）的定义</h3><p><strong>定义</strong>：若关系模式 $R \in 1NF$，且每一个非主属性都<strong>完全函数依赖</strong>于任何一个候选码，则 $R \in 2NF$。</p>
<p><strong>通俗解释</strong>：</p>
<ul>
<li>首先，它必须满足 1NF。</li>
<li>其次，表里的每一列（非主属性），都必须依赖于<strong>主键的全集</strong>。</li>
<li><strong>核心目标</strong>：消除<strong>部分函数依赖</strong>。</li>
</ul>
<hr>
<h3 id="2-为什么要-2NF？（通过“反面教材”理解）"><a href="#2-为什么要-2NF？（通过“反面教材”理解）" class="headerlink" title="2. 为什么要 2NF？（通过“反面教材”理解）"></a>2. 为什么要 2NF？（通过“反面教材”理解）</h3><p>让我们看一个经典的违反 2NF 的选课关系模式 $SLC$：</p>
<p>$SLC(\text{Sno, Cno, Grade, Sdept, Sloc})$</p>
<p>（学号, 课程号, 成绩, 所在系, 学生住处）</p>
<ul>
<li><p>第一步：找码。</p>
<p>业务逻辑：一个学生选一门课才有成绩。所以码是 $(Sno, Cno)$。</p>
</li>
<li><p><strong>第二步：分析依赖关系</strong>。</p>
<ol>
<li>$(Sno, Cno) \rightarrow Grade$ （成绩必须靠学号+课号，这是<strong>完全依赖</strong>）。</li>
<li>$Sno \rightarrow Sdept$ （系只跟人走，跟课程无关，这是<strong>部分依赖</strong>）。</li>
<li>$Sno \rightarrow Sloc$ （住处也只跟人走，这是<strong>部分依赖</strong>）。</li>
</ol>
</li>
</ul>
<p><strong>结论</strong>：因为存在非主属性（Sdept, Sloc）对码（Sno, Cno）的<strong>部分函数依赖</strong>，所以它<strong>不属于 2NF</strong>。</p>
<hr>
<h3 id="3-不满足-2NF-会有什么恶果？"><a href="#3-不满足-2NF-会有什么恶果？" class="headerlink" title="3. 不满足 2NF 会有什么恶果？"></a>3. 不满足 2NF 会有什么恶果？</h3><p>这种“大杂烩”表会导致四个典型问题：</p>
<ol>
<li><strong>数据冗余</strong>：张三选了 10 门课，他的系名和住处就要存 10 遍。</li>
<li><strong>更新异常</strong>：张三搬家了，你得去改 10 行记录，漏了一行数据就不一致。</li>
<li><strong>插入异常</strong>：一个新同学刚入学，还没选课（没 Cno），因为码的一部分为空，他的系和住处信息存不进去。</li>
<li><strong>删除异常</strong>：某同学只选了一门课，由于课程取消删除了记录，结果这个同学的学籍信息（系、住处）也跟着消失了。</li>
</ol>
<hr>
<h3 id="4-规范化：如何变成-2NF？"><a href="#4-规范化：如何变成-2NF？" class="headerlink" title="4. 规范化：如何变成 2NF？"></a>4. 规范化：如何变成 2NF？</h3><p>解决办法就是<strong>“模式分解”</strong>。我们将表一分为二，让不同的事实待在不同的表里：</p>
<ul>
<li><strong>表 A (选课表)</strong>：$(Sno, Cno, Grade)$<ul>
<li>此时码是 $(Sno, Cno)$，成绩完全依赖于码。<strong>符合 2NF</strong>。</li>
</ul>
</li>
<li><strong>表 B (学生信息表)</strong>：$(Sno, Sdept, Sloc)$<ul>
<li>此时码是 $Sno$，系和住处完全依赖于 $Sno$。<strong>符合 2NF</strong>。</li>
</ul>
</li>
</ul>
<h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><h3 id="1-第三范式（3NF）的严格定义"><a href="#1-第三范式（3NF）的严格定义" class="headerlink" title="1. 第三范式（3NF）的严格定义"></a>1. 第三范式（3NF）的严格定义</h3><p><strong>定义 6.7</strong>：设关系模式 $R<U,F> \in 1NF$，若 $R$ 中不存在这样的码 $X$、属性组 $Y$ 及非主属性 $Z$（$Z \not\subseteq Y$），使得 $X \rightarrow Y$，$Y \rightarrow Z$ 成立，且 $Y \not\rightarrow X$，则称 $R \in 3NF$。</U,F></p>
<p><strong>通俗解释</strong>：</p>
<ul>
<li>首先，它必须满足 1NF（进阶要求通常也包含满足 2NF）。</li>
<li>其次，<strong>非主属性之间不能有“连环套”</strong>。即：不能让码先决定一个中间人 $Y$，再由 $Y$ 决定非主属性 $Z$。</li>
<li>一句话总结：<strong>任何非主属性都必须直接依赖于码，不能“间接”依赖</strong>。</li>
</ul>
<hr>
<h3 id="2-实例分析：为什么-S-L-不符合-3NF？"><a href="#2-实例分析：为什么-S-L-不符合-3NF？" class="headerlink" title="2. 实例分析：为什么 S-L 不符合 3NF？"></a>2. 实例分析：为什么 S-L 不符合 3NF？</h3><p>在之前的分解中，我们得到了学生表 <strong>S-L(Sno, Sdept, Sloc)</strong>（学号, 所在系, 住处）：</p>
<ol>
<li><strong>路径</strong>：$Sno \rightarrow Sdept$（学号决定系），且 $Sdept \rightarrow Sloc$（系决定住处）。</li>
<li><strong>判定</strong>：这里 $Sdept$ 不是码，但它决定了另一个非主属性 $Sloc$。因此，<strong>$Sloc$ 对 $Sno$ 存在传递依赖</strong>。</li>
<li><strong>结果</strong>：S-L 虽然满足 2NF，但不满足 3NF。这会导致我们之前讨论的“换系主任/住处要改全表”等冗余问题。</li>
</ol>
<hr>
<h3 id="3-规范化处理：迈向-3NF"><a href="#3-规范化处理：迈向-3NF" class="headerlink" title="3. 规范化处理：迈向 3NF"></a>3. 规范化处理：迈向 3NF</h3><p>解决办法依然是<strong>模式分解</strong>。我们要把那个“中间人” $Y$（即 $Sdept$）提取出来，单独建表：</p>
<ul>
<li><strong>表 1：S-D(Sno, Sdept)</strong><ul>
<li>学号决定所在的系。</li>
<li>非主属性直接依赖于码，满足 3NF。</li>
</ul>
</li>
<li><strong>表 2：D-L(Sdept, Sloc)</strong><ul>
<li>系决定所在的住处。</li>
<li>非主属性直接依赖于码，满足 3NF。</li>
</ul>
</li>
</ul>
<h2 id="2NF-升级到-3NF举例"><a href="#2NF-升级到-3NF举例" class="headerlink" title="2NF 升级到 3NF举例"></a><strong>2NF 升级到 3NF</strong>举例</h2><h3 id="1-现状分析：为什么是-2NF-但不是-3NF？"><a href="#1-现状分析：为什么是-2NF-但不是-3NF？" class="headerlink" title="1. 现状分析：为什么是 2NF 但不是 3NF？"></a>1. 现状分析：为什么是 2NF 但不是 3NF？</h3><p>关系模式为 $F={Sno, Sage, Ssex, Sdept, Mname}$。</p>
<ul>
<li><strong>它是 2NF</strong>：因为码是单属性 <strong>$Sno$</strong>，不存在“非主属性只依赖主键一部分”的情况。所有非主属性都<strong>完全函数依赖</strong>于 $Sno$。</li>
<li><strong>它不是 3NF</strong>：因为存在<strong>传递函数依赖</strong>。<ul>
<li>$Sno \rightarrow Sdept$ （学号确定所在的系）。</li>
<li>$Sdept \rightarrow Mname$ （系确定该系的系主任）。</li>
<li>由于系主任是通过“系”这个中间环节间接被学号确定的，即 <strong>$Sno \xrightarrow{T} Mname$</strong>，这违反了 3NF 关于“消除传递依赖”的规定。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-存在的问题：不规范带来的麻烦"><a href="#2-存在的问题：不规范带来的麻烦" class="headerlink" title="2. 存在的问题：不规范带来的麻烦"></a>2. 存在的问题：不规范带来的麻烦</h3><p>如你之前所见，这种设计会导致：</p>
<ul>
<li><strong>数据冗余</strong>：同一个系有多少学生，系主任的名字就要存多少遍。</li>
<li><strong>操作异常</strong>：想存一个没有学生的新系及其主任却存不进去（插入异常）；删掉某个系的最后一个学生，主任信息也没了（删除异常）。</li>
</ul>
<hr>
<h3 id="3-解决方案：模式分解（迈向-3NF）"><a href="#3-解决方案：模式分解（迈向-3NF）" class="headerlink" title="3. 解决方案：模式分解（迈向 3NF）"></a>3. 解决方案：模式分解（迈向 3NF）</h3><p>为了达到 3NF，我们需要把这个“连环套”解开，将原表拆分为两个独立的关系模式：</p>
<ul>
<li><strong>表 1：学生表 $F={Sno, Sage, Ssex, Sdept}$</strong><ul>
<li>此时，每个非主属性（年龄、性别、系别）都<strong>直接</strong>依赖于码 $Sno$。</li>
<li>不存在非主属性之间的相互依赖。<strong>符合 3NF</strong>。</li>
</ul>
</li>
<li><strong>表 2：系部表 $D={Sdept, Mname}$</strong><ul>
<li>此时，码变成了 <strong>$Sdept$</strong>。</li>
<li>系主任 $Mname$ 直接依赖于其所在的系。<strong>符合 3NF</strong>。</li>
</ul>
</li>
</ul>
<h2 id="BCNF（Boyce-Codd-Normal-Form，BC-范式）"><a href="#BCNF（Boyce-Codd-Normal-Form，BC-范式）" class="headerlink" title="BCNF（Boyce Codd Normal Form，BC 范式）"></a>BCNF（Boyce Codd Normal Form，BC 范式）</h2><h3 id="1-BCNF-的核心定义"><a href="#1-BCNF-的核心定义" class="headerlink" title="1. BCNF 的核心定义"></a>1. BCNF 的核心定义</h3><p>一个关系模式 $R \in BCNF$ 的充要条件是：在任何非平凡的函数依赖 $X \rightarrow Y$ 中，<strong>$X$ 必须含有码（即 $X$ 是超码）</strong>。</p>
<ul>
<li><strong>通俗理解</strong>：在表里的每一个函数依赖中，<strong>箭头左边的“决定因素”必须是候选码</strong>。</li>
<li><strong>大白话口号</strong>：<strong>“只有主键才有权决定别人！”</strong> 如果一个不是主键的属性组（哪怕它包含主属性）能决定别人，就不符合 BCNF。</li>
</ul>
<hr>
<h3 id="2-为什么需要-BCNF？（对比-3NF）"><a href="#2-为什么需要-BCNF？（对比-3NF）" class="headerlink" title="2. 为什么需要 BCNF？（对比 3NF）"></a>2. 为什么需要 BCNF？（对比 3NF）</h3><p>3NF 的标准相对宽松：它只要求非主属性不能部分或传递依赖于码。</p>
<p>但是，3NF 允许以下情况存在：</p>
<ul>
<li><strong>主属性</strong>对码的部分函数依赖。</li>
<li><strong>主属性</strong>对码的传递函数依赖。</li>
</ul>
<p>这些主属性之间的“勾结”依然会引发数据冗余和操作异常。而 BCNF 排除了<strong>任何属性</strong>（无论主属性还是非主属性）对码的部分或传递依赖。</p>
<hr>
<h3 id="3-BCNF-的性质"><a href="#3-BCNF-的性质" class="headerlink" title="3. BCNF 的性质"></a>3. BCNF 的性质</h3><p>如果一个关系模式达到了 BCNF，它必然具备以下特征：</p>
<ol>
<li><strong>满足 3NF 的所有要求</strong>：所有非主属性都完全且直接地依赖于每个候选码。</li>
<li><strong>主属性也“干净”</strong>：所有主属性都完全函数依赖于每个不包含它的候选码。</li>
<li><strong>决定因素必为码</strong>：没有任何属性依赖于非码的任何属性组。</li>
</ol>
<hr>
<h3 id="4-判定-BCNF-的实战技巧"><a href="#4-判定-BCNF-的实战技巧" class="headerlink" title="4. 判定 BCNF 的实战技巧"></a>4. 判定 BCNF 的实战技巧</h3><p>判定一个表是否符合 BCNF，可以遵循以下三个步骤：</p>
<ol>
<li><strong>找出所有候选码</strong>。</li>
<li><strong>列出所有的函数依赖 $X \rightarrow Y$</strong>。</li>
<li><strong>检查左侧</strong>：看每一个依赖的左侧 $X$ 是否都是候选码？<ul>
<li><strong>是</strong> $\rightarrow$ 符合 BCNF。</li>
<li><strong>否</strong> $\rightarrow$ 只是 3NF（或更低），存在冗余隐患。</li>
</ul>
</li>
</ol>
<h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="1-核心直觉：独立的一对多"><a href="#1-核心直觉：独立的一对多" class="headerlink" title="1. 核心直觉：独立的一对多"></a>1. 核心直觉：独立的一对多</h3><p>回到你给出的 PPT 例子：<strong>Teaching(课程 C, 教师 T, 参考书 B)</strong>。</p>
<p>业务规则如下：</p>
<ul>
<li>一门课程可以由<strong>多个教师</strong>讲授。</li>
<li>一门课程使用<strong>一套（多个）参考书</strong>。</li>
<li><strong>关键点</strong>：谁来教这门课，和这门课用什么参考书，是<strong>完全无关</strong>的。</li>
</ul>
<hr>
<h3 id="2-为什么会有“依赖”？"><a href="#2-为什么会有“依赖”？" class="headerlink" title="2. 为什么会有“依赖”？"></a>2. 为什么会有“依赖”？</h3><p>虽然教师 $T$ 和参考书 $B$ 无关，但在数据库的一行记录里，你必须同时把它们写出来。为了表达“王老师教数据库”且“数据库课用《数据结构》书”，你得写一行。</p>
<p>但因为<strong>“老师”和“书”是独立的</strong>，数据库为了保证逻辑完整，必须穷举所有组合：</p>
<p>假设《数据库》有 2 名老师（张、李）和 2 本书（书A、书B），表里必须出现：</p>
<ol>
<li>(数据库, <strong>张</strong>, 书A)</li>
<li>(数据库, <strong>张</strong>, 书B)</li>
<li>(数据库, <strong>李</strong>, 书A)</li>
<li>(数据库, <strong>李</strong>, 书B)</li>
</ol>
<p><strong>这就是多值依赖：</strong> 给定一个课程 $C$，有一组老师 $T$ 与之对应，且这组 $T$ 的取值<strong>完全不受到</strong>参考书 $B$ 的影响。我们记作：$C \rightarrow\rightarrow T$ 和 $C \rightarrow\rightarrow B$。</p>
<hr>
<h3 id="3-多值依赖带来的麻烦"><a href="#3-多值依赖带来的麻烦" class="headerlink" title="3. 多值依赖带来的麻烦"></a>3. 多值依赖带来的麻烦</h3><p>这种依赖会导致严重的<strong>冗余</strong>和<strong>异常</strong>：</p>
<ul>
<li><strong>冗余</strong>：如果有 10 个老师和 10 本书，你得存 100 行数据。</li>
<li><strong>插入异常</strong>：如果《数据库》新聘请了一位“赵老师”，你不能只加一行。你必须为他配齐所有的参考书，插入多行记录。</li>
<li><strong>删除异常</strong>：如果你想取消《数据库》的一本参考书，你必须把所有老师关联的那本书记录全部删掉。</li>
</ul>
<hr>
<h3 id="4-判定与解决-第四范式-4NF"><a href="#4-判定与解决-第四范式-4NF" class="headerlink" title="4. 判定与解决 (第四范式 4NF)"></a>4. 判定与解决 (第四范式 4NF)</h3><p>判定：</p>
<p>如果一个表里存在多值依赖，且这个依赖的起始属性（左部）不是候选码，那么它就违反了 4NF。</p>
<p>在我们的例子中，候选码是全码 $(C, T, B)$，而 $C \rightarrow\rightarrow T$ 的左部只有 $C$，不是码。</p>
<p>解决方法：拆分（一事一表）</p>
<p>将这种“被迫组合”的关系拆开，变成两个独立的表：</p>
<ol>
<li><strong>CT 表 (课程, 教师)</strong>：只记录谁教什么。</li>
<li><strong>CB 表 (课程, 参考书)</strong>：只记录什么课用什么书。</li>
</ol>
<h2 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h2><h3 id="1-什么是-4NF？（核心定义）"><a href="#1-什么是-4NF？（核心定义）" class="headerlink" title="1. 什么是 4NF？（核心定义）"></a>1. 什么是 4NF？（核心定义）</h3><p>根据 PPT 的定义，一个关系模式 $R$ 满足 4NF 的条件是：</p>
<ul>
<li><strong>前提</strong>：必须先满足第一范式（1NF）。</li>
<li><strong>核心规则</strong>：对于 $R$ 的每个 <strong>非平凡多值依赖</strong> $X \rightarrow\rightarrow Y$，<strong>$X$ 都必须含有码（即 $X$ 必须是候选码）</strong>。</li>
</ul>
<p>简单来说：<strong>如果一个表里存在“一对多”的对应关系，这个“一”必须是该表的候选码</strong>。</p>
<hr>
<h3 id="2-为什么要搞出-4NF？（BCNF-的局限性）"><a href="#2-为什么要搞出-4NF？（BCNF-的局限性）" class="headerlink" title="2. 为什么要搞出 4NF？（BCNF 的局限性）"></a>2. 为什么要搞出 4NF？（BCNF 的局限性）</h3><p>很多时候我们以为达到 BCNF 就完美了，但看 PPT 中的这个例子：<strong>Teaching(课程 C, 教师 T, 参考书 B)</strong>。</p>
<ul>
<li><strong>它的情况</strong>：没有函数依赖，候选码是全码 $(C, T, B)$。</li>
<li><strong>范式级别</strong>：因为它没有不含码的函数依赖，所以它<strong>属于 BCNF</strong>。</li>
<li><strong>问题所在</strong>：虽然它是 BCNF，但依然存在严重的冗余。因为“教师”和“参考书”是<strong>互相独立</strong>的，但它们都得围着“课程”转。</li>
<li><strong>结论</strong>：这个表不满足 4NF，因为它存在多值依赖 $C \rightarrow\rightarrow T$ 和 $C \rightarrow\rightarrow B$，而左边的 <strong>$C$ 并不是码</strong>。</li>
</ul>
<hr>
<h3 id="3-理解“非平凡多值依赖”"><a href="#3-理解“非平凡多值依赖”" class="headerlink" title="3. 理解“非平凡多值依赖”"></a>3. 理解“非平凡多值依赖”</h3><p>PPT 提到 4NF 限制的是“非平凡且非函数依赖的多值依赖”。</p>
<ul>
<li><strong>平凡多值依赖</strong>：如果 $Y \subset X$ 或者 $X \cup Y = U$（全集），这种依赖是自然的，不引起冗余。</li>
<li><strong>非平凡多值依赖</strong>：像课程决定一组老师，这组老师和表里的其他东西（书）没关系。这种“各管各的一对多”强行凑在一起，就是灾难。</li>
</ul>
<hr>
<h3 id="4-4NF-的实际意义：消除“独立组合”"><a href="#4-4NF-的实际意义：消除“独立组合”" class="headerlink" title="4. 4NF 的实际意义：消除“独立组合”"></a>4. 4NF 的实际意义：消除“独立组合”</h3><p>4NF 的本质是要求：<strong>一个表里不准同时存在两类独立的“一对多”关系</strong>。</p>
<p>在 <code>Teaching(C, T, B)</code> 中：</p>
<ol>
<li>课程 $C$ 对应一组教师 $T$（第一个一对多）。</li>
<li>课程 $C$ 对应一组参考书 $B$（第二个一对多）。</li>
<li>$T$ 和 $B$ 没关系。</li>
</ol>
<p>为了满足 4NF，你必须把这个表<strong>“劈开”</strong>：</p>
<ul>
<li>表1：$(C, T)$ —— 专门记录课程有哪些老师。</li>
<li>表2：$(C, B)$ —— 专门记录课程有哪些参考书。</li>
</ul>
<hr>
<h3 id="5-总结-4NF-的特点"><a href="#5-总结-4NF-的特点" class="headerlink" title="5. 总结 4NF 的特点"></a>5. 总结 4NF 的特点</h3><ul>
<li><strong>包容性</strong>：如果一个模式是 4NF，那它<strong>必为 BCNF</strong>。</li>
<li><strong>针对性</strong>：4NF 删除了非主属性对候选码以外属性的多值依赖。</li>
<li><strong>直观理解</strong>：4NF 实现了真正的<strong>“一事一表”</strong>。如果一个属性组（比如课程）能对应多个独立的值域（教师组、图书组），就必须分家。</li>
</ul>
<h2 id="概念模型（Conceptual-Model）"><a href="#概念模型（Conceptual-Model）" class="headerlink" title="概念模型（Conceptual Model）"></a>概念模型（Conceptual Model）</h2><h3 id="1-什么是概念模型？"><a href="#1-什么是概念模型？" class="headerlink" title="1. 什么是概念模型？"></a>1. 什么是概念模型？</h3><p>概念结构设计是将需求分析得到的用户需求抽象为<strong>信息结构</strong>（即概念模型）的过程。在这个过程中，设计师的主要任务是发现信息的<strong>内在本质联系</strong>。</p>
<p>它不关心数据在计算机里是怎么存的，只关心现实世界中有哪些“人、事、物”以及它们之间是什么关系。</p>
<h3 id="2-概念模型的核心特点"><a href="#2-概念模型的核心特点" class="headerlink" title="2. 概念模型的核心特点"></a>2. 概念模型的核心特点</h3><p>根据 PPT 总结，概念模型具有以下四个显著特点：</p>
<ul>
<li><strong>真实性</strong>：能够真实、充分地反映现实世界，是现实世界的真实模型。</li>
<li><strong>易沟通性</strong>：易于理解，可以用它和不熟悉计算机的用户交换意见。这意味着客户不需要懂代码，看懂模型图就能确认需求是否正确。</li>
<li><strong>易修改性</strong>：易于更改，当应用环境和应用要求改变时，容易对概念模型进行修改和扩充。</li>
<li><strong>中立性（易转换性）</strong>：它不依赖于具体的数据库管理系统，易于向关系、网状、层次等各种逻辑模型转换。</li>
</ul>
<h3 id="3-描述工具：E-R-模型"><a href="#3-描述工具：E-R-模型" class="headerlink" title="3. 描述工具：E-R 模型"></a>3. 描述工具：E-R 模型</h3><p>PPT 明确指出，描述概念模型最常用的工具是 <strong>E-R 模型（Entity-Relationship Model，实体-联系模型）</strong>。</p>
<p>在 E-R 模型中：</p>
<ul>
<li><strong>实体（Entity）</strong>：客观存在并可相互区别的事物（如：学生、老师、商店）。</li>
<li><strong>属性（Attribute）</strong>：实体所具有的特征（如：学生的姓名、商店的地址）。</li>
<li><strong>联系（Relationship）</strong>：实体之间的相互关联（如：教师“讲授”课程、学生“选修”课程）。</li>
</ul>
<h2 id="E-R模型的实体之间的联系"><a href="#E-R模型的实体之间的联系" class="headerlink" title="E-R模型的实体之间的联系"></a>E-R模型的实体之间的联系</h2><h3 id="1-两个实体型之间的联系"><a href="#1-两个实体型之间的联系" class="headerlink" title="1. 两个实体型之间的联系"></a>1. 两个实体型之间的联系</h3><p>这是最常见的情况，描述两个不同类别的实体（如“学生”和“班级”）之间的对应关系。主要分为三种类型：</p>
<ul>
<li><strong>一对一联系 (1:1)</strong><ul>
<li><strong>定义</strong>：实体集 A 中的每一个实体，在实体集 B 中至多有一个实体与之联系；反之亦然。</li>
<li><strong>例子</strong>：一个班级只有一个正班长，而一个班长只在一个班级中任职。</li>
</ul>
</li>
<li><strong>一对多联系 (1:n)</strong><ul>
<li><strong>定义</strong>：实体集 A 中的每一个实体，在实体集 B 中有 $n$ 个实体与之联系 ($n \ge 0$)；而实体集 B 中的每一个实体，在实体集 A 中至多只有一个实体与之联系。</li>
<li><strong>例子</strong>：一个班级中有若干名学生，而每个学生只在一个班级中学习。</li>
</ul>
</li>
<li><strong>多对多联系 (m:n)</strong><ul>
<li><strong>定义</strong>：实体集 A 中的每一个实体，在实体集 B 中有 $n$ 个实体与之联系；反之，实体集 B 中的每一个实体，在实体集 A 中也有 $m$ 个实体与之联系。</li>
<li><strong>例子</strong>：一门课程同时有若干个学生选修，而一个学生可以同时选修多门课程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-两个以上实体型之间的联系"><a href="#2-两个以上实体型之间的联系" class="headerlink" title="2. 两个以上实体型之间的联系"></a>2. 两个以上实体型之间的联系</h3><p>有时候，一个联系会同时涉及三个或更多的实体。</p>
<ul>
<li><strong>多元联系</strong>：描述多个实体间的相互作用。</li>
<li><strong>例子</strong>：课程、教师与参考书之间的联系。<ul>
<li>如果一门课程有若干个教师讲授，使用若干本参考书，而<strong>每一个教师只讲授一门课程，每一本参考书只供一门课程使用</strong>，那么这三个实体之间就是一个 <strong>1:m:n</strong> 的一对多联系。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-单个实体型内的联系（自联系）"><a href="#3-单个实体型内的联系（自联系）" class="headerlink" title="3. 单个实体型内的联系（自联系）"></a>3. 单个实体型内的联系（自联系）</h3><p>同一个实体集内部的不同实体之间也可以存在联系。</p>
<ul>
<li><strong>定义</strong>：这种联系描述了同一类事物内部的层级或关联。</li>
<li><strong>例子</strong>：职工实体型内部的“领导”联系。<ul>
<li>某一个职工（干部）可以领导若干名职工，而一个职工仅被另外一个职工直接领导，这在职工实体内部构成了一个 <strong>1:n</strong> 的联系。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>联系类型</strong></th>
<th><strong>符号表示</strong></th>
<th><strong>关键点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一对一</strong></td>
<td>$1:1$</td>
<td>双向唯一对应。</td>
</tr>
<tr>
<td><strong>一对多</strong></td>
<td>$1:n$</td>
<td>一方对应多个，另一方最多对应一个。</td>
</tr>
<tr>
<td><strong>多对多</strong></td>
<td>$m:n$</td>
<td>双向都是“一对多”关系。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><h3 id="1-逻辑结构设计的核心定位"><a href="#1-逻辑结构设计的核心定位" class="headerlink" title="1. 逻辑结构设计的核心定位"></a>1. 逻辑结构设计的核心定位</h3><p>在整个数据库设计流程中，逻辑结构设计起到了“承上启下”的作用：</p>
<ul>
<li><strong>承上</strong>：它接收概念模型（E-R 图），这些图描述的是现实世界的本质联系，与计算机无关。</li>
<li><strong>启下</strong>：它的输出是一组<strong>关系模式</strong>（即表格定义），这些模式随后会被用于物理设计，并在实际的数据库软件（如 MySQL, Oracle）中建立起来。</li>
</ul>
<hr>
<h3 id="2-逻辑结构设计的主要任务"><a href="#2-逻辑结构设计的主要任务" class="headerlink" title="2. 逻辑结构设计的主要任务"></a>2. 逻辑结构设计的主要任务</h3><p>逻辑结构设计不仅仅是“画表格”，它包含两个关键步骤：</p>
<h4 id="第一步：转换-Transformation"><a href="#第一步：转换-Transformation" class="headerlink" title="第一步：转换 (Transformation)"></a>第一步：转换 (Transformation)</h4><p>将 E-R 图中的实体、属性和联系按照特定的规则转化为关系模式。</p>
<ul>
<li><strong>实体的转换</strong>：每一个实体型转换为一个关系模式，实体的属性变为关系的属性。</li>
<li><strong>联系的转换</strong>：根据联系的类型（1:1, 1:n, m:n）决定是合并到已有表格还是独立建表。<ul>
<li><strong>1:n 联系</strong>：通常合并到 n 端关系模式中。</li>
<li><strong>m:n 联系</strong>：必须转换为一个独立的、新的关系模式。</li>
</ul>
</li>
</ul>
<h4 id="第二步：规范化与优化-Normalization-amp-Optimization"><a href="#第二步：规范化与优化-Normalization-amp-Optimization" class="headerlink" title="第二步：规范化与优化 (Normalization &amp; Optimization)"></a>第二步：规范化与优化 (Normalization &amp; Optimization)</h4><p>这是为了确保生成的表格结构是科学且高效的：</p>
<ul>
<li><strong>应用范式理论</strong>：利用你之前学习的 <strong>3NF、BCNF 或 4NF</strong> 对转换后的关系模式进行分析和分解，以消除数据冗余和操作异常。</li>
<li><strong>处理多值依赖</strong>：识别并处理类似 $C \rightarrow\rightarrow T$ 这样的多值依赖，确保模式达到 4NF 级别。</li>
</ul>
<hr>
<h3 id="3-逻辑结构设计的产出结果"><a href="#3-逻辑结构设计的产出结果" class="headerlink" title="3. 逻辑结构设计的产出结果"></a>3. 逻辑结构设计的产出结果</h3><p>完成逻辑设计后，你将得到一组完整的<strong>关系模式集合</strong>。例如在之前“商店-商品”的例子中，逻辑设计的最终产出就是两个规范化的表结构：</p>
<ol>
<li><strong>R1 (商店S, 商品T, 商品经营部D)</strong></li>
<li><strong>R2 (商店S, 商品经营部D, 经营部经理M)</strong></li>
</ol>
<p>这些模式明确了每个表的<strong>属性</strong>、<strong>候选码</strong>以及表与表之间的<strong>参照关系</strong>。</p>
<h2 id="关系代数（Relational-Algebra）"><a href="#关系代数（Relational-Algebra）" class="headerlink" title="关系代数（Relational Algebra）"></a>关系代数（Relational Algebra）</h2><p><img src="/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235719915.png" alt="image-20260101235719915"></p>
<h3 id="1-五种基本操作"><a href="#1-五种基本操作" class="headerlink" title="1. 五种基本操作"></a>1. 五种基本操作</h3><p>这些是构成所有复杂查询的“原子”动作：</p>
<ul>
<li><strong>选择 ($\sigma$ - Selection)</strong>：从关系中挑出满足特定条件的<strong>行（元组）</strong>。<ul>
<li><em>优化直觉</em>：尽早执行选择（选择下推），可以极大减少中间数据量。</li>
</ul>
</li>
<li><strong>投影 ($\pi$ - Projection)</strong>：从关系中选出指定的<strong>列（属性）</strong>，并去掉重复行。</li>
<li><strong>并 ($\cup$ - Union)</strong>：合并两个结构相同的表。</li>
<li><strong>差 ($-$ - Difference)</strong>：找出存在于表 A 但不存在于表 B 的行。</li>
<li><strong>笛卡尔积 ($\times$ - Cartesian Product)</strong>：将两张表的每一行进行所有可能的组合。<ul>
<li><em>注意</em>：它是<strong>连接（Join）</strong>的基础，但直接计算它代价极大。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-为什么学习关系代数对“查询优化”至关重要？"><a href="#2-为什么学习关系代数对“查询优化”至关重要？" class="headerlink" title="2. 为什么学习关系代数对“查询优化”至关重要？"></a>2. 为什么学习关系代数对“查询优化”至关重要？</h3><p>通过你提供的案例，我们可以看到关系代数如何揭示性能差异：</p>
<h4 id="场景：求选修了-2-号课程的学生姓名"><a href="#场景：求选修了-2-号课程的学生姓名" class="headerlink" title="场景：求选修了 2 号课程的学生姓名"></a>场景：求选修了 2 号课程的学生姓名</h4><ul>
<li><strong>SQL 表达</strong>：<code>SELECT Sname FROM Student, SC WHERE Student.Sno=SC.Sno AND SC.Cno=&#39;2&#39;</code>。</li>
<li><strong>低效的代数等价式</strong>：$\Pi<em>{Sname}(\sigma</em>{Student.Sno=SC.Sno \wedge SC.Cno=’2’}(Student \times SC))$。<ul>
<li><strong>执行逻辑</strong>：先做巨大的笛卡尔积（1000 $\times$ 10000 = 1000万行），再过滤。</li>
</ul>
</li>
<li><strong>高效的代数等价式（优化后的）</strong>：$\Pi<em>{Sname}(Student \bowtie \sigma</em>{SC.Cno=’2’}(SC))$。<ul>
<li><strong>执行逻辑</strong>：先过滤出 50 条选课记录，再进行<strong>自然连接（$\bowtie$）</strong>。</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="1-什么是事务？-Definition"><a href="#1-什么是事务？-Definition" class="headerlink" title="1. 什么是事务？(Definition)"></a>1. 什么是事务？(Definition)</h3><p>定义：事务是用户定义的一个数据库操作序列。</p>
<p>核心特征：“不可分割” (Indivisible)。</p>
<ul>
<li><strong>要么全做 (All)</strong>：序列中的所有操作都成功。</li>
<li><strong>要么全不做 (Nothing)</strong>：只要有一个操作失败，前面做过的所有操作都要撤销，就像没发生过一样。</li>
</ul>
<p><strong>误区澄清</strong>：</p>
<ul>
<li>事务 $\neq$ 程序。一个程序（比如一个 Java 后端服务）可能包含多个事务。</li>
<li>事务 $\neq$ 一条 SQL。虽然一条 SQL 可以是一个事务，但事务通常包含一组相关的 SQL 语句（比如先 <code>UPDATE</code> 再 <code>INSERT</code>）。</li>
</ul>
<hr>
<h3 id="2-事务的两条路：提交与回滚"><a href="#2-事务的两条路：提交与回滚" class="headerlink" title="2. 事务的两条路：提交与回滚"></a>2. 事务的两条路：提交与回滚</h3><p>一旦使用了 <code>BEGIN TRANSACTION</code> 开启了事务，它最终只有两个结局：</p>
<h4 id="结局-A：正常结束-——-提交-COMMIT"><a href="#结局-A：正常结束-——-提交-COMMIT" class="headerlink" title="结局 A：正常结束 —— 提交 (COMMIT)"></a><strong>结局 A：正常结束 —— 提交 (COMMIT)</strong></h4><ul>
<li><strong>命令</strong>：<code>COMMIT</code></li>
<li><strong>含义</strong>：<ul>
<li>事务中所有的操作（读+更新）全部生效。</li>
<li><strong>持久化</strong>：数据库会将这些更新真正写入到<strong>磁盘</strong>上的物理数据库中，即使之后系统断电，数据也不会丢。</li>
</ul>
</li>
</ul>
<h4 id="结局-B：异常终止-——-回滚-ROLLBACK"><a href="#结局-B：异常终止-——-回滚-ROLLBACK" class="headerlink" title="结局 B：异常终止 —— 回滚 (ROLLBACK)"></a><strong>结局 B：异常终止 —— 回滚 (ROLLBACK)</strong></h4><ul>
<li><strong>命令</strong>：<code>ROLLBACK</code></li>
<li><strong>含义</strong>：<ul>
<li>事务运行过程中发生了故障，或者用户主动取消。</li>
<li><strong>撤销</strong>：系统会将该事务中<strong>所有已完成</strong>的操作全部撤销。</li>
<li><strong>复原</strong>：数据库“滚回”到事务开始时的状态，仿佛什么都没发生过。</li>
</ul>
</li>
</ul>
<blockquote>
<p>经典案例（转账）：</p>
<p>事务开始 -&gt; A 账户扣 100 元 -&gt; (突然断电/系统报错) -&gt; ROLLBACK。</p>
<p>结果：A 账户的钱没少。如果没有事务回滚，A 的钱扣了但 B 没收到，钱就“蒸发”了。</p>
</blockquote>
<hr>
<h3 id="3-如何定义事务？-Explicit-vs-Implicit"><a href="#3-如何定义事务？-Explicit-vs-Implicit" class="headerlink" title="3. 如何定义事务？(Explicit vs Implicit)"></a>3. 如何定义事务？(Explicit vs Implicit)</h3><h4 id="显式定义-Explicit"><a href="#显式定义-Explicit" class="headerlink" title="显式定义 (Explicit)"></a><strong>显式定义 (Explicit)</strong></h4><p>你需要明确告诉数据库哪里是开始，哪里是结束。</p>
<p>SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION;  -- 开始</span><br><span class="line">   SQL 语句1;</span><br><span class="line">   SQL 语句2;</span><br><span class="line">...</span><br><span class="line">COMMIT;             -- 成功提交</span><br><span class="line">-- 或者</span><br><span class="line">ROLLBACK;           -- 失败回滚</span><br></pre></td></tr></table></figure>
<h4 id="隐式方式-Implicit"><a href="#隐式方式-Implicit" class="headerlink" title="隐式方式 (Implicit)"></a><strong>隐式方式 (Implicit)</strong></h4><ul>
<li><strong>默认行为</strong>：如果你不写 <code>BEGIN</code>，大多数数据库管理系统（DBMS）会按<strong>“缺省规定”</strong>自动划分事务。</li>
<li><strong>一句一事务</strong>：通常情况下，DBMS 会把你写的每一条独立的 SQL 语句当做一个独立的事务。执行完一句，自动 <code>COMMIT</code> 一句。</li>
</ul>
<h3 id="4-为什么要引入事务？"><a href="#4-为什么要引入事务？" class="headerlink" title="4. 为什么要引入事务？"></a>4. 为什么要引入事务？</h3><p>PPT <code>2c5f13</code> 的最后一句点出了事务的地位： 它是<strong>恢复 (Recovery)</strong> 和 <strong>并发控制 (Concurrency Control)</strong> 的基本单位。</p>
<ul>
<li><strong>恢复</strong>：系统崩溃了，重启后依靠事务日志来回滚未完成的操作。</li>
<li><strong>并发</strong>：多个用户同时操作一张表，靠事务来隔离彼此，防止数据打架。</li>
</ul>
<h2 id="事务的特性（ACID特性）"><a href="#事务的特性（ACID特性）" class="headerlink" title="事务的特性（ACID特性）"></a>事务的特性（ACID特性）</h2><h3 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1. 原子性 (Atomicity)"></a>1. 原子性 (Atomicity)</h3><ul>
<li><strong>定义</strong>：事务是一个不可分割的工作单位。事务中的操作，<strong>要么全部做，要么全部不做</strong>。</li>
<li><strong>通俗理解</strong>：就像原子在化学反应中不可再分一样。</li>
<li><strong>案例</strong>：银行转账。从 A 账户扣 100 元，往 B 账户加 100 元。这两个动作必须捆绑在一起。如果扣钱成功了但加钱失败了，数据库必须把扣掉的钱“退回去”（回滚），绝对不允许出现“钱扣了但对方没收到”的中间状态。</li>
</ul>
<h3 id="2-一致性-Consistency"><a href="#2-一致性-Consistency" class="headerlink" title="2. 一致性 (Consistency)"></a>2. 一致性 (Consistency)</h3><ul>
<li><strong>定义</strong>：事务执行的结果必须使数据库从一个<strong>一致性状态</strong>变到另一个<strong>一致性状态</strong>。</li>
<li><strong>通俗理解</strong>：数据必须守规矩，不能违反业务逻辑或约束。</li>
<li><strong>案例</strong>：<ul>
<li><strong>守恒律</strong>：转账前后，A 和 B 的账户余额总和必须保持不变。</li>
<li><strong>完整性约束</strong>：如果数据库规定“余额不能为负数”，那么任何导致余额为负的事务都必须失败，不能让数据库进入“非法状态”。</li>
</ul>
</li>
</ul>
<h3 id="3-隔离性-Isolation"><a href="#3-隔离性-Isolation" class="headerlink" title="3. 隔离性 (Isolation)"></a>3. 隔离性 (Isolation)</h3><ul>
<li><strong>定义</strong>：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li><strong>通俗理解</strong>：虽然大家在同时用数据库，但感觉上就像只有我一个人在用一样。</li>
<li><strong>案例</strong>：<ul>
<li>A 正在给 B 转账，还没提交。</li>
<li>C 去查 B 的余额。</li>
<li><strong>隔离性保证</strong>：C 查到的应该是转账<strong>前</strong>的余额，或者是转账<strong>后</strong>的余额，而绝对不该看到“钱正在路上”的临时混乱状态。</li>
</ul>
</li>
</ul>
<h3 id="4-持续性-Durability"><a href="#4-持续性-Durability" class="headerlink" title="4. 持续性 (Durability)"></a>4. 持续性 (Durability)</h3><ul>
<li><strong>定义</strong>：一个事务一旦提交 (COMMIT)，它对数据库中数据的改变就应该是<strong>永久性</strong>的。</li>
<li><strong>通俗理解</strong>：落袋为安。只要数据库告诉你“成功了”，这事就算天塌下来（断电、宕机）也赖不掉。</li>
<li><strong>机制</strong>：接下来的系统故障（如断电）不应该导致已提交的数据丢失。数据库通常通过<strong>重做日志 (Redo Log)</strong> 来保证这一点。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Atomicity</strong> (原子性) $\rightarrow$ <strong>要么全做，要么不做</strong>。</li>
<li><strong>Consistency</strong> (一致性) $\rightarrow$ <strong>数据始终合法</strong>。</li>
<li><strong>Isolation</strong> (隔离性) $\rightarrow$ <strong>你干你的，我干我的</strong>。</li>
<li><strong>Durability</strong> (持续性) $\rightarrow$ <strong>说了算数，永久保存</strong>。</li>
</ul>
<h2 id="事务故障的恢复步骤"><a href="#事务故障的恢复步骤" class="headerlink" title="事务故障的恢复步骤"></a>事务故障的恢复步骤</h2><h3 id="1-什么是事务故障？"><a href="#1-什么是事务故障？" class="headerlink" title="1. 什么是事务故障？"></a>1. 什么是事务故障？</h3><ul>
<li><strong>定义</strong>：事务在运行到正常终点（COMMIT）之前被强行终止。</li>
<li><strong>原因</strong>：可能是程序逻辑错误、运算溢出、死锁被系统选中牺牲，或者用户主动取消等。</li>
<li><strong>恢复目标</strong>：清除该事务对数据库产生的所有“半成品”影响。</li>
</ul>
<h3 id="2-恢复的核心机制"><a href="#2-恢复的核心机制" class="headerlink" title="2. 恢复的核心机制"></a>2. 恢复的核心机制</h3><ul>
<li><strong>自动完成</strong>：这个过程由 DBMS 的恢复子系统自动完成，对用户是<strong>透明</strong>的（用户完全不需要干预，甚至可能感觉不到）。</li>
<li><strong>利用日志</strong>：系统通过读取<strong>日志文件</strong>来实现撤销（UNDO）。</li>
</ul>
<h3 id="3-具体恢复步骤-4步走"><a href="#3-具体恢复步骤-4步走" class="headerlink" title="3. 具体恢复步骤 (4步走)"></a>3. 具体恢复步骤 (4步走)</h3><p>整个过程就像是在<strong>倒带</strong>看电影：</p>
<ul>
<li><strong>第一步：反向扫描 (Reverse Scan)</strong> 系统从日志文件的<strong>最后面开始向前扫描</strong>，查找属于该故障事务的更新操作记录。<ul>
<li><em>为什么要反向？</em> 因为我们要撤销最近的操作，必须按照“后做的先撤销”的顺序进行。</li>
</ul>
</li>
<li><strong>第二步：执行逆操作 (Inverse Operation)</strong> 对找到的每一个更新操作，执行它的<strong>反操作</strong>，将数据库恢复到“更新前的值”。<ul>
<li><strong>如果是插入操作 (INSERT)</strong>：日志里记了插入了什么，恢复时就<strong>删除 (DELETE)</strong> 它。</li>
<li><strong>如果是删除操作 (DELETE)</strong>：日志里记了删除了什么（更新前的值），恢复时就重新<strong>插入 (INSERT)</strong> 回去。</li>
<li><strong>如果是修改操作 (UPDATE)</strong>：用日志中记录的<strong>“修改前的值”</strong>去覆盖现在的“修改后的值”。</li>
</ul>
</li>
<li><strong>第三步：继续扫描</strong> 继续反向扫描日志文件，查找该事务的其他更新操作，并重复执行第二步的处理。</li>
<li><strong>第四步：结束</strong> 如此一直处理下去，直到读到该事务的<strong>“开始标记” (BEGIN TRANSACTION)</strong>。这意味着该事务的所有操作都已撤销完毕，故障恢复完成</li>
</ul>
<h2 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h2><h3 id="1-为什么系统故障会导致数据不一致？"><a href="#1-为什么系统故障会导致数据不一致？" class="headerlink" title="1. 为什么系统故障会导致数据不一致？"></a>1. 为什么系统故障会导致数据不一致？</h3><p>当系统崩溃时，可能会出现两种糟糕的情况：</p>
<ul>
<li><strong>坏人进门了</strong>：有些<strong>未完成</strong>的事务，它们修改的数据可能已经偷偷写入了磁盘（Undo 需求）。</li>
<li><strong>好人没进门</strong>：有些<strong>已提交</strong>的事务，它们的数据可能还在内存缓冲区里排队，没来得及写入磁盘就断电了（Redo 需求）。</li>
</ul>
<p>因此，系统重启时的恢复策略是：<strong>Undo（撤销）未完成的事务，Redo（重做）已提交的事务</strong>。</p>
<hr>
<h3 id="2-恢复的具体步骤（三遍扫描法）"><a href="#2-恢复的具体步骤（三遍扫描法）" class="headerlink" title="2. 恢复的具体步骤（三遍扫描法）"></a>2. 恢复的具体步骤（三遍扫描法）</h3><p>这个过程由系统在重启时自动完成，不需要人工干预。系统会像侦探一样扫描日志文件，分三步走：</p>
<h4 id="第一步：正向扫描，划分阵营"><a href="#第一步：正向扫描，划分阵营" class="headerlink" title="第一步：正向扫描，划分阵营"></a><strong>第一步：正向扫描，划分阵营</strong></h4><p>系统从头到尾扫描日志文件，建立两个队列（名单）：</p>
<ul>
<li><strong>重做队列 (REDO Queue)</strong>：凡是既有 <code>BEGIN</code> 又有 <code>COMMIT</code> 记录的事务，说明它在故障前已经成功了，属于“好人”，放入 Redo 队列。</li>
<li><strong>撤销队列 (UNDO Queue)</strong>：凡是只有 <code>BEGIN</code> 却找不到 <code>COMMIT</code> 记录的事务，说明它在故障时还没跑完，属于“坏人”，放入 Undo 队列。</li>
</ul>
<blockquote>
<p>示例演示：</p>
<p>日志记录：t1 begin, t2 begin, t1 commit … (BOOM! 故障发生)</p>
<ul>
<li><strong>t1</strong>：有头有尾 $\rightarrow$ 进入 <strong>REDO 队列</strong>。</li>
<li><strong>t2</strong>：有头无尾 $\rightarrow$ 进入 <strong>UNDO 队列</strong>。</li>
</ul>
</blockquote>
<h4 id="第二步：反向扫描，撤销坏人-Undo"><a href="#第二步：反向扫描，撤销坏人-Undo" class="headerlink" title="第二步：反向扫描，撤销坏人 (Undo)"></a><strong>第二步：反向扫描，撤销坏人 (Undo)</strong></h4><ul>
<li><strong>方向</strong>：从后向前扫描日志。</li>
<li><strong>对象</strong>：针对 <strong>UNDO 队列</strong> 中的事务。</li>
<li><strong>动作</strong>：执行<strong>逆操作</strong>。将日志中记录的“更新前的值”写回数据库，把它们产生的影响彻底抹除。</li>
</ul>
<h4 id="第三步：正向扫描，重做好人-Redo"><a href="#第三步：正向扫描，重做好人-Redo" class="headerlink" title="第三步：正向扫描，重做好人 (Redo)"></a><strong>第三步：正向扫描，重做好人 (Redo)</strong></h4><ul>
<li><strong>方向</strong>：从头向后扫描日志。</li>
<li><strong>对象</strong>：针对 <strong>REDO 队列</strong> 中的事务。</li>
<li><strong>动作</strong>：重新执行登记的操作。将日志中记录的“更新后的值”写入数据库。<ul>
<li><em>为什么要重做？</em> 因为虽然它们提交了，但数据可能还没来得及从内存写到硬盘。重做一遍确保数据万无一失。</li>
</ul>
</li>
</ul>
<h2 id="利用检查点的恢复策略"><a href="#利用检查点的恢复策略" class="headerlink" title="利用检查点的恢复策略"></a>利用检查点的恢复策略</h2><p><img src="/2025/12/24/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20260101235032775.png" alt="image-20260101235032775"></p>
<h3 id="1-核心思想：为什么要用检查点？"><a href="#1-核心思想：为什么要用检查点？" class="headerlink" title="1. 核心思想：为什么要用检查点？"></a>1. 核心思想：为什么要用检查点？</h3><ul>
<li><strong>问题</strong>：如果没有检查点，系统故障后必须扫描整个日志。</li>
<li><strong>解决</strong>：如果在某个时间点（$T_c$）打了个“检查点”，意味着在此之前提交的所有事务，其数据都已经<strong>安全写入磁盘</strong>了。</li>
<li><strong>结论</strong>：恢复时，对于检查点之前就已经结束的事务（如 $T_1$），完全不用管，只需要重做或撤销检查点之后的事务即可。</li>
</ul>
<hr>
<h3 id="2-场景解析：T1-T5-的命运-关键图解"><a href="#2-场景解析：T1-T5-的命运-关键图解" class="headerlink" title="2. 场景解析：T1-T5 的命运 (关键图解)"></a>2. 场景解析：T1-T5 的命运 (关键图解)</h3><p>请重点看图片 <code>image_37aa4b.png</code>。图中定义了两个关键时刻：</p>
<ul>
<li><strong>$T_c$ (Checkpoint)</strong>：检查点时刻。</li>
<li><strong>$T_f$ (Failure)</strong>：系统故障（断电）时刻。</li>
</ul>
<p>我们根据事务在这两个时刻的状态，决定怎么处理它们：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>事务</strong></th>
<th><strong>状态描述</strong></th>
<th><strong>恢复策略</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>$T_1$</strong></td>
<td>在 $T_c$ 之前就早已提交。</td>
<td><strong>不重做 (Ignore)</strong></td>
<td>它的修改在打检查点前就已经写入磁盘，安全了。</td>
</tr>
<tr>
<td><strong>$T_2$</strong></td>
<td>跨越了 $T_c$，但在故障 $T_f$ 前提交了。</td>
<td><strong>重做 (REDO)</strong></td>
<td>虽然提交了，但部分数据可能还在内存里，没来得及写盘。</td>
</tr>
<tr>
<td><strong>$T_3$</strong></td>
<td>跨越了 $T_c$，但在故障 $T_f$ 时还没跑完。</td>
<td><strong>撤销 (UNDO)</strong></td>
<td>这是一个“烂尾”的事务，必须回滚。</td>
</tr>
<tr>
<td><strong>$T_4$</strong></td>
<td>在 $T_c$ 之后开始，在 $T_f$ 前提交了。</td>
<td><strong>重做 (REDO)</strong></td>
<td>它是“好人”，但数据可能丢失了。</td>
</tr>
<tr>
<td><strong>$T_5$</strong></td>
<td>在 $T_c$ 之后才开始，故障时还没跑完。</td>
<td><strong>撤销 (UNDO)</strong></td>
<td>纯粹的“烂尾”事务，回滚。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-恢复算法的具体步骤"><a href="#3-恢复算法的具体步骤" class="headerlink" title="3. 恢复算法的具体步骤"></a>3. 恢复算法的具体步骤</h3><p>系统重启时，会执行以下逻辑来自动分类 $T_1$ 到 $T_5$：</p>
<h4 id="第一步：找到最近的检查点"><a href="#第一步：找到最近的检查点" class="headerlink" title="第一步：找到最近的检查点"></a><strong>第一步：找到最近的检查点</strong></h4><p>系统从“重新开始文件”中找到最后一个检查点的记录地址，然后在日志文件中找到这个 <strong>CheckPoint 记录</strong>。</p>
<h4 id="第二步：初始化队列"><a href="#第二步：初始化队列" class="headerlink" title="第二步：初始化队列"></a><strong>第二步：初始化队列</strong></h4><p>检查点记录里会保存一个 <strong>“当时正在执行的事务清单” (ACTIVE-LIST)</strong>。</p>
<ul>
<li>先把 ACTIVE-LIST 里的事务暂时放入 <strong>UNDO-LIST</strong>（撤销队列）。</li>
<li><strong>REDO-LIST</strong>（重做队列）暂时为空。</li>
<li><em>对应图中</em>：此时 $T_2, T_3$ 被放入 UNDO 队列（因为在 $T_c$ 时它们是活着的）。$T_1$ 不在清单里，所以被直接忽略。</li>
</ul>
<h4 id="第三步：正向扫描-从-T-c-扫到-T-f"><a href="#第三步：正向扫描-从-T-c-扫到-T-f" class="headerlink" title="第三步：正向扫描 (从 $T_c$ 扫到 $T_f$)"></a><strong>第三步：正向扫描 (从 $T_c$ 扫到 $T_f$)</strong></h4><p>系统从检查点开始，往后扫描日志：</p>
<ol>
<li><strong>遇到新开始的事务 ($T_4, T_5$)</strong>：把它放入 <strong>UNDO-LIST</strong>。<ul>
<li><em>现在的 UNDO 队列</em>：${T_2, T_3, T_4, T_5}$。</li>
</ul>
</li>
<li><strong>遇到提交 (COMMIT) 的事务 ($T_2, T_4$)</strong>：把它从 UNDO-LIST 移到 <strong>REDO-LIST</strong>。<ul>
<li><em>移动后</em>：<ul>
<li><strong>UNDO 队列</strong> (烂尾的)：${T_3, T_5}$。</li>
<li><strong>REDO 队列</strong> (成功的)：${T_2, T_4}$。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第四步：执行恢复"><a href="#第四步：执行恢复" class="headerlink" title="第四步：执行恢复"></a><strong>第四步：执行恢复</strong></h4><ol>
<li><strong>撤销 (Undo)</strong>：对 UNDO 队列中的事务 ($T_3, T_5$) 执行<strong>逆向扫描</strong>和撤销操作。</li>
<li><strong>重做 (Redo)</strong>：对 REDO 队列中的事务 ($T_2, T_4$) 执行<strong>正向扫描</strong>和重做操作。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="张熙浚 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="张熙浚 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag"># 大学</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/20/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/pytorch/" rel="prev" title="learn_pytorch">
                  <i class="fa fa-angle-left"></i> learn_pytorch
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2026/01/02/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LinearRAG%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="next" title="LinearRAG论文阅读">
                  LinearRAG论文阅读 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
