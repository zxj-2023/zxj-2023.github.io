<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zxj Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang XiJun">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="zxj Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="zxj">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/13/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang XiJun</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">155</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/15/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/15/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/" class="post-title-link" itemprop="url">前端1——入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-15T00:00:00+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:04:00" itemprop="dateModified" datetime="2025-06-12T18:04:00+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>vscode</p>
<p>插件：</p>
<p>HTML CSS Support 写css代码</p>
<p>Live Serve 实时预览html网页</p>
<p>Auto Rename Tag 同步修改标签名称</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>html （hyper text markup language） 超文本标记语言</p>
<p>网页是又html标签描述出来的</p>
<p>html文件结构</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>//文档编码格式</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span>//文档标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>//页面内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>块元素（block）：块级元素通常用于组织和布局页面的主要结构和内容，例如段落、标题、列表、表格等。它们用于创建页面的主要部分，将内容分隔成逻辑块。</p>
<p>行内元素（inline）：行内元素通常用于添加文本样式或为文本中的一部分应用样式。它们可以在文本中插入小的元素，例如超链接、强调文本等。</p>
<p>常用标签</p>
<p><code>&lt;h1&gt; &lt;/h1&gt;</code>一级标签</p>
<p><code>&lt;p&gt; &lt;/p&gt;</code>段落标签</p>
<p><code>&lt;b&gt; &lt;/b&gt;</code> bold 文本加粗</p>
<p><code>&lt;u&gt; &lt;/u&gt;</code> 下划线</p>
<p><code>&lt;s&gt; &lt;/s&gt;</code> 删除线</p>
<p>无序列表</p>
<p><code>&lt;ul&gt;</code><br>    <code>&lt;li&gt;1&lt;/li&gt;</code><br>    <code>&lt;li&gt;2&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code></p>
<p>有序列表</p>
<p><code>&lt;ol&gt;</code><br>    <code>&lt;li&gt;1&lt;/li&gt;</code><br>    <code>&lt;li&gt;2&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code></p>
<p>表格</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span>//边框宽度为1</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">th</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>元素2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>html属性 基本语法：&lt;开始标签 属性名=“属性值”&gt;</p>
<p><code>&lt;a href=&quot;www.zxj-2023.github.io&quot; target=&quot;_blank&quot;&gt;超链接&lt;/a&gt;</code> 超链接，target决定链接打开方式</p>
<p><code>&lt;br&gt;</code> 换行</p>
<p><code>&lt;hr&gt;</code> 分割线</p>
<p><code>&lt;img src=&quot;图片路径或链接&quot; alt=&quot;代替文本&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;&lt;/img&gt;</code> 图片</p>
<p><code>&lt;div class=&quot;名称&quot;&gt;&lt;/div&gt;</code>块级标签，用于创建页面的布局结构，如导航栏，页眉等</p>
<p>优先级：id&gt;class&gt;标签名</p>
<p><code>&lt;span&gt;&lt;/span&gt;</code>包装文本以便对其使用css，js行为或样式等</p>
<p>form标签是html表单的容器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span>//URL</span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span>//与span类似，for用于和input的id绑定</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placehoud</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">	//input其他属性，value：规定input内的值</span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placehoud</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span> 男//单选择 名称一致</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span> 女</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>爱好：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 唱歌//多选</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 跳舞</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>//提交按钮 提交表单数据</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>css cascading style sheets 用于定义网页样式和布局的样式表语言，通过CSS，可以指定页面中各个元素的颜色、字体、大小、间距、边框、背景等样式，从而实现更精确的页面设计。</p>
<p>语法：</p>
<p>选择器{</p>
<p>​    属性1：属性值1；</p>
<p>​    属性2：属性值2；</p>
<p>}</p>
<p>内部样式表：放在head里面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:bule;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>:<span class="number">16px</span>;//字体大小</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>:yellow//背景色</span></span><br><span class="line"><span class="language-css">            font-family:<span class="string">&#x27;KaiTi&#x27;</span>//修改字体，楷体</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>外部样式：需在head链接</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;路径&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内联样式：标签内</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color=red;&quot;</span>&gt;</span></span><br><span class="line">    内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优先级：内联样式&gt;内部样式表&gt;外部样式</p>
<p>css选择器：</p>
<p>元素选择器：标签名</p>
<p>类选择器：.+类名</p>
<p>id选择器：#+id名</p>
<p>通用选择器：*</p>
<p>子代选择器：父+&gt;+子</p>
<p>后代选择器：父+空格+子</p>
<p>相邻元素选择器：1+2    需要满足相邻条件</p>
<p>伪类选择器</p>
<p>css属性：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-reference.html">CSS 参考手册 |菜鸟教程</a></p>
<p><code>&lt;h1 style=&quot;font: bolder 50px &#39;KaiTi&#39;;&quot;&gt;复合属性&lt;/h1&gt;</code> font符合属性示例</p>
<p>区分块、行内、行内块元素width和height的差异</p>
<p>通过display转换以上三者(block,inline,inline-block)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.div-inline&#123;</span><br><span class="line">	display:inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>盒子模型：</p>
<ol>
<li>内容（content）</li>
<li>内边距（padding）：内容与边框之间的空间</li>
<li>边框（border）：盒子的边界  上右下左</li>
<li>外边距（margin）：盒子与其他元素之间的空间</li>
</ol>
<p><img src="/2025/02/15/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/asdsdf.png" alt="asdsdf"></p>
<p>浮动：改变元素默认的排列顺序，使网页布局更加灵活多变(letf right)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.son&#123;</span><br><span class="line">	float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除浮动的方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定位布局：</p>
<p>相对定位(relative)∶相对于元素在文档流中的正常位置进行定位。</p>
<p>绝对定位(absolute)︰相对于其最近的已定位祖先元素进行定位，不占据文档流。</p>
<p>固定定位(fixed)︰相对于浏览器窗口进行定位。不占据文档流，固定在屏幕上的位置，不随滚动而移动。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box-relative&#123;</span><br><span class="line">	position: relative;//相对定位</span><br><span class="line">	left:</span><br><span class="line">	right:</span><br><span class="line">	top:</span><br><span class="line">	bottom:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript是一种轻量级、解释型、面向对象的脚本语言。它主要被设计用于在网页上实现动态效果，增加用户与网页的交互性。<br>作为一种客户端脚本语言，JavaScript可以直接嵌入HTML，并在浏览器中执行。<br>与HTML和CSS不同，JavaScript使得网页不再是静态的，而是可以根据用户的操作动态变化的。</p>
<p><code>客户端脚本</code>:用于在用户浏览器中执行，实现动态效果和用户交互。</p>
<p><code>网页开发</code>:与HTML和CSS协同工作，使得网页具有更强的交互性和动态性。</p>
<p><code>后端开发</code>︰使用Node.js，JavaScript 也可以在服务器端运行，实现服务器端应用的开发。</p>
<p>js的导入</p>
<p>内联</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello,world&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>外联</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;相对路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello,world&#x27;</span>)<span class="comment">//控制台输出</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;&#x27;</span>)<span class="comment">//内联弹窗</span></span><br></pre></td></tr></table></figure>
<p>js语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="keyword">var</span> x;<span class="comment">//varible</span></span><br><span class="line"><span class="keyword">let</span> t=<span class="number">5</span>;<span class="comment">//块级作用域</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> =<span class="number">3.14</span>;<span class="comment">//常量</span></span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line"><span class="comment">//循环，for，while</span></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">function_name</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用html属性触发事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;click_event()&quot;</span>&gt;</span></span><br><span class="line">        点击事件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onfocus</span>=<span class="string">&quot;focus_event()&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;blur_event()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="keyword">function</span> <span class="title function_">click_event</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;触发点击事件&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">focus_event</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取焦点&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">blur_event</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失去焦点&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>DOM</p>
<p>当网页被加载时，浏览器会创建页面的文档对象模型，也就是DOM (Document Object Model) .每个HTML或XML文档都可以被视为一个文档树，文档树是整个文档的层次结构表示。</p>
<p>文档节点是整个文档树的根节点。</p>
<p>DOM为这个文档树提供了一个编程接口，开发者可以使用JavaScript来操作这个树状结构。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>ID选择器标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>类选择器标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">        点击按钮</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">scrip</span>&gt;</span></span><br><span class="line">    	var element_id = document.getElementById(&#x27;box1&#x27;);//id唯一，获取的是元素</span><br><span class="line">        console.log(element_id)</span><br><span class="line">		</span><br><span class="line">        var element_class = document.getElementsByClassName(&#x27;box2&#x27;)[0];//类不唯一，获取的是数组</span><br><span class="line">        console.log(element_id)</span><br><span class="line">        </span><br><span class="line">        element_id.innerHTML = &#x27;修改id标签内容&#x27;;</span><br><span class="line">        element_id.innerText</span><br><span class="line">        element_id.style.color</span><br><span class="line">        element_id.style.fontSize</span><br><span class="line">        </span><br><span class="line">        //DOM属性绑定事件</span><br><span class="line">        var button_element = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">        </span><br><span class="line">        button_element.onclick = function()&#123;</span><br><span class="line">        	alert(&#x27;DOM 属性按键触发&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        button)element.addEventListener(&#x27;click&#x27;,click_event)</span><br><span class="line">        function click_event()&#123;</span><br><span class="line">        	alert(&#x27;通过addEventListener触发&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">scrip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>对象</strong></p>
<p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型</p>
<p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;itbaizhan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;13&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（property），它的“键</p>
<p>值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="title function_">getName</span>(<span class="string">&quot;itbaizhan&quot;</span>) <span class="comment">// itbaizhan</span></span><br></pre></td></tr></table></figure>
<p><img src="/2025/02/15/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/image-20211025173456785.png" alt="image-20211025173456785"></p>
<h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1BT4y1W7Aw/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">3小时前端入门教程（HTML+CSS+JS）_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/15/%E5%AD%A6%E4%B9%A0/python-web/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/15/%E5%AD%A6%E4%B9%A0/python-web/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/" class="post-title-link" itemprop="url">前端1——入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-15T00:00:00+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:04:00" itemprop="dateModified" datetime="2025-06-12T18:04:00+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>vscode</p>
<p>插件：</p>
<p>HTML CSS Support 写css代码</p>
<p>Live Serve 实时预览html网页</p>
<p>Auto Rename Tag 同步修改标签名称</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>html （hyper text markup language） 超文本标记语言</p>
<p>网页是又html标签描述出来的</p>
<p>html文件结构</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>//文档编码格式</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span>//文档标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>//页面内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>块元素（block）：块级元素通常用于组织和布局页面的主要结构和内容，例如段落、标题、列表、表格等。它们用于创建页面的主要部分，将内容分隔成逻辑块。</p>
<p>行内元素（inline）：行内元素通常用于添加文本样式或为文本中的一部分应用样式。它们可以在文本中插入小的元素，例如超链接、强调文本等。</p>
<p>常用标签</p>
<p><code>&lt;h1&gt; &lt;/h1&gt;</code>一级标签</p>
<p><code>&lt;p&gt; &lt;/p&gt;</code>段落标签</p>
<p><code>&lt;b&gt; &lt;/b&gt;</code> bold 文本加粗</p>
<p><code>&lt;u&gt; &lt;/u&gt;</code> 下划线</p>
<p><code>&lt;s&gt; &lt;/s&gt;</code> 删除线</p>
<p>无序列表</p>
<p><code>&lt;ul&gt;</code><br>    <code>&lt;li&gt;1&lt;/li&gt;</code><br>    <code>&lt;li&gt;2&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code></p>
<p>有序列表</p>
<p><code>&lt;ol&gt;</code><br>    <code>&lt;li&gt;1&lt;/li&gt;</code><br>    <code>&lt;li&gt;2&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code></p>
<p>表格</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span>//边框宽度为1</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">th</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>元素2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>html属性 基本语法：&lt;开始标签 属性名=“属性值”&gt;</p>
<p><code>&lt;a href=&quot;www.zxj-2023.github.io&quot; target=&quot;_blank&quot;&gt;超链接&lt;/a&gt;</code> 超链接，target决定链接打开方式</p>
<p><code>&lt;br&gt;</code> 换行</p>
<p><code>&lt;hr&gt;</code> 分割线</p>
<p><code>&lt;img src=&quot;图片路径或链接&quot; alt=&quot;代替文本&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;&lt;/img&gt;</code> 图片</p>
<p><code>&lt;div class=&quot;名称&quot;&gt;&lt;/div&gt;</code>块级标签，用于创建页面的布局结构，如导航栏，页眉等</p>
<p>优先级：id&gt;class&gt;标签名</p>
<p><code>&lt;span&gt;&lt;/span&gt;</code>包装文本以便对其使用css，js行为或样式等</p>
<p>form标签是html表单的容器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span>//URL</span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span>//与span类似，for用于和input的id绑定</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placehoud</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">	//input其他属性，value：规定input内的值</span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placehoud</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span> 男//单选择 名称一致</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span> 女</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>爱好：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 唱歌//多选</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 跳舞</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>//提交按钮 提交表单数据</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>css cascading style sheets 用于定义网页样式和布局的样式表语言，通过CSS，可以指定页面中各个元素的颜色、字体、大小、间距、边框、背景等样式，从而实现更精确的页面设计。</p>
<p>语法：</p>
<p>选择器{</p>
<p>​    属性1：属性值1；</p>
<p>​    属性2：属性值2；</p>
<p>}</p>
<p>内部样式表：放在head里面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:bule;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>:<span class="number">16px</span>;//字体大小</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>:yellow//背景色</span></span><br><span class="line"><span class="language-css">            font-family:<span class="string">&#x27;KaiTi&#x27;</span>//修改字体，楷体</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>外部样式：需在head链接</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;路径&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内联样式：标签内</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color=red;&quot;</span>&gt;</span></span><br><span class="line">    内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优先级：内联样式&gt;内部样式表&gt;外部样式</p>
<p>css选择器：</p>
<p>元素选择器：标签名</p>
<p>类选择器：.+类名</p>
<p>id选择器：#+id名</p>
<p>通用选择器：*</p>
<p>子代选择器：父+&gt;+子</p>
<p>后代选择器：父+空格+子</p>
<p>相邻元素选择器：1+2    需要满足相邻条件</p>
<p>伪类选择器</p>
<p>css属性：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-reference.html">CSS 参考手册 |菜鸟教程</a></p>
<p><code>&lt;h1 style=&quot;font: bolder 50px &#39;KaiTi&#39;;&quot;&gt;复合属性&lt;/h1&gt;</code> font符合属性示例</p>
<p>区分块、行内、行内块元素width和height的差异</p>
<p>通过display转换以上三者(block,inline,inline-block)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.div-inline&#123;</span><br><span class="line">	display:inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>盒子模型：</p>
<ol>
<li>内容（content）</li>
<li>内边距（padding）：内容与边框之间的空间</li>
<li>边框（border）：盒子的边界  上右下左</li>
<li>外边距（margin）：盒子与其他元素之间的空间</li>
</ol>
<p><img src="/2025/02/15/%E5%AD%A6%E4%B9%A0/python-web/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/asdsdf.png" alt="asdsdf"></p>
<p>浮动：改变元素默认的排列顺序，使网页布局更加灵活多变(letf right)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.son&#123;</span><br><span class="line">	float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除浮动的方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定位布局：</p>
<p>相对定位(relative)∶相对于元素在文档流中的正常位置进行定位。</p>
<p>绝对定位(absolute)︰相对于其最近的已定位祖先元素进行定位，不占据文档流。</p>
<p>固定定位(fixed)︰相对于浏览器窗口进行定位。不占据文档流，固定在屏幕上的位置，不随滚动而移动。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box-relative&#123;</span><br><span class="line">	position: relative;//相对定位</span><br><span class="line">	left:</span><br><span class="line">	right:</span><br><span class="line">	top:</span><br><span class="line">	bottom:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript是一种轻量级、解释型、面向对象的脚本语言。它主要被设计用于在网页上实现动态效果，增加用户与网页的交互性。<br>作为一种客户端脚本语言，JavaScript可以直接嵌入HTML，并在浏览器中执行。<br>与HTML和CSS不同，JavaScript使得网页不再是静态的，而是可以根据用户的操作动态变化的。</p>
<p><code>客户端脚本</code>:用于在用户浏览器中执行，实现动态效果和用户交互。</p>
<p><code>网页开发</code>:与HTML和CSS协同工作，使得网页具有更强的交互性和动态性。</p>
<p><code>后端开发</code>︰使用Node.js，JavaScript 也可以在服务器端运行，实现服务器端应用的开发。</p>
<p>js的导入</p>
<p>内联</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello,world&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>外联</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;相对路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello,world&#x27;</span>)<span class="comment">//控制台输出</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;&#x27;</span>)<span class="comment">//内联弹窗</span></span><br></pre></td></tr></table></figure>
<p>js语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="keyword">var</span> x;<span class="comment">//varible</span></span><br><span class="line"><span class="keyword">let</span> t=<span class="number">5</span>;<span class="comment">//块级作用域</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> =<span class="number">3.14</span>;<span class="comment">//常量</span></span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line"><span class="comment">//循环，for，while</span></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">function_name</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用html属性触发事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;click_event()&quot;</span>&gt;</span></span><br><span class="line">        点击事件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onfocus</span>=<span class="string">&quot;focus_event()&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;blur_event()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="keyword">function</span> <span class="title function_">click_event</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;触发点击事件&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">focus_event</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取焦点&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">blur_event</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失去焦点&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>DOM</p>
<p>当网页被加载时，浏览器会创建页面的文档对象模型，也就是DOM (Document Object Model) .每个HTML或XML文档都可以被视为一个文档树，文档树是整个文档的层次结构表示。</p>
<p>文档节点是整个文档树的根节点。</p>
<p>DOM为这个文档树提供了一个编程接口，开发者可以使用JavaScript来操作这个树状结构。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>ID选择器标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>类选择器标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">        点击按钮</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">scrip</span>&gt;</span></span><br><span class="line">    	var element_id = document.getElementById(&#x27;box1&#x27;);//id唯一，获取的是元素</span><br><span class="line">        console.log(element_id)</span><br><span class="line">		</span><br><span class="line">        var element_class = document.getElementsByClassName(&#x27;box2&#x27;)[0];//类不唯一，获取的是数组</span><br><span class="line">        console.log(element_id)</span><br><span class="line">        </span><br><span class="line">        element_id.innerHTML = &#x27;修改id标签内容&#x27;;</span><br><span class="line">        element_id.innerText</span><br><span class="line">        element_id.style.color</span><br><span class="line">        element_id.style.fontSize</span><br><span class="line">        </span><br><span class="line">        //DOM属性绑定事件</span><br><span class="line">        var button_element = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">        </span><br><span class="line">        button_element.onclick = function()&#123;</span><br><span class="line">        	alert(&#x27;DOM 属性按键触发&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        button)element.addEventListener(&#x27;click&#x27;,click_event)</span><br><span class="line">        function click_event()&#123;</span><br><span class="line">        	alert(&#x27;通过addEventListener触发&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">scrip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>对象</strong></p>
<p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型</p>
<p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;itbaizhan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;13&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（property），它的“键</p>
<p>值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="title function_">getName</span>(<span class="string">&quot;itbaizhan&quot;</span>) <span class="comment">// itbaizhan</span></span><br></pre></td></tr></table></figure>
<p><img src="/2025/02/15/%E5%AD%A6%E4%B9%A0/python-web/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF1/image-20211025173456785.png" alt="image-20211025173456785"></p>
<h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1BT4y1W7Aw/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">3小时前端入门教程（HTML+CSS+JS）_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">大创——模型环境配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-21 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-21T00:00:00+08:00">2025-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-13 17:20:56" itemprop="dateModified" datetime="2025-07-13T17:20:56+08:00">2025-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" itemprop="url" rel="index"><span itemprop="name">项目经历</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E5%A4%A7%E5%88%9B/" itemprop="url" rel="index"><span itemprop="name">大创</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="模型环境配置"><a href="#模型环境配置" class="headerlink" title="模型环境配置"></a>模型环境配置</h3><p>利用yml导入conda虚拟环境</p>
<p><img src="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/sad.png" alt="sad"></p>
<p>安装cuda与cudnn</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44779079/article/details/141528972">cuda和cudnn的安装教程(全网最详细保姆级教程)_cudnn安装-CSDN博客</a></p>
<p>使用国内源安装</p>
<p><code>pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p><code>pip install --upgrade tensorflow -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p>测试gpu运行</p>
<p><img src="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/as.png" alt="as"></p>
<p><img src="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/daf.png" alt="daf"></p>
<p>根据提示补全依赖项</p>
<p>datasetProcess.py 将视频文件转换为 NumPy 数组（.npy 文件），并保存到指定目录中</p>
<p>models_rgb_depth.py 模型</p>
<p>evaluate_rgb_depth.py 跑数据集，返回准确度</p>
<p><img src="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/asd.png" alt="asd"></p>
<p>prediction_test.py 返回true or false</p>
<p><img src="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/sadff.png" alt="sadff"></p>
<p>前两者需要输入命令行参数</p>
<p><code>python evaluate_rgb_depth.py --dataset rwf2000 --vidLen 32 --batchSize 4 --mode all --lstmType sepconv --fusionType C --weightsPath models/rgb_rgbdiff_depth_C_6/rwf2000_best_val_acc_Model</code></p>
<p><img src="/2025/01/21/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B5%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/gadga.png" alt="gadga"></p>
<ul>
<li><code>--dataset rwf2000</code>: 指定数据集为 <code>rwf2000</code>。</li>
<li><code>--vidLen 32</code>: 每个视频序列的帧数为 32。</li>
<li><code>--batchSize 4</code>: 训练和评估的批量大小为 4。</li>
<li><code>--mode all</code>: 模型工作模式为 <code>all</code>，即使用视频帧、帧差和深度图三种输入。</li>
<li><code>--lstmType sepconv</code>: 使用 <code>sepconv</code> 类型的 LSTM 层。</li>
<li><code>--fusionType C</code>: 使用 <code>C</code> 类型的融合策略（特征拼接和注意力机制）。</li>
<li><code>--weightsPath models/rgb_rgbdiff_depth_C_6/rwf2000_best_val_acc_Model</code>: 指定预训练权重文件路径。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数据结构——查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-15T00:00:00+08:00">2024-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-26 17:47:48" itemprop="dateModified" datetime="2025-06-26T17:47:48+08:00">2025-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大二上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="查找的概念"><a href="#查找的概念" class="headerlink" title="查找的概念"></a>查找的概念</h2><p><strong>查找(Searching)</strong> ：就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素( 或记录)。</p>
<p><strong>查找表(Search Table)</strong> ：是由同一类型的数据元素(或记录)构成的集合。</p>
<p><strong>关键字(Key)</strong> ：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。</p>
<p><strong>静态查找表(Static Search Table)</strong> ：只作查找操作的查找表。<br><strong>动态查找表(Dynamic Search Table)</strong> ： 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</p>
<p><strong>平均查找长度</strong> ：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度，则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为$\ ASL=\sum_{i=1}^{n}P_iC_i$</p>
<p>式中，n是查找表的长度;P是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即P,= 1/n;C;是找到第i个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。</p>
<h2 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有哨兵顺序查找*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	a[<span class="number">0</span>] = key;	<span class="comment">//设置a[0]为关键字，称之为“哨兵”</span></span><br><span class="line">	i = n;	<span class="comment">//循环从数组尾部开始</span></span><br><span class="line">	<span class="keyword">while</span>(a[i] != key)&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;	<span class="comment">//返回0则说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。<br>上述顺序表查找时间复杂度是O (n) 。</p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>当查找表是有序表时，可采用折半查找的方法。</p>
<p>算法思路：</p>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/image-20241215134842077.png" alt="image-20241215134842077"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>, high = L.length - <span class="number">1</span>, mid;</span><br><span class="line">	<span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">		mid = (low + hight)/<span class="number">2</span>;	<span class="comment">//取中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(L.elem[mid] == key)&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;	<span class="comment">//查找成功返回所在位置</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)&#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;	<span class="comment">//从后半部分继续查找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/image-20241215134858075.png" alt="image-20241215134858075"></p>
<p>折半查找的过程可用二叉树来描述，称为判定树。</p>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/image-20241215135512761.png" alt="image-20241215135512761"></p>
<p>节点的树高代表该节点的查询次数</p>
<p>因此，长度为13的有序表进行折半查找的平均查找长度ASL=(1×1+2×2+3×4+4×6)/13 =41/13。</p>
<p>折半查找的时间复杂度为$\ O(\log_2n)$，平均情况下比顺序查找的效率高。</p>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。</p>
<p>分块有序，是把数据集的记录分成了若千块，并且这些块需要满足两个条件：</p>
<ul>
<li><p>块内无序：即每一块内的记录不要求有序。</p>
</li>
<li><p>块间有序：例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字…因为只有块间有序，才有可能在查找时带来效率。</p>
</li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项， 这种索引方法叫做分块索引。如下图所示，我们定义的分块索引的索引项结构分三个数据项：</p>
<ul>
<li><p>最大关键码：它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大；</p>
</li>
<li><p>块长：存储了块中的记录个数，以便于循环时使用；</p>
</li>
<li>块首指针：用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/825a789b2d39804be6b9aede1bbc0ba1.png" alt="825a789b2d39804be6b9aede1bbc0ba1"></p>
<p>在分块索引表中查找，就是分两步进行:<br>1.在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。例如在上图的数据集中查找62，我们可以很快可以从左上角的索引表中由57&lt;62&lt;96得到62在第三个块中。<br>2.根据块首指针找到相应的块，并在块中顺序查找关键码。</p>
<h2 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树(也称二叉查找树)或者是一棵空树，或者是具有下列特性的二叉树:</p>
<ol>
<li>若左子树非空，则<strong>左子树上所有结点的值均小于根结点的值</strong>。</li>
<li>若右子树非空，则<strong>右子树上所有结点的值均大于根结点的值</strong>。</li>
<li>左、右子树也分别是一棵二叉排序树。</li>
</ol>
<p>根据二叉排序树的定义，左子树结点值&lt;根结点值&lt;右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，下图所示二叉排序树的中序遍历序列为123468。</p>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/bec1d08d423a4860887667fb980dfbea.png" alt="bec1d08d423a4860887667fb980dfbea"></p>
<h4 id="二叉排序树的插入和建立"><a href="#二叉排序树的插入和建立" class="headerlink" title="二叉排序树的插入和建立"></a>二叉排序树的插入和建立</h4><p>在一棵二叉排序树中插入值为系的结点的步骤如下：</p>
<p>①若二叉排序树为空，则生成值为k的新结点s，同时将新结点s作为根结点插入。</p>
<p>②若k小于根结点的值,则在根的左子树中插入值为k的结点。</p>
<p>③若k大于根结点的值,则在根的右子树中插入值为k的结点。</p>
<p>④若k等于根结点的值，表明二叉排序树中已有此关键字，则无需插入。</p>
<p>二叉排序树插入算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//构造函数</span></span><br><span class="line"> <span class="built_in">BiNode</span>(<span class="type">int</span> k) : <span class="built_in">key</span>(k), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// 递归插入函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(BiNode*&amp; ptr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果当前指针为空，插入新节点</span></span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="built_in">BiNode</span>(k);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; ptr-&gt;key) &#123; </span><br><span class="line">            <span class="built_in">Insert</span>(ptr-&gt;lchild, k); <span class="comment">// 递归插入到左子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; ptr-&gt;key) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(ptr-&gt;rchild, k); <span class="comment">// 递归插入到右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果k等于当前节点值，则不插入（BST通常不允许重复值）</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 插入值到BST</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Insert</span>(root, k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>二叉排序树的建立</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数：利用数组 a[] 和大小 n 建立二叉排序树</span></span><br><span class="line">    <span class="built_in">BiSortTree</span>(<span class="type">int</span> a[], <span class="type">int</span> n) &#123;</span><br><span class="line">        root = <span class="literal">nullptr</span>; <span class="comment">// 初始化根节点为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(root, a[i]); <span class="comment">// 插入数组中的每个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/image-20241215144119644.png" alt="image-20241215144119644"></p>
<h4 id="二叉排序树的查找过程"><a href="#二叉排序树的查找过程" class="headerlink" title="二叉排序树的查找过程"></a>二叉排序树的查找过程</h4><p>根据二叉排序树的定义，在二叉排序树中查找给定值k的过程如下:</p>
<p>①若二叉排序树为空，则表明查找失败，返回空指针;否则，若给定值k等于根结点的值,则表明查找成功,返回根结点。</p>
<p>②若给定值k小于根结点的值,则继续在根的左子树中查找。</p>
<p>③若给定值k大于根结点的值,则继续在根的右子树中查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归查找函数</span></span><br><span class="line">   <span class="function">BiNode* <span class="title">Search2</span><span class="params">(BiNode* ptr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (ptr) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k == ptr-&gt;key) <span class="comment">// 找到目标节点</span></span><br><span class="line">               <span class="keyword">return</span> ptr;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; ptr-&gt;key) <span class="comment">// 查找左子树</span></span><br><span class="line">               ptr = ptr-&gt;lchild;</span><br><span class="line">           <span class="keyword">else</span>                  <span class="comment">// 查找右子树</span></span><br><span class="line">               ptr = ptr-&gt;rchild;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 未找到</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>若二叉排序树是<strong>平衡的(即形态均匀)</strong>，则进行查找的时间复杂度为$\ O(log_2n)$;若退化为一棵单支树（最极端和最差的情况)，则其时间复杂度为$\ O(n)$。对于一般情况，其时间复杂度可以认为是$\ O(log_2n)$。</p>
<h4 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h4><p>二叉排序树的查找和插入都很简单，但是删除操作就要复杂一些，此时要删除的结点有三种情况：</p>
<ol>
<li>叶子结点；</li>
<li>仅有左或右子树的结点；</li>
<li>左右子树都有的结点；</li>
</ol>
<p>前两种情况都很简单，第一种只需删除该结点不需要做其他操作；第二种删除后需让被删除结点的直接后继接替它的位置；<strong>复杂就复杂在第三种，此时我们需要遍历得到被删除结点的直接前驱或者直接后继来接替它的位置，然后再删除</strong>。</p>
<p>第三种情况如下图所示：</p>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/1fa9d70c1f0ef1ab673061a9c2e39a08.png" alt="1fa9d70c1f0ef1ab673061a9c2e39a08"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，</span></span><br><span class="line"><span class="comment">并返回TRUE;否则返回FALSE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!T)&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">			<span class="comment">//找到关键字等于key的数据元素</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Delete</span>(T);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(T -&gt; lchild, key);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(T -&gt; rchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是Delete()方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从二叉排序树中删除结点p，并重接它的左或右子树。*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(BiTree *p)</span></span>&#123;</span><br><span class="line">	BiTree q, s;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="comment">//右子树为空则只需重接它的左子树</span></span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;lchild;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="comment">//左子树为空则只需重接它的右子树</span></span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//左右子树均不空</span></span><br><span class="line">		q = p;</span><br><span class="line">		s = p-&gt;lchild;	<span class="comment">//先转左</span></span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild)&#123;<span class="comment">//然后向右到尽头，找待删结点的前驱</span></span><br><span class="line">			q = s;</span><br><span class="line">			s = s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//此时s指向被删结点的直接前驱，p指向s的父母节点</span></span><br><span class="line">		p-&gt;data = s-&gt;data;	<span class="comment">//被删除结点的值替换成它的直接前驱的值</span></span><br><span class="line">		<span class="keyword">if</span>(q != p)&#123;</span><br><span class="line">			q-&gt;rchild = s-&gt;lchild;	<span class="comment">//重接q的右子树</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			q-&gt;lchild = s-&gt;lchild;	<span class="comment">//重接q的左子树</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pree</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二叉排序树的查找性能取决于二叉排序树的形状</strong>。</p>
<p>例如{ 62 , 88 , 58 , 47 , 35 , 73 , 51 , 99 , 37 , 93 } {62,88,58,47,35,73,51,99,37,93}{62,88,58,47,35,73,51,99,37,93}这样的数组，我们可以构建如下左图的二叉排序树。但如果数组元素的次序是从小到大有序，如{35,37,47,51,58,62,73,88,93,99},则二叉排序树就成了极端的右斜树，如下面右图的二叉排序树：<br><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/f33a1ebf98e14082fb0df30072964e09.png" alt="f33a1ebf98e14082fb0df30072964e09"></p>
<p>也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂也就为$\ O(\log_2n)$，近似于折半查找。<br>不平衡的最坏情况就是像上面右图的斜树，查找时间复杂度为O(n)，这等同于顺序查找。<br>因此，如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵<strong>平衡的二叉排序树</strong>。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><strong>平衡二叉树</strong>：<strong>是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。</strong></p>
<p>我们<strong>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF</strong></p>
<p>那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/a1f704e077a99af5d0e5491cfbd18b50.png" alt="a1f704e077a99af5d0e5491cfbd18b50"></p>
<h4 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h4><p>新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：</p>
<ol>
<li><strong>LL平衡旋转(右单旋转)</strong>:由于在结点A的左孩子(L)的左子树(L)上插入了新结点</li>
</ol>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/c1f0364ace56db6d49fe314233364370.png" alt="c1f0364ace56db6d49fe314233364370"></p>
<ol>
<li><strong>RR平衡旋转(左单旋转)</strong>:由于在结点A的右孩子(R)的右子树(R)上插入了 新结点</li>
</ol>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/741cd35f51fbb8eab58cd2dbb8988875.png" alt="741cd35f51fbb8eab58cd2dbb8988875"></p>
<ol>
<li><strong>LR平衡旋转(先左后右双旋转)</strong>:由于在A的左孩子(L)的右子树(R)上插入新结点</li>
</ol>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/53cabfa17150d6a0c98b467098d6379d.png" alt="53cabfa17150d6a0c98b467098d6379d"></p>
<ol>
<li><strong>RL平衡旋转(先右后左双旋转)</strong>:由于在A的右孩子(R)的左子树(L)上插入新结点</li>
</ol>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/fcb6dda8bd30d25a55cab887fb332c04.png" alt="fcb6dda8bd30d25a55cab887fb332c04"></p>
<p>举例</p>
<p><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/image-20241215152052099.png" alt="image-20241215152052099"></p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。<br><strong>B树是所有结点的平衡因子均等于0的多路平衡查找树。</strong></p>
<p>下图所示的B树中所有结点的最大孩子数m = 5，因此它是一棵5阶B树，在m mm阶B树中结点最多可以有m个孩子。可以借助该实例来分析上述性质：<br><img src="/2024/12/15/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E6%9F%A5%E6%89%BE/91938989f25f6c683f053d6b71647591.png" alt="91938989f25f6c683f053d6b71647591"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JU411d7iY?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">B树(B-树) - 删除_哔哩哔哩_bilibili</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/114359564">数据结构：查找(Search)【详解】_index.search返回什么结构-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/08/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B4%E2%80%94%E2%80%94%E7%AB%8B%E9%A1%B9%E7%AD%94%E8%BE%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/08/%E7%A7%91%E7%A0%94/%E5%A4%A7%E5%88%9B/%E5%A4%A7%E5%88%9B4%E2%80%94%E2%80%94%E7%AB%8B%E9%A1%B9%E7%AD%94%E8%BE%A9/" class="post-title-link" itemprop="url">大创——立项答辩</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-08 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-08T00:00:00+08:00">2024-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-15 18:15:58" itemprop="dateModified" datetime="2024-12-15T18:15:58+08:00">2024-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" itemprop="url" rel="index"><span itemprop="name">项目经历</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E5%A4%A7%E5%88%9B/" itemprop="url" rel="index"><span itemprop="name">大创</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="答辩稿"><a href="#答辩稿" class="headerlink" title="答辩稿"></a>答辩稿</h2><p>各位评委老师大家好，我是我们组的主持人张熙浚，我们组的研究方向是基于多模态特征融合的视频暴力行为识别方法的研究</p>
<p>接下来我会从四个方面介绍我们的项目</p>
<p>首先是背景与意义，暴力行为对社会危害极大，即使公共场所存在大量监控摄像头，但这些视频片段通常被用来在暴力犯罪发生后提供线索和证据，而很少被用来实时监控并阻止暴力行为。</p>
<p>由于监控人员不可能实时监控每一个摄像头产生的视频，所以部署暴力行为监测系统，能够节约人力资源，降低监控人员因疲劳而造成的风险，这十分关键</p>
<p>接下来，我将讲述当前暴力行为检测的研究现状。主流的人体动作识别把数据模态分为2类：视觉模态和非视觉模态。不同模态的数据有着各自的独特优势。</p>
<p>目前主流的单模态深度学习方法存在以下缺点。但真实的暴力事件场景往往存在以下特点。因此，我们提出了基于多模态的暴力事件检测，通过结合多种数据来源，从多个角度捕捉行为特征，尤其是在面对复杂环境、多人交互和遮挡等问题时，具有显著的优势。</p>
<p>接下来我会通过几篇论文中的方法介绍行为识别算法的研究现状</p>
<p>这一篇提出了数据集Rwf-2000，同时提出一种的双流网络架构，他们充分利用了RGB数据提供的外观信息和光流提供的运动信息，但缺点在于光流法计算量大、存储成本高，仅仅适用于光照条件良好、不拥挤的情况</p>
<p>这一篇是基于骨架的方法，通过提取人体骨骼关节，构成三维骨架阵列，通过骨架点卷积，实现分类。</p>
<p>优点是骨架可以很好的表示人体运动信息，但问题在于仅使用骨架数据，效果高度依赖于位姿估计的精度，无法有效应对存在遮挡的情况，同时因为仅使用骨架数据，其他信息存在缺失</p>
<p>这一篇是基于 2D CNN + RNN 的方法，2D CNN 提供强大的空间特征提取能力，RNN 提供强大的时间序列建模能力。将两者结合，能够更好地理解视频中的空间和时间信息。这一篇使用简单快速的预处理方法减少了冗余的背景信息，但其仅使用RGB模态，提取的特征不够全面</p>
<p>接下来我将介绍我们的研究内容与方法</p>
<p>我们的研究内容大致包含三个部分：1.提出一种基于多模态特征融合的视频暴力行为识别算法2.提出一种自适应的注意力算法用于多模态融合3.完成人体暴力行为检测系统的设计，接下来我将依次为大家介绍</p>
<p>第一部分，在特征提取阶段，为了区分暴力行为与非暴力行为，我们选择了三个要素进行提取：人体姿态、运动趋势和幅度、人物之间的位置关系，为了获取以上三个要素，研究工作包括下列内容： </p>
<p>a.RGB模态的去除冗余信息<br>为了避免原生RGB图像冗余信息影响模型判断，我们决定对于原生RGB图像进行冗余信息去除工作，首先计算一个视频中所有帧的均值，记为平均帧，用每一帧减去平均帧：去除不变的背景，保留运动的人体。</p>
<p>b.运动趋势与幅度特征的提取<br>目前主流反映物体运动趋势的方法是光流法，但我们考虑到光流图像在低像素复杂场景下效果不佳，且易受光照条件改变，并且计算量巨大，于是我们决定采取帧差法，通过对视频图像序列中相邻两帧作差分运算，来获得运动目标轮廓，以很好地适用于存在多个运动目标的情况。</p>
<p>c.深度模态的提取<br>在原始的RGB模态，复杂场景中难以分辨人物间的相对位置关系。因此，我们选取深度模态，其去除了颜色和纹理信息，并提供三维结构信息和人体轮廓，我们利用该论文提出的深度估计算法，对原始RGB视频进行深度估计，得到深度图，其清晰地反映了三维空间中人物间的相对位置关系。</p>
<p>算法框架方面，我们选择了CNN-LSTM的深度学习网络<strong>。</strong>LSTM擅长处理时序数据，而CNN能够从视频帧中提取空间特征。通过结合两者的优势，并以此构建了算法框架。</p>
<p>第二部分我们提出了一种自适应的注意力算法用于多模态融合，动态调整每个模态的权重，强调有用的信息特征，抑制不太有用的特征，从而应对不同场景。</p>
<p>池化，全连接层，归一化函数</p>
<p>第三部分，我们完成了人体暴力行为检测系统的设计，刻画了系统的边界及大小，人体暴力行为检测系统是一个自动检测暴力行为的智能视频监控系统。该系统采用了四层架构，即访问层，表示层、业务层以及数据层。 包含暴力检测模块，用户管理模块，视频源管理模块</p>
<p>我们已经初步构建了暴力行为的检测流程，系统包含离线分析和在线监测两种模式</p>
<p>为了提高检测速度和避免资源浪费，根据传入视频的总帧数进行判断，采取提示过短、一次预测或是多轮预测。</p>
<p>离线分析不依赖实时的监控视频，可对任意视频进行分析。它 的优点是它不依赖于视频监控系统，可以直接选择视频开始分析。</p>
<p>在线监测是暴力行为检测系统提供的另一种检测方式。它旨在利用监控视频资源，进行实时的暴力行为检测，达到即时分析并报警提示的功能。</p>
<p>最后是进度安排，我们已经完成算法大部分的编写，后续会继续完成系统的开发</p>
<p>谢谢各位老师观看，请各位老师批评指正</p>
<h2 id="疑问与解惑"><a href="#疑问与解惑" class="headerlink" title="疑问与解惑"></a>疑问与解惑</h2><h3 id="为什么暴力行为检测隶属于人体行为识别"><a href="#为什么暴力行为检测隶属于人体行为识别" class="headerlink" title="为什么暴力行为检测隶属于人体行为识别"></a>为什么暴力行为检测隶属于人体行为识别</h3><p>人体行为识别（Human Activity Recognition, HAR）是一个广泛的领域，旨在通过传感器或视频数据来识别和分析人的各种动作或行为。暴力行为检测（Violent Behavior Detection, VBD）是这一领域的一个子任务，其核心目标是识别出具有暴力性质的特定行为，如打斗、推搡、殴打等。</p>
<p>暴力行为检测隶属于人体行为识别，主要原因是暴力行为本质上也是一种“人体行为”，通过分析人体的运动模式、姿态变化、动作轨迹等特征，能够有效识别出暴力事件。</p>
<h3 id="对于暴力行为的定义是什么？"><a href="#对于暴力行为的定义是什么？" class="headerlink" title="对于暴力行为的定义是什么？"></a>对于暴力行为的定义是什么？</h3><p>暴力行为通常指的是一种以伤害他人或具有威胁性、攻击性目的的行为。</p>
<h3 id="之前的暴力行为检测方向是什么，现在侧重于人体动作本身有什么好处吗？"><a href="#之前的暴力行为检测方向是什么，现在侧重于人体动作本身有什么好处吗？" class="headerlink" title="之前的暴力行为检测方向是什么，现在侧重于人体动作本身有什么好处吗？"></a>之前的暴力行为检测方向是什么，现在侧重于人体动作本身有什么好处吗？</h3><p>暴力行为的检测方法<strong>传统上</strong>主要依赖于视频监控中检测到的图像信息、声音信号以及动作的特征。早期的检测方法侧重于基于背景和环境的变化,声学信号分析</p>
<p>现代的暴力行为检测越来越注重<strong>人体动作本身的识别</strong>，这有几个显著的好处：</p>
<ol>
<li><strong>精确度提高</strong>：通过分析人体动作的细节，尤其是肢体的动态变化（如运动轨迹、速度、姿势变化），可以更准确地判断是否为暴力行为。</li>
<li><strong>降低误报率</strong>：单纯依靠环境变化或者声学分析容易受其他因素干扰（如背景噪音、非暴力事件的运动），而人体动作本身可以提供更加直接、可靠的行为判定依据。</li>
<li><strong>多模态融合</strong>：现代的暴力行为检测往往不仅仅依赖于单一的视觉信息，还结合了深度学习、动作识别等技术，可以从多个角度进行判断。通过分析人体动作特征和其他环境数据（如声音、位置等），可以更好地识别暴力事件。</li>
<li><strong>实时监控</strong>：实时检测人体动作变化对于暴力行为的早期预警至关重要，尤其是在公共安全或视频监控系统中，动作识别可以即时检测到潜在的暴力行为并进行响应。</li>
</ol>
<p>综上，侧重人体动作本身不仅可以提升检测的准确性，还能更好地从动态和连续的角度识别暴力行为，提高系统的实时性和鲁棒性。</p>
<h3 id="单模态的人体动作识别的缺点有哪些"><a href="#单模态的人体动作识别的缺点有哪些" class="headerlink" title="单模态的人体动作识别的缺点有哪些"></a>单模态的人体动作识别的缺点有哪些</h3><p>单模态人体动作识别（即仅使用一种数据模态，如视觉、声音、加速度等）存在以下主要缺点：</p>
<ol>
<li><p><strong>信息局限性</strong>：</p>
<p>单一模态只能捕获动作的部分信息，可能导致对动作的理解不够全面。例如，仅依赖视觉模态可能无法捕获细微的物理接触或动作的力度变化。</p>
</li>
<li><p><strong>环境敏感性</strong>：</p>
<p>单模态方法对环境条件过于依赖。例如，视觉模态在光照不足或存在遮挡的情况下表现不佳，而非视觉模态（如加速度计）在传感器未正确佩戴或被干扰时表现不佳。</p>
</li>
<li><p><strong>无法应对模糊或模态冲突</strong>：</p>
<p>单模态方法难以处理模糊的行为信号或区分相似动作。例如，在视觉模态中，某些动作（如挥手与投掷）可能在外观上十分相似。</p>
</li>
<li><p><strong>鲁棒性差</strong>：</p>
<p>单模态在面对复杂场景（如多人交互、噪音、遮挡等）时，容易出现误判或漏判。例如，在仅依赖声音模态时，背景噪音可能干扰动作识别。</p>
</li>
<li><p><strong>缺乏上下文信息</strong>：</p>
<p>单模态通常难以捕获行为发生的上下文。例如，仅通过视觉识别到一个人弯腰的动作，可能无法判断是捡拾物品还是摔倒</p>
</li>
</ol>
<h3 id="暴力行为场景有哪些特点，使用多模态对这些特点的优势有哪些"><a href="#暴力行为场景有哪些特点，使用多模态对这些特点的优势有哪些" class="headerlink" title="暴力行为场景有哪些特点，使用多模态对这些特点的优势有哪些"></a>暴力行为场景有哪些特点，使用多模态对这些特点的优势有哪些</h3><p>暴力行为场景通常具有以下几个显著特点，这些特点对检测系统提出了更高的要求：</p>
<ol>
<li><p><strong>动态性强</strong>：</p>
<p>暴力行为往往是迅速发生的，例如打斗、推搡、摔倒等动作可能在短时间内完成，导致动作的变化非常快。</p>
</li>
<li><p><strong>多人交互</strong>：</p>
<p>暴力行为通常涉及两个或更多个体之间的互动，如互相推搡、打斗或攻击等。多个目标的运动和交互增加了识别的复杂度。</p>
</li>
<li><p><strong>复杂的姿态变化</strong>：</p>
<p>暴力行为中的人物姿态变化通常非常剧烈，涉及肢体的快速摆动、抓握、推拉等动作，且可能伴随一定的身体接触。</p>
</li>
<li><p><strong>不规则的空间布局</strong>：</p>
<p>在暴力行为场景中，人物可能会在空间内迅速移动，动作的方向和速度可能会发生剧烈变化。背景也可能因为人物的动态而发生显著变化。</p>
</li>
<li><p><strong>潜在的遮挡</strong>：</p>
<p>在暴力行为中，人物之间的动作可能会出现遮挡（例如，两人打斗时，其中一个人可能被另一个人挡住）。这种情况给基于视觉的检测带来了挑战。</p>
</li>
<li><p><strong>噪声与干扰因素</strong>：</p>
<p>背景中的其他活动、环境变化、背景噪声等都可能干扰暴力行为的识别。例如，打斗声可能被背景音乐、交通噪声等因素掩盖。</p>
</li>
</ol>
<p>多模态（即结合多种数据来源或感知方式，如视觉、声音、传感器数据等）方法能够弥补单模态方法的不足，通过结合视觉、声音和传感器等多模态信息，可以更好地应对这些挑战，提升暴力行为检测的准确性、鲁棒性和实时性。多模态方法能够综合各类信息，从多个角度捕捉行为特征，尤其是在面对复杂环境、多人交互和遮挡等问题时，具有显著的优势。</p>
<h3 id="2D-CNN-RNN-的优点"><a href="#2D-CNN-RNN-的优点" class="headerlink" title="2D CNN + RNN 的优点"></a>2D CNN + RNN 的优点</h3><p>2D CNN（卷积神经网络）与 RNN（递归神经网络）的结合是行为识别中的一种常见方法，尤其适用于视频行为识别任务。其主要优点包括：</p>
<ol>
<li><strong>空间特征与时间依赖性的有效结合</strong>：</li>
</ol>
<ul>
<li><strong>2D CNN</strong>：能够从视频帧中提取空间特征，如人物的姿态、背景和动作细节。通过多层卷积，CNN能够识别局部和全局的空间信息。</li>
<li><strong>RNN（LSTM/GRU）</strong>：RNN特别擅长处理时序数据，可以建模视频帧之间的时间依赖关系，捕捉动作的动态变化和时间长短的依赖，适应动作序列的连续性和长期依赖。</li>
<li><strong>优点</strong>：2D CNN 提供强大的空间特征提取能力，RNN 提供强大的时间序列建模能力。将两者结合，能够更好地理解视频中的空间和时间信息，提升行为识别的准确性。</li>
</ul>
<ol>
<li><strong>自动特征学习</strong>：</li>
</ol>
<ul>
<li>传统方法依赖手工特征提取（如HOG、光流等），需要依赖专家知识且难以适应多样的场景。而 <strong>2D CNN</strong> 能够自动学习空间特征，减少了人工设计特征的依赖，提高了对复杂场景的适应能力。</li>
<li><strong>RNN</strong> 则可以自动从数据中学习到行为模式的时间序列特征，不需要事先设定固定的时间模型或参数。</li>
</ul>
<ol>
<li><strong>鲁棒性强，适应性好</strong>：</li>
</ol>
<ul>
<li><strong>2D CNN</strong> 通过卷积层提取多层次的空间特征，具有较好的鲁棒性，能够应对不同背景和复杂场景中的视频数据。</li>
<li><strong>RNN</strong> 具有处理不规则、可变时间长度序列的能力，能够识别动态变化的动作和突发行为，提高了模型的适应性。</li>
</ul>
<ol>
<li><strong>可扩展性强</strong>：</li>
</ol>
<ul>
<li>2D CNN 和 RNN 的组合能够很好地扩展到不同的视频数据规模、场景和复杂度上。随着数据集的增大，模型仍然能够通过更深的网络层次和更多的时序数据进行训练，进一步提升识别效果。</li>
</ul>
<h2 id="答辩稿——初版"><a href="#答辩稿——初版" class="headerlink" title="答辩稿——初版"></a>答辩稿——初版</h2><p>各位评委老师大家好，我是我们组的主持人张熙浚，我们组的研究方式是基于多模态特征融合的视频暴力行为识别方法研究</p>
<p>接下来我会从五个方面介绍我们的项目</p>
<p>首先是背景与意义，暴力行为对社会危害极大，即使诸如学校、商场、银行、车站等公共场所存在大量监控摄像头，产生了大量的视频片段，但这些片段通常被用来在暴力犯罪发生后提供线索和证据，而很少被用来实时识别并停止暴力行为。</p>
<p>这便引出了我们项目的目的，我们希望利用计算机视觉技术，赋予机器暴力行为的判别能力，从而及时发现暴力行为并能有效降低其带来的危害，而且大大降低了人力成本，在安防领域有极大的应用价值。</p>
<p>暴力行为的检测方法早期的检测方法主要是依靠设立一些规则，或是依靠背景和环境的变化，这些方法在很多方面存在不足，包括受环境因素影响大，特征提取和分析能力有限，计算效率低等问题</p>
<p>而现代的暴力行为检测越来越注重<strong>人体动作本身的识别</strong>，其通过分析人体动作的细节，尤其是肢体的动态变化，不仅可以提升检测的准确性，还能更好地从动态和连续的角度识别暴力行为，提高系统的实时性和鲁棒性。</p>
<p>由于监控人员不可能实时监控每一个摄像头产生的视频，所以部署视频暴力行为识别系统，能够节约用于监控的人力资源，降低监控人员因疲劳或走神而造成的漏检风险，一旦识别到暴力行为立即警示相关人员，进一步采取相应措施。由此可以得出我们项目研究的现实意义和应用场景。</p>
<p>接下来，我将讲述当前暴力行为检测的研究背景和挑战，并引出我们的解决方案。多种不同的数据形态都可以用来表示人类的动作和行为。主流的人体动作识别把这些模态分为2类：视觉模态和非视觉模态。这些数据模态是对不同的信息来源进行编码，根据应用场景的不同，不同模态的数据有着不同的独特优势。</p>
<p>目前主流的单模态深度学习方法存在以下缺点：信息单一、对环境敏感、鲁棒性较差，难以应对复杂场景等。但真实的暴力事件场景往往存在以下特点：存在复杂姿态变化，多人交互，大量环境噪声等。因此，我们提出了基于多模态的暴力事件检测，通过结合多种数据来源，从多个角度捕捉行为特征，尤其是在面对复杂环境、多人交互和遮挡等问题时，具有显著的优势。</p>
<p>随着深度学习和计算机视觉技术的发展，深度学习方法已经成为了行为识别算法的主流方向，接下来我会通过几篇论文中的方法介绍研究现状</p>
<p>这一篇是早提出使用深度学习方法解决视频暴力行为识别任务，直接将视频输入三维卷积进行建模</p>
<p>这一篇提出了数据集Rwf-2000，同时提出一种的双流网络架构，他们充分利用了RGB数据提供的外观信息和光流提供的运动信息，但缺点在于光流法计算、存储成本高，适用于光照条件良好、不拥挤的情况</p>
<p>这一篇提出了一种弱监督方法，即通过少量的标签（例如，仅标记视频是否包含暴力，而不是标记具体的暴力事件位置和类型）来训练模型。他选取视频帧最关键的区域，但使用I3D作为骨干网络，参数量巨大（1300万）</p>
<p>这一篇是基于骨架的方法，通过提取人体骨骼关节点构成三维骨架阵列，根据局部区域点的特征和时空位置信息，构建特定的权重分布策略，通过骨架点卷积实现分类。优点是骨架可以很好的表示人体运动信息，但问题在于仅使用骨架数据，效果高度依赖于位姿估计的精度，无法有效遮挡情况，同时因为仅使用骨架数据，其他信息缺失</p>
<p>这一篇是基于 2D CNN + RNN 的方法，2D CNN 提供强大的空间特征提取能力，RNN 提供强大的时间序列建模能力。将两者结合，能够更好地理解视频中的空间和时间信息，提升行为识别的准确性。这一篇使用简单快速的预处理方法突出了人体，减少了冗余的背景信息，但其仅使用RGB模态，提取的特征不够全面</p>
<p>我们的研究内容大致包含三个部分：1.提出一种基于多模态特征融合的视频暴力行为识别算法2.提出一种自适应的注意力算法用于多模态融合3.完成人体暴力行为检测系统的设计，接下来我将依次为大家介绍</p>
<p>第一部分，在特征提取阶段，为了区分暴力行为与非暴力行为，我们选择了三个要素进行提取：人体姿态、运动（趋势、幅度）、人物之间的位置关系，为了获取以上三个要素，并保证模型的通用性和现实性，需要从原始的RGB图像中提取以上特征，研究工作包括下列内容： </p>
<p>a.RGB模态的去除冗余信息<br>  为了避免原生RGB图像冗余信息影响模型判断，减少计算量，我们决定对于原生RGB图像进行冗余信息去除工作，首先计算一个视频中所有帧的均值，记为平均帧（主要包含背景信息，因为背景在所有视频帧中几乎保持不变）用每一帧减去平均帧：去除（不变的）背景，保留（运动的）人体。通过简易的预处理，去除了冗余的背景信息，聚焦于人体的外观、姿态。</p>
<p>b.运动趋势与幅度特征的提取<br>目前主流反映物体运动趋势的方法是光流法，但我们考虑到光流图像在低像素复杂场景下效果不佳，且易受光照条件改变的影响，于是决定采取帧差法，通过对视频图像序列中相邻两帧作差分运算来获得运动目标轮廓的方法，以很好地适用于存在多个运动目标的情况，算法相对实现简单，程序设计复杂度低，对光线等场景变化不太敏感，能够适应各种动态环境，有着比较强的鲁棒。</p>
<p>c.深度模态的提取<br>在原始的RGB模态中，复杂场景中，人物多且受光照影响严重，难以分辨人物间的相对位置关系。为了反映人物之间的位置关系，我们选取深度模态，其去除了颜色和纹理信息并提供三维结构信息和人体轮廓，我们利用Depth estimation算法，对原始RGB视频进行深度估计，得到视点到场景中各点之间的距离作为像素点的图片，即深度图，其划分了近景与远景，刻画了人物的轮廓，反映了三维空间中人物间的相对位置关系。</p>
<p>我们选择了CNN-LSTM的深度学习方法<strong>。</strong>LSTM擅长处理时序数据，可以建模视频帧之间的时间依赖关系，而CNN能够从视频帧中提取空间特征。通过结合两者的优势，我们可以让模型同时考虑到数据的时序信息和空间信息，减少参数降低过拟合风险，从而提供更精确的预测、更出色的性能以及更高的训练效率，并以此构建了算法思路。</p>
<p>第二部分，针对多模态融合中权重数值处理的问题，我们提出了一种自适应的注意力算法用于多模态融合，让模型自适应地学习不同模态特征之间的权重关系，允许模型根据具体任务动态调整每个模态的重要性，强调信息特征，抑制不太有用的特征,从而更灵活地应对不同的场景。</p>
<p>第三部分，我们完成了人体暴力行为检测系统的设计，刻画了系统的边界及大小，人体暴力行为检测系统是一个自动检测暴力行为的智能视频监控系统。该系统采用了三层架构，即表示层、业务层以及数据层。 它被设计成一个Web系统，主要以网页的形式显示在PC 显示器上</p>
<p>我们已经初步构建了暴力行为的检测流程，系统包含离线分析和在线监测两种模式</p>
<p>离线分析不依赖实时的监控视频，可对任意视频进行后处理式的分析。它 的优点是它不依赖于视频监控系统，可以直接选择视频开始分析，在视频来源 和分析时机的选择上更自由。</p>
<p>在线监测是人体暴力行为检测系统提供的另一种检测方式。它旨在利用监 控视频资源，进行实时的暴力行为检测，达到即时分析并报警提示的功能。这 一功能极大地降低了人工分析实时监控视频的成本，便于管理人员进行安全监 管，提高了监管的效率。</p>
<p>为了提高检测速度和避免资源浪费，根据传入视频的总帧数进行判断，采取提示过短、一次预测或是多轮预测。</p>
<p>最后是进度安排，我们已经完成算法大部分的编写，后续会继续完成系统的开发</p>
<p>谢谢各位老师观看，请各位老师批评指正</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LangChain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LangChain/" class="post-title-link" itemprop="url">机设——Langchain与LLM集成解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-07T00:00:00+08:00">2024-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:41:44" itemprop="dateModified" datetime="2025-06-12T18:41:44+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" itemprop="url" rel="index"><span itemprop="name">项目经历</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E6%9C%BA%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">机设</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="了解Langchain"><a href="#了解Langchain" class="headerlink" title="了解Langchain"></a>了解Langchain</h2><p>LangChain是一个强大的框架，旨在帮助开发人员使用语言模型构建端到端的应用程序。它提供了一套工具、组件和接口，可简化创建由大型语言模型 (LLM) 和聊天模型提供支持的应用程序的过程。LangChain 可以轻松管理与语言模型的交互，将多个组件链接在一起，并集成额外的资源，例如 API 和数据库。</p>
<p>一句话概括就是：<strong>langchain 完成了对数据一个提炼、查找的完全链路。</strong>它并不能提供数据源、查找理由，只是一种方法的凝练。</p>
<p>数据源支持由用户等自行提供，因此它支持本地知识库的搭建，合理想象未来的学生课设系统将会是：金融知识系统（使用 langchain 爬取金融网站提取摘要凝练成知识）、图书简介系统（使用 langchain 对图书提取摘要进行展示）……</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Jupyter 就是一个非常好用的 Python 语言编程工具。</p>
<p>或者说是一个 Python 编程语言、以及更多其他编程语言的，交互式集成开发环境。</p>
<p>Jupyter 的一个非常重要的优点，就是 写程序的界面，和运行程序的界面，在一起。</p>
<p>jubyter notebook的安装：<code>pip install jupyterlab</code></p>
<p>web页面的启动：<code>jupyter-lab</code></p>
<p>vscode：创建.ipynb格式的文件</p>
<hr>
<p>langchain的安装：<code>pip install langchain</code></p>
<h2 id="提供一种LLM集成解决方案，一份代码支持快速同时支持gpt大模型、国产大模型-通义千问、文心一言、百度千帆、讯飞星火等-、本地开源大模型-Ollama"><a href="#提供一种LLM集成解决方案，一份代码支持快速同时支持gpt大模型、国产大模型-通义千问、文心一言、百度千帆、讯飞星火等-、本地开源大模型-Ollama" class="headerlink" title="提供一种LLM集成解决方案，一份代码支持快速同时支持gpt大模型、国产大模型(通义千问、文心一言、百度千帆、讯飞星火等)、本地开源大模型(Ollama)"></a>提供一种LLM集成解决方案，一份代码支持快速同时支持gpt大模型、国产大模型(通义千问、文心一言、百度千帆、讯飞星火等)、本地开源大模型(Ollama)</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/NanGePlus/LLMTest">NanGePlus/LLMTest: 为实现代码的高扩展性和兼容性，提出一套综合解决方案，支持多种大模型类型的无缝集成，包括GPT系列大模型、国内主流模型（如通义千问、智谱AI等），以及本地化部署的大模型（如qwen2.5）。</a></p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>openai-api代理：<a target="_blank" rel="noopener" href="https://api.wlai.vip/">云雾 API</a></p>
<p>安装One-Api</p>
<p><a target="_blank" rel="noopener" href="https://github.com/songquanpeng/one-api">songquanpeng/one-api: OpenAI 接口管理 &amp; 分发系统，支持 Azure、Anthropic Claude、Google PaLM 2 &amp; Gemini、智谱 ChatGLM、百度文心一言、讯飞星火认知、阿里通义千问、360 智脑以及腾讯混元，可用于二次分发管理 key，仅单可执行文件，已打包好 Docker 镜像，一键部署，开箱即用. OpenAI key management &amp; redistribution system, using a single API for all LLMs, and features an English UI.</a></p>
<p>利用exe</p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/">One API</a></p>
<p>默认账号密码：root     12345</p>
<p>创建渠道，这里以阿里通义千问为例</p>
<p>获取API-KEY：<a target="_blank" rel="noopener" href="https://bailian.console.aliyun.com/?spm=5176.29619931.J__Z58Z6CX7MY__Ll8p1ZOR.1.136959fcA1q1xF&amp;accounttraceid=a01e32df30fa4776a42f6cb88a6f938dfnlu#/model-market/detail/qwen-plus">阿里云百炼</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26303031/article/details/140987551">2024年最新免费AI大模型API汇总及国内大模型使用教程（附代码）_免费大模型api-CSDN博客</a></p>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LangChain/image-20241216103856131.png" alt="image-20241216103856131"></p>
<hr>
<p>使用 Ollama 非常简单，只需要按照以下步骤：</p>
<ol>
<li><strong>安装 Ollama</strong> ： 根据你的操作系统，从 <a target="_blank" rel="noopener" href="https://ollama.com/">Ollama 官网 </a>下载并安装最新版本。</li>
<li><strong>启动 Ollama</strong> ： 打开终端或命令行，输入 <code>ollama serve</code> 命令启动 Ollama 服务器。</li>
<li><strong>下载模型</strong>： 在<a target="_blank" rel="noopener" href="https://ollama.com/library">模型仓库 </a>找到想要的模型，然后使用 <code>ollama pull</code> 命令下载，例如 <code>ollama pull llama3:70b</code> 。</li>
<li><strong>运行模型</strong> ： 使用 <code>ollama run</code> 命令启动模型，例如 <code>ollama run llama3:70b</code> 。</li>
<li><strong>开始聊天</strong> ： 在终端中输入你的问题或指令，Ollama 会根据模型生成相应的回复。</li>
<li><strong>查看模型列表</strong> ：<code>ollama list</code></li>
</ol>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LangChain/image-20241216115902772.png" alt="image-20241216115902772"></p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>初始化：采用pycharm+anaconda</p>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LangChain/image-20241216120328229.png" alt="image-20241216120328229"></p>
<p>安装依赖</p>
<p>pip install -r requirements.txt<br>每个软件包后面都指定了本次视频测试中固定的版本号<br><strong>注意：</strong> 截止2024.10.18，langchain最新版本为0.3.3，langchain-openai最新版本为0.2.2</p>
<p>调整api，调整 utils/myLLM.py 内容</p>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LangChain/image-20241216131346999.png" alt="image-20241216131346999"></p>
<p>调整 llmTest.py 内容</p>
<p>LLM_TYPE = “oneapi” # openai：调用gpt模型;oneapi：调用oneapi方案支持的模型（这里调用通义千问）</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://github.com/langchain-ai/langchain?tab=readme-ov-file">langchain-ai/langchain：🦜🔗构建上下文感知推理应用程序</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/680828606">LangChain 入门与避坑指北 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.langchain.com.cn/docs/introduction/">LangChain中文网</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/franklfeng/article/details/117562667">Jupyter 是什么-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://vscode.github.net.cn/docs/datascience/jupyter-notebooks#_save-your-jupyter-notebook">在 Visual Studio Code 中使用 Jupyter Notebook_Vscode中文网</a></p>
<p><a target="_blank" rel="noopener" href="https://cuterwrite.top/p/ollama/#:~:text=如何使用 Ollama？ 1 安装 Ollama： 根据你的操作系统，从 Ollama 官网,ollama run llama3%3A70b 。 5 开始聊天： 在终端中输入你的问题或指令，Ollama 会根据模型生成相应的回复。">Ollama：从入门到进阶</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LightRAG%E4%B8%8EGraphRAG/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LightRAG%E4%B8%8EGraphRAG/" class="post-title-link" itemprop="url">机设——LightRAG与GraphRAG</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-07T00:00:00+08:00">2024-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:42:06" itemprop="dateModified" datetime="2025-06-12T18:42:06+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" itemprop="url" rel="index"><span itemprop="name">项目经历</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E6%9C%BA%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">机设</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="GraphRAG"><a href="#GraphRAG" class="headerlink" title="GraphRAG"></a>GraphRAG</h2><p>最新消息是11.26凌晨，微软宣布将推出 GraphRAG 的全新迭代版本LazyGraphRAG<br>核心亮点是极低的使用成本，其数据索引成本仅为现有GraphRAG 的 0.1%。此外，LazyGraphRAG 引入了全新的混合数据检索方法，大幅提升了生成结果的准确性和效率。该版本将很快开源，并纳入到 GitHub GraphRAG 库中<br>原文链接如下:<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/blog/lazygraphrag-setting-a-new-standard-for-quality-and-cost/">https://www.microsoft.com/en-us/research/blog/lazygraphrag-setting-a-new-standard-for-quality-and-cost/</a></p>
<hr>
<p><strong>支持的检索方式</strong></p>
<p><strong>Naive Search</strong><br>Naive 模式是最简单的检索策略，它直接基于输入查询计算向量相似度，返回最接近的结果，不进行任何额外的优化或复杂处理<br><strong>Local Search</strong><br>Local 模式只在本地上下文范围内进行检索。它聚焦于用户当前输入的特定领域或某部分数据，不会考虑全局数据<br><strong>Global Search</strong><br>Global 模式会在整个知识库范围内进行检索，试图找到与查询最相关的信息，而不局限于当前上下文或局部区域<br><strong>Hybrid Search</strong><br>Hybrid 模式结合了 Local 和 Global 的优势，同时考虑局部上下文和全局信息，综合结果以提高答案的相关性和覆盖范围</p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>Anaconda，中文大蟒蛇，是一个开源的Anaconda是专注于数据分析的Python发行版本，包含了conda、Python等190多个科学包及其依赖项。</p>
<p>Anaconda就是可以便捷获取包且对包能够进行管理，包括了python和很多常见的软件库和一个包管理器conda。常见的科学计算类的库都包含在里面了，使得安装比常规python安装要容易，同时对环境可以统一管理的发行版本</p>
<h3 id="为什么要安装Anaconda？"><a href="#为什么要安装Anaconda？" class="headerlink" title="为什么要安装Anaconda？"></a>为什么要安装Anaconda？</h3><p>Anaconda对于python初学者而言及其友好，相比单独安装python主程序，选择Anaconda可以帮助省去很多麻烦，Anaconda里添加了许多常用的功能包，如果单独安装python，这些功能包则需要一条一条自行安装，在Anaconda中则不需要考虑这些，同时Anaconda还附带捆绑了两个非常好用的交互式代码编辑器（Spyder、Jupyter notebook）。</p>
<p>简单来说，Anconda，可以理解成运输车，每当下载Anconda的时候，里面不仅包含了python，还有180多个库（武器)一同被打包下载下来。</p>
<p>下载完Anconda之后，再也不用一个个下载那些库了。</p>
<h3 id="集成开发环境搭建Anaconda-PyCharm"><a href="#集成开发环境搭建Anaconda-PyCharm" class="headerlink" title="集成开发环境搭建Anaconda+PyCharm"></a>集成开发环境搭建Anaconda+PyCharm</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q9HxeEEtT/?vd_source=30acb5331e4f5739ebbad50f7cc6b949">【大模型应用开发基础】集成开发环境搭建Anaconda+PyCharm_哔哩哔哩_bilibili</a></p>
<h2 id="LightRAG与GraphRAG运行对比"><a href="#LightRAG与GraphRAG运行对比" class="headerlink" title="LightRAG与GraphRAG运行对比"></a>LightRAG与GraphRAG运行对比</h2><p><a target="_blank" rel="noopener" href="https://github.com/NanGePlus/LightRAGTest">NanGePlus/LightRAGTest: LightRAG与GraphRAG在索引构建、检索测试中的耗时、模型请求次数、Token消耗金额、检索质量等方面进行对比</a></p>
<p>命令行终端中执行如下命令安装依赖包<br>cd LightRAG<br>pip install -e .<br>cd GraphRAG<br>pip install graphrag==0.5.0</p>
<hr>
<p><strong>测试文本</strong> 测试文本均为使用西游记白话文前九回内容，文件名为book.txt<br><strong>模型配置</strong> 大模型使用OpenAI(代理方案)，Chat模型均使用gpt-4o-mini,Embedding模型均使用text-embedding-3-small<br><strong>其他配置</strong> 笔记本均为MacBook Pro2017,网速、python环境均相同</p>
<hr>
<p>LightRAG测试</p>
<p>(1)构建索引</p>
<p>打开命令行终端，执行如下指令<br>cd LightRAG/nangeAGICode<br>python test.py<br><strong>注意</strong> 在运行脚本之前，需要调整相关代码将如下代码块打开，检索相关的代码块注释</p>
<p>(2)逐一测试</p>
<p>执行如下指令<br>cd LightRAG/nangeAGICode<br>python test.py<br><strong>注意</strong> 在运行脚本之前，需要注释如下构建索引代码，取消检索相关的代码块注释</p>
<p>GraphRAG测试</p>
<p>(1)构建索引</p>
<p>打开命令行终端，执行如下指令<br>cd GraphRAG<br>graphrag index —root ./</p>
<p>(2)逐一测试</p>
<p>graphrag query —root ./ —method local —query “这个故事的核心主题是什么?”<br>graphrag query —root ./ —method global —query “这个故事的核心主题是什么?”<br>graphrag query —root ./ —method drift —query “这个故事的核心主题是什么?”</p>
<hr>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LightRAG%E4%B8%8EGraphRAG/img.png" alt="img"></p>
<h2 id="利用neo4j可视化"><a href="#利用neo4j可视化" class="headerlink" title="利用neo4j可视化"></a>利用neo4j可视化</h2><p><strong>测试文本</strong> 测试文本均为使用西游记白话文前九回内容<br><strong>模型配置</strong> 大模型均使用OpenAI(代理方案)，Chat模型均使用gpt-4o,Embedding模型均使用text-embedding-3-small<br><strong>其他配置</strong> 笔记本均为MacBook Pro2017,网速、python环境均相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># gpt大模型相关配置根据自己的实际情况进行调整</span><br><span class="line">OPENAI_API_BASE = &quot;https://api.wlai.vip/v1&quot;</span><br><span class="line">OPENAI_CHAT_API_KEY = &quot;sk-Tuza9B8WYo1vkBAAmmLeQjuOl1VTP9Dd0nuKxqnLOaJJMZZd&quot;</span><br><span class="line">OPENAI_CHAT_MODEL = &quot;gpt-4o&quot;</span><br><span class="line">OPENAI_EMBEDDING_MODEL = &quot;text-embedding-3-small&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="LightRAG构建索引测试"><a href="#LightRAG构建索引测试" class="headerlink" title="LightRAG构建索引测试"></a>LightRAG构建索引测试</h3><h4 id="1-安装textract依赖包"><a href="#1-安装textract依赖包" class="headerlink" title="(1)安装textract依赖包"></a>(1)安装textract依赖包</h4><p>通过指令 pip install textract 安装时会报错，报错的原因是<br>其元数据文件中使用了不再被支持的版本约束符号（&lt;=0.29.*），而当前 pip 和 setuptools 不再接受这种格式<br>解决方案:下载依赖包源码，修改相应参数后本地进行安装<br><a target="_blank" rel="noopener" href="https://pypi.org/project/textract/1.6.5/#description">https://pypi.org/project/textract/1.6.5/#description</a><br>cd textract-1.6.5<br>pip install .</p>
<h4 id="2-创建neo4j数据库实例"><a href="#2-创建neo4j数据库实例" class="headerlink" title="(2) 创建neo4j数据库实例"></a>(2) 创建neo4j数据库实例</h4><p>推荐使用云服务进行测试，链接地址如下:<br><a target="_blank" rel="noopener" href="https://console-preview.neo4j.io/tools/query">https://console-preview.neo4j.io/tools/query</a><br>注册登录成功，直接新建实例即可</p>
<p>也可以用本地neo4j</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库连接相关参数配置</span></span><br><span class="line">NEO4J_URI=<span class="string">&quot;bolt://localhost:7687&quot;</span></span><br><span class="line">NEO4J_USERNAME=<span class="string">&quot;neo4j&quot;</span></span><br><span class="line">NEO4J_PASSWORD=<span class="string">&quot;zxj03051218&quot;</span></span><br><span class="line">NEO4J_DATABASE=<span class="string">&quot;neo4j&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-增量索引构建及知识图谱可视化测试"><a href="#3-增量索引构建及知识图谱可视化测试" class="headerlink" title="(3)增量索引构建及知识图谱可视化测试"></a>(3)增量索引构建及知识图谱可视化测试</h4><p>运行如下指令进行索引构建<br>cd LightRAG/nangeAGICode1201<br>python insertTest.py<br>python queryTest.py<br>每一次构建完成，先清除数据库中的数据再运行如下指令进行可视化<br>在运行之前需要根据自己的实际情况进行参数的调整<br>python graph_visual_with_html.py</p>
<p>python graph_visual_with_neo4j.py<br><strong>在数据库中进行查询测试</strong><br>MATCH (n:<code>PERSON</code>)<br>WHERE n.displayName CONTAINS ‘唐僧’<br>RETURN n LIMIT 25;</p>
<p>MATCH (n:<code>PERSON</code>)<br>WHERE n.displayName CONTAINS ‘八戒’<br>RETURN n LIMIT 25;</p>
<p>MATCH (n:<code>PERSON</code>)<br>WHERE n.displayName CONTAINS ‘沙和尚’<br>RETURN n LIMIT 25;</p>
<p><strong>清除数据</strong><br>MATCH (n)<br>CALL { WITH n DETACH DELETE n } IN TRANSACTIONS OF 25000 ROWS;</p>
<p>MATCH (n)<br>OPTIONAL MATCH (n)-[r]-()<br>DELETE n,r</p>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LightRAG%E4%B8%8EGraphRAG/image-20241221160947727.png" alt="image-20241221160947727"></p>
<p><img src="/2024/12/07/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94LightRAG%E4%B8%8EGraphRAG/image-20241221160843951.png" alt="image-20241221160843951"></p>
<h3 id="LightRAG和GraphRAG生成的知识图谱对比"><a href="#LightRAG和GraphRAG生成的知识图谱对比" class="headerlink" title="LightRAG和GraphRAG生成的知识图谱对比"></a>LightRAG和GraphRAG生成的知识图谱对比</h3><p>运行如下指令将GraphRAG生成的知识图谱进行可视化展示<br>cd GraphRAG/utils<br>python graph<em>visual<em>with_neo4j.py<br>在运行脚本前根据自己的实际情况进行调整,修改文件所在路径为存储增量数据的文件路径<br>GRAPHRAG_FOLDER=”/Users/janetjiang/Desktop/agi_code/LightRAGTest/GraphRAG/output”<br><strong>在数据库中进行查询测试</strong><br>MATCH (n:`__Entity</em></em>`)<br>WHERE n.name CONTAINS ‘唐僧’<br>RETURN n LIMIT 25;</p>
<p>MATCH (n:<code>__Entity__</code>)<br>WHERE n.name CONTAINS ‘八戒’<br>RETURN n LIMIT 25;</p>
<p>MATCH (n:<code>__Entity__</code>)<br>WHERE n.name CONTAINS ‘沙和尚’<br>RETURN n LIMIT 25;</p>
<p><strong>清除数据</strong><br>MATCH (n)<br>CALL { WITH n DETACH DELETE n } IN TRANSACTIONS OF 25000 ROWS;</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CmzEYcEnS/?spm_id_from=333.1007.tianma.1-1-1.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">LightRAG与GraphRAG对比评测，从索引构建、本地检索、全局检索、混合检索等维度对请求大模型次数、Token消耗、金额消耗、检索质量等方面进行全面对比_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_56197703/article/details/124630222">还是搞不懂Anaconda是什么?读这一篇文章就够了-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/06/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94Neo4j/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/06/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94Neo4j/" class="post-title-link" itemprop="url">机设——Neo4j</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-06T00:00:00+08:00">2024-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:42:14" itemprop="dateModified" datetime="2025-06-12T18:42:14+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" itemprop="url" rel="index"><span itemprop="name">项目经历</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E6%9C%BA%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">机设</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是-Neo4j？"><a href="#什么是-Neo4j？" class="headerlink" title="什么是 Neo4j？"></a>什么是 Neo4j？</h2><p><strong>Neo4j</strong> 是一个开源的<strong>图形数据库</strong>，由 Neo4j 公司开发和维护。作为图数据库的代表，Neo4j 使用图理论中的节点和边（关系）来表示和存储数据，相较于传统的关系型数据库（如 MySQL、PostgreSQL）和其他 NoSQL 数据库（如文档型、键值型数据库），Neo4j 在处<strong>理复杂关系和连接性强的数据方面</strong>具有显著优势。</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>图模型</strong>：使用节点、关系和属性来建模数据，直观地反映实体及其之间的关联。</li>
<li><strong>Cypher 查询语言</strong>：专为图数据库设计的声明式查询语言，语法简洁，易于表达复杂的图形查询。</li>
<li><strong>高性能</strong>：优化的存储和索引机制，能够高效地处理大规模图数据和复杂查询。</li>
<li><strong>ACID 事务支持</strong>：保证数据的一致性和可靠性，适用于需要强事务保障的应用场景。</li>
</ul>
<h2 id="为什么需要-Neo4j？"><a href="#为什么需要-Neo4j？" class="headerlink" title="为什么需要 Neo4j？"></a>为什么需要 Neo4j？</h2><p>在许多应用场景中，<strong>数据之间存在复杂的关系和连接性</strong>。传统的关系型数据库在处理多层级的关联查询时，往往需要大量的联接操作（JOIN），这会导致查询性能下降，尤其是在数据规模庞大时。而 Neo4j 通过图模型天然适合表示和处理这种高度连接的数据，能够更高效地执行复杂的关系查询。</p>
<h3 id="主要需求原因："><a href="#主要需求原因：" class="headerlink" title="主要需求原因："></a>主要需求原因：</h3><ol>
<li><strong>复杂关系处理</strong>：需要频繁进行多级关联查询，如社交网络、推荐系统等。</li>
<li><strong>灵活的数据模型</strong>：数据结构可能随时间变化，图数据库提供了更大的灵活性。</li>
<li><strong>性能需求</strong>：需要在大规模数据集上执行快速的关系查询和遍历操作。</li>
<li><strong>实时性</strong>：需要实时分析和处理数据关系，如欺诈检测、网络安全等。</li>
</ol>
<p><img src="/2024/12/06/%E7%A7%91%E7%A0%94/%E6%9C%BA%E8%AE%BE/%E6%9C%BA%E8%AE%BE%E2%80%94%E2%80%94Neo4j/ed250b8ea580015278be07a9233448c2.png" alt="ed250b8ea580015278be07a9233448c2"></p>
<h2 id="GraphRAG的理解"><a href="#GraphRAG的理解" class="headerlink" title="GraphRAG的理解"></a>GraphRAG的理解</h2><p><strong>GraphRAG=Graph(知识图谱)+RAG技术</strong></p>
<p><strong>GraphRAG</strong> 是一种结合了<strong>图结构</strong>和<strong>检索增强生成（RAG）</strong>的方法，旨在增强语言模型（如大规模预训练的变换器模型）的推理能力和信息检索能力。这个方法通常用于处理复杂的推理任务，尤其是当涉及到大规模知识库或图形数据时，GraphRAG可以通过图的结构来有效地组织信息，从而提高模型在生成和推理时的效率和准确性。</p>
<p><strong>图结构（Graph）</strong>：</p>
<ul>
<li><strong>图</strong>通常用于表示节点之间的关系和依赖，在处理复杂知识结构时非常有用。在GraphRAG中，图结构帮助捕捉信息之间的关系，能够有效地组织和链接不同的知识点，尤其是在涉及多个实体和关系的任务中。</li>
</ul>
<p><strong>检索增强生成（RAG）</strong>：</p>
<ul>
<li>RAG 是一种将信息检索与生成模型结合的框架。它的核心思想是，模型在生成答案时不仅仅依赖于其预训练时获得的知识，还会从一个外部数据库或文档库中检索相关的信息来增强回答的准确性和上下文适应性。</li>
</ul>
<h2 id="Neo4j的安装"><a href="#Neo4j的安装" class="headerlink" title="Neo4j的安装"></a>Neo4j的安装</h2><ol>
<li>官网下载社区版</li>
<li>安装JDK，java11</li>
<li>配置环境变量</li>
<li>启动Neo4j</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"># 启动服务</span><br><span class="line">neo4j(.bat) start</span><br><span class="line"># 重启服务</span><br><span class="line">neo4j(.bat) restart</span><br><span class="line"># 停止服务</span><br><span class="line">neo4j(.bat) stop</span><br><span class="line"># 控制台模式启动</span><br><span class="line">neo4j(.bat) console</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>进入到 <a target="_blank" rel="noopener" href="http://localhost:7474">http://localhost:7474</a></li>
</ol>
<p>账号密码  neo4j    zxj03051218</p>
<p>第一次进入前安装neo4j 的服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j install-service</span><br></pre></td></tr></table></figure>
<p>查看版本   neo4j —version</p>
<h2 id="apoc用处"><a href="#apoc用处" class="headerlink" title="apoc用处"></a>apoc用处</h2><p>数据导入和导出：使用APOC插件可以轻松导入和导出不同格式的数据到Neo4j图数据库。您可以将数据从关系型数据库、CSV文件、JSON等转换为图形数据，并相反地，将图形数据导出到其他格式。<br>图形算法：APOC提供了许多有用的图形算法，如PageRank、社区发现（例如Louvain算法），路径分析等。这些算法可以帮助您发现数据之间的关联性和模式，并从中提取有价值的信息。<br>数据清洗和转换：APOC提供了丰富的过程和函数，用于数据清洗和转换。您可以使用它来处理字符串、时间、密码学等方面的数据，并进行必要的清洗和格式化。<br>可视化：APOC支持将图形数据转换为其他可视化工具所需的格式，例如Gephi、D3.js等。这使得您可以将您的图形数据以更直观的方式呈现，进一步探索和交流。<br>地理空间分析：APOC提供了与地理空间数据相关的功能，如计算两个地点之间的距离、查找附近的地点等。这对于在地理空间上分析和查询数据特别有用。</p>
<p>我应该是主要用到了数据导入和导出的功能，因为要将构建好的所以传到本地neo4j上</p>
<h2 id="apoc插件安装"><a href="#apoc插件安装" class="headerlink" title="apoc插件安装"></a>apoc插件安装</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shdabai/article/details/132880323">知识图谱基本工具Neo4j使用笔记 五 ：APOC插件安装及简单应用_neo4j apoc-CSDN博客</a></p>
<p>版本 neo4j 4.4.39</p>
<p>APOC插件下载：apoc-4.4.0.9-all.jar（注意apoc要与neo4j版本对应）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/neo4j/apoc/releases?page=2">Releases · neo4j/apoc</a></p>
<p>将下载的 <code>apoc-4.4.0.9-all.jar</code> 直接复制到neo4j/plugins文件夹</p>
<p>修改APOC的配置文件</p>
<p>打开配置文件将，这一下内容的注释去掉</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbms.security.procedures.unrestricted=apoc.*</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037690548#item-0-2">java - 我的Neo4j探索之旅 - 初识Neo4j（一） - 个人文章 - SegmentFault 思否</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/05/%E6%AF%94%E8%B5%9B/%E4%B8%AD%E6%95%B0%E6%9D%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/05/%E6%AF%94%E8%B5%9B/%E4%B8%AD%E6%95%B0%E6%9D%AF/" class="post-title-link" itemprop="url">AIGC——中数杯</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-12-05 00:00:00 / 修改时间：16:36:18" itemprop="dateCreated datePublished" datetime="2024-12-05T00:00:00+08:00">2024-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《老匠新传》"><a href="#《老匠新传》" class="headerlink" title="《老匠新传》"></a>《老匠新传》</h1><p><strong>背景剧情：</strong></p>
<p>在安徽省一个偏远小山村里，住着一位年迈的老匠人程老。他是村里最后一位木雕匠，祖传的技艺如今面临失传的窘境。一天，城市的女孩小林，来到了这个小山村。她被精致的雕刻作品和老人的精湛技艺所吸引，留下来悉心学习这传统技艺。</p>
<p>多年后，女孩学成回到城市。她呼吸着浮躁的空气，下定决心在城市的一隅开设了一家雕刻工作室。门口摆放着一只木雕鸟，和曾经吸引她踏入木雕门扉的那只一般，精致而美丽。但是简约的线条又让它显得轻盈而现代。</p>
<p>“那是一块文化的拼图，串起了过去岁月的技艺，和当代创新的潮流。”</p>
<p><strong>创作理念：</strong></p>
<p>我们的故事从安徽省一个偏远小山村的年迈木雕匠人程老为起点，通过他与来自城市的女孩小林之间的师徒传承，展现传统技艺在现代社会中的困境与重生。</p>
<p>文化传承：我们希望强调了传统技艺的文化价值，如木雕这一几代人相传的技艺，不仅是技艺本身，更是一种文化的延续。程老作为村里最后一位木雕匠，他的技艺和作品承载着丰富的历史和文化信息。</p>
<p>师徒传承：通过小林对程老技艺的学习和传承，我们希望展现师徒之间深厚的情感纽带和技艺的传递。这种传承不仅是对技艺的保存，更是对文化精神的延续。</p>
<p>创新融合：小林学成后，在城市开设雕刻工作室，将传统技艺与现代审美相结合，创作出既具有传统韵味又符合现代审美的作品。其中表达着对传统文化的创新和发展，以及传统技艺在现代社会中焕发出新的生命力。</p>
<p>文化自信：故事中的小林在回到城市后，能够自信地展示和推销自己的作品，体现了对传统文化的自信和自豪感。</p>
<p><strong>艺术表达：</strong></p>
<p>我们采用现代的技术载体讲述传统技艺的传承和新生，希望增添作品的现实意义。</p>
<p>细节描写：故事中对木雕作品的细节描写，如“精致的雕刻作品”和“一只木雕鸟”，不仅展现了程老技艺的精湛，也通过小林对这些作品的喜爱和学习，传递了她对传统文化的热爱和尊重。</p>
<p>情感渲染：通过小林与程老之间的互动，以及小林学成后回到城市的心理变化，渲染师徒之间的深厚情感和传统文化的厚重感。</p>
<p>象征手法：木雕鸟作为故事中的象征物，既代表了程老的技艺传承，也象征着传统技艺在现代社会中的重生和创新。它的“精致而美丽”和“简约的线条”既体现了传统技艺的精髓，又融入了现代审美元素。</p>
<p>语言风格：故事中的语言风格简洁明了，富有诗意。</p>
<p><strong>使用技术：</strong></p>
<p>图像生成：首先训练GPT-4成为Midjourney提示词生成器。然后通过文字描述剧本中的场景，获取提示词。最后使用Midjourney生成场景图片，进行筛选。</p>
<p>视频生成：我们利用可灵AI进行视频的制作，我们使用生成的图片生成初版视频，然后通过提示词进行多次约束，修改，最后剪辑合并。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/" class="post-title-link" itemprop="url">数据结构——图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-02T00:00:00+08:00">2024-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:56:04" itemprop="dateModified" datetime="2025-06-12T18:56:04+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大二上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="图的基本概念和术语"><a href="#图的基本概念和术语" class="headerlink" title="图的基本概念和术语"></a>图的基本概念和术语</h2><p>定义：一个图可以利用两个集合进行定义。第一个集合是点的集合,这些点在图术语中一般被称(Vertex);第二个集合是连接两个顶点的边(Edge)的集合。图的具体定义如下。 图是由顶点集合及顶点间的关系集合组成的一种数据结构:Graph = (V, E)</p>
<p>基本术语</p>
<ol>
<li><p>有向图</p>
</li>
<li><p>无向图</p>
</li>
<li><p>邻接点</p>
</li>
<li><p>顶点的度，入度与出度</p>
</li>
<li><p>权和网：</p>
<ul>
<li><strong>权 ：</strong> 某些图的每条边都可能赋予一个数值，这个数值称为权。</li>
<li><strong>网 ：</strong> 带有权的图称为网。</li>
</ul>
</li>
<li><p><strong>无向完全图：</strong> 任意两个顶点之间都有一条边的无向图。</p>
<p><strong>有向完全图：</strong> 任意两个顶点之间都有方向相反的两条边的有向图。</p>
</li>
</ol>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202190122603.png" alt="image-20241202190122603"></p>
<ol>
<li><p>路径与路径长度</p>
</li>
<li><p><strong>简单路径</strong>：若路径上经过的各顶点均不重复，则称这样的路径为简单路径。</p>
<p><strong>回路或环</strong>：若路径上的第一个顶点与最后一个顶点相同，则称这样的路径为回路或环。</p>
</li>
</ol>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202190704319.png" alt="image-20241202190704319"></p>
<ol>
<li><p><strong>连通图：</strong> 在无向图中，若任意两个顶点之间都存在路径，则称该图为连通图。</p>
<p><strong>连通分量：</strong> 非连通图的极大连通子图称为连通分量。也就是说，一个连通分量是一个连通的子图，且不能再扩大。</p>
</li>
<li><p><strong>强连通图：</strong> 在有向图中，若对于任意一对顶点 u 和 v，都存在一条从 u 到 v 和从 v 到 u 的路径，则称该图为强连通图。</p>
<p><strong>强连通分量：</strong> 非强连通图的极大强连通子图称为强连通分量。</p>
</li>
<li><p><strong>生成树：</strong> 一个连通图的生成树是包含图中所有顶点的极小连通子图。也就是说，生成树是一棵树，且包含图中的所有顶点。</p>
<p><strong>生成森林：</strong> 非连通图的每个连通分量分别可以得到一棵生成树，这些生成树的集合称为生成森林。</p>
</li>
</ol>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202191533963.png" alt="image-20241202191533963"></p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202191543162.png" alt="image-20241202191543162"></p>
<h2 id="图的储存结构"><a href="#图的储存结构" class="headerlink" title="图的储存结构"></a>图的储存结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵表示法的基本思想是引入两个数组：</p>
<ul>
<li>一个用于记录图中各个顶点信息的—维数组，称为顶点表；</li>
<li>另一个用于表示图中各个顶点之间关系的二维数组，称为邻接矩阵。</li>
</ul>
<p>设图G=(V, E)是具有n(n&gt;0)个顶点的图，则图G所对应的邻接矩阵A是一个n阶方阵</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202192441396.png" alt="image-20241202192441396"></p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202192456777.png" alt="image-20241202192456777"></p>
<p>无向图的邻接矩阵可采用只存储上三角阵或下三角阵的压缩存储方法</p>
<hr>
<p>对于带权图，需要对邻接矩阵的元素值定义进行修改，让元素值表示相应顶点的权值</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202192636345.png" alt="image-20241202192636345"></p>
<p>其中，∞可用计算机中的一个足够大的数代替，以与权重区分</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241202193146935.png" alt="image-20241202193146935"></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>图类MGraph的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的类型定义: 无向图、无向网、有向图、有向网</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GraphType</span> &#123; undigraph, digraph, undinetwork, dinetwork &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeType</span> &#123; <span class="comment">// 本类型定义也适用于后面的邻接表结构</span></span><br><span class="line">    T head, tail;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">    <span class="built_in">EdgeType</span>(T h, T t, <span class="type">int</span> c) &#123;</span><br><span class="line">        head = h;</span><br><span class="line">        tail = t;</span><br><span class="line">        cost = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">    GraphType kind;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges; <span class="comment">// 邻接矩阵</span></span><br><span class="line">    vector&lt;T&gt; vexs;            <span class="comment">// 顶点表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无向有权图的邻接矩阵构建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createAdjMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjMatrix, <span class="type">const</span> vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> numVertices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化邻接矩阵为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numVertices; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) adjMatrix[i][j] = INT_MAX; <span class="comment">// 没有边的地方设置为无穷大，当i=j的值为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充边的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(edge);  <span class="comment">// 获取第一个元素</span></span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(edge);  <span class="comment">// 获取第二个元素</span></span><br><span class="line">        <span class="type">int</span> weight = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(edge);  <span class="comment">// 获取第三个元素</span></span><br><span class="line">        adjMatrix[u][v] = weight;</span><br><span class="line">        adjMatrix[v][u] = weight;  <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>当一个图为稀疏图时（边数相对顶点较少），使用邻接矩阵法显然要浪费大量的存储空间，如下图所示：</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/dc28a71607451fd5adeb57fadf14659b.png" alt="dc28a71607451fd5adeb57fadf14659b"></p>
<p>邻接表中存在两种结点:顶点表结点和边表结点，如下图所示。</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/5257342f8b24df2a6af18a35e74af60b.png" alt="5257342f8b24df2a6af18a35e74af60b"></p>
<p>顶点表结点由顶点域(data)和指向第一条邻接边的指针(firstarc) 构成，边表(邻接表)结点由邻接点域(adjvex)和指向下一条邻接边的指针域(nextarc) 构成。</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241205203225293.png" alt="image-20241205203225293"></p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>基于邻接表存储表示的图类ALGraph定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjvex;  <span class="comment">// 邻接点下标</span></span><br><span class="line">    EdgeNode* next; <span class="comment">// 指向下一个邻接点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VexNode</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    EdgeNode* firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的邻接表表示</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span> &#123;</span><br><span class="line">    vector&lt;VexNode&lt;T&gt;&gt; vex;  <span class="comment">// 顶点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, edgenum;  <span class="comment">// 顶点数和边数</span></span><br><span class="line">	GraphType kind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无向图的构建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ALGraph&lt;T&gt;::<span class="built_in">ALGraph</span>(GraphType t, T vexs[], <span class="type">int</span> n, <span class="type">int</span> e) &#123;</span><br><span class="line">    <span class="comment">// 参数表示图的类型, 参数vexs为存储各顶点值的数组, 参数n和e分别为顶点数和边数</span></span><br><span class="line">    vexnum = n;</span><br><span class="line">    edgenum = e;</span><br><span class="line">    kind = t;</span><br><span class="line">    adjlist.<span class="built_in">resize</span>(vexnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化顶点表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; ++i) &#123;</span><br><span class="line">        adjlist[i].data = vexs[i];</span><br><span class="line">        adjlist[i].firstEdge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次输入所有的边的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; edgenum; j++) &#123;</span><br><span class="line">        <span class="type">int</span> va, vb;</span><br><span class="line">        cin &gt;&gt; va &gt;&gt; vb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 产生第一个表结点</span></span><br><span class="line">        EdgeNode* p = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        p-&gt;adjvex = vb;</span><br><span class="line">        p-&gt;nextedge = adjlist[va].firstEdge;</span><br><span class="line">        adjlist[va].firstEdge = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 产生第二个表结点</span></span><br><span class="line">        p = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        p-&gt;adjvex = va;</span><br><span class="line">        p-&gt;nextedge = adjlist[vb].firstEdge;</span><br><span class="line">        adjlist[vb].firstEdge = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>为了防止已经访问过的结点重复访问的问题，提出了辅助数组 <code>visited[]</code></p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p><strong>深度优先搜索类似于树的先序遍历。</strong></p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241205210048064.png" alt="image-20241205210048064"></p>
<p>算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];	<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">/*从顶点出发，深度优先遍历图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">	<span class="built_in">visit</span>(v);	<span class="comment">//访问顶点</span></span><br><span class="line">	visited[v] = TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">	<span class="comment">//FirstNeighbor(G,v):求图G中顶点v的第一个邻接点，若有则返回顶点号，否则返回-1。</span></span><br><span class="line">	<span class="comment">//NextNeighbor(G,v,w):假设图G中顶点w是顶点v的一个邻接点，返回除w外顶点v</span></span><br><span class="line">	<span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G, v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighor</span>(G, v, w))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[w])&#123;	<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">			<span class="built_in">DFS</span>(G, w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对图进行深度优先遍历*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> v; </span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)&#123;</span><br><span class="line">		visited[v] = FALSE;	<span class="comment">//初始化已访问标记数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)&#123;	<span class="comment">//从v=0开始遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">			<span class="built_in">DFS</span>(G, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为O(V)。</p>
<p>对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(V^2)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(V＋E)。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p><strong>图的广度优先遍历就类似于树的层序遍历</strong></p>
<p>算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵的广度遍历算法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	Queue Q;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;G,numVertexes; i++)&#123;</span><br><span class="line">		visited[i] = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">InitQueue</span>(&amp;Q);	<span class="comment">//初始化一辅助用的队列</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.numVertexes; i++)&#123;</span><br><span class="line">		<span class="comment">//若是未访问过就处理</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">			vivited[i] = TRUE;	<span class="comment">//设置当前访问过</span></span><br><span class="line">			<span class="built_in">visit</span>(i);	<span class="comment">//访问顶点</span></span><br><span class="line">			<span class="built_in">EnQueue</span>(&amp;Q, i);	<span class="comment">//将此顶点入队列</span></span><br><span class="line">			<span class="comment">//若当前队列不为空</span></span><br><span class="line">			<span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">				<span class="built_in">DeQueue</span>(&amp;Q, &amp;i);	<span class="comment">//顶点i出队列</span></span><br><span class="line">				<span class="comment">//FirstNeighbor(G,v):求图G中顶点v的第一个邻接点，若有则返回顶点号，否则返回-1。</span></span><br><span class="line">				<span class="comment">//NextNeighbor(G,v,w):假设图G中顶点w是顶点v的一个邻接点，返回除w外顶点v</span></span><br><span class="line">				<span class="keyword">for</span>(j=<span class="built_in">FirstNeighbor</span>(G, i); j&gt;=<span class="number">0</span>; j=<span class="built_in">NextNeighbor</span>(G, i, j))&#123;</span><br><span class="line">					<span class="comment">//检验i的所有邻接点</span></span><br><span class="line">					<span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">						<span class="built_in">visit</span>(j);	<span class="comment">//访问顶点j</span></span><br><span class="line">						visited[j] = TRUE;	<span class="comment">//访问标记</span></span><br><span class="line">						<span class="built_in">EnQueue</span>(Q, j);	<span class="comment">//顶点j入队列</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q, n个顶点均需入队一次，在最坏的情况下，空间复杂度为O(V)。<br>采用邻接表存储方式时，每个顶点均需搜索一次(或入队一次)，在搜索任一顶点的邻接点时，每条边至少访问一次，算法总的时间复杂度为O(V＋E)。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为O(V)，故算法总的时间复杂度为O(V^2)。</p>
<blockquote>
<p>注意:图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>简单路径的搜索算法 dfs</p>
<p>二部图的判定算法</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>生成树变成非连通图;若给它增加一条边，则会形成图中的一条回路。对于一个带权连通无向图G=(V,E)，生成树不同，其中边的权值之和最小的那棵生成树（构造连通网的最小代价生成树)，称为G的<strong>最小生成树(Minimum-Spanning-Tree,MST)</strong>。</p>
<h3 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h3><p><strong>从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。</strong></p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/d0daac1cd8df11a443697ee6bc3fcf03.png" alt="d0daac1cd8df11a443697ee6bc3fcf03"></p>
<p>引入辅助数组<code>miniedges[]</code>，用于存放每个节点到节点v的边的权值，并每次挑选出权值最小的那个边所对应的节点加入生成树，辅助数组<code>miniedges[]</code>的数据类型如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjvex;  <span class="comment">// 与当前生成树连接的节点的编号</span></span><br><span class="line">    <span class="type">int</span> lowcost; <span class="comment">// 到当前生成树的最小边权值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若将某个数组元素<code>miniedges[i]</code>的 lowcost成员值设为0，则表示相应的顶点v,已加入到最小生成树中。</p>
<p>为便于算法在执行过程中读取任意两个顶点之间边的权值，对图宜采用<strong>邻接矩阵存储结构</strong>。</p>
<p>算法思路：</p>
<ol>
<li><p>初始化辅助数组，从节点v开始，将v的lowcost设为0，说明已经加入生成树</p>
</li>
<li><p>循环vexnum-1次，利用函数<code>MiniNum</code>找到权值最小的节点并输出</p>
<p>函数<code>MiniNum</code>循环vexnum次，找到当前所有节点中，<strong>未加入生成树的</strong>，lowcost最小的节点</p>
</li>
<li><p>更新辅助数组<code>miniedges[]</code>的每个节点的lowcost：循环vexnum次，如果通过当前节点k能找到比原先更小的边，更新该节点的lowcost；如果大，则保留原lowcost的值，更新后代表生成树节点的集合到未加入节点的集合的权值最小的vexnum条边</p>
</li>
</ol>
<p>时间复杂度：O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> v, <span class="type">int</span> vexnum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 miniedges 数组</span></span><br><span class="line">    Edge* miniedges = <span class="keyword">new</span> Edge[vexnum];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 miniedges，每个节点到起始点v的边的权值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">        miniedges[i].adjvex = <span class="built_in">GetVexValue</span>(v);        <span class="comment">// 初始时节点的连接为起始节点v</span></span><br><span class="line">        miniedges[i].lowcost = <span class="built_in">GetEdgeValue</span>(graph, v, i);   <span class="comment">// 初始化每个节点到v的边权值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    miniedges[v].lowcost = <span class="number">0</span>; <span class="comment">// 将起始节点v的lowcost设为0，表示已经加入生成树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行，每次选取一个未加入生成树的权值最小的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到最小的lowcost</span></span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">MiniNum</span>(miniedges, vexnum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出当前加入生成树的边</span></span><br><span class="line">        cout &lt;&lt; miniedges[k].adjvex &lt;&lt; <span class="string">&quot; --&gt; &quot;</span> &lt;&lt; <span class="built_in">GetVexValue</span>(k) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将选中的节点k加入生成树</span></span><br><span class="line">        miniedges[k].lowcost = <span class="number">0</span>; <span class="comment">// 表示节点k已加入生成树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新与当前生成树连接的节点的lowcost（最小边权值）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vexnum; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果通过当前节点k能找到比原先更小的边，更新该节点的lowcost</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetEdgeValue</span>(graph, k, j) &lt; miniedges[j].lowcost) &#123;</span><br><span class="line">                miniedges[j].adjvex = <span class="built_in">GetVexValue</span>(k);   <span class="comment">// 记录当前节点k</span></span><br><span class="line">                miniedges[j].lowcost = <span class="built_in">GetEdgeValue</span>(graph, k, j); <span class="comment">// 更新到生成树的最小边权值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] miniedges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>MiniNum</code>用于在数组miniedges中查找集合V-U中的具有最小权值的顶点,可以将它定义为私有成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到当前所有节点中，未加入生成树的，lowcost最小的节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MiniNum</span><span class="params">(Edge miniedges[], <span class="type">int</span> vexnum)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min = INT_MAX;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (miniedges[i].lowcost != <span class="number">0</span> &amp;&amp; miniedges[i].lowcost &lt; min) &#123; <span class="comment">// 如果该节点未加入生成树</span></span><br><span class="line">            min = miniedges[i].lowcost;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k; <span class="comment">// 返回最小权值的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h3><p><strong>与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</strong></p>
<p>每次挑选为加入生成树的最小边，若不构成回路，则加入生成树，若构成则挑选下一个</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/6b95ef2bc34f407c122e931cf06b11e6.png" alt="6b95ef2bc34f407c122e931cf06b11e6"></p>
<p>为提高算法执行过程中<strong>查找最小权值边的速度</strong>，可以采用一种排序算法(如堆排序算法)对边集数组中的边按权值进行排序。</p>
<p>接下来，Kruskal算法的关键问题就是<strong>如何判断所选取的边加入T中是否会产生回路</strong>，这里通过引入称为<strong>并查集</strong>的数据结构来解决</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/fb9515df040633c09b3c136601c8dbd7-1743416415437-1.png" alt="fb9515df040633c09b3c136601c8dbd7"></p>
<p>在下面描述的Kruskal 算法实现中，首先利用私有成员 <code>GetGraph()函数</code><strong>将图的边按权值排好序后存入边集数组graph中</strong>，而<code>边集数组tree</code>则用于<strong>保存和返回算法所构造的最小生成树T</strong>。</p>
<p>算法思路：</p>
<ol>
<li>初始话数组<code>graph</code>，用于存放所有的边，并对其排序</li>
<li>并查集的使用利用<code>数组components</code>，先进行初始化，每个节点的祖先都是自己，也可以理解成每个节点都构成一个集合，后续并查集的过程即为集合合并的过程</li>
<li>循环直到找到最小生成树的所有边（vexnum - 1条），对于每条边，查找他的起点和终点节点的祖先，若是一个祖先则说明在同一集合，不能加入到生成树；若不是一个，则可以加入到<code>生成树数组tree</code>，并要修改节点的祖先，使他们集合合并</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;T&gt;::<span class="built_in">Kruskal</span>(vector&lt;EdgeType&gt; &amp;tree) &#123;</span><br><span class="line">    <span class="comment">// 创建一个图的边集合，用于存放所有的边</span></span><br><span class="line">    vector&lt;EdgeType&gt; graph;</span><br><span class="line">    <span class="comment">// GetGraph函数将图的所有边按权值从小到大存放到graph数组中</span></span><br><span class="line">    <span class="built_in">GetGraph</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最小生成树数组，并且初始化并查集组件</span></span><br><span class="line">    tree.<span class="built_in">resize</span>(vexnum - <span class="number">1</span>);  <span class="comment">// 最小生成树包含的边数量是vexnum - 1</span></span><br><span class="line">    <span class="type">int</span> *components = <span class="keyword">new</span> <span class="type">int</span>[vexnum];  <span class="comment">// 记录每个节点所属的集合</span></span><br><span class="line">    <span class="comment">// 初始时，每个节点都属于自己的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">        components[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环直到找到最小生成树的所有边（vexnum - 1条）</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; vexnum - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从排序好的边中选择一条边</span></span><br><span class="line">        <span class="type">int</span> h1 = graph[j].head;  <span class="comment">// 边的起点</span></span><br><span class="line">        <span class="type">int</span> t1 = graph[j].tail;  <span class="comment">// 边的终点</span></span><br><span class="line">        <span class="type">int</span> h2 = components[h1];  <span class="comment">// 获取起点所在的集合</span></span><br><span class="line">        <span class="type">int</span> t2 = components[t1];  <span class="comment">// 获取终点所在的集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果起点和终点属于不同的集合，则这条边可以加入最小生成树</span></span><br><span class="line">        <span class="keyword">if</span> (h2 != t2) &#123;</span><br><span class="line">            <span class="comment">// 将这条边加入最小生成树中</span></span><br><span class="line">            tree[k].head = h1;</span><br><span class="line">            tree[k].tail = t1;</span><br><span class="line">            tree[k].cost = graph[j].cost;  <span class="comment">// 边的权值</span></span><br><span class="line">            k++;  <span class="comment">// 记录已选择的边的数量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并两个集合，统一编号</span></span><br><span class="line">            <span class="comment">// 将所有属于终点集合t2的顶点，集合编号更新为起点集合h2的编号</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (components[i] == t2) &#123;</span><br><span class="line">                    components[i] = h2;  <span class="comment">// 更新组件编号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;  <span class="comment">// 继续检查下一条边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] components;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显然，Kruskal算法的效率与所选择的<strong>排序算法的效率</strong>以及<strong>并查集数据结构的实现效率</strong>有关。若采用第10章介绍的比较高效的<strong>堆排序算法</strong>排序，<strong>并查集采用树结构</strong>实现，则Kruskal算法的时间复杂度可达到O($\ elog_{2}{e}$)。相比 Prim 算法而言，Kruskal算法更适用于求解稀疏网(指边数较少的网)的最小生成树。</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而<strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</strong></p>
<p>求图的最短路径问题通常可分为两类。一类是求图中某顶点到其余各顶点的最短路径问题，也称为<strong>单源最短路径问题</strong>;另一类是求图中每对顶点之间的最短路径问题。</p>
<h3 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉( Dijkstra )算法"></a>迪杰斯特拉( Dijkstra )算法</h3><p>Dijkstra算法用于构建单源点的最短路径—，即图中某个点到任何其他点的距离都是最短的。例如，构建地图应用时查找自己的坐标离某个地标的最短距离。可以用于有向图，但是不能存在负权值。</p>
<p><strong>通俗点说，迪杰斯特拉(Dijkstra)算法，它并不是一下子求出了$\ v_i$到$\ v_j$的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。</strong></p>
<p>下面介绍 Dijkstra算法的具体实现。为便于在算法执行过程中快速地求得任意两个顶点之间边的权值，图的存储结构宜采用邻接矩阵方式。</p>
<p>为标识图中各顶点在算法执行过程中<strong>是否已求出最短路径</strong>，设置一个<code>一维数组s[]</code></p>
<p>为记录 Dijkstra算法所求出的从源点到各顶点的最短路径，引入<code>数组 path[]</code>, path[i]中保存了从源点到终点v,的最短路径上该顶点的<strong>前驱顶点的序号</strong>。算法结束时，可根据数组path[ ]找到源点到v,的最短路径上每个顶点的前驱顶点，并一直回溯至源点，从而推出从源点到v的最短路径。</p>
<p>为便于每次从V-S中选择当前离源点距离最短的顶点，需要引人一个<code>辅助数组dist[]</code>。它的每一个分量dist[i]表示当前所确定的从源点$\ v<em>0$,到终点$\ v</em>{i}$的最短路径.</p>
<p>算法思路：</p>
<ol>
<li>初始化，s[]所有值为0，s[0]设置为1，代表从$\ v<em>{0}$节点开始，path[]所有值设为0，path[0]设为-1，dist[]通过查找邻接矩阵，得到$\ v</em>{0}$到各个顶点的值</li>
<li>查找dist中最小的值，从该节点继续完成最小路径，将该节点对应s[]设为1</li>
<li>遍历尚未找到最短路径的节点，即s[]为0，dist[i] = Min{dist[i]，dist[j] +cost(j,i)}，选择是借用上一个最短路径的节点到达还是直接到达，更新dist的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra算法：计算从起点start到其他所有节点的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = numVertices;  <span class="comment">// 获取图中节点的数量</span></span><br><span class="line">    <span class="type">bool</span> visited[n];  <span class="comment">// 访问标记数组，用于标记节点是否已经被访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化dist数组和path数组</span></span><br><span class="line">    <span class="comment">// dist[i] 表示从起点到节点i的最短距离</span></span><br><span class="line">    <span class="comment">// path[i] 表示从起点到节点i的最短路径的前驱节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;  <span class="comment">// 初始时，所有节点均未被访问</span></span><br><span class="line">        dist[i] = adjMatrix[start][i];  <span class="comment">// dist数组初始化为起点到各节点的初始距离</span></span><br><span class="line">        <span class="keyword">if</span> (dist[i] != INT_MAX || i == start) &#123;  <span class="comment">// 如果有边（距离不为无穷大），或者是起点本身</span></span><br><span class="line">            path[i] = start;  <span class="comment">// 将路径的前驱节点设置为起点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path[i] = <span class="number">-1</span>;  <span class="comment">// 如果节点无法从起点到达，前驱节点为-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;  <span class="comment">// 起点到起点的距离为0</span></span><br><span class="line">    visited[start] = <span class="literal">true</span>;  <span class="comment">// 标记起点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行n-1轮循环，逐步更新最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; n - <span class="number">1</span>; ++count) &#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX, min_index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到未访问的节点中距离最小的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">            <span class="comment">// 选择距离最小且未被访问的节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="literal">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">                min = dist[v];  <span class="comment">// 更新最小距离</span></span><br><span class="line">                min_index = v;  <span class="comment">// 记录最小距离节点的索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[min_index] = <span class="literal">true</span>;  <span class="comment">// 标记该节点为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新与该最小距离节点相邻的节点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">            <span class="comment">// 如果v节点未被访问，并且从min_index到v有边，且经过min_index节点的路径更短</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp;  </span><br><span class="line">                dist[v] &gt; dist[min_index] + adjMatrix[min_index][v]) &#123;</span><br><span class="line">                dist[v] = dist[min_index] + adjMatrix[min_index][v];  <span class="comment">// 更新v的最短距离</span></span><br><span class="line">                path[v] = min_index;  <span class="comment">// 更新v的前驱节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241209092422699.png" alt="image-20241209092422699"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印从源节点到目标节点v的路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPath</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g, vector&lt;<span class="type">int</span>&gt; path, vector&lt;<span class="type">int</span>&gt; dist, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dist[v] == INF) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;节点 &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; 无法到达&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归打印路径</span></span><br><span class="line">    <span class="keyword">if</span> (path[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">PrintPath</span>(g, path, dist, path[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)</p>
<h3 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德( Floyd )算法"></a>弗洛伊德( Floyd )算法</h3><p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/e00a2f6ecb05b16c2cae4adfb9da8698.png" alt="e00a2f6ecb05b16c2cae4adfb9da8698"></p>
<p>算法原理：递归</p>
<p>n阶数组D：用于保留每一步所求得的所有顶点对之间的当前最短路径长度</p>
<p>初始化：$\ D[i][j]=cost(i,j)$用邻接矩阵进行初始化</p>
<p>状态转移方程：$\ D^{k}[i][j]=min{D^{k-1}[i][j],D^{k-1}[i][k]+D^{k-1}[k][j]}$更新$v_i$到$v_j$的最短路径</p>
<p>path数组：用于存储最短路径，初始化若没有直接路径则$\ path[i][j]=-1$，若有则$\ path[i][j] = j$</p>
<p>算法思路：</p>
<p>初始化数组，遍历n*n次，即$v_i$到$v_j$和$v_j$到$v_i$都遍历一遍，通过状态转移方程更新D数组的值，若找到短的路径，则同时也更新path数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Floyd算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;T&gt;::<span class="built_in">Floyd</span>(<span class="type">int</span> path[][MAXV], <span class="type">int</span> D[][MAXV]) &#123;</span><br><span class="line">    <span class="comment">// 初始化距离矩阵D和路径矩阵path</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vexnum; ++j) &#123;</span><br><span class="line">            D[i][j] = edges[i][j];</span><br><span class="line">            <span class="comment">//初始化path</span></span><br><span class="line">            <span class="keyword">if</span> (D[i][j] &lt; INF &amp;&amp; i != j)</span><br><span class="line">                path[i][j] = j;  <span class="comment">// 若i到j有直接路径，记录路径</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][j] = <span class="number">-1</span>; <span class="comment">// 否则路径不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心Floyd-Warshall算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; vexnum; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vexnum; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vexnum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[i][k] != INF &amp;&amp; D[k][j] != INF &amp;&amp; D[i][k] + D[k][j] &lt; D[i][j]) &#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];  <span class="comment">// 更新最短路径长度</span></span><br><span class="line">                    path[i][j] = path[i][k];      <span class="comment">// 更新路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数OutputPath用于输出保存于二维数组path中的所有路径以及保存于二维数组D中的路径长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputPath</span><span class="params">(MGraph&lt;T&gt; &amp;G, <span class="type">int</span> path[][MAXV], <span class="type">int</span> D[][MAXV])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有顶点对，输出源点到目标点的最短路径及路径长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;      <span class="comment">// 遍历所有源点 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j) &#123;  <span class="comment">// 遍历所有目标点 j</span></span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123; <span class="comment">// 排除自身到自身的情况</span></span><br><span class="line">                <span class="keyword">if</span> (D[i][j] == INF) &#123;  <span class="comment">// 若距离为无穷大，表示无路径</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;Path from &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;: No path exists.\n&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 若存在路径</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;Path from &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; (Length: &quot;</span> &lt;&lt; D[i][j] &lt;&lt; <span class="string">&quot;): &quot;</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 输出路径，使用 path 数组逐步跟踪中间节点</span></span><br><span class="line">                    <span class="type">int</span> temp = i;      <span class="comment">// 起始点</span></span><br><span class="line">                    std::cout &lt;&lt; temp; <span class="comment">// 输出源点</span></span><br><span class="line">                    <span class="keyword">while</span> (temp != j) &#123; <span class="comment">// 当未到达目标点时</span></span><br><span class="line">                        temp = path[temp][j];  <span class="comment">// 获取路径中的下一个节点</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; temp; <span class="comment">// 输出中间节点或目标点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    std::cout &lt;&lt; std::endl; <span class="comment">// 换行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AOV网与拓扑排序"><a href="#AOV网与拓扑排序" class="headerlink" title="AOV网与拓扑排序"></a>AOV网与拓扑排序</h2><p><strong>有向无环图：不含环的有向图</strong></p>
<p><strong>AOV网</strong>：<strong>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网</strong></p>
<p><strong>拓扑序列</strong>：<strong>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V, V2 ,..V n，满足若从顶点V到V;有一条路径，则在顶点序列中顶点V必在顶点V;之前。则我们称这样的顶点序列为一个拓扑序列。</strong></p>
<p><strong>拓扑排序</strong>：<strong>其实就是对一个有向图构造拓扑序列的过程</strong>。每个AOV网都有一个或多个拓扑排序序列。</p>
<p><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241215131046998.png" alt="image-20241215131046998"></p>
<p>对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤:</p>
<p>①从AOV网中选择一个没有前驱的顶点并输出。<br>②从网中删除该顶点和所有以它为起点的有向边。<br>③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环(回路)，不是AOV网。<br><img src="/2024/12/02/college/%E5%A4%A7%E4%BA%8C%E4%B8%8A/Data%20Structure/%E5%9B%BE/image-20241215131727207.png" alt="image-20241215131727207"></p>
<p>算法原理：dfs</p>
<p>对于AOV 网宜采用<strong>邻接表</strong>作为存储结构</p>
<p>数组indegree：用于存放各个顶点的入度</p>
<p>算法思路：</p>
<p>每次遍历数组indegree，查找入度为零的顶点，将其加入队列，再遍历邻接表，将遍历到的顶点的indegree值减一，并判断是否为零，若为零则加入队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(V, <span class="number">0</span>)</span></span>; <span class="comment">// 入度数组</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;              <span class="comment">// 队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有顶点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[i]) &#123;</span><br><span class="line">            indegree[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将入度为0的顶点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 用于检测图是否存在环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出拓扑排序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拓扑排序顺序为: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出顶点</span></span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接点，并更新它们的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            indegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有输出所有顶点，说明存在环</span></span><br><span class="line">    <span class="keyword">if</span> (count != V) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;图中存在环，无法进行拓扑排序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/114141377">数据结构：图(Graph)【详解】_图数据结构-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gT4y1v768/?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">数据结构-图-prim（普里姆）算法最小生成树（过程分析+手写代码）_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19S4y1Y7MT?spm_id_from=333.788.player.switch&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">数据结构-图-最小生成树-克鲁斯卡尔（Kruskal)算法-手画+过程分析+代码_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
