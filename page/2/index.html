<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zxj Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang XiJun">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="zxj Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="zxj">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang XiJun</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/python-uv%E5%8C%85%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/02/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/python-uv%E5%8C%85%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">python-uv包管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-02T00:00:00+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-04 16:20:46" itemprop="dateModified" datetime="2025-08-04T16:20:46+08:00">2025-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是uv"><a href="#什么是uv" class="headerlink" title="什么是uv"></a>什么是uv</h3><p><code>uv</code> 是由 <strong>Astral</strong> 团队开发的一个<strong>超高速 Python 包管理器</strong>，用 <strong>Rust</strong> 编写，目标是替代 <code>pip</code>、<code>venv</code>、<code>pip-tools</code>、<code>poetry</code> 等多个工具。</p>
<h3 id="uv常用命令"><a href="#uv常用命令" class="headerlink" title="uv常用命令"></a>uv常用命令</h3><p>uv init myproj    创建新项目</p>
<p>source .venv/bin/activate（Linux/macOS）激活虚拟环境</p>
<p>uv add requests    安装依赖并写入 pyproject.toml</p>
<p>uv remove requests    移除依赖</p>
<p>uv sync    同步依赖到虚拟环境</p>
<p>uv export    导出 lock 文件为 requirements.txt 等格式</p>
<p>uv build    构建源码包和 wheel</p>
<p>uv publish    发布到 PyPI</p>
<h3 id="uvx是什么"><a href="#uvx是什么" class="headerlink" title="uvx是什么"></a>uvx是什么</h3><p><strong><code>uvx</code></strong> 是：</p>
<blockquote>
<p><strong>uv tool run</strong> 的<strong>快捷别名</strong>（alias），用于<strong>无需安装即可运行 Python 包提供的命令行工具</strong>。</p>
</blockquote>
<p><code>uvx</code> 就像 Python 世界的 <strong><code>npx</code></strong> 或 <strong><code>pipx run</code></strong> ——<br><strong>临时拉取、构建隔离环境、运行工具，用完即走，不留痕迹</strong>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ajJ7zPEa5/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【uv】Python迄今最好的项目管理+环境管理工具（吧？）_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13WGHz8EEz?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">从pip到uv：一口气梳理现代Python项目管理全流程！_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/python-logging%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/02/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/python-logging%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python-logging模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-02T00:00:00+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-03 18:50:57" itemprop="dateModified" datetime="2025-08-03T18:50:57+08:00">2025-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>级别</th>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEBUG</td>
<td><code>logging.debug()</code></td>
<td>调试信息</td>
</tr>
<tr>
<td>INFO</td>
<td><code>logging.info()</code></td>
<td>普通信息</td>
</tr>
<tr>
<td>WARNING</td>
<td><code>logging.warning()</code></td>
<td>警告信息</td>
</tr>
<tr>
<td>ERROR</td>
<td><code>logging.error()</code></td>
<td>错误信息</td>
</tr>
<tr>
<td>CRITICAL</td>
<td><code>logging.critical()</code></td>
<td>严重错误</td>
</tr>
</tbody>
</table>
</div>
<p>python默认只会打印warning以上级别的日志，可通过<code>basicConfig</code>进行设置，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 基础配置</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"># 记录不同级别的日志</span><br><span class="line">logging.debug(&quot;这是一个DEBUG级别的日志&quot;)</span><br><span class="line">logging.info(&quot;这是一个INFO级别的日志&quot;)</span><br><span class="line">logging.warning(&quot;这是一个WARNING级别的日志&quot;)</span><br><span class="line">logging.error(&quot;这是一个ERROR级别的日志&quot;)</span><br><span class="line">logging.critical(&quot;这是一个CRITICAL级别的日志&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="格式化log并输出"><a href="#格式化log并输出" class="headerlink" title="格式化log并输出"></a>格式化log并输出</h3><p>我们可以使用全局配置，完成log的格式化和输出成文件，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG,format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;,filename=&#x27;basic.log&#x27;,filemode=&#x27;w&#x27;)</span><br></pre></td></tr></table></figure>
<p>同样，我们可以自定义logger</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 创建自定义logger</span><br><span class="line">logger = logging.getLogger(&#x27;my_app&#x27;)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"># 清除之前的处理器</span><br><span class="line">logger.handlers.clear()</span><br><span class="line"></span><br><span class="line"># 创建文件处理器</span><br><span class="line">file_handler = logging.FileHandler(&#x27;logs/my_app.log&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">file_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"># 创建控制台处理器</span><br><span class="line">console_handler = logging.StreamHandler()</span><br><span class="line">console_handler.setLevel(logging.WARNING)</span><br><span class="line"></span><br><span class="line"># 创建不同的格式器</span><br><span class="line">file_formatter = logging.Formatter(</span><br><span class="line">    &#x27;%(asctime)s | %(name)s | %(levelname)s | %(funcName)s:%(lineno)d | %(message)s&#x27;</span><br><span class="line">)</span><br><span class="line">console_formatter = logging.Formatter(</span><br><span class="line">    &#x27;🚨 %(levelname)s: %(message)s&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">file_handler.setFormatter(file_formatter)</span><br><span class="line">console_handler.setFormatter(console_formatter)</span><br><span class="line"></span><br><span class="line"># 添加处理器</span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line">logger.addHandler(console_handler)</span><br><span class="line"></span><br><span class="line"># 测试不同级别的日志</span><br><span class="line">logger.debug(&quot;调试信息 - 只写入文件&quot;)</span><br><span class="line">logger.info(&quot;普通信息 - 只写入文件&quot;)</span><br><span class="line">logger.warning(&quot;警告信息 - 控制台和文件都有&quot;)</span><br><span class="line">logger.error(&quot;错误信息 - 控制台和文件都有&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = divide(10, 0)</span><br><span class="line">except ZeroDivisionError as exc:</span><br><span class="line">    # 方式 1：记录异常对象</span><br><span class="line">    logger.error(&quot;除零异常发生: &#123;&#125;&quot;, exc)</span><br><span class="line"></span><br><span class="line">    # 方式 2：记录完整 traceback（推荐）</span><br><span class="line">    logger.exception(&quot;捕获到异常，详情如下&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="loguru的常用使用方法"><a href="#loguru的常用使用方法" class="headerlink" title="loguru的常用使用方法"></a>loguru的常用使用方法</h3><p>基础用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.debug(&quot;这是 debug&quot;)</span><br><span class="line">logger.info(&quot;这是 info&quot;)</span><br><span class="line">logger.warning(&quot;这是 warning&quot;)</span><br><span class="line">logger.error(&quot;这是 error&quot;)</span><br><span class="line">logger.critical(&quot;这是 critical&quot;)</span><br></pre></td></tr></table></figure>
<p>输出到文件    logger.add(“app.log”)</p>
<p>过滤级别    logger.add(“app.log”, level=”WARNING”)</p>
<p>移除默认控制台输出       logger.remove()</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rJv8eNE1x?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">[Python] logging模块怎么用_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VnW7edEq7?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">[Python] 打印log神器 —— loguru_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/mcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/mcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">MCP 客户端实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-01 00:00:00 / 修改时间：17:03:37" itemprop="dateCreated datePublished" datetime="2025-08-01T00:00:00+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mcp/" itemprop="url" rel="index"><span itemprop="name">mcp</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 创建项目目录</span><br><span class="line">uv init mcp-client</span><br><span class="line">cd mcp-client</span><br><span class="line"></span><br><span class="line"># 创建虚拟环境</span><br><span class="line">uv venv</span><br><span class="line"></span><br><span class="line"># 激活虚拟环境</span><br><span class="line"># 在 Windows 上:</span><br><span class="line">.venv\Scripts\activate</span><br><span class="line"># 在 Unix 或 MacOS 上:</span><br><span class="line">source .venv/bin/activate</span><br><span class="line"></span><br><span class="line"># 安装所需包</span><br><span class="line">uv add mcp anthropic python-dotenv</span><br><span class="line">#使用镜像源安装</span><br><span class="line">uv add mcp anthropic python-dotenv --index-url https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"></span><br><span class="line"># 删除样板文件</span><br><span class="line"># 在 Windows 上:</span><br><span class="line">del main.py</span><br><span class="line"># 在 Unix 或 MacOS 上:</span><br><span class="line">rm main.py</span><br><span class="line"></span><br><span class="line"># 创建我们的主文件</span><br><span class="line">touch client.py</span><br></pre></td></tr></table></figure>
<h3 id="设置-API-密钥"><a href="#设置-API-密钥" class="headerlink" title="设置 API 密钥"></a>设置 API 密钥</h3><p>创建一个 <code>.env</code> 文件来存储它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Create .env file</span><br><span class="line">touch .env</span><br></pre></td></tr></table></figure>
<p>将您的密钥添加到 <code>.env</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANTHROPIC_API_KEY=&lt;your key here&gt;</span><br></pre></td></tr></table></figure>
<p>将 <code>.env</code> 添加到您的 <code>.gitignore</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;.env&quot; &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将 <code>.env</code> 文件名添加到 <code>.gitignore</code> 文件中，这样 Git 就会忽略 <code>.env</code> 文件，不会将其纳入版本控制。</p>
</blockquote>
<h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><h4 id="基本客户端结构"><a href="#基本客户端结构" class="headerlink" title="基本客户端结构"></a>基本客户端结构</h4><p>首先，让我们设置我们的导入并创建基本的客户端类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from typing import Optional</span><br><span class="line">from contextlib import AsyncExitStack</span><br><span class="line"></span><br><span class="line">from mcp import ClientSession, StdioServerParameters</span><br><span class="line">from mcp.client.stdio import stdio_client</span><br><span class="line"></span><br><span class="line">from anthropic import Anthropic</span><br><span class="line">from dotenv import load_dotenv</span><br><span class="line"></span><br><span class="line">load_dotenv()  # 从 .env 文件加载环境变量</span><br><span class="line"></span><br><span class="line">class MCPClient:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化会话和客户端对象</span><br><span class="line">        self.session: Optional[ClientSession] = None  # MCP客户端会话</span><br><span class="line">        self.exit_stack = AsyncExitStack()  # 异步上下文管理器堆栈，用于资源清理</span><br><span class="line">        self.anthropic = Anthropic()  # Anthropic AI 客户端</span><br><span class="line">        </span><br><span class="line">    # 后续方法将在这里定义</span><br></pre></td></tr></table></figure>
<h4 id="服务器连接管理"><a href="#服务器连接管理" class="headerlink" title="服务器连接管理"></a>服务器连接管理</h4><p>接下来，我们将实现连接到 MCP 服务器的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">async def connect_to_server(self, server_script_path: str):</span><br><span class="line">    &quot;&quot;&quot;连接到MCP服务器</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        server_script_path: 服务器脚本路径 (.py 或 .js 文件)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 检查是否为Python文件</span><br><span class="line">    is_python = server_script_path.endswith(&#x27;.py&#x27;)</span><br><span class="line">    # 检查是否为JavaScript文件</span><br><span class="line">    is_js = server_script_path.endswith(&#x27;.js&#x27;)</span><br><span class="line">    </span><br><span class="line">    # 如果不是Python或JavaScript文件，则抛出错误</span><br><span class="line">    if not (is_python or is_js):</span><br><span class="line">        raise ValueError(&quot;服务器脚本必须是 .py 或 .js 文件&quot;)</span><br><span class="line"></span><br><span class="line">    # 根据文件类型确定执行命令</span><br><span class="line">    command = &quot;python&quot; if is_python else &quot;node&quot;</span><br><span class="line">    </span><br><span class="line">    # 创建服务器参数对象</span><br><span class="line">    server_params = StdioServerParameters(</span><br><span class="line">        command=command,           # 执行命令</span><br><span class="line">        args=[server_script_path], # 脚本路径作为参数</span><br><span class="line">        env=None                   # 环境变量（使用默认环境）</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 建立stdio客户端连接并将其添加到异步上下文管理器中</span><br><span class="line">    stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))</span><br><span class="line">    self.stdio, self.write = stdio_transport</span><br><span class="line">    </span><br><span class="line">    # 创建客户端会话并将其添加到异步上下文管理器中</span><br><span class="line">    self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))</span><br><span class="line"></span><br><span class="line">    # 初始化会话</span><br><span class="line">    await self.session.initialize()</span><br><span class="line"></span><br><span class="line">    # 列出可用的工具</span><br><span class="line">    response = await self.session.list_tools()</span><br><span class="line">    tools = response.tools</span><br><span class="line">    </span><br><span class="line">    # 打印连接的服务器提供的工具列表</span><br><span class="line">    print(&quot;\n已连接到服务器，可用工具:&quot;, [tool.name for tool in tools])</span><br></pre></td></tr></table></figure>
<h4 id="查询处理逻辑"><a href="#查询处理逻辑" class="headerlink" title="查询处理逻辑"></a>查询处理逻辑</h4><p>现在让我们添加处理查询和调用工具的核心功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">async def process_query(self, query: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;使用Claude和可用工具处理查询&quot;&quot;&quot;</span><br><span class="line">    # 构建消息列表</span><br><span class="line">    messages = [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;user&quot;,      # 用户角色</span><br><span class="line">            &quot;content&quot;: query     # 用户查询内容</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    # 获取可用工具列表</span><br><span class="line">    response = await self.session.list_tools()</span><br><span class="line">    available_tools = [&#123;</span><br><span class="line">        &quot;name&quot;: tool.name,           # 工具名称</span><br><span class="line">        &quot;description&quot;: tool.description,  # 工具描述</span><br><span class="line">        &quot;input_schema&quot;: tool.inputSchema  # 工具输入模式</span><br><span class="line">    &#125; for tool in response.tools]</span><br><span class="line"></span><br><span class="line">    # 初始Claude API调用</span><br><span class="line">    response = self.anthropic.messages.create(</span><br><span class="line">        model=&quot;qwen3-235b-a22b&quot;,  # 使用的模型</span><br><span class="line">        max_tokens=1000,                     # 最大返回令牌数</span><br><span class="line">        messages=messages,                   # 消息历史</span><br><span class="line">        tools=available_tools               # 可用工具</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 处理响应并处理工具调用</span><br><span class="line">    final_text = []  # 存储最终文本结果</span><br><span class="line"></span><br><span class="line">    assistant_message_content = []  # 存储助手消息内容</span><br><span class="line">    for content in response.content:  # 遍历响应内容</span><br><span class="line">        if content.type == &#x27;text&#x27;:  # 如果是文本内容</span><br><span class="line">            final_text.append(content.text)  # 添加到最终结果</span><br><span class="line">            assistant_message_content.append(content)  # 添加到助手消息</span><br><span class="line">        elif content.type == &#x27;tool_use&#x27;:  # 如果是工具调用</span><br><span class="line">            tool_name = content.name    # 工具名称</span><br><span class="line">            tool_args = content.input   # 工具参数</span><br><span class="line"></span><br><span class="line">            # 执行工具调用</span><br><span class="line">            result = await self.session.call_tool(tool_name, tool_args)</span><br><span class="line">            final_text.append(f&quot;[调用工具 &#123;tool_name&#125;，参数 &#123;tool_args&#125;]&quot;)</span><br><span class="line"></span><br><span class="line">            assistant_message_content.append(content)</span><br><span class="line">            # 添加助手消息到历史</span><br><span class="line">            messages.append(&#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: assistant_message_content</span><br><span class="line">            &#125;)</span><br><span class="line">            # 添加工具执行结果到历史</span><br><span class="line">            messages.append(&#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;tool_result&quot;,      # 工具结果类型</span><br><span class="line">                        &quot;tool_use_id&quot;: content.id,  # 工具使用ID</span><br><span class="line">                        &quot;content&quot;: result.content   # 工具执行结果</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            # 获取Claude的下一个响应</span><br><span class="line">            response = self.anthropic.messages.create(</span><br><span class="line">                model=&quot;qwen3-235b-a22b&quot;,</span><br><span class="line">                max_tokens=1000,</span><br><span class="line">                messages=messages,</span><br><span class="line">                tools=available_tools</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            # 添加响应文本到最终结果</span><br><span class="line">            final_text.append(response.content[0].text)</span><br><span class="line"></span><br><span class="line">    # 返回连接后的最终文本结果</span><br><span class="line">    return &quot;\n&quot;.join(final_text)</span><br></pre></td></tr></table></figure>
<h4 id="交互式聊天界面"><a href="#交互式聊天界面" class="headerlink" title="交互式聊天界面"></a>交互式聊天界面</h4><p>现在我们将添加聊天循环和清理功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">async def chat_loop(self):</span><br><span class="line">    &quot;&quot;&quot;运行交互式聊天循环&quot;&quot;&quot;</span><br><span class="line">    print(&quot;\nMCP客户端已启动!&quot;)</span><br><span class="line">    print(&quot;输入您的问题或输入&#x27;quit&#x27;退出。&quot;)</span><br><span class="line"></span><br><span class="line">    while True:  # 无限循环，持续接收用户输入</span><br><span class="line">        try:</span><br><span class="line">            query = input(&quot;\n问题: &quot;).strip()  # 获取用户输入并去除首尾空格</span><br><span class="line"></span><br><span class="line">            if query.lower() == &#x27;quit&#x27;:  # 如果用户输入&#x27;quit&#x27;（不区分大小写）</span><br><span class="line">                break  # 退出循环</span><br><span class="line"></span><br><span class="line">            # 处理用户查询并获取响应</span><br><span class="line">            response = await self.process_query(query)</span><br><span class="line">            print(&quot;\n&quot; + response)  # 打印AI响应结果</span><br><span class="line"></span><br><span class="line">        except Exception as e:  # 捕获所有异常</span><br><span class="line">            print(f&quot;\n错误: &#123;str(e)&#125;&quot;)  # 打印错误信息</span><br><span class="line"></span><br><span class="line">async def cleanup(self):</span><br><span class="line">    &quot;&quot;&quot;清理资源&quot;&quot;&quot;</span><br><span class="line">    await self.exit_stack.aclose()  # 异步关闭所有在exit_stack中管理的资源</span><br></pre></td></tr></table></figure>
<h4 id="主入口点"><a href="#主入口点" class="headerlink" title="主入口点"></a>主入口点</h4><p>最后，我们将添加主要的执行逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">async def main():</span><br><span class="line">    # 检查命令行参数数量，如果少于2个则显示使用说明</span><br><span class="line">    if len(sys.argv) &lt; 2:</span><br><span class="line">        print(&quot;用法: python client.py &lt;服务器脚本路径&gt;&quot;)</span><br><span class="line">        sys.exit(1)  # 退出程序，返回错误码1</span><br><span class="line"></span><br><span class="line">    # 创建MCP客户端实例</span><br><span class="line">    client = MCPClient()</span><br><span class="line">    try:</span><br><span class="line">        # 连接到服务器，sys.argv[1]是第一个命令行参数（服务器脚本路径）</span><br><span class="line">        await client.connect_to_server(sys.argv[1])</span><br><span class="line">        # 启动交互式聊天循环</span><br><span class="line">        await client.chat_loop()</span><br><span class="line">    finally:</span><br><span class="line">        # 确保程序结束时清理资源</span><br><span class="line">        await client.cleanup()</span><br><span class="line"></span><br><span class="line"># 程序入口点</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    import sys  # 导入sys模块用于处理命令行参数</span><br><span class="line">    # 运行异步主函数</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><img src="/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/mcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%88%98/QQ20250801-164738.png" alt="QQ20250801-164738"></p>
<h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><p>要使您的客户端与任何 MCP 服务器运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv run client.py path/to/server.py # python server</span><br><span class="line">uv run client.py path/to/build/index.js # node server</span><br></pre></td></tr></table></figure>
<p>客户端将：</p>
<ol>
<li>连接到指定服务器</li>
<li>列出可用工具</li>
<li>开始一个交互式聊天会话，您可以在其中：<ul>
<li>输入查询</li>
<li>查看工具执行情况</li>
<li>从 Claude 获取响应</li>
</ul>
</li>
</ol>
<h3 id="运作流程"><a href="#运作流程" class="headerlink" title="运作流程"></a>运作流程</h3><p>当你提交查询时：</p>
<ol>
<li>客户端从服务器获取可用工具列表</li>
<li>你的查询连同工具描述一起发送给 Claude</li>
<li>Claude 决定使用哪些工具（如果有的话）</li>
<li>客户端通过服务器执行任何请求的工具调用</li>
<li>结果会发送回 Claude</li>
<li>Claude 提供自然语言响应</li>
<li>响应显示给您</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/quickstart/client#main-entry-point">Build an MCP Client - Model Context Protocol</a></p>
<h3 id="适配openai版本"><a href="#适配openai版本" class="headerlink" title="适配openai版本"></a>适配openai版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import json</span><br><span class="line">import sys</span><br><span class="line">from typing import Optional</span><br><span class="line">from contextlib import AsyncExitStack</span><br><span class="line"></span><br><span class="line">from mcp import ClientSession, StdioServerParameters</span><br><span class="line">from mcp.client.stdio import stdio_client</span><br><span class="line"></span><br><span class="line">from openai import OpenAI</span><br><span class="line">from dotenv import load_dotenv</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">load_dotenv()  # 从 .env 文件加载环境变量</span><br><span class="line"></span><br><span class="line">class MCPClient:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化会话和客户端对象</span><br><span class="line">        self.session: Optional[ClientSession] = None  # MCP客户端会话</span><br><span class="line">        self.exit_stack = AsyncExitStack()  # 异步上下文管理器堆栈，用于资源清理</span><br><span class="line">        self.anthropic = OpenAI(</span><br><span class="line">            api_key=os.getenv(&quot;DASHSCOPE_API_KEY&quot;),</span><br><span class="line">            base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span><br><span class="line">        )  # 使用OpenAI兼容模式连接通义千问</span><br><span class="line">        </span><br><span class="line">    async def connect_to_server(self, server_script_path: str):</span><br><span class="line">        &quot;&quot;&quot;连接到MCP服务器</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            server_script_path (str): 服务器脚本路径，支持.py或.js文件</span><br><span class="line">        </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当脚本文件不是.py或.js格式时抛出</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 检查是否为Python文件</span><br><span class="line">        is_python = server_script_path.endswith(&#x27;.py&#x27;)</span><br><span class="line">        # 检查是否为JavaScript文件</span><br><span class="line">        is_js = server_script_path.endswith(&#x27;.js&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 如果不是Python或JavaScript文件，则抛出错误</span><br><span class="line">        if not (is_python or is_js):</span><br><span class="line">            raise ValueError(&quot;服务器脚本必须是 .py 或 .js 文件&quot;)</span><br><span class="line"></span><br><span class="line">        # 根据文件类型确定执行命令</span><br><span class="line">        command = &quot;python&quot; if is_python else &quot;node&quot;</span><br><span class="line">        </span><br><span class="line">        # 创建服务器参数对象</span><br><span class="line">        server_params = StdioServerParameters(</span><br><span class="line">            command=command,           # 执行命令</span><br><span class="line">            args=[server_script_path], # 脚本路径作为参数</span><br><span class="line">            env=None                   # 环境变量（使用默认环境）</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        # 建立stdio客户端连接并将其添加到异步上下文管理器中</span><br><span class="line">        stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))</span><br><span class="line">        self.stdio, self.write = stdio_transport</span><br><span class="line">        </span><br><span class="line">        # 创建客户端会话并将其添加到异步上下文管理器中</span><br><span class="line">        self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))</span><br><span class="line"></span><br><span class="line">        # 初始化会话</span><br><span class="line">        await self.session.initialize()</span><br><span class="line"></span><br><span class="line">        # 列出可用的工具</span><br><span class="line">        response = await self.session.list_tools()</span><br><span class="line">        tools = response.tools</span><br><span class="line">        </span><br><span class="line">        # 打印连接的服务器提供的工具列表</span><br><span class="line">        print(&quot;\n已连接到服务器，可用工具:&quot;, [tool.name for tool in tools])</span><br><span class="line"></span><br><span class="line">    async def process_query(self, query: str) -&gt; str:</span><br><span class="line">        &quot;&quot;&quot;使用Qwen和可用工具处理查询&quot;&quot;&quot;</span><br><span class="line">        # 构建消息列表</span><br><span class="line">        messages = [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: query</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        # 获取可用工具列表并转换为OpenAI格式</span><br><span class="line">        response = await self.session.list_tools()</span><br><span class="line">        available_tools = []</span><br><span class="line">        for tool in response.tools:</span><br><span class="line">            schema = tool.inputSchema</span><br><span class="line">            if isinstance(schema, str):</span><br><span class="line">                schema = json.loads(schema)</span><br><span class="line">            if isinstance(schema, dict) and &quot;properties&quot; in schema:</span><br><span class="line">                schema = &#123;&quot;type&quot;: &quot;object&quot;, **schema&#125;</span><br><span class="line"></span><br><span class="line">            available_tools.append(&#123;</span><br><span class="line">                &quot;type&quot;: &quot;function&quot;,</span><br><span class="line">                &quot;function&quot;: &#123;</span><br><span class="line">                    &quot;name&quot;: tool.name,</span><br><span class="line">                    &quot;description&quot;: tool.description,</span><br><span class="line">                    &quot;parameters&quot;: schema</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        # 第一次调用模型</span><br><span class="line">        response = self.anthropic.chat.completions.create(</span><br><span class="line">            model=&quot;qwen3-235b-a22b&quot;,</span><br><span class="line">            max_tokens=1000,</span><br><span class="line">            messages=messages,</span><br><span class="line">            tools=available_tools,</span><br><span class="line">            extra_body=&#123;&quot;enable_thinking&quot;: False&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        final_text = []</span><br><span class="line">        message = response.choices[0].message</span><br><span class="line"></span><br><span class="line">        # 处理文本内容</span><br><span class="line">        if message.content:</span><br><span class="line">            final_text.append(message.content)</span><br><span class="line"></span><br><span class="line">        # 处理工具调用</span><br><span class="line">        if message.tool_calls:</span><br><span class="line">            for tool_call in message.tool_calls:</span><br><span class="line">                tool_name = tool_call.function.name</span><br><span class="line">                tool_args = json.loads(tool_call.function.arguments)</span><br><span class="line">                </span><br><span class="line">                # 执行工具调用</span><br><span class="line">                result = await self.session.call_tool(tool_name, tool_args)</span><br><span class="line">                final_text.append(f&quot;[调用工具 &#123;tool_name&#125;，参数 &#123;tool_args&#125;]&quot;)</span><br><span class="line">                </span><br><span class="line">                # 处理工具结果</span><br><span class="line">                tool_result_content = &quot;&quot;</span><br><span class="line">                if result.content:</span><br><span class="line">                    for item in result.content:</span><br><span class="line">                        if hasattr(item, &#x27;type&#x27;) and item.type == &#x27;text&#x27;:</span><br><span class="line">                            tool_result_content += item.text</span><br><span class="line">                        else:</span><br><span class="line">                            tool_result_content += str(item)</span><br><span class="line"></span><br><span class="line">                # 添加助手消息到历史</span><br><span class="line">                messages.append(&#123;</span><br><span class="line">                    &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                    &quot;content&quot;: None,</span><br><span class="line">                    &quot;tool_calls&quot;: [tool_call]</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                # 添加工具执行结果到历史</span><br><span class="line">                messages.append(&#123;</span><br><span class="line">                    &quot;role&quot;: &quot;tool&quot;,</span><br><span class="line">                    &quot;tool_call_id&quot;: tool_call.id,</span><br><span class="line">                    &quot;content&quot;: tool_result_content</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                # 再次调用模型</span><br><span class="line">                response = self.anthropic.chat.completions.create(</span><br><span class="line">                    model=&quot;qwen3-235b-a22b&quot;,</span><br><span class="line">                    max_tokens=1000,</span><br><span class="line">                    messages=messages,</span><br><span class="line">                    tools=available_tools,</span><br><span class="line">                    extra_body=&#123;&quot;enable_thinking&quot;: False&#125;</span><br><span class="line">                )</span><br><span class="line">                </span><br><span class="line">                # 处理最终响应</span><br><span class="line">                if response.choices and response.choices[0].message.content:</span><br><span class="line">                    final_text.append(response.choices[0].message.content)</span><br><span class="line"></span><br><span class="line">        return &quot;\n&quot;.join(final_text)</span><br><span class="line"></span><br><span class="line">    async def chat_loop(self):</span><br><span class="line">        &quot;&quot;&quot;运行交互式聊天循环&quot;&quot;&quot;</span><br><span class="line">        print(&quot;\nMCP客户端已启动!&quot;)</span><br><span class="line">        print(&quot;输入您的问题或输入&#x27;quit&#x27;退出。&quot;)</span><br><span class="line"></span><br><span class="line">        while True:  # 无限循环，持续接收用户输入</span><br><span class="line">            try:</span><br><span class="line">                query = input(&quot;\n问题: &quot;).strip()  # 获取用户输入并去除首尾空格</span><br><span class="line"></span><br><span class="line">                if query.lower() == &#x27;quit&#x27;:  # 如果用户输入&#x27;quit&#x27;（不区分大小写）</span><br><span class="line">                    break  # 退出循环</span><br><span class="line"></span><br><span class="line">                # 处理用户查询并获取响应</span><br><span class="line">                response = await self.process_query(query)</span><br><span class="line">                print(&quot;\n&quot; + response)  # 打印AI响应结果</span><br><span class="line"></span><br><span class="line">            except Exception as e:  # 捕获所有异常</span><br><span class="line">                print(f&quot;\n错误: &#123;str(e)&#125;&quot;)  # 打印错误信息</span><br><span class="line">                import traceback</span><br><span class="line">                traceback.print_exc()  # 打印详细错误信息</span><br><span class="line"></span><br><span class="line">    async def cleanup(self):</span><br><span class="line">        &quot;&quot;&quot;清理资源&quot;&quot;&quot;</span><br><span class="line">        await self.exit_stack.aclose()  # 异步关闭所有在exit_stack中管理的资源</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    # 检查命令行参数数量，如果少于2个则显示使用说明</span><br><span class="line">    if len(sys.argv) &lt; 2:</span><br><span class="line">        print(&quot;用法: python client.py &lt;服务器脚本路径&gt;&quot;)</span><br><span class="line">        sys.exit(1)  # 退出程序，返回错误码1</span><br><span class="line"></span><br><span class="line">    # 创建MCP客户端实例</span><br><span class="line">    client = MCPClient()</span><br><span class="line">    try:</span><br><span class="line">        # 连接到服务器，sys.argv[1]是第一个命令行参数（服务器脚本路径）</span><br><span class="line">        await client.connect_to_server(sys.argv[1])</span><br><span class="line">        # 启动交互式聊天循环</span><br><span class="line">        await client.chat_loop()</span><br><span class="line">    finally:</span><br><span class="line">        # 确保程序结束时清理资源</span><br><span class="line">        await client.cleanup()</span><br><span class="line"></span><br><span class="line"># 程序入口点</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 运行异步主函数</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h3 id="openai和claude在工具调用的差异"><a href="#openai和claude在工具调用的差异" class="headerlink" title="openai和claude在工具调用的差异"></a>openai和claude在工具调用的差异</h3><ol>
<li><strong>工具格式转换修复</strong></li>
</ol>
<p><strong>问题</strong>：MCP工具格式与OpenAI API不兼容<br><strong>修复</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原错误格式</span></span><br><span class="line">available_tools = [&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: tool.name,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: tool.description,</span><br><span class="line">    <span class="string">&quot;input_schema&quot;</span>: tool.inputSchema</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复后格式（符合OpenAI规范）</span></span><br><span class="line">available_tools = [&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: tool.name,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: tool.description,</span><br><span class="line">        <span class="string">&quot;parameters&quot;</span>: schema  <span class="comment"># 正确的JSON Schema格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>API响应处理修复</strong></li>
</ol>
<p><strong>问题</strong>：错误访问了OpenAI响应对象的属性<br><strong>修复</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原错误代码</span></span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> response.content:  <span class="comment"># ❌ response没有content属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复后代码</span></span><br><span class="line">message = response.choices[<span class="number">0</span>].message  <span class="comment"># ✅ 正确的访问路径</span></span><br><span class="line"><span class="keyword">if</span> message.content:</span><br><span class="line">    final_text.append(message.content)</span><br><span class="line"><span class="keyword">if</span> message.tool_calls:</span><br><span class="line">    <span class="keyword">for</span> tool_call <span class="keyword">in</span> message.tool_calls:</span><br><span class="line">        <span class="comment"># 处理工具调用</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>工具调用结果处理修复</strong></li>
</ol>
<p><strong>问题</strong>：错误处理MCP工具调用返回的结果结构<br><strong>修复</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原错误代码</span></span><br><span class="line"><span class="string">&quot;content&quot;</span>: result.content  <span class="comment"># ❌ 可能包含复杂对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复后代码</span></span><br><span class="line">tool_result_content = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> result.content:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result.content:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(item, <span class="string">&#x27;type&#x27;</span>) <span class="keyword">and</span> item.<span class="built_in">type</span> == <span class="string">&#x27;text&#x27;</span>:</span><br><span class="line">            tool_result_content += item.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tool_result_content += <span class="built_in">str</span>(item)</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>消息历史构建修复</strong></li>
</ol>
<p><strong>问题</strong>：工具调用后消息历史格式不正确<br><strong>修复</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确的消息历史格式</span></span><br><span class="line">messages.append(&#123;</span><br><span class="line">    <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">&quot;tool_calls&quot;</span>: [tool_call]</span><br><span class="line">&#125;)</span><br><span class="line">messages.append(&#123;</span><br><span class="line">    <span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tool_call_id&quot;</span>: tool_call.<span class="built_in">id</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: tool_result_content</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>JSON Schema兼容性处理</strong></li>
</ol>
<p><strong>问题</strong>：MCP返回的schema可能缺少必要的根类型定义<br><strong>修复</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">schema = tool.inputSchema</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(schema, <span class="built_in">str</span>):</span><br><span class="line">    schema = json.loads(schema)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(schema, <span class="built_in">dict</span>) <span class="keyword">and</span> <span class="string">&quot;properties&quot;</span> <span class="keyword">in</span> schema:</span><br><span class="line">    schema = &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>, **schema&#125;  <span class="comment"># 确保有根类型</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/langgraph%E5%AE%9E%E6%88%98mcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/langgraph%E5%AE%9E%E6%88%98mcp/" class="post-title-link" itemprop="url">langgraph实战mcp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-01T00:00:00+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-02 11:47:14" itemprop="dateModified" datetime="2025-08-02T11:47:14+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mcp/" itemprop="url" rel="index"><span itemprop="name">mcp</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install langchain-mcp-adapters</span><br></pre></td></tr></table></figure>
<h3 id="使用langgraph调用mcp"><a href="#使用langgraph调用mcp" class="headerlink" title="使用langgraph调用mcp"></a>使用langgraph调用mcp</h3><p>要点主要是利用MultiServerMCPClient构建服务，获取tool</p>
<p>利用预设的create_react_agent构建ReAct架构的智能体并调用工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import asyncio # 需要导入 asyncio 来运行异步函数</span><br><span class="line"># 从langchain_mcp_adapters.client模块导入MultiServerMCPClient类</span><br><span class="line"># 从langgraph.prebuilt模块导入create_react_agent函数</span><br><span class="line">from langchain_mcp_adapters.client import MultiServerMCPClient</span><br><span class="line">from langgraph.prebuilt import create_react_agent</span><br><span class="line"></span><br><span class="line"># 导入 LLM 相关库</span><br><span class="line">from langchain_openai import ChatOpenAI</span><br><span class="line"></span><br><span class="line"># 将主要逻辑封装在一个异步函数中</span><br><span class="line">async def main():</span><br><span class="line">    # 创建MultiServerMCPClient实例，配置两个不同的服务</span><br><span class="line">    client = MultiServerMCPClient(</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;math&quot;: &#123;  # 数学计算服务</span><br><span class="line">                &quot;command&quot;: &quot;python&quot;,  # 使用python命令启动</span><br><span class="line">                # 替换为你的math_server.py文件的绝对路径</span><br><span class="line">                &quot;args&quot;: [&quot;/workspace/langgraph-mcp/math_server.py&quot;],</span><br><span class="line">                &quot;transport&quot;: &quot;stdio&quot;,  # 使用标准输入输出传输</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;weather&quot;: &#123;  # 天气服务</span><br><span class="line">                # 确保你的天气服务器在8000端口运行</span><br><span class="line">                # *** 确保这个 URL 是正确的，并且服务器正在运行 ***</span><br><span class="line">                &quot;url&quot;: &quot;http://localhost:8000/mcp&quot;,</span><br><span class="line">                &quot;transport&quot;: &quot;streamable_http&quot;,  # 使用可流式HTTP传输</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    tools = []</span><br><span class="line">    try:</span><br><span class="line">        # 在异步函数内部正确使用 await</span><br><span class="line">        tools = await client.get_tools()</span><br><span class="line">        print(f&quot;成功获取到 &#123;len(tools)&#125; 个MCP工具。&quot;)</span><br><span class="line">        for tool_item in tools:</span><br><span class="line">            print(f&quot;  - &#123;tool_item.name&#125;: &#123;tool_item.description&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;获取MCP工具失败: &#123;e&#125;&quot;)</span><br><span class="line">        print(&quot;请确保MCP服务URL有效且可访问，或者您已正确配置了认证信息。&quot;)</span><br><span class="line">        # 在函数内部，如果出错可以选择返回或继续处理</span><br><span class="line">        # return # 这里可以 return，但会结束 main 函数</span><br><span class="line"></span><br><span class="line">    if not tools:</span><br><span class="line">        print(&quot;没有获取到工具，无法创建代理。&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 创建ReAct代理</span><br><span class="line">    llm = ChatOpenAI(</span><br><span class="line">        model=&quot;qwen3-235b-a22b-thinking-2507&quot;,</span><br><span class="line">        api_key=&quot;sk-a8ef27c47ea84224ac6eed6d4bba1bab&quot;,</span><br><span class="line">        base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot; # 修正了末尾多余的空格</span><br><span class="line">    )</span><br><span class="line">    agent = create_react_agent(llm, tools)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    # 异步调用代理来解决数学问题</span><br><span class="line">    # 确保在异步函数内部使用 await</span><br><span class="line">    math_response = await agent.ainvoke(</span><br><span class="line">        &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;what&#x27;s (3 + 5) x 12?&quot;&#125;]&#125;</span><br><span class="line">    )</span><br><span class="line">    print(&quot;\n--- 数学问题回答 ---&quot;)</span><br><span class="line">    print(math_response[&quot;messages&quot;][-1].content) # 打印最后一条消息（LLM的回答）</span><br><span class="line"></span><br><span class="line">    # 异步调用代理来查询天气</span><br><span class="line">    weather_response = await agent.ainvoke(</span><br><span class="line">        &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;what is the weather in nyc?&quot;&#125;]&#125;</span><br><span class="line">    )</span><br><span class="line">    print(&quot;\n--- 天气问题回答 ---&quot;)</span><br><span class="line">    print(weather_response[&quot;messages&quot;][-1].content) # 打印最后一条消息（LLM的回答）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># --- 这是脚本的入口点 ---</span><br><span class="line"># 使用 asyncio.run() 来运行你的主异步函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://github.langchain.ac.cn/langgraph/agents/mcp/">使用 MCP - LangChain 框架</a></p>
<h3 id="框架流程"><a href="#框架流程" class="headerlink" title="框架流程"></a>框架流程</h3><p><img src="/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/langgraph%E5%AE%9E%E6%88%98mcp/image-20250801164905578.png" alt="image-20250801164905578"></p>
<p>✅ 三个角色（系统组件）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Client</strong></td>
<td>前端或用户界面，发起请求</td>
</tr>
<tr>
<td><strong>Auth Provider</strong></td>
<td>认证服务（如 OAuth、JWT 提供者），负责登录和签发 token</td>
</tr>
<tr>
<td><strong>LangGraph Backend</strong></td>
<td>应用的后端服务，处理业务逻辑</td>
</tr>
<tr>
<td><strong>Secret Store</strong></td>
<td>存放用户敏感信息（如 token、密钥等）</td>
</tr>
<tr>
<td><strong>MCP Server</strong></td>
<td>后端工具服务，提供具体的工具或资源接口</td>
</tr>
</tbody>
</table>
</div>
<p>✅ 流程详解（12步）</p>
<p>🔐 阶段一：用户登录 &amp; 获取 Token（1~6）</p>
<ol>
<li><p><strong>用户登录</strong><br>Client 提交用户名和密码给 Auth Provider。</p>
</li>
<li><p><strong>返回 Token</strong><br>Auth Provider 验证成功后，返回一个访问令牌（token）。</p>
</li>
<li><p><strong>携带 Token 请求</strong><br>Client 将 token 附加在请求头中，发给 LangGraph Backend。</p>
</li>
<li><p><strong>验证 Token</strong><br>LangGraph Backend 使用 <code>@auth.authenticate</code> 中间件验证 token 是否有效。</p>
</li>
<li><p><strong>获取用户信息</strong><br>验证通过后，LangGraph Backend 从 Auth Provider 拉取用户详细信息。</p>
</li>
<li><p><strong>确认有效性</strong><br>后端确认用户信息无误，流程继续。</p>
</li>
</ol>
<p>🔑 阶段二：获取用户权限 Token（6a~6b）</p>
<p>6a. <strong>拉取用户权限 Token</strong><br>   LangGraph Backend 从 Secret Store 获取该用户对应的权限 token（可能是 MCP 所需的访问凭证）。</p>
<p>6b. <strong>返回权限 Token</strong><br>   Secret Store 返回该 token。</p>
<p>🛠️ 阶段三：调用工具 &amp; 返回结果（7~12）</p>
<ol>
<li><p><strong>权限控制检查</strong><br>LangGraph Backend 使用 <code>@auth.on.*</code> 权限控制逻辑，确认用户是否有权调用该工具。</p>
</li>
<li><p><strong>构建 MCP Client</strong><br>后端用用户的权限 token 构建一个 MCP 客户端。</p>
</li>
<li><p><strong>调用 MCP 工具</strong><br>MCP Client 发起请求，调用某个具体工具，携带 token（通常放在请求头中）。</p>
</li>
<li><p><strong>MCP 验证并执行</strong><br>MCP Server 验证 token 是否有效，确认无误后执行工具逻辑。</p>
</li>
<li><p><strong>工具返回结果</strong><br>MCP Server 返回工具执行结果或资源数据。</p>
</li>
<li><p><strong>返回给前端</strong><br>LangGraph Backend 将结果返回给 Client，完成整个链路。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/mcp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/mcp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">MCP 服务端实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-01T00:00:00+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-02 12:01:55" itemprop="dateModified" datetime="2025-08-02T12:01:55+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mcp/" itemprop="url" rel="index"><span itemprop="name">mcp</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Create a new directory for our project</span><br><span class="line">uv init weather</span><br><span class="line">cd weather</span><br><span class="line"></span><br><span class="line"># Create virtual environment and activate it</span><br><span class="line">uv venv</span><br><span class="line">source .venv/bin/activate</span><br><span class="line"></span><br><span class="line"># Install dependencies</span><br><span class="line">uv add &quot;mcp[cli]&quot; httpx</span><br><span class="line"></span><br><span class="line"># Create our server file</span><br><span class="line">touch weather.py</span><br></pre></td></tr></table></figure>
<h3 id="mcp-studio样例"><a href="#mcp-studio样例" class="headerlink" title="mcp studio样例"></a>mcp studio样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from mcp.server.fastmcp import FastMCP</span><br><span class="line"></span><br><span class="line">mcp = FastMCP(&quot;Math&quot;)</span><br><span class="line"></span><br><span class="line">@mcp.tool()</span><br><span class="line">def add(a: int, b: int) -&gt; int:</span><br><span class="line">    &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line">@mcp.tool()</span><br><span class="line">def multiply(a: int, b: int) -&gt; int:</span><br><span class="line">    &quot;&quot;&quot;Multiply two numbers&quot;&quot;&quot;</span><br><span class="line">    return a * b</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    mcp.run(transport=&quot;stdio&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="mcp-streamable-http-样例"><a href="#mcp-streamable-http-样例" class="headerlink" title="mcp streamable-http 样例"></a>mcp streamable-http 样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from mcp.server.fastmcp import FastMCP</span><br><span class="line"></span><br><span class="line">mcp = FastMCP(&quot;Weather&quot;)</span><br><span class="line"></span><br><span class="line">@mcp.tool()</span><br><span class="line">async def get_weather(location: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;Get weather for location.&quot;&quot;&quot;</span><br><span class="line">    return &quot;It&#x27;s always sunny in New York&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    mcp.run(transport=&quot;streamable-http&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>mcp市场<a target="_blank" rel="noopener" href="https://www.modelscope.cn/mcp">MCP 广场 · 魔搭社区</a></p>
<p><strong>使用 uv（推荐）</strong></p>
<p>当使用 <a target="_blank" rel="noopener" href="https://docs.astral.sh/uv/"><code>uv</code></a> 时不需要特定的安装步骤。我们将使用 <a target="_blank" rel="noopener" href="https://docs.astral.sh/uv/guides/tools/"><code>uvx</code></a> 直接运行 <em>mcp-server-fetch</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;mcpServers&quot;: &#123;</span><br><span class="line">  &quot;fetch&quot;: &#123;</span><br><span class="line">    &quot;command&quot;: &quot;uvx&quot;,</span><br><span class="line">    &quot;args&quot;: [&quot;mcp-server-fetch&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 PIP</strong></p>
<p>或者，您可以通过 pip 安装 <code>mcp-server-fetch</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mcp-server-fetch</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;mcpServers&quot;: &#123;</span><br><span class="line">  &quot;fetch&quot;: &#123;</span><br><span class="line">    &quot;command&quot;: &quot;python&quot;,</span><br><span class="line">    &quot;args&quot;: [&quot;-m&quot;, &quot;mcp_server_fetch&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>远程托管</strong></p>
<p><img src="/2025/08/01/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/mcp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E6%88%98/image-20250802120145192.png" alt="image-20250802120145192"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;mcpServers&quot;: &#123;</span><br><span class="line">    &quot;fetch&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;sse&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https://mcp.api-inference.modelscope.net/991cf46/sse&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/quickstart/server#core-mcp-concepts">构建 MCP 服务器 - 模型上下文协议 —- Build an MCP Server - Model Context Protocol</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/31/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/%E5%82%A8%E5%AD%98%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93Chroma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/31/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/%E5%82%A8%E5%AD%98%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93Chroma/" class="post-title-link" itemprop="url">储存向量数据库Chroma</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-31 00:00:00 / 修改时间：15:54:10" itemprop="dateCreated datePublished" datetime="2025-07-31T00:00:00+08:00">2025-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Chroma是什么"><a href="#Chroma是什么" class="headerlink" title="Chroma是什么"></a>Chroma是什么</h3><p>Chroma（通常指 <strong>ChromaDB</strong>）是一款 <strong>开源、AI 原生的向量数据库</strong>，专为存储和检索 <strong>高维嵌入向量</strong> 而设计，目标是让开发者 <strong>5 分钟内在本地跑起一个语义搜索或 RAG 系统</strong>。</p>
<p><strong>极简安装</strong>：<code>pip install chromadb</code></p>
<p><strong>双运行模式</strong>：</p>
<ul>
<li><strong>内存模式</strong>：调试/原型随意重启；</li>
<li><strong>持久化模式</strong>：指定 <code>persist_directory</code> 即可落盘，生产也不怕丢数据。</li>
</ul>
<p><strong>HNSW 索引</strong>：百万级向量也能 <strong>毫秒级</strong> 响应。</p>
<h3 id="使用chroma存储"><a href="#使用chroma存储" class="headerlink" title="使用chroma存储"></a>使用chroma存储</h3><h4 id="文档分块"><a href="#文档分块" class="headerlink" title="文档分块"></a>文档分块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langchain.document_loaders import PyPDFLoader</span><br><span class="line">from langchain.text_splitter import RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">loader = PyPDFLoader(&quot;input/健康档案.pdf&quot;)</span><br><span class="line">docs = loader.load()</span><br><span class="line">#递归分块</span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(chunk_siz</span><br></pre></td></tr></table></figure>
<h4 id="定义embedding模型与chroma"><a href="#定义embedding模型与chroma" class="headerlink" title="定义embedding模型与chroma"></a>定义embedding模型与chroma</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from langchain.vectorstores import Chroma</span><br><span class="line">from langchain_openai import OpenAIEmbeddings</span><br><span class="line">embedding = OpenAIEmbeddings(</span><br><span class="line">api_key=&quot;sk-&quot;, </span><br><span class="line">base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;,</span><br><span class="line">model=&quot;text-embedding-v4&quot;,</span><br><span class="line">check_embedding_ctx_length = False,</span><br><span class="line">dimensions=1536</span><br><span class="line">)</span><br><span class="line"># 使用 Chroma 向量数据库存储文档 chunks</span><br><span class="line">vectorstore = Chroma.from_documents(</span><br><span class="line">    documents=chunks,           # 要存储的文档chunks列表（已处理好的文本片段）</span><br><span class="line">    embedding=embedding,        </span><br><span class="line">    persist_directory=&quot;chromaDB&quot;,  # 向量数据库的持久化存储目录路径</span><br><span class="line">    collection_name=&quot;demo001&quot;   # 集合名称，用于区分不同的文档集合</span><br><span class="line">)</span><br><span class="line">vectorstore.persist()</span><br></pre></td></tr></table></figure>
<h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h4><p>这里采取直接检索进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">results = vectorstore.similarity_search(</span><br><span class="line">    &quot;张三九的基本信息是什么&quot;,</span><br><span class="line">    k=2,</span><br><span class="line">    collection_name=&quot;demo001&quot;  # 指定检索的集合</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/vectorstores/chroma/#add-items-to-vector-store">Chroma | 🦜️🔗 LangChain —- Chroma | 🦜️🔗 LangChain</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/pgsql%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/pgsql%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">pgsql实现持久化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-28T00:00:00+08:00">2025-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-06 15:00:34" itemprop="dateModified" datetime="2025-08-06T15:00:34+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>常使用pgsql与redis配合langgraph的checkpoint与store进行持久化储存，完成长期记忆与短期记忆的实现</p>
<h3 id="pgsql实现持久化"><a href="#pgsql实现持久化" class="headerlink" title="pgsql实现持久化"></a>pgsql实现持久化</h3><h4 id="什么是pgsql"><a href="#什么是pgsql" class="headerlink" title="什么是pgsql"></a>什么是pgsql</h4><p>PostgreSQL（常简称pgsql或Postgres）是一个功能强大的开源对象-关系型数据库管理系统（ORDBMS），以其稳定性、扩展性和符合SQL标准著称。</p>
<h4 id="docker拉取"><a href="#docker拉取" class="headerlink" title="docker拉取"></a>docker拉取</h4><p>docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  postgres:</span><br><span class="line">    image: postgres:15        # 指定具体版本</span><br><span class="line">    container_name: postgres_db</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_USER: postgres</span><br><span class="line">      POSTGRES_PASSWORD: postgres</span><br><span class="line">      POSTGRES_DB: postgres</span><br><span class="line">      TZ: Asia/Shanghai       # 设置时区</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5432:5432&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - pgdata:/var/lib/postgresql/data</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    healthcheck:             # 健康检查</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;pg_isready&quot;, &quot;-U&quot;, &quot;nange&quot;]</span><br><span class="line">      interval: 10s</span><br><span class="line">      timeout: 5s</span><br><span class="line">      retries: 5</span><br><span class="line">    command: [&quot;postgres&quot;, &quot;-c&quot;, &quot;max_connections=200&quot;]  # 自定义配置</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  pgdata:</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Docker Compose</strong> 是一个 <strong>定义和运行多容器 Docker 应用</strong> 的 <strong>声明式工具</strong>。<br>它通过一个 <strong>YAML 文件（通常叫 <code>docker-compose.yml</code>）</strong> 描述整个应用的服务、网络、存储等配置，然后用一条命令即可 <strong>启动/停止/管理</strong> 所有容器，无需手动逐个 <code>docker run</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#拉取并运行</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h4 id="在pgsqsl安装依赖"><a href="#在pgsqsl安装依赖" class="headerlink" title="在pgsqsl安装依赖"></a>在pgsqsl安装依赖</h4><p>因为LangGraph的PostgresStore需要使用到pgvector，因此需要在容器中按照如下步骤进行操作，直接使用Docker Desktop软件中进行操作 </p>
<blockquote>
<ul>
<li>为什么需要 <code>pgvector</code>？</li>
<li><code>PostgresStore</code> 支持将 <strong>向量嵌入（embedding）</strong> 存储在 PostgreSQL 中，并基于它们进行 <strong>语义搜索</strong>。</li>
<li>该功能依赖 <code>pgvector</code> 扩展提供的 <code>vector</code> 类型和索引机制（如 HNSW）。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装依赖           </span><br><span class="line">apt update    #刷新本地软件包索引           </span><br><span class="line">apt install -y git build-essential postgresql-server-dev-15                          </span><br></pre></td></tr></table></figure>
<blockquote>
<p>apt install -y git build-essential postgresql-server-dev-15一次性安装 3 类依赖。</p>
<ul>
<li><code>git</code> —— 用来克隆 pgvector 源码。</li>
<li><code>build-essential</code> —— Debian/Ubuntu 的“编译工具链”元包，包含 gcc、make 等。</li>
<li><code>postgresql-server-dev-15</code> —— 与当前 Postgres <strong>主版本一致</strong> 的开发头文件和 <code>pg_config</code>。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">编译并安装 pgvector      </span><br><span class="line">#把 pgvector 的 v0.7.0 稳定版 源码克隆到本地目录 ./pgvector。</span><br><span class="line">git clone --branch v0.7.0 https://github.com/pgvector/pgvector.git                </span><br><span class="line">cd pgvector  </span><br><span class="line">#调用 Makefile 根据当前操作系统 + PostgreSQL 版本编译出二进制文件（.so 共享库）。</span><br><span class="line">make          </span><br><span class="line">#把刚刚编好的 .so 文件和 .sql/.control 文件复制到 PostgreSQL 的扩展目录</span><br><span class="line">make install                </span><br><span class="line">验证安装，检查扩展文件是否安装成功                    </span><br><span class="line">ls -l /usr/share/postgresql/15/extension/vector* </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/pgvector/pgvector">pgvector/pgvector: Open-source vector similarity search for Postgres</a></p>
<p>接下来，若要在脚本中进行使用，首先在系统环境中需要安装PostgreSQL 的开发库（libpq），因为 psycopg 需要它来编译或运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libpq-dev postgresql-server-dev-all</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>psycopg（Python 操作 PostgreSQL 的库）</strong> 在 <strong>Linux/macOS</strong> 上运行时，底层依赖于 <strong>PostgreSQL 的 C 语言开发库 libpq</strong>。<br>如果系统里 <strong>没有 libpq</strong>，psycopg 会出现以下两种问题：</p>
<ol>
<li><p><strong>编译安装失败</strong>（源码/旧版本）<br>当 <code>pip install psycopg2</code> 需要现场编译时，会找不到头文件 <code>libpq-fe.h</code> 或动态库 <code>libpq.so</code>，导致报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: libpq-fe.h: No such file or directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行时崩溃</strong><br>即使通过预编译的 wheel 包安装成功，运行时也可能提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libpq.so.5: cannot open shared object file</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>最后，再安装相关依赖包  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install langgraph-checkpoint-postgres                    </span><br><span class="line">pip install psycopg psycopg-pool </span><br></pre></td></tr></table></figure>
<p>psycopg官方 PostgreSQL 驱动，在 <code>psycopg</code> 之上再包一层“<strong>连接池</strong>”，让并发访问更快、更稳定。</p>
<h4 id="连接pgsql"><a href="#连接pgsql" class="headerlink" title="连接pgsql"></a>连接pgsql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.store.postgres import PostgresStore</span><br><span class="line">from langgraph.checkpoint.postgres import PostgresSaver</span><br><span class="line">from psycopg_pool import ConnectionPool</span><br><span class="line"># 1) 连接字符串（URI 语法）</span><br><span class="line">DB_URI = &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&quot;</span><br><span class="line">#   协议://      用户   : 密码   @ 主机:端口 / 数据库名  ? 额外参数</span><br><span class="line"></span><br><span class="line"># 2) 连接级参数</span><br><span class="line">connection_kwargs = &#123;</span><br><span class="line">    &quot;autocommit&quot;: True,     # 每条 SQL 执行完立即提交，无需手动 commit</span><br><span class="line">    &quot;prepare_threshold&quot;: 0, # 禁用服务器端 prepared statement，可减少一次往返</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3) 创建池</span><br><span class="line">connection_pool = ConnectionPool(</span><br><span class="line">    conninfo=DB_URI,</span><br><span class="line">    max_size=20,            # 最多 20 条物理连接</span><br><span class="line">    kwargs=connection_kwargs,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 4) 显式打开池（psycopg 3 的 ConnectionPool 默认懒启动，调 open() 会立即建 min_size 条连接）</span><br><span class="line">connection_pool.open()</span><br><span class="line">print(&quot;数据库连接池初始化成功&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正常情况每次 SQL 都新建一条 TCP 连接、做 SSL 握手、验证密码、分配内存，如果不复用连接，这些动作就要 <strong>每次都重新来一遍</strong>，<strong>成本非常高</strong>。</p>
<p>连接池（Connection Pool）是一种 <strong>数据库访问层资源管理组件</strong>，其核心目标是在 <strong>高并发、短事务</strong> 场景下，通过 <strong>复用已建立的数据库物理连接</strong> 来降低系统整体延迟、减少资源消耗，并防止数据库因瞬时连接风暴而崩溃。</p>
</blockquote>
<h4 id="初始化pgsql"><a href="#初始化pgsql" class="headerlink" title="初始化pgsql"></a>初始化pgsql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 初始化PostgresStore</span><br><span class="line">in_postgres_store = PostgresStore(</span><br><span class="line">    pool,</span><br><span class="line">    index=&#123;</span><br><span class="line">        &quot;dims&quot;: 1536,</span><br><span class="line">        &quot;embed&quot;: embedding</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">in_postgres_store.setup()</span><br><span class="line"></span><br><span class="line">#初始化checkpoint</span><br><span class="line"># 使用传入的连接池创建 PostgresSaver</span><br><span class="line">checkpointer = PostgresSaver(pool)</span><br><span class="line">checkpointer.setup()</span><br><span class="line"></span><br><span class="line">#最后编译时添加</span><br><span class="line">graph_builder.compile(checkpointer=checkpointer, store=in_postgres_store)</span><br></pre></td></tr></table></figure>
<p><code>in_postgres_store.setup()</code> 的角色一句话就能说清：</p>
<blockquote>
<p><strong>把数据库里所有为了让向量存储正常工作的“一次性基建”全部建好</strong>——只建一次，后面再跑就不会重复执行。</p>
</blockquote>
<p>具体而言，它通常干下面三件事：1.<strong>建表 / 建扩展</strong>；2.<strong>建向量索引</strong>；3.<strong>元数据初始化</strong></p>
<h4 id="fastapi实现生命周期的管理"><a href="#fastapi实现生命周期的管理" class="headerlink" title="fastapi实现生命周期的管理"></a>fastapi实现生命周期的管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 定义了一个异步函数lifespan，它接收一个FastAPI应用实例app作为参数。这个函数将管理应用的生命周期，包括启动和关闭时的操作</span><br><span class="line"># 函数在应用启动时执行一些初始化操作，如加载上下文数据、以及初始化问题生成器</span><br><span class="line"># 函数在应用关闭时执行一些清理操作</span><br><span class="line"># @asynccontextmanager 装饰器用于创建一个异步上下文管理器，它允许你在 yield 之前和之后执行特定的代码块，分别表示启动和关闭时的操作</span><br><span class="line">@asynccontextmanager</span><br><span class="line">async def lifespan(app: FastAPI):</span><br><span class="line">    # 启动时执行</span><br><span class="line">    # 申明引用全局变量，在函数中被初始化，并在整个应用中使用</span><br><span class="line">    global graph, connection_pool</span><br><span class="line">    # 启动时执行</span><br><span class="line">    try:</span><br><span class="line">        logger.info(&quot;正在初始化模型、定义 Graph...&quot;)</span><br><span class="line">        # 初始化 LLM</span><br><span class="line">        llm, embedding = get_llm(llm_type)</span><br><span class="line">        # 创建数据库连接池</span><br><span class="line">        DB_URI = &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&quot;</span><br><span class="line">        connection_kwargs = &#123;</span><br><span class="line">            &quot;autocommit&quot;: True,</span><br><span class="line">            &quot;prepare_threshold&quot;: 0,</span><br><span class="line">        &#125;</span><br><span class="line">        connection_pool = ConnectionPool(</span><br><span class="line">            conninfo=DB_URI,</span><br><span class="line">            max_size=20,</span><br><span class="line">            kwargs=connection_kwargs,</span><br><span class="line">        )</span><br><span class="line">        connection_pool.open()  # 显式打开连接池</span><br><span class="line">        logger.info(&quot;数据库连接池初始化成功&quot;)</span><br><span class="line">        # 短期记忆 初始化checkpointer</span><br><span class="line">        checkpointer = PostgresSaver(connection_pool)</span><br><span class="line">        checkpointer.setup()</span><br><span class="line">        # 长期记忆 初始化PostgresStore</span><br><span class="line">        in_postgres_store = PostgresStore(</span><br><span class="line">            connection_pool,</span><br><span class="line">            index=&#123;</span><br><span class="line">                &quot;dims&quot;: 1536,</span><br><span class="line">                &quot;embed&quot;: embedding</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        in_postgres_store.setup()</span><br><span class="line">        # 定义 Graph</span><br><span class="line">        graph = create_graph(llm, checkpointer, in_postgres_store )</span><br><span class="line">        # 保存 Graph 可视化图</span><br><span class="line">        save_graph_visualization(graph)</span><br><span class="line">        logger.info(&quot;初始化完成&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logger.error(f&quot;初始化过程中出错: &#123;str(e)&#125;&quot;)</span><br><span class="line">        raise</span><br><span class="line"></span><br><span class="line">    yield  # 应用运行期间</span><br><span class="line"></span><br><span class="line">    # 关闭时执行</span><br><span class="line">    logger.info(&quot;正在关闭...&quot;)</span><br><span class="line">    if connection_pool:</span><br><span class="line">        connection_pool.close()  # 关闭连接池</span><br><span class="line">        logger.info(&quot;数据库连接池已关闭&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># lifespan参数用于在应用程序生命周期的开始和结束时执行一些初始化或清理工作</span><br><span class="line">app = FastAPI(lifespan=lifespan)</span><br></pre></td></tr></table></figure>
<h3 id="pgsql的存储结构"><a href="#pgsql的存储结构" class="headerlink" title="pgsql的存储结构"></a>pgsql的存储结构</h3><h4 id="一、Checkpoints-系列"><a href="#一、Checkpoints-系列" class="headerlink" title="一、Checkpoints 系列"></a>一、Checkpoints 系列</h4><blockquote>
<p>作用：让 <strong>LangGraph Runtime</strong> 能在 <strong>分布式/长流程</strong> 场景下 <strong>断点续跑、重放、并发控制</strong>。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>表名</th>
<th>存什么</th>
<th>典型字段（示意）</th>
<th>何时写入</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>checkpoints</strong></td>
<td>每个「图实例」的 <strong>最新快照</strong>（state 的完整 JSONB）</td>
<td><code>thread_id</code>, <code>checkpoint_ns</code>, <code>checkpoint_id</code>, <code>parent_checkpoint_id</code>, <code>state</code>, <code>created_at</code></td>
<td>每次节点执行成功后覆盖更新</td>
</tr>
<tr>
<td><strong>checkpoint_blobs</strong></td>
<td>checkpoints 里 <strong>大字段的拆分</strong>（避免行过大）</td>
<td><code>thread_id</code>, <code>checkpoint_ns</code>, <code>channel</code>, <code>type</code>, <code>blob</code></td>
<td>当 state 过大，自动拆分</td>
</tr>
<tr>
<td><strong>checkpoint_migrations</strong></td>
<td>记录 <strong>schema 版本/迁移脚本</strong></td>
<td><code>version</code>, <code>name</code>, <code>applied_at</code></td>
<td>只在 <code>setup()</code> 时写一次</td>
</tr>
<tr>
<td><strong>checkpoint_writes</strong></td>
<td><strong>写放大日志</strong>（每个节点写 state 的增量 diff）</td>
<td><code>thread_id</code>, <code>checkpoint_id</code>, <code>task_id</code>, <code>idx</code>, <code>channel</code>, <code>type</code>, <code>value</code></td>
<td>每次节点完成时追加</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>关系：<br><code>checkpoints</code> = 最新完整快照<br><code>checkpoint_writes</code> = 所有增量历史（用于重放/审计）<br><code>checkpoint_blobs</code> = checkpoints 里超大型 value 的切片</p>
</blockquote>
<h4 id="二、Store-系列"><a href="#二、Store-系列" class="headerlink" title="二、Store 系列"></a>二、Store 系列</h4><blockquote>
<p>作用：给 <strong>业务代码（开发者）</strong> 提供 <strong>持久化 KV / 向量存储</strong>，与图运行状态无关。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>表名</th>
<th>存什么</th>
<th>典型字段（示意）</th>
<th>何时写入</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>store</strong></td>
<td><strong>任意 KV 文档</strong>（LangChain Document → JSONB）</td>
<td><code>uuid</code>, <code>namespace</code>, <code>key</code>, <code>value</code>, <code>created_at</code>, <code>updated_at</code></td>
<td>你调用 <code>store.amput</code> / <code>amset</code> 等 API</td>
</tr>
<tr>
<td><strong>store_migrations</strong></td>
<td>同 checkpoint_migrations，记录 store schema 版本</td>
<td><code>version</code>, <code>name</code>, <code>applied_at</code></td>
<td>只在第一次 <code>setup()</code></td>
</tr>
<tr>
<td><strong>store_vectors</strong></td>
<td><strong>向量索引表</strong>（embedding → vector 类型）</td>
<td><code>uuid</code>, <code>collection_id</code>, <code>embedding</code>, <code>document</code>, <code>metadata</code></td>
<td>你调用 <code>add_documents(..., embeddings=...)</code></td>
</tr>
<tr>
<td><strong>vector_migrations</strong></td>
<td>记录 pgvector 扩展及索引迁移版本</td>
<td><code>version</code>, <code>applied_at</code></td>
<td><code>setup()</code> 时若第一次装 pgvector</td>
</tr>
</tbody>
</table>
</div>
<h4 id="三、调用链脑图"><a href="#三、调用链脑图" class="headerlink" title="三、调用链脑图"></a>三、调用链脑图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐</span><br><span class="line">│ LangGraph    │ 运行图实例</span><br><span class="line">└────┬─────────┘</span><br><span class="line">     │1. 写 checkpoints</span><br><span class="line">     │2. 写 checkpoint_writes</span><br><span class="line">     │3. 拆大字段到 checkpoint_blobs</span><br><span class="line">     ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│ 业务代码     │ 读写 KV/向量</span><br><span class="line">└────┬─────────┘</span><br><span class="line">     │1. 写 store</span><br><span class="line">     │2. 写 store_vectors</span><br><span class="line">     ▼</span><br><span class="line"> PostgreSQL (pgsql)</span><br></pre></td></tr></table></figure>
<h3 id="在linux安装postgresql"><a href="#在linux安装postgresql" class="headerlink" title="在linux安装postgresql"></a>在linux安装postgresql</h3><h4 id="查看linux发行版本"><a href="#查看linux发行版本" class="headerlink" title="查看linux发行版本"></a>查看linux发行版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看发行版名称和版本</span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PRETTY_NAME=&quot;Ubuntu 24.04.2 LTS&quot;</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION_ID=&quot;24.04&quot;</span><br><span class="line">VERSION=&quot;24.04.2 LTS (Noble Numbat)&quot;</span><br><span class="line">VERSION_CODENAME=noble</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class="line">UBUNTU_CODENAME=noble</span><br><span class="line">LOGO=ubuntu-logo</span><br></pre></td></tr></table></figure>
<h4 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 更新软件包索引</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"># 安装 PostgreSQL 和常用扩展</span><br><span class="line">sudo apt install -y postgresql postgresql-contrib</span><br><span class="line"></span><br><span class="line"># 检查服务状态</span><br><span class="line">#Linux 容器/子系统（ Docker、WSL 或 LXC）没有使用 systemd ，因此 systemctl 无法工作</span><br><span class="line">sudo systemctl status postgresql</span><br><span class="line"></span><br><span class="line">#确认 PostgreSQL 已安装</span><br><span class="line">which psql            # 应该输出 /usr/bin/psql</span><br><span class="line">pg_ctl --version      # 显示版本号即已安装</span><br></pre></td></tr></table></figure>
<ul>
<li><code>postgresql</code> 是主程序</li>
<li><code>postgresql-contrib</code> 提供额外扩展（如 <code>uuid-ossp</code>、<code>pgcrypto</code> 等）</li>
</ul>
<blockquote>
<p>systemctl一般用于服务器上，完整的linux系统上</p>
<p>Linux 容器/子系统（ Docker、WSL 或 LXC）使用 service</p>
</blockquote>
<h4 id="pgsql常用指令"><a href="#pgsql常用指令" class="headerlink" title="pgsql常用指令"></a>pgsql常用指令</h4><p>启动pgsql服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service postgresql start</span><br></pre></td></tr></table></figure>
<p>停止pgsql服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service postgresql stop</span><br></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service postgresql status</span><br></pre></td></tr></table></figure>
<p>连接PostgreSQL 默认的系统用户，可以执行pgsql的相关指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>psql</strong>为PostgreSQL 的终端客户端，默认会连接与当前操作系统用户名同名的数据库用户和数据库。</p>
<p><strong>postgres</strong>为PostgreSQL 自带的系统数据库，<code>postgres</code> 默认 <strong>数据库密码为空</strong>，可以通过以下指令进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 设置postgres用户密码</span><br><span class="line">ALTER USER postgres PASSWORD &#x27;postgres&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>数据库关于user的作用</p>
<p>数据库里的“用户”是 PostgreSQL <strong>内部用来做“访问控制”的一把钥匙</strong>。一句话：<strong>“谁能连哪个库、谁能读哪张表、谁能改哪些行”——全靠这些数据库用户（角色）来判定。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 认证</strong>（Authentication）</td>
<td>告诉 PostgreSQL “我连库时提供的用户名+密码是否合法”。</td>
</tr>
<tr>
<td><strong>2. 授权</strong>（Authorization）</td>
<td>决定 “这个用户连进来后，对哪些库、哪些表、哪些行有何种权限（SELECT/INSERT/UPDATE/DELETE…）”。</td>
</tr>
<tr>
<td><strong>3. 资源隔离</strong>（Isolation）</td>
<td>不同业务/团队用不同用户，方便审计、限流、回收权限，互不干扰。</td>
</tr>
</tbody>
</table>
</div>
<p>pgsql通用 URL 模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgresql://&lt;用户名&gt;:&lt;密码&gt;@127.0.0.1:5432/&lt;数据库名&gt;[?参数=值&amp;...]</span><br></pre></td></tr></table></figure>
<h4 id="连接pgsql-1"><a href="#连接pgsql-1" class="headerlink" title="连接pgsql"></a>连接pgsql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 基于数据库持久化存储的short-term</span><br><span class="line">db_uri = &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&quot;</span><br><span class="line"></span><br><span class="line"># short-term短期记忆 实例化PostgresSaver对象 并初始化checkpointer</span><br><span class="line"># long-term长期记忆 实例化PostgresStore对象 并初始化store</span><br><span class="line">async with (</span><br><span class="line">    AsyncPostgresSaver.from_conn_string(db_uri) as checkpointer,</span><br><span class="line">    AsyncPostgresStore.from_conn_string(db_uri) as store</span><br><span class="line"></span><br><span class="line">):</span><br><span class="line">    await store.setup()</span><br><span class="line">    await checkpointer.setup()</span><br></pre></td></tr></table></figure>
<h3 id="更换apt镜像源"><a href="#更换apt镜像源" class="headerlink" title="更换apt镜像源"></a>更换apt镜像源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/apt/sources.list &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ bookworm main contrib non-free</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ bookworm-updates main contrib non-free</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ bookworm-backports main contrib non-free</span><br><span class="line">deb http://mirrors.aliyun.com/debian-security bookworm-security main contrib non-free</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">apt update</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7470702616906645540">postgresql向量扩展pgvector的安装与入门本文简答的介绍了 rag 的架构，引申出向量数据库的作用，介绍了 - 掘金</a></p>
<p>langchain支持向量存储<a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/vectorstores/">向量存储 | 🦜️🔗 LangChain —- Vector stores | 🦜️🔗 LangChain</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Plan-and-Execute%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Plan-and-Execute%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Plan-and-Execute模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-28T00:00:00+08:00">2025-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-02 11:03:31" itemprop="dateModified" datetime="2025-08-02T11:03:31+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是Plan-and-Execute模式"><a href="#什么是Plan-and-Execute模式" class="headerlink" title="什么是Plan-and-Execute模式"></a>什么是Plan-and-Execute模式</h3><p>与ReAct模式不同的是，ReAct只做一次规划，而Plan-and-Execute模式核心思想是首先制定一个多步骤计划，然后逐项执行该计划。完成特定任务后，可以重新审视计划并进行适当修改。</p>
<p>举个例子，用户在问一个问题后，agent产生一份任务清单，选取第一份任务开始执行，执行后的结果结合任务清单，执行replan，结合新的信息，更改任务清单的内容，让后续大模型更好地执行，并去除已经完成的任务</p>
<p>实际生产中，应该在planner之前再进行一次判断，如果问题过于简单，不需要进行Plan-and-Execute模式</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --quiet -U langgraph langchain-community langchain-openai tavily-python</span><br></pre></td></tr></table></figure>
<h4 id="定义网络搜索工具与执行agent"><a href="#定义网络搜索工具与执行agent" class="headerlink" title="定义网络搜索工具与执行agent"></a>定义网络搜索工具与执行agent</h4><p>在产生plan后，要有一个agent对任务清单进行执行，这里以一个ReAct的网络搜索agent为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#定义工具</span><br><span class="line">from langchain_tavily import TavilySearch</span><br><span class="line">tools = [TavilySearch(max_results=3)]</span><br><span class="line"></span><br><span class="line">from langchain_openai import ChatOpenAI</span><br><span class="line"></span><br><span class="line">from langgraph.prebuilt import create_react_agent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    model=&quot;qwen3-235b-a22b-thinking-2507&quot;,</span><br><span class="line">    api_key=&quot;sk-&quot;,</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span><br><span class="line">)</span><br><span class="line">prompt = &quot;You are a helpful assistant.&quot;</span><br><span class="line">agent_executor = create_react_agent(llm, tools, prompt=prompt)</span><br></pre></td></tr></table></figure>
<p>测试功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent_executor.invoke(&#123;&quot;messages&quot;: [(&quot;user&quot;, &quot;今天是几月几日&quot;)]&#125;)</span><br></pre></td></tr></table></figure>
<p>定义执行节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from typing import Literal</span><br><span class="line">from langgraph.graph import END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def execute_step(state: PlanExecute):</span><br><span class="line">    &quot;&quot;&quot;执行计划中的步骤&quot;&quot;&quot;</span><br><span class="line">    plan = state[&quot;plan&quot;]</span><br><span class="line">    # 将计划格式化为带编号的字符串</span><br><span class="line">    plan_str = &quot;\n&quot;.join(f&quot;&#123;i + 1&#125;. &#123;step&#125;&quot; for i, step in enumerate(plan))</span><br><span class="line">    task = plan[0]  # 获取第一个待执行的任务</span><br><span class="line">    task_formatted = f&quot;&quot;&quot;对于以下计划:</span><br><span class="line">&#123;plan_str&#125;\n\n你被分配执行第 &#123;1&#125; 步, &#123;task&#125;。&quot;&quot;&quot;</span><br><span class="line">    # 调用代理执行器来执行任务</span><br><span class="line">    agent_response = await agent_executor.ainvoke(</span><br><span class="line">        &#123;&quot;messages&quot;: [(&quot;user&quot;, task_formatted)]&#125;</span><br><span class="line">    )</span><br><span class="line">    # 返回执行结果，添加到历史步骤中</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;past_steps&quot;: [(task, agent_response[&quot;messages&quot;][-1].content)],</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>create_react_agent 是 LangGraph 提供的一个预构建函数，位于 langgraph.prebuilt 模块中，用于快速创建一个基于 ReAct（Reasoning + Acting）架构的智能代理。</p>
<p>langgraph预设的其他常用组件如下</p>
<p><strong>ToolNode</strong></p>
<p>功能：把 LangChain 工具（BaseTool）封装成一个图节点，负责：</p>
<ul>
<li><p>接收 LLM 生成的工具调用请求</p>
</li>
<li><p>真正执行工具</p>
</li>
<li><p>把结果返回给图</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.prebuilt import ToolNode</span><br><span class="line"></span><br><span class="line">tool_node = ToolNode(tools=[search, calculator])</span><br></pre></td></tr></table></figure>
<p><strong>tools_condition</strong></p>
<p>功能：判断 LLM 是否要继续调用工具的“路由函数”。</p>
<p>在 ReAct 图里通常放在节点之间的 条件边：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.prebuilt import tools_condition</span><br><span class="line"></span><br><span class="line">graph.add_conditional_edges(&quot;agent&quot;, tools_condition, &#123;</span><br><span class="line"></span><br><span class="line">  &quot;tools&quot;: &quot;tool_node&quot;,    # 需要工具 → 去 ToolNode</span><br><span class="line"></span><br><span class="line">  &quot;**__end__**&quot;: END       # 不需要 → 结束</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import operator</span><br><span class="line">from typing import Annotated, List, Tuple</span><br><span class="line">from typing_extensions import TypedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PlanExecute(TypedDict):</span><br><span class="line">    input: str</span><br><span class="line">    plan: List[str]</span><br><span class="line">    past_steps: Annotated[List[Tuple], operator.add]</span><br><span class="line">    response: str</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pydantic import BaseModel, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Plan(BaseModel):</span><br><span class="line">    &quot;&quot;&quot;未来要遵循的计划&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    steps: List[str] = Field(</span><br><span class="line">        description=&quot;需要遵循的不同步骤，应该按排序顺序排列&quot;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h4 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from langchain_community.chat_models import ChatTongyi</span><br><span class="line">model=ChatTongyi(</span><br><span class="line"> model=&quot;qwen-plus-2025-07-14&quot;,</span><br><span class="line"> api_key=&quot;sk-&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="定义初始计划节点"><a href="#定义初始计划节点" class="headerlink" title="定义初始计划节点"></a>定义初始计划节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from langchain_core.prompts import ChatPromptTemplate</span><br><span class="line"></span><br><span class="line">planner_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (</span><br><span class="line">            &quot;system&quot;,</span><br><span class="line">            &quot;&quot;&quot;对于给定的目标，制定一个简单的逐步计划。\</span><br><span class="line">这个计划应该包含独立的任务，如果正确执行这些任务将得到正确的答案。不要添加任何多余的步骤。\</span><br><span class="line">最后一步的结果应该是最终答案。确保每个步骤都包含所需的所有信息——不要跳过任何步骤。&quot;&quot;&quot;,</span><br><span class="line">        ),</span><br><span class="line">        (&quot;placeholder&quot;, &quot;&#123;messages&#125;&quot;),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">planner = planner_prompt | model.with_structured_output(Plan)</span><br><span class="line"></span><br><span class="line">async def plan_step(state: PlanExecute):</span><br><span class="line">    &quot;&quot;&quot;制定初始计划步骤&quot;&quot;&quot;</span><br><span class="line">    # 使用规划器为用户输入制定计划</span><br><span class="line">    plan = await planner.ainvoke(&#123;&quot;messages&quot;: [(&quot;user&quot;, state[&quot;input&quot;])]&#125;)</span><br><span class="line">    </span><br><span class="line">    return &#123;&quot;plan&quot;: plan.steps&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义再计划节点"><a href="#定义再计划节点" class="headerlink" title="定义再计划节点"></a>定义再计划节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from typing import Union</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Response(BaseModel):</span><br><span class="line">    &quot;&quot;&quot;对用户的响应&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    response: str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Act(BaseModel):</span><br><span class="line">    &quot;&quot;&quot;要执行的动作&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    action: Union[Response, Plan] = Field(</span><br><span class="line">        description=&quot;要执行的动作。如果你想响应用户，使用 Response。&quot;</span><br><span class="line">        &quot;如果你需要进一步使用工具来获取答案，使用 Plan。&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">replanner_prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    &quot;&quot;&quot;对于给定的目标，制定一个简单的逐步计划。\</span><br><span class="line">这个    计划应该包含独立的任务，如果正确执行这些任务将得到正确的答案。不要添加任何多余的步骤。\</span><br><span class="line">最后一步的结果应该是最终答案。确保每个步骤都包含所需的所有信息——不要跳过任何步骤。</span><br><span class="line"></span><br><span class="line">你的目标是：</span><br><span class="line">&#123;input&#125;</span><br><span class="line"></span><br><span class="line">你的原始计划是：</span><br><span class="line">&#123;plan&#125;</span><br><span class="line"></span><br><span class="line">你目前已经完成了以下步骤：</span><br><span class="line">&#123;past_steps&#125;</span><br><span class="line"></span><br><span class="line">相应地更新你的计划。如果不需要更多步骤并且可以返回给用户，则直接响应。否则，填写计划。只添加仍需要完成的步骤到计划中。不要将已经完成的步骤作为计划的一部分返回。&quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">replanner = replanner_prompt | model.with_structured_output(Act)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async def replan_step(state: PlanExecute):</span><br><span class="line">    &quot;&quot;&quot;重新规划步骤&quot;&quot;&quot;</span><br><span class="line">    # 使用重新规划器根据当前状态更新计划</span><br><span class="line">    output = await replanner.ainvoke(state)</span><br><span class="line">    if isinstance(output.action, Response):</span><br><span class="line">        # 如果动作是响应，返回最终响应</span><br><span class="line">        return &#123;&quot;response&quot;: output.action.response&#125;</span><br><span class="line">    else:</span><br><span class="line">        # 如果动作是计划，返回新的计划步骤</span><br><span class="line">        return &#123;&quot;plan&quot;: output.action.steps&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def should_end(state: PlanExecute):</span><br><span class="line">    &quot;&quot;&quot;判断是否结束执行流程&quot;&quot;&quot;</span><br><span class="line">    if &quot;response&quot; in state and state[&quot;response&quot;]:</span><br><span class="line">        # 如果存在响应内容，结束流程</span><br><span class="line">        return END</span><br><span class="line">    else:</span><br><span class="line">        # 否则继续执行代理步骤</span><br><span class="line">        return &quot;agent&quot;</span><br></pre></td></tr></table></figure>
<h4 id="编译图"><a href="#编译图" class="headerlink" title="编译图"></a>编译图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import StateGraph, START</span><br><span class="line">from langgraph.checkpoint.memory import MemorySaver</span><br><span class="line"></span><br><span class="line"># 创建内存检查点保存器</span><br><span class="line">memory = MemorySaver()</span><br><span class="line"></span><br><span class="line"># 创建工作流图，使用 PlanExecute 状态类型</span><br><span class="line">workflow = StateGraph(PlanExecute)</span><br><span class="line"></span><br><span class="line"># 添加计划节点</span><br><span class="line">workflow.add_node(&quot;planner&quot;, plan_step)</span><br><span class="line"></span><br><span class="line"># 添加执行步骤节点</span><br><span class="line">workflow.add_node(&quot;agent&quot;, execute_step)</span><br><span class="line"></span><br><span class="line"># 添加重新规划节点</span><br><span class="line">workflow.add_node(&quot;replan&quot;, replan_step)</span><br><span class="line"></span><br><span class="line"># 从开始节点连接到计划节点</span><br><span class="line">workflow.add_edge(START, &quot;planner&quot;)</span><br><span class="line"></span><br><span class="line"># 从计划节点连接到代理执行节点</span><br><span class="line">workflow.add_edge(&quot;planner&quot;, &quot;agent&quot;)</span><br><span class="line"></span><br><span class="line"># 从代理执行节点连接到重新规划节点</span><br><span class="line">workflow.add_edge(&quot;agent&quot;, &quot;replan&quot;)</span><br><span class="line"></span><br><span class="line"># 添加条件边 - 从重新规划节点根据条件决定下一步</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    &quot;replan&quot;,</span><br><span class="line">    # 传入决定下一个调用节点的函数</span><br><span class="line">    should_end,</span><br><span class="line">    [&quot;agent&quot;, END],  # 可能的下一个节点：代理节点或结束</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 最后，编译工作流并添加检查点功能！</span><br><span class="line"># 这将其编译为 LangChain Runnable，</span><br><span class="line"># 意味着你可以像使用其他任何 runnable 一样使用它</span><br><span class="line">app = workflow.compile(checkpointer=memory)</span><br></pre></td></tr></table></figure>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Plan-and-Execute%E6%A8%A1%E5%BC%8F/image-20250729092408872.png" alt="image-20250729092408872"></p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 配置递归限制，防止无限循环</span><br><span class="line">config = &#123;&quot;configurable&quot;: &#123;</span><br><span class="line">        &quot;thread_id&quot;: &quot;1&quot;,  # 必需：线程ID</span><br><span class="line">    &#125;,&quot;recursion_limit&quot;: 50&#125;</span><br><span class="line"></span><br><span class="line"># 输入问题：2024年澳大利亚网球公开赛男单冠军的家乡是哪里？</span><br><span class="line">inputs = &#123;&quot;input&quot;: &quot;2024年澳大利亚网球公开赛男单冠军的家乡是哪里？&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 异步流式执行应用</span><br><span class="line">async for event in app.astream(inputs, config=config):</span><br><span class="line">    # 遍历每个事件</span><br><span class="line">    for k, v in event.items():</span><br><span class="line">        # 排除结束标记，打印其他所有事件内容</span><br><span class="line">        if k != &quot;__end__&quot;:</span><br><span class="line">            print(v)</span><br></pre></td></tr></table></figure>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/plan-and-execute/plan-and-execute/">计划与执行 —- Plan-and-Execute</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Transformer学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-28T00:00:00+08:00">2025-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-11 15:40:11" itemprop="dateModified" datetime="2025-08-11T15:40:11+08:00">2025-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">大模型算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/transformer/" itemprop="url" rel="index"><span itemprop="name">transformer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文基于<a target="_blank" rel="noopener" href="https://github.com/Hoper-J/AI-Guide-and-Demos-zh_CN/blob/master/PaperNotes/Transformer 论文精读.md#前言">AI-Guide-and-Demos-zh_CN/PaperNotes/Transformer 论文精读.md at master · Hoper-J/AI-Guide-and-Demos-zh_CN</a>与<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pu411o7BE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">Transformer论文逐段精读【论文精读】_哔哩哔哩_bilibili</a>阅读学习</p>
<h3 id="transformer贡献"><a href="#transformer贡献" class="headerlink" title="transformer贡献"></a>transformer贡献</h3><p>实际在这一阶段的工作中，<strong>注意力机制</strong>就已经在<strong>编码器-解码器架构</strong>中被广泛应用（与 RNN 一起使用），但 Transformer 彻底颠覆了默认采取的逻辑：<strong>直接放弃 RNN 的递归结构，只使用注意力机制来编码和解码序列信息</strong>。</p>
<p>Transformer 的主要贡献如下：</p>
<ul>
<li><p><strong>取消递归结构，实现并行计算</strong></p>
<p>通过采用<strong>自注意力机制（Self-Attention）</strong>，Transformer 可以同时处理多个输入序列，极大提高了计算的并行度和训练速度。</p>
</li>
<li><p><strong>引入位置编码（Positional Encoding）并结合 Attention 机制巧妙地捕捉位置信息</strong></p>
<p>在不依赖 RNN 结构的情况下，通过位置编码为序列中的每个元素嵌入位置信息，从而使模型能够感知输入的顺序。</p>
</li>
</ul>
<h3 id="transformer架构"><a href="#transformer架构" class="headerlink" title="transformer架构"></a>transformer架构</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250807135151542.png" alt="image-20250807135151542"></p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250807145354145.png" alt="image-20250807145354145"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MY41137AK?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【Transformer模型】曼妙动画轻松学，形象比喻贼好记_哔哩哔哩_bilibili</a></p>
<p>Transformer 模型基于<strong>编码器</strong>（左）- <strong>解码器</strong>（右）架构</p>
<p><strong>Transformer编码器</strong>同样由 <strong>N 个完全相同的层</strong>（原始论文中 N=6）堆叠而成，每层只有两个子层，而解码器有三个。</p>
<ol>
<li>多头自注意力（Multi-Head Self-Attention）<br>让输入序列中的每个位置都能关注序列内所有位置，直接建模全局依赖。</li>
<li>前馈全连接网络（Position-wise Feed-Forward Network）<br>对每个位置独立地做一次两层的全连接变换（通常先升维再降维）。</li>
</ol>
<p>同样，每个子层后都有</p>
<ul>
<li>残差连接（Residual Connection）</li>
<li>层归一化（Layer Normalization）</li>
</ul>
<p>另外，编码器在输入端还会用到</p>
<ul>
<li>位置编码（Positional Encoding）——给模型提供序列位置信息，因为注意力本身不包含顺序信息。</li>
</ul>
<p><strong>Transformer解码器</strong>由多个相同的层堆叠而成，每一层包含三个核心子层：</p>
<ol>
<li><strong>掩蔽多头自注意力机制</strong>（Masked Multi-Head Attention）<br>用于处理目标序列，通过掩码防止当前位置关注未来位置，确保生成过程的自回归特性。</li>
<li><strong>编码器-解码器注意力机制</strong>（Encoder-Decoder Attention）<br>使解码器能够关注编码器输出的上下文信息，建立输入与输出序列之间的关联。</li>
<li><strong>前馈神经网络</strong>（Feed-Forward Neural Network）<br>对注意力机制的输出进行非线性变换，增强模型的表达能力。</li>
</ol>
<p>此外，每个子层后均包含<strong>残差连接</strong>（Residual Connection）和<strong>层归一化</strong>（Layer Normalization），以稳定训练过程并加速收敛。最终，解码器的输出通过线性层和Softmax层映射为词汇表上的概率分布。</p>
<h3 id="嵌入（Embeddings）"><a href="#嵌入（Embeddings）" class="headerlink" title="嵌入（Embeddings）"></a>嵌入（Embeddings）</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808103256344.png" alt="image-20250808103256344"></p>
<p>在 Transformer 模型中，<strong>嵌入层</strong>（Embedding Layer） 是处理输入和输出数据的关键步骤，因为模型实际操作的是<strong>张量</strong>（tensor），而非<strong>字符串</strong>（string）。在将输入文本传递给模型之前，首先需要进行<strong>分词</strong>（tokenization），即将文本拆解为多个 <strong>token</strong>，随后这些 token 会被映射为对应的 <strong>token ID</strong>，从而转换为模型可理解的数值形式。此时，数据的形状为 <code>(seq_len,)</code>，其中 <code>seq_len</code> 表示输入序列的长度。</p>
<p>目的：为了让模型捕捉到 token 背后复杂的语义（Semantic meaning）关系，我们需要将离散的 token ID 映射到一个高维的连续向量空间（Continuous, dense）。这意味着每个 token ID 会被转换为一个<strong>嵌入向量</strong>（embedding vector），期望通过这种方式让语义相近的词汇在向量空间中距离更近，使模型能更好地捕捉词汇之间的关系。</p>
<p>流程：（前面要进行分词，后面要进行位置编码）</p>
<p>初始化一个可学习的矩阵 <code>E ∈ ℝ^(|V| × d_model)</code><br><code>|V|</code> = 词表大小（比如 32 k、50 k），<code>d_model</code> = 512/768/1024…</p>
<p>把 token id 作为行号，直接取对应行：<br><code>x_i = E[token_id_i]</code><br>得到 <code>[batch, seq_len, d_model]</code> 的浮点张量。</p>
<h3 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a>位置编码（Positional Encoding）</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808103418150.png" alt="image-20250808103418150"></p>
<p>Transformer 的自注意力机制（Self-Attention）是<strong>位置无关（position-agnostic）</strong>的。也就是说，如果不做任何处理，模型无法区分“我爱你”和“你爱我”这两个句子的差异，因为自注意力机制只关注 token 之间的相关性，而不考虑它们在序列中的顺序。</p>
<p>为了让模型感知到 token 的位置信息，Transformer 引入了<strong>位置编码</strong>。</p>
<p>在原始论文中，Transformer 使用的是固定位置编码（Positional Encoding），其公式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
PE_{(pos, 2i)} &= \sin\left(\frac{pos}{10000^{2i/d_{\text{model}}}}\right), \\
PE_{(pos, 2i+1)} &= \cos\left(\frac{pos}{10000^{2i/d_{\text{model}}}}\right).
\end{aligned}</script><p>其中：</p>
<ul>
<li>$pos$ 表示位置索引（Position）。</li>
<li>$i$ 表示维度索引。</li>
<li>$d_{\text{model}}$ 是嵌入向量的维度。</li>
</ul>
<p>流程：输入的是一个<strong>整数索引</strong>（位置序号 0,1,2,…）。位置编码模块先把这些整数映射成与词向量同维度的向量（例如 512 维），再把结果加到词向量上。</p>
<h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808111823715.png" alt="image-20250808111823715"></p>
<p>在 Transformer 模型中，<strong>Softmax</strong> 函数不仅在计算<strong>注意力权重</strong>时用到，在预测阶段的输出处理环节也会用到，因为预测 token 的过程可以看成是<strong>多分类问题</strong>。</p>
<p><strong>Softmax</strong> 函数是一种常用的激活函数，能够将任意实数向量转换为<strong>概率分布</strong>，确保每个元素的取值范围在 [0, 1] 之间，并且所有元素的和为 1。其数学定义如下：</p>
<script type="math/tex; mode=display">
\text{Softmax}(x_i) = \frac{e^{x_i}}{\sum_{j} e^{x_j}}</script><p>其中：</p>
<ul>
<li>$x_i$ 表示输入向量中的第 $i$ 个元素。</li>
<li>$\text{Softmax}(x_i)$ 表示输入 $x_i$ 转换后的概率。</li>
</ul>
<p>我们可以把 Softmax 看作一种<strong>归一化的指数变换</strong>。相比于简单的比例归一化 $\frac{x_i}{\sum_j x_j}$, <strong>Softmax 通过指数变换放大数值间的差异，让较大的值对应更高的概率，同时避免了负值和数值过小的问题，让模型聚焦于权重最高的位置</strong>，同时保留全局信息（低权重仍非零）。</p>
<h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xS4y1k7tn?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【Attention 注意力机制】激情告白transformer、Bert、GNN的精髓_哔哩哔哩_bilibili</a></p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808135811744.png" alt="image-20250808135811744"></p>
<h4 id="缩放点积注意力机制（Scaled-Dot-Product-Attention）"><a href="#缩放点积注意力机制（Scaled-Dot-Product-Attention）" class="headerlink" title="缩放点积注意力机制（Scaled Dot-Product Attention）"></a><strong>缩放点积注意力机制（Scaled Dot-Product Attention）</strong></h4><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808140834132.png" alt="image-20250808140834132"></p>
<p>Transformer 的核心是<strong>多头注意力机制（Multi-Head Attention）</strong>，它能够捕捉输入序列中不同位置之间的依赖关系，并从多个角度对信息进行建模。模块将自底向上的进行讲解：在深入理解注意力机制前，首先需要理解论文使用的<strong>缩放点积注意力机制（Scaled Dot-Product Attention）</strong>。</p>
<p>给定查询矩阵 $Q$、键矩阵 $K$ 和值矩阵 $V$, 其注意力输出的数学表达式如下：</p>
<script type="math/tex; mode=display">
\text{Attention}(Q, K, V) = \text{Softmax}\left(\frac{Q K^\top}{\sqrt{d_k}}\right) V</script><ul>
<li><strong>$Q$（Query）</strong>: 用于查询的向量矩阵。</li>
<li><strong>$K$（Key）</strong>: 表示键的向量矩阵，用于与查询匹配。</li>
<li><strong>$V$（Value）</strong>: 值矩阵，注意力权重最终会作用在该矩阵上。</li>
<li><strong>$d_k$</strong>: 键或查询向量的维度。</li>
</ul>
<blockquote>
<p>理解 Q、K、V 的关键在于代码，它们实际上是通过线性变换从输入序列生成的</p>
</blockquote>
<p>公式解释</p>
<ol>
<li><p><strong>点积计算（Dot Produce）</strong></p>
<p>将查询矩阵 $Q$ 与键矩阵的转置 $K^\top$ 做点积，计算每个查询向量与所有键向量之间的相似度：</p>
<p>$<code>\text&#123;Scores&#125; = Q K^\top</code>$</p>
<ul>
<li><strong>每一行</strong>表示某个查询与所有键之间的相似度（匹配分数）。</li>
<li><strong>每一列</strong>表示某个键与所有查询之间的相似度（匹配分数）。</li>
</ul>
</li>
<li><p><strong>缩放（Scaling）</strong></p>
<p>当 $d_k$ 较大时，点积的数值可能会过大，导致 Softmax 过后的梯度变得极小，因此除以 $\sqrt{d_k}$ 缩放点积结果的数值范围：</p>
<p>$<code>\text&#123;Scaled Scores&#125; = \frac&#123;Q K^\top&#125;&#123;\sqrt&#123;d_k&#125;&#125;</code>$</p>
<p>缩放后（Scaled Dot-Product）也称为注意力分数（<strong>attention scores</strong>）。</p>
</li>
<li><p><strong>Softmax 归一化</strong></p>
<p>使用 Softmax 函数将缩放后的分数转换为概率分布：</p>
<p>$<code>\text&#123;Attention Weights&#125; = \text&#123;Softmax&#125;\left(\frac&#123;Q K^\top&#125;&#123;\sqrt&#123;d_k&#125;&#125;\right)</code>$</p>
<blockquote>
<p><strong>注意</strong>：Softmax 是在每一行上进行的，这意味着每个查询的匹配分数将归一化为概率，总和为 1。</p>
</blockquote>
</li>
<li><p><strong>加权求和（Weighted Sum）</strong></p>
<p>最后，使用归一化后的注意力权重对值矩阵 $V$ 进行加权求和，得到每个查询位置的最终输出：<br>$<code>\text&#123;Output&#125; = \text&#123;Attention Weights&#125; \times V</code>$</p>
</li>
</ol>
<h3 id="单头注意力机制（Single-Head-Attention）"><a href="#单头注意力机制（Single-Head-Attention）" class="headerlink" title="单头注意力机制（Single-Head Attention）"></a>单头注意力机制（Single-Head Attention）</h3><p>将输入序列（Inputs）通过线性变换生成<strong>查询矩阵</strong>（Query, Q）、<strong>键矩阵</strong>（Key, K）和<strong>值矩阵</strong>（Value, V），随后执行<strong>缩放点积注意力</strong>（Scaled Dot-Product Attention）。</p>
<h4 id="掩码注意力机制（Masked-Attention）"><a href="#掩码注意力机制（Masked-Attention）" class="headerlink" title="掩码注意力机制（Masked Attention）"></a>掩码注意力机制（Masked Attention）</h4><p>如果使用 mask 掩盖将要预测的词汇，那么 Attention 就延伸为 Masked Attention</p>
<p>在这段代码中，<code>mask</code> 矩阵用于指定哪些位置应该被遮蔽（即填充为 -∞），从而保证这些位置的注意力权重在 softmax 输出中接近于零。注意，掩码机制并不是直接在截断输入序列，也不是在算分数的时候就排除不应该看到的位置，因为看到也没有关系，不会影响与其他位置的分数，所以在传入 Softmax（计算注意力权重）之前排除就可以了。</p>
<p>另外，根据输入数据的来源，还可以将注意力分为<strong>自注意力（Self-Attention）和交叉注意力（Cross-Attention)</strong>。</p>
<h4 id="自注意力机制（Self-attention）"><a href="#自注意力机制（Self-attention）" class="headerlink" title="自注意力机制（Self-attention）"></a>自注意力机制（Self-attention）</h4><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808142109091.png" alt="image-20250808142109091"></p>
<p>Transformer 模型架构使用到了三个看起来不同的注意力机制，我们继续忽视共有的 Multi-Head。观察输入，线条一分为三传入 Attention 模块，这意味着查询（query）、键（key）和值（value）实际上都来自<strong>同一输入序列 $\mathbf{X}$</strong>，数学表达如下：</p>
<script type="math/tex; mode=display">
Q = XW^Q, \quad K = XW^K, \quad V = XW^V</script><ul>
<li><strong>$W^Q, W^K, W^V$</strong>：可训练的线性变换权重，实际上就是简单的线性层</li>
</ul>
<h4 id="交叉注意力机制（Cross-Attention）"><a href="#交叉注意力机制（Cross-Attention）" class="headerlink" title="交叉注意力机制（Cross-Attention）"></a>交叉注意力机制（Cross-Attention）</h4><p>在 Transformer 解码器中，除了自注意力外，还使用了 <strong>交叉注意力（Cross-Attention）</strong>。</p>
<p>如下图所示，解码器（右）在自底向上的处理过程中，先执行自注意力机制，然后通过交叉注意力从编码器的输出中获取上下文信息。</p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808142428374.png" alt="image-20250808142428374"></p>
<p>数学表达如下：</p>
<script type="math/tex; mode=display">
Q = X_{\text{decoder}} W^Q, \quad K = X_{\text{encoder}} W^K, \quad V = X_{\text{encoder}} W^V</script><h4 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h4><p><strong>Masked Attention</strong>、<strong>Self-Attention</strong> 和 <strong>Cross-Attention</strong> 的本质是一致的，这一点从代码调用可以看出来，三者的区别在于未来掩码的使用和输入数据的来源：</p>
<ul>
<li><p><strong>Masked Attention</strong>：用于解码过程，通过掩码屏蔽未来的时间步，确保模型只能基于已生成的部分进行预测，论文中解码器部分的第一个 Attention 使用的是 Masked Self-Attention。</p>
</li>
<li><p><strong>Self-Attention</strong>：查询、键和值矩阵来自同一输入序列，模型通过自注意力机制学习输入序列的全局依赖关系。</p>
</li>
<li><p><strong>Cross-Attention</strong>：查询矩阵来自解码器的输入，而键和值矩阵来自编码器的输出，解码器的第二个 Attention 模块就是 Cross-Attention，用于从编码器输出中获取相关的上下文信息。</p>
<ul>
<li><p>以<strong>机器翻译</strong>中的<strong>中译英任务</strong>为例：对于中文句子“<strong>中国的首都是北京</strong>”，假设模型已经生成了部分译文“The capital of China is”，此时需要预测下一个单词。</p>
<p>在这一阶段，<strong>解码器中的交叉注意力机制</strong>会使用<strong>当前已生成的译文“The capital of China is”的编码表示作为查询</strong>，并将<strong>编码器对输入句子“中国的首都是北京”编码表示</strong>作为<strong>键</strong>和<strong>值</strong>，通过计算<strong>查询与键之间的匹配程度</strong>，生成相应的注意力权重，以此从值中提取上下文信息，基于这些信息生成下一个可能的单词（token），比如：“Beijing”。</p>
</li>
</ul>
</li>
</ul>
<h3 id="多头注意力机制（Multi-Head-Attention）"><a href="#多头注意力机制（Multi-Head-Attention）" class="headerlink" title="多头注意力机制（Multi-Head Attention）"></a>多头注意力机制（Multi-Head Attention）</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808143810965.png" alt="image-20250808143810965"></p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808143822630.png" alt="image-20250808143822630"></p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808143845681.png" alt="image-20250808143845681"></p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808145725202.png" alt="image-20250808145725202"></p>
<p>多头注意力机制就是存在多个不同的权重矩阵，形成多个矩阵Z，再把它们 <strong>按最后一维（hidden）拼接（concat）→ 做一次线性变换</strong> 得到最终输出。</p>
<blockquote>
<p>线性bian’h把拼接后的多头结果 <code>Z_concat</code>（形状 batch×seq×d_model）重新<strong>线性映射</strong>回与输入相同的维度，同时让网络可以<strong>学习如何融合不同头的信息</strong>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MY41137AK?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【Transformer模型】曼妙动画轻松学，形象比喻贼好记_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HsTyz8ECC?spm_id_from=333.788.player.switch&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">Transformer原理及架构：多头自注意力机制_哔哩哔哩_bilibili</a></p>
<h3 id="残差连接（Residual-Connection）和层归一化（Layer-Normalization-LayerNorm）"><a href="#残差连接（Residual-Connection）和层归一化（Layer-Normalization-LayerNorm）" class="headerlink" title="残差连接（Residual Connection）和层归一化（Layer Normalization, LayerNorm）"></a>残差连接（Residual Connection）和层归一化（Layer Normalization, LayerNorm）</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808150313758.png" alt="image-20250808150313758"></p>
<p>在 Transformer 架构中，<strong>残差连接</strong>（Residual Connection）与<strong>层归一化</strong>（LayerNorm）结合使用，统称为 <strong>Add &amp; Norm</strong> 操作。</p>
<h4 id="Add（残差连接，Residual-Connection）"><a href="#Add（残差连接，Residual-Connection）" class="headerlink" title="Add（残差连接，Residual Connection）"></a>Add（残差连接，Residual Connection）</h4><p>残差连接是一种跳跃连接（Skip Connection），它将层的输入直接加到输出上（观察架构图中的箭头），对应的公式如下：</p>
<script type="math/tex; mode=display">
\text{Output} = \text{SubLayer}(x) + x</script><p>这种连接方式有效缓解了<strong>深层神经网络的梯度消失</strong>问题。</p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250808151004667.png" alt="image-20250808151004667"></p>
<p>在transform中，就是输入的矩阵x加上经过注意力机制计算出来的z矩阵</p>
<h4 id="Norm（层归一化，Layer-Normalization）"><a href="#Norm（层归一化，Layer-Normalization）" class="headerlink" title="Norm（层归一化，Layer Normalization）"></a>Norm（层归一化，Layer Normalization）</h4><p><strong>层归一化</strong>（LayerNorm）是一种归一化技术，用于提升训练的稳定性和模型的泛化能力。</p>
<p>假设输入向量为 $x = (x_1, x_2, \dots, x_d)$, LayerNorm 的计算步骤如下：</p>
<ol>
<li><p><strong>计算均值和方差</strong>：<br>对输入的所有特征求均值 $\mu$ 和方差 $\sigma^2$：</p>
<p>$<code>\mu = \frac&#123;1&#125;&#123;d&#125; \sum_&#123;j=1&#125;^&#123;d&#125; x_j, \quad 
\sigma^2 = \frac&#123;1&#125;&#123;d&#125; \sum_&#123;j=1&#125;^&#123;d&#125; (x_j - \mu)^2</code>$</p>
</li>
<li><p><strong>归一化公式</strong>：<br>将输入特征 $\hat{x}_i$ 进行归一化：</p>
<p>$<code>\hat&#123;x&#125;_i = \frac&#123;x_i - \mu&#125;&#123;\sqrt&#123;\sigma^2 + \epsilon&#125;&#125;</code>$</p>
<p>其中, $\epsilon$ 是一个很小的常数（比如 1e-9），用于防止除以零的情况。</p>
</li>
<li><p><strong>引入可学习参数</strong>：<br>归一化后的输出乘以 $\gamma$ 并加上 $\beta$, 公式如下：</p>
<p>$<code>\text&#123;Output&#125; = \gamma \hat&#123;x&#125; + \beta</code>$</p>
<p>其中 $\gamma$ 和 $\beta$ 是可学习的参数，用于进一步调整归一化后的输出。</p>
</li>
</ol>
<h3 id="前馈神经网络-Position-wise-Feed-Forward-Networks（FFN）"><a href="#前馈神经网络-Position-wise-Feed-Forward-Networks（FFN）" class="headerlink" title="前馈神经网络 Position-wise Feed-Forward Networks（FFN）"></a>前馈神经网络 Position-wise Feed-Forward Networks（FFN）</h3><p>在 Transformer 中，前馈网络层（Feed-Forward Network，FFN）的作用可以概括为一句话：<br><strong>“对每个位置的向量进行非线性变换，增加模型的表达能力。”</strong></p>
<p>在编码器-解码器架构中，另一个看起来“大一点”的模块就是 Feed Forward，它在每个位置 $i$ 上的计算可以表示为：</p>
<script type="math/tex; mode=display">
\text{FFN}(x_i) = \text{max}(0, x_i W_1 + b_1) W_2 + b_2</script><p>其中：</p>
<ul>
<li>$x<em>i \in \mathbb{R}^{d</em>{\text{model}}}$ 表示第 $i$ 个位置的输入向量。 </li>
<li>$W<em>1 \in \mathbb{R}^{d</em>{\text{model}} \times d<em>{\text{ff}}}$ 和 $W_2 \in \mathbb{R}^{d</em>{\text{ff}} \times d_{\text{model}}}$ 是两个线性变换的权重矩阵。</li>
<li>$b<em>1 \in \mathbb{R}^{d</em>{\text{ff}}}$ 和 $b<em>2 \in \mathbb{R}^{d</em>{\text{model}}}$ 是对应的偏置向量。</li>
<li>$\text{max}(0, \cdot)$ 是 <strong>ReLU 激活函数</strong>，用于引入非线性。</li>
</ul>
<h3 id="大模型发展树"><a href="#大模型发展树" class="headerlink" title="大模型发展树"></a>大模型发展树</h3><p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250807171237889.png" alt="image-20250807171237889"></p>
<p><img src="/2025/07/28/%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/Transformer%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20250807173520481.png" alt="image-20250807173520481"></p>
<h3 id="预训练语言模型"><a href="#预训练语言模型" class="headerlink" title="预训练语言模型"></a>预训练语言模型</h3><p>预训练语言模型（PLM）是一种通过大量文本数据进行无监督或弱监督训练的语言模型，目的是学习语言的通用表示（即语言的模式、语法、语义等）。这些模型通常在大规模文本数据上进行预训练，然后可以被微调（Fine - tuning）以适应各种下游任务，如文本分类、问答、命名实体识别等。</p>
<p>预训练语言模型的核心思想是利用大量的无标注文本数据来学习语言的通用特征，从而为各种自然语言处理任务提供强大的语言理解能力。预训练模型可以显著提高任务的性能，减少对标注数据的依赖，并且能够快速适应新的任务。</p>
<h4 id="BERT模型（Encoder-only-PLM）"><a href="#BERT模型（Encoder-only-PLM）" class="headerlink" title="BERT模型（Encoder-only PLM）"></a>BERT模型（Encoder-only PLM）</h4><p>针对 Encoder、Decoder 的特点，引入 ELMo 的预训练思路，开始出现不同的、对 Transformer 进行优化的思路。例如，<strong>Google 仅选择了 Encoder 层</strong>，通过将 Encoder 层进行堆叠，再提出不同的预训练任务-掩码语言模型（Masked Language Model，MLM），打造了一统自然语言理解（Natural Language Understanding，NLU）任务的代表模型——<strong>BERT</strong>。</p>
<p>BERT，全名为 Bidirectional Encoder Representations from Transformers，是由 Google 团队在 2018年发布的预训练语言模型。该模型发布于论文《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》，实现了包括 GLUE、MultiNLI 等七个自然语言处理评测任务的最优性能（State Of The Art，SOTA），堪称里程碑式的成果。</p>
<h4 id="T5（Encoder-Decoder-PLM）"><a href="#T5（Encoder-Decoder-PLM）" class="headerlink" title="T5（Encoder-Decoder PLM）"></a>T5（Encoder-Decoder PLM）</h4><p>BERT 也存在一些问题，例如 MLM 任务和下游任务微调的不一致性，以及无法处理超过模型训练长度的输入等问题。为了解决这些问题，研究者们提出了 <strong>Encoder-Decoder 模型</strong>，通过引入 Decoder 部分来解决这些问题，同时也为 NLP 领域带来了新的思路和方法。</p>
<p><strong>T5（Text-To-Text Transfer Transformer）是由 Google 提出的一种预训练语言模型</strong>，通过将所有 NLP 任务统一表示为文本到文本的转换问题，大大简化了模型设计和任务处理。T5 基于 Transformer 架构，包含编码器和解码器两个部分，使用自注意力机制和多头注意力捕捉全局依赖关系，利用相对位置编码处理长序列中的位置信息，并在每层中包含前馈神经网络进一步处理特征。</p>
<h4 id="LLama模型（Decoder-Only-PLM）"><a href="#LLama模型（Decoder-Only-PLM）" class="headerlink" title="LLama模型（Decoder-Only PLM）"></a>LLama模型（Decoder-Only PLM）</h4><p>LLaMA模型是由Meta（前Facebook）开发的一系列大型预训练语言模型。从LLaMA-1到LLaMA-3，LLaMA系列模型展示了大规模预训练语言模型的演进及其在实际应用中的显著潜力。</p>
<h4 id="GPT模型（Decoder-Only-PLM）"><a href="#GPT模型（Decoder-Only-PLM）" class="headerlink" title="GPT模型（Decoder-Only PLM）"></a>GPT模型（Decoder-Only PLM）</h4><p>GPT，即 Generative Pre-Training Language Model，是由 OpenAI 团队于 2018年发布的预训练语言模型。虽然学界普遍认可 BERT 作为预训练语言模型时代的代表，但首先明确提出<strong>预训练-微调思想的模型</strong>其实是 GPT。</p>
<p>GPT 提出了通用预训练的概念，也就是在海量无监督语料上预训练，进而在每个特定任务上进行微调，从而实现这些任务的巨大收益。虽然在发布之初，由于性能略输于不久后发布的 BERT，没能取得轰动性成果，也没能让 GPT 所使用的 <strong>Decoder-Only 架构</strong>成为学界研究的主流，但 OpenAI 团队坚定地选择了不断扩大预训练数据、增加模型参数，在 GPT 架构上不断优化，最终在 2020年发布的 GPT-3 成就了 LLM 时代的基础，并以 GPT-3 为基座模型的 ChatGPT 成功打开新时代的大门，成为 LLM 时代的最强竞争者也是目前的最大赢家。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://transformers.run/">Hello! · Transformers快速入门</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jsksxs360/How-to-use-Transformers">jsksxs360/How-to-use-Transformers: Transformers 库快速入门教程</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hoper-J/AI-Guide-and-Demos-zh_CN">Hoper-J/AI-Guide-and-Demos-zh_CN: 这是一份入门AI/LLM大模型的逐步指南，包含教程和演示代码，带你从API走进本地大模型部署和微调，代码文件会提供Kaggle或Colab在线版本，即便没有显卡也可以进行学习。项目中还开设了一个小型的代码游乐场🎡，你可以尝试在里面实验一些有意思的AI脚本。同时，包含李宏毅 (HUNG-YI LEE）2024生成式人工智能导论课程的完整中文镜像作业。</a></p>
<p><a target="_blank" rel="noopener" href="https://datawhalechina.github.io/happy-llm/#/">Happy-LLM</a></p>
<p><a target="_blank" rel="noopener" href="https://gengzhige.ai/video.html">梗直哥</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RBdTYxENw/?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">90%人不知道的LLM黑科技：拆解Transformer如何吃透全网知识！_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/27/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/MCP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/27/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/MCP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MCP 学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-27T00:00:00+08:00">2025-07-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-01 14:31:13" itemprop="dateModified" datetime="2025-08-01T14:31:13+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mcp/" itemprop="url" rel="index"><span itemprop="name">mcp</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是-MCP？"><a href="#什么是-MCP？" class="headerlink" title="什么是 MCP？"></a>什么是 MCP？</h3><ul>
<li><strong>全称</strong>：Model Context Protocol</li>
<li><strong>作用</strong>：让 AI 助手（如 Claude、Cline 等）在对话过程中，动态调用外部工具（Tool）完成复杂任务（读写文件、查询数据库、调用 API 等）。</li>
<li><strong>组成</strong>：<ol>
<li><strong>MCP Host</strong>（宿主，如 Cline、Claude Desktop）</li>
<li><strong>MCP Server</strong>（提供 Tool 的后台服务）</li>
<li><strong>Tool</strong>（具体功能单元，如 <code>read_file</code>, <code>exec_command</code> 等）</li>
</ol>
</li>
</ul>
<h3 id="核心概念速记"><a href="#核心概念速记" class="headerlink" title="核心概念速记"></a>核心概念速记</h3><ul>
<li><strong>MCP Server</strong><ul>
<li>一个独立进程，提供 1-N 个 Tool。</li>
<li>可以用任何语言编写，只要暴露标准 MCP 接口。</li>
</ul>
</li>
<li><strong>Tool</strong><ul>
<li>最小执行单元，必须包含：<ul>
<li>name（唯一）</li>
<li>description（让 LLM 理解何时调用）</li>
<li>input schema（参数结构，JSON Schema）</li>
</ul>
</li>
</ul>
</li>
<li><strong>交互流程（重点）</strong><ul>
<li>在启动mcp server时，server将tool信息传送给host</li>
<li>用户在 Host 输入自然语言需求。</li>
<li>Host 将需求 + 可用 Tool 列表发给 LLM。</li>
<li>LLM 判断调用哪个 Tool，并填充参数。</li>
<li>Host 通过 MCP 协议向对应 Server 发送请求。</li>
<li>Server 执行 Tool 并返回结果。</li>
<li>Host 将结果合并上下文，继续对话。</li>
</ul>
</li>
</ul>
<h3 id="安装mcp"><a href="#安装mcp" class="headerlink" title="安装mcp"></a>安装mcp</h3><p>在mcp server市场查找自己想用的mcp服务，如<a target="_blank" rel="noopener" href="https://mcp.so/server/fetch/modelcontextprotocol?tab=content">Fetch MCP Server</a></p>
<p>复制mcp配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;mcpServers&quot;: &#123;</span><br><span class="line">    &quot;fetch&quot;: &#123;</span><br><span class="line">      &quot;command&quot;: &quot;uvx&quot;,</span><br><span class="line">      &quot;args&quot;: [</span><br><span class="line">        &quot;mcp-server-fetch&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在mcp host 中安装，如trae</p>
<p>host会自动完成对mcp的配置</p>
<h3 id="创建一个mcp-server"><a href="#创建一个mcp-server" class="headerlink" title="创建一个mcp server"></a>创建一个mcp server</h3><p>初始化项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uv init weather</span><br><span class="line"></span><br><span class="line">uv sync</span><br><span class="line"></span><br><span class="line">source .venv/bin/activate </span><br><span class="line"></span><br><span class="line">#添加依赖</span><br><span class="line">uv add &quot;mcp[cli]&quot; httpx</span><br></pre></td></tr></table></figure>
<p>创建weather.py</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"># 导入类型提示模块，用于类型注解</span><br><span class="line">from typing import Any</span><br><span class="line"></span><br><span class="line"># 导入httpx库，用于发送HTTP请求</span><br><span class="line">import httpx</span><br><span class="line"></span><br><span class="line"># 从mcp.server.fastmcp模块导入FastMCP类</span><br><span class="line"># FastMCP是一个快速构建MCP（Model Control Protocol）服务器的框架</span><br><span class="line">from mcp.server.fastmcp import FastMCP</span><br><span class="line"></span><br><span class="line"># 创建FastMCP实例，命名为&quot;weather&quot;，日志级别设置为ERROR（只显示错误信息）</span><br><span class="line">mcp = FastMCP(&quot;weather&quot;, log_level=&quot;ERROR&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 常量定义</span><br><span class="line"># NWS（National Weather Service）API的基础URL</span><br><span class="line">NWS_API_BASE = &quot;https://api.weather.gov&quot;</span><br><span class="line"># 用户代理字符串，用于标识应用程序</span><br><span class="line">USER_AGENT = &quot;weather-app/1.0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def make_nws_request(url: str) -&gt; dict[str, Any] | None:</span><br><span class="line">    &quot;&quot;&quot;向NWS API发起请求并处理错误。</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        url: 要请求的API URL</span><br><span class="line">        </span><br><span class="line">    Returns:</span><br><span class="line">        成功时返回解析后的JSON数据字典，失败时返回None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 设置请求头信息</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;User-Agent&quot;: USER_AGENT,           # 用户代理标识</span><br><span class="line">        &quot;Accept&quot;: &quot;application/geo+json&quot;    # 接受的数据格式</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 创建异步HTTP客户端</span><br><span class="line">    async with httpx.AsyncClient() as client:</span><br><span class="line">        try:</span><br><span class="line">            # 发起GET请求，设置超时时间为30秒</span><br><span class="line">            response = await client.get(url, headers=headers, timeout=30.0)</span><br><span class="line">            # 如果响应状态码不是2xx，抛出异常</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">            # 返回解析后的JSON数据</span><br><span class="line">            return response.json()</span><br><span class="line">        except Exception:</span><br><span class="line">            # 捕获所有异常，返回None表示请求失败</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def format_alert(feature: dict) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;将警报数据格式化为可读的字符串。</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        feature: 包含警报信息的字典</span><br><span class="line">        </span><br><span class="line">    Returns:</span><br><span class="line">        格式化后的警报字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 获取警报属性</span><br><span class="line">    props = feature[&quot;properties&quot;]</span><br><span class="line">    # 格式化警报信息，使用get方法提供默认值防止键不存在</span><br><span class="line">    return f&quot;&quot;&quot;</span><br><span class="line">事件: &#123;props.get(&#x27;event&#x27;, &#x27;未知&#x27;)&#125;</span><br><span class="line">区域: &#123;props.get(&#x27;areaDesc&#x27;, &#x27;未知&#x27;)&#125;</span><br><span class="line">严重程度: &#123;props.get(&#x27;severity&#x27;, &#x27;未知&#x27;)&#125;</span><br><span class="line">描述: &#123;props.get(&#x27;description&#x27;, &#x27;无描述信息&#x27;)&#125;</span><br><span class="line">指示: &#123;props.get(&#x27;instruction&#x27;, &#x27;无具体指示&#x27;)&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用@mcp.tool()装饰器将函数注册为MCP工具</span><br><span class="line">@mcp.tool()</span><br><span class="line">async def get_alerts(state: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;获取指定美国州的天气警报。</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        state: 两个字母的美国州代码（例如：CA, NY）</span><br><span class="line">        </span><br><span class="line">    Returns:</span><br><span class="line">        格式化后的警报信息字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 构建获取州警报的URL</span><br><span class="line">    url = f&quot;&#123;NWS_API_BASE&#125;/alerts/active/area/&#123;state&#125;&quot;</span><br><span class="line">    # 发起API请求获取数据</span><br><span class="line">    data = await make_nws_request(url)</span><br><span class="line"></span><br><span class="line">    # 检查数据是否有效</span><br><span class="line">    if not data or &quot;features&quot; not in data:</span><br><span class="line">        return &quot;无法获取警报或未找到警报。&quot;</span><br><span class="line"></span><br><span class="line">    # 检查是否有警报</span><br><span class="line">    if not data[&quot;features&quot;]:</span><br><span class="line">        return &quot;该州无活动警报。&quot;</span><br><span class="line"></span><br><span class="line">    # 格式化所有警报</span><br><span class="line">    alerts = [format_alert(feature) for feature in data[&quot;features&quot;]]</span><br><span class="line">    # 用分隔符连接所有警报</span><br><span class="line">    return &quot;\n---\n&quot;.join(alerts)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注册为MCP工具的天气预报函数</span><br><span class="line">@mcp.tool()</span><br><span class="line">async def get_forecast(latitude: float, longitude: float) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;获取指定位置的天气预报。</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        latitude: 位置的纬度</span><br><span class="line">        longitude: 位置的经度</span><br><span class="line">        </span><br><span class="line">    Returns:</span><br><span class="line">        格式化后的天气预报字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 首先获取预报网格端点</span><br><span class="line">    points_url = f&quot;&#123;NWS_API_BASE&#125;/points/&#123;latitude&#125;,&#123;longitude&#125;&quot;</span><br><span class="line">    points_data = await make_nws_request(points_url)</span><br><span class="line"></span><br><span class="line">    # 检查点数据是否获取成功</span><br><span class="line">    if not points_data:</span><br><span class="line">        return &quot;无法获取此位置的预报数据。&quot;</span><br><span class="line"></span><br><span class="line">    # 从点响应中获取预报URL</span><br><span class="line">    forecast_url = points_data[&quot;properties&quot;][&quot;forecast&quot;]</span><br><span class="line">    forecast_data = await make_nws_request(forecast_url)</span><br><span class="line"></span><br><span class="line">    # 检查预报数据是否获取成功</span><br><span class="line">    if not forecast_data:</span><br><span class="line">        return &quot;无法获取详细预报。&quot;</span><br><span class="line"></span><br><span class="line">    # 将时间段格式化为可读的预报</span><br><span class="line">    periods = forecast_data[&quot;properties&quot;][&quot;periods&quot;]</span><br><span class="line">    forecasts = []</span><br><span class="line">    # 只显示接下来的5个时间段</span><br><span class="line">    for period in periods[:5]:</span><br><span class="line">        forecast = f&quot;&quot;&quot;</span><br><span class="line">&#123;period[&#x27;name&#x27;]&#125;:</span><br><span class="line">温度: &#123;period[&#x27;temperature&#x27;]&#125;°&#123;period[&#x27;temperatureUnit&#x27;]&#125;</span><br><span class="line">风力: &#123;period[&#x27;windSpeed&#x27;]&#125; &#123;period[&#x27;windDirection&#x27;]&#125;</span><br><span class="line">预报: &#123;period[&#x27;detailedForecast&#x27;]&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">        forecasts.append(forecast)</span><br><span class="line"></span><br><span class="line">    # 用分隔符连接所有预报</span><br><span class="line">    return &quot;\n---\n&quot;.join(forecasts)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 程序入口点</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 初始化并运行服务器，使用stdio传输方式</span><br><span class="line">    mcp.run(transport=&#x27;stdio&#x27;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@mcp.tool()可以将函数内的字符串，参数类型等信息传给大模型，以供大模型决定何时调用这个tool</p>
<p>mcp.run(transport=’stdio’)说明mcp server和host的传输方式是输入和输出</p>
</blockquote>
<p>mcp server 配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;weather&quot;: &#123;</span><br><span class="line">    &quot;disabled&quot;: false,</span><br><span class="line">    &quot;timeout&quot;: 60,</span><br><span class="line">    &quot;command&quot;: &quot;uv&quot;,</span><br><span class="line">    &quot;args&quot;: [</span><br><span class="line">      &quot;--directory&quot;,</span><br><span class="line">      &quot;/Users/joeygreen/PycharmProjects/weather&quot;,</span><br><span class="line">      &quot;run&quot;,</span><br><span class="line">      &quot;weather.py&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;transportType&quot;: &quot;stdio&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“disabled”: false表示该服务是否被禁用。<code>false</code> 表示该服务是启用状态，可以正常运行。</p>
<p>“timeout”: 60设置该服务的超时时间，单位为秒。</p>
<p>“command”: “uv”指定执行该服务时使用的命令。</p>
<p>“args”出了执行 <code>command</code> 时需要传递的参数。</p>
<p>“transportType”: “stdio”指定服务的通信方式。<code>stdio</code> 表示标准输入输出流（Standard Input Output），通常用于进程间通信。</p>
</blockquote>
<h3 id="解析mcp-server与host的通信"><a href="#解析mcp-server与host的通信" class="headerlink" title="解析mcp server与host的通信"></a>解析mcp server与host的通信</h3><p><img src="/2025/07/27/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/MCP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250727154739013.png" alt="image-20250727154739013"></p>
<p>输入为host对server发送，输出为server对host发送，以下将列举几个重要的说明</p>
<p>输入中：<code>method</code>字段为host告诉server接下来要干什么，如<strong>初始化 (Initialization)</strong>，<strong>通知已初始化 (Notification)</strong>，<strong>查询可用工具 (Listing Tools)</strong>，<strong>调用工具 (Calling a Tool)</strong></p>
<p><code>protocolVersion</code>说明了mcp使用的协议版本</p>
<p>以下见server返回的tool信息，其中的一个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;get_forecast&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;Get weather forecast for a location.\n\nArgs:\n    latitude: Latitude of the location\n    longitude: Longitude of the location\n&quot;,</span><br><span class="line">    &quot;inputSchema&quot;: &#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;latitude&quot;: &#123;</span><br><span class="line">                &quot;title&quot;: &quot;Latitude&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;number&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;longitude&quot;: &#123;</span><br><span class="line">                &quot;title&quot;: &quot;Longitude&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;number&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;required&quot;: [</span><br><span class="line">            &quot;latitude&quot;,</span><br><span class="line">            &quot;longitude&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;title&quot;: &quot;get_forecastArguments&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;object&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以和定义的函数对比学习</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 注册为MCP工具的天气预报函数</span><br><span class="line">@mcp.tool()</span><br><span class="line">async def get_forecast(latitude: float, longitude: float) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;获取指定位置的天气预报。</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        latitude: 位置的纬度</span><br><span class="line">        longitude: 位置的经度</span><br><span class="line">        </span><br><span class="line">    Returns:</span><br><span class="line">        格式化后的天气预报字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 首先获取预报网格端点</span><br><span class="line">    points_url = f&quot;&#123;NWS_API_BASE&#125;/points/&#123;latitude&#125;,&#123;longitude&#125;&quot;</span><br><span class="line">    points_data = await make_nws_request(points_url)</span><br><span class="line"></span><br><span class="line">    # 检查点数据是否获取成功</span><br><span class="line">    if not points_data:</span><br><span class="line">        return &quot;无法获取此位置的预报数据。&quot;</span><br><span class="line"></span><br><span class="line">    # 从点响应中获取预报URL</span><br><span class="line">    forecast_url = points_data[&quot;properties&quot;][&quot;forecast&quot;]</span><br><span class="line">    forecast_data = await make_nws_request(forecast_url)</span><br><span class="line"></span><br><span class="line">    # 检查预报数据是否获取成功</span><br><span class="line">    if not forecast_data:</span><br><span class="line">        return &quot;无法获取详细预报。&quot;</span><br><span class="line"></span><br><span class="line">    # 将时间段格式化为可读的预报</span><br><span class="line">    periods = forecast_data[&quot;properties&quot;][&quot;periods&quot;]</span><br><span class="line">    forecasts = []</span><br><span class="line">    # 只显示接下来的5个时间段</span><br><span class="line">    for period in periods[:5]:</span><br><span class="line">        forecast = f&quot;&quot;&quot;</span><br><span class="line">&#123;period[&#x27;name&#x27;]&#125;:</span><br><span class="line">温度: &#123;period[&#x27;temperature&#x27;]&#125;°&#123;period[&#x27;temperatureUnit&#x27;]&#125;</span><br><span class="line">风力: &#123;period[&#x27;windSpeed&#x27;]&#125; &#123;period[&#x27;windDirection&#x27;]&#125;</span><br><span class="line">预报: &#123;period[&#x27;detailedForecast&#x27;]&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">        forecasts.append(forecast)</span><br><span class="line"></span><br><span class="line">    # 用分隔符连接所有预报</span><br><span class="line">    return &quot;\n---\n&quot;.join(forecasts)</span><br></pre></td></tr></table></figure>
<p><code>description</code>内容即为我们在定义这个tool的时候写的<strong>文档字符串</strong>（Documentation String），通常简称为 <strong>docstring</strong></p>
<p><code>inputSchema</code> 是在MCP（Model Control Protocol）中用来<strong>描述工具（tool）所需参数的结构和类型的规范</strong>。它本质上是一个JSON Schema。</p>
<blockquote>
<p>JSON Schema 是一个用于<strong>描述和验证 JSON 数据结构的规范</strong>。你可以把它理解为 JSON 数据的“蓝图”或“模板”。</p>
</blockquote>
<p><code>required</code>指明哪些参数是必需的，哪些是可选的。</p>
<h3 id="理解mcp的本质"><a href="#理解mcp的本质" class="headerlink" title="理解mcp的本质"></a>理解mcp的本质</h3><p>以上内容皆是server与host直接的交互，本质上可以理解成host对server提供的工具进行注册与使用。这其中并不涉及到host与大模型的交互，也就是大模型是如何使用host提供的信息。实际上不同的mcp host与模型的交互协议也不同，如cline使用的是xml格式；cherry studio使用的则是fuction calling</p>
<p>再看mcp的全称Model Context Protocol，模型上下文协议，也就是mcp增加模型的扩展性，使他可以获取更多信息，而server就是为模型提供更多信息的工具</p>
<h3 id="mcp-host与模型的交互"><a href="#mcp-host与模型的交互" class="headerlink" title="mcp host与模型的交互"></a>mcp host与模型的交互</h3><p>使用中转服务器截获日志</p>
<p><img src="/2025/07/27/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/MCP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250727163811531-1753605912284-1.png" alt="image-20250727163811531"></p>
<p>以下为cline发送给模型的请求</p>
<p><img src="/2025/07/27/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/MCP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250727164527797.png" alt="image-20250727164527797"></p>
<p><code>messages</code>包含了系统提示词与用户输入</p>
<p>先来看系统提示词，cline提供的提示词包括工具使用格式，工具信息，工具使用方法等。这里重点说一下，cline的工具使用格式xml</p>
<p>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tool_name&gt;</span><br><span class="line">&lt;parameter1_name&gt;value1&lt;/parameter1_name&gt;</span><br><span class="line">&lt;parameter2_name&gt;value2&lt;/parameter2_name&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tool_name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;read_file&gt;</span><br><span class="line">src/main.js</span><br><span class="line">&lt;/read_file&gt;</span><br></pre></td></tr></table></figure>
<p>再举个例子</p>
<p>use_mcp_tool<br>描述：请求使用由连接的 MCP 服务器提供的工具。每个 MCP 服务器可以提供具有不同功能的多个工具。工具有定义的输入模式，用于指定必需和可选参数。<br>参数：</p>
<p>server_name: (必需) 提供该工具的 MCP 服务器的名称<br>tool_name: (必需) 要执行的工具的名称<br>arguments: (必需) 一个 JSON 对象，包含工具的输入参数，遵循工具的输入模式<br>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;use_mcp_tool&gt;</span><br><span class="line">&lt;server_name&gt;服务器名称在此&lt;/server_name&gt;</span><br><span class="line">&lt;tool_name&gt;工具名称在此&lt;/tool_name&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;param1&quot;: &quot;value1&quot;,</span><br><span class="line">&quot;param2&quot;: &quot;value2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/use_mcp_tool&gt;</span><br></pre></td></tr></table></figure>
<p>模型返回响应如下</p>
<p><img src="/2025/07/27/%E5%AD%A6%E4%B9%A0/mcp%E5%AD%A6%E4%B9%A0/MCP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250727174504506.png" alt="image-20250727174504506"></p>
<p>sse连接，流式输出</p>
<blockquote>
<p>SSE 是一种<strong>基于标准 HTTP</strong>、<strong>只允许服务器向客户端单向推送文本流</strong>的实时通信技术，浏览器原生支持，自动重连，常用于<strong>AI 流式回答</strong>、<strong>实时日志</strong>、<strong>股价/监控推送</strong>等场景。</p>
<p>即客户端发送一次请求，连续接受多次响应直到结束</p>
</blockquote>
<h3 id="mcp的三种传输协议"><a href="#mcp的三种传输协议" class="headerlink" title="mcp的三种传输协议"></a>mcp的三种传输协议</h3><div class="table-container">
<table>
<thead>
<tr>
<th>协议名称</th>
<th>通信方式</th>
<th>适用场景</th>
<th>优势</th>
<th>局限</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Stdio</strong>（标准输入输出）</td>
<td>使用进程的标准输入（stdin）和标准输出（stdout）进行本地通信，基于 JSON-RPC 2.0 格式</td>
<td>本地开发、调试、IDE插件、命令行工具</td>
<td>简单易实现、跨平台、低延迟</td>
<td>仅支持本地通信，无法跨网络，低并发</td>
</tr>
<tr>
<td><strong>SSE</strong>（Server-Sent Events）</td>
<td>客户端通过 HTTP POST 发送请求，服务器通过 SSE 单向推送流式响应</td>
<td>实时监控、新闻推送、远程服务调用</td>
<td>基于 HTTP，浏览器友好，支持流式数据</td>
<td>仅支持单向通信，MCP官方已标记为“即将废弃”</td>
</tr>
<tr>
<td><strong>Streamable HTTP</strong>（新型流式HTTP）</td>
<td>支持双向流式通信的现代 HTTP 协议，替代 SSE，支持会话恢复、OAuth 认证等</td>
<td>分布式系统、高并发、双向实时交互</td>
<td>双向通信、高性能、企业级安全机制</td>
<td>实现较复杂，生态仍在发展中</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ReAct"><a href="#ReAct" class="headerlink" title="ReAct"></a>ReAct</h3><p>ReAct 是一种用于增强大型语言模型（LLMs）推理和行动能力的技术框架，它通过结合“推理”（Reasoning）和“行动”（Acting）来提升模型处理复杂任务的能力。</p>
<p>其工作流程通常包括以下几个步骤：</p>
<ol>
<li><strong>思考（Reasoning）</strong>：模型对当前问题进行分析，思考下一步需要采取的行动。</li>
<li><strong>行动（Acting）</strong>：模型决定调用哪些工具或函数，并提供必要的参数。</li>
<li><strong>观察（Observation）</strong>：工具执行后返回结果，模型对结果进行观察。</li>
<li><strong>响应（Response）</strong>：根据观察结果，模型生成最终的用户响应。</li>
</ol>
<p>实际应用上就是告诉大模型用ReAct这种模式来思考</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uronYREWR?spm_id_from=333.788.player.switch&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">MCP终极指南 - 从原理到实战，带你深入掌握MCP（基础篇）_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
