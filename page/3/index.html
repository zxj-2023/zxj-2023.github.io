<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zxj Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang XiJun">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="zxj Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="zxj">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang XiJun</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/" class="post-title-link" itemprop="url">matlab与opencv基本操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-15T00:00:00+08:00">2025-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-12 19:08:42" itemprop="dateModified" datetime="2025-11-12T19:08:42+08:00">2025-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">数字图像处理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言">前言</h3>
<p>本文讲解matlab<del>与opencv</del>对图像处理的基础操作，代码会有matlab<del>与python两版</del>，可对比学习。</p>
<h3 id="读写">读写</h3>
<h4 id="读入图像">读入图像</h4>
<p>matlab</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">&#x27;cameraman.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I = cv2.imread(&#x27;cameraman.jpg&#x27;, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure>
<p><strong><code>cv2.IMREAD_COLOR</code> = 强制读成 3 通道 BGR
彩色图。</strong></p>
<h4 id="存入图像">存入图像</h4>
<p>matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imwrite(J,&#x27;cameramanC.jpg&#x27;);</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(&#x27;cameramanC.jpg&#x27;, J)</span><br></pre></td></tr></table></figure>
<h4 id="读图并转-double">读图并转 double</h4>
<p>matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image1 = im2double(imread(&#x27;lotus.jpg&#x27;));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>imread</code> 把图像读成 0-255 的 <code>uint8</code>。</li>
<li><code>im2double</code> 把像素值线性缩放到 <strong>0–1
浮点</strong>，方便后续计算。</li>
</ul>
<blockquote>
<p>为什么要转成double</p>
<p>如果像素是 0–255，你在代码里写 <code>0.299*r</code> 就永远只用到
0.299×255≈76 灰度级，结果会整体偏暗甚至直接截断。</p>
<p>几级灰度的含义是什么</p>
<p><strong>几级灰度</strong>”这句话里的“级”就是“<strong>台阶</strong>”的意思：
把黑→白这段连续亮度等间隔切成多少份，就有多少个离散台阶，叫多少<strong>灰度级</strong>。</p>
<ul>
<li>2 级灰度 → 纯黑 + 纯白，一共 2 个台阶（1 bit）</li>
<li>8 级灰度 → 0, 36, 73, 109, 146, 182, 219, 255（3 bit）</li>
<li>256 级灰度 → 0–255，共 256 个台阶（8 bit）</li>
</ul>
<p><code>uint8</code> 是“<strong>Unsigned Integer, 8
bit</strong>”的缩写，含义一句话：</p>
<blockquote>
<p><strong>无符号、8 位、整型数字，只能放 0–255 的整数。</strong></p>
</blockquote>
</blockquote>
<h3 id="图像操作">图像操作</h3>
<h4 id="反色">反色</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J=255-I;</span><br></pre></td></tr></table></figure>
<h4 id="提取通道">提取通道</h4>
<p>matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Image1(:,:,1);</span><br><span class="line">g = Image1(:,:,2);</span><br><span class="line">b = Image1(:,:,3);</span><br></pre></td></tr></table></figure>
<p>分别提取rgb三个通道</p>
<p>opencv</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matlab:g = Image1(1,1,2)提取G通道的第一个像素点</span><br><span class="line">opencv:g = image[0,0,1]</span><br></pre></td></tr></table></figure>
<p>opencv是从下标0开始</p>
<h4 id="合并通道">合并通道</h4>
<p>NTSC 标准</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = 0.299*r + 0.587*g + 0.114*b;</span><br></pre></td></tr></table></figure>
<p><strong>0.299、0.587、0.114 是 NTSC 在 1953
年定下的“亮度加权系数”，源于人眼三种视锥细胞对 R、G、B
光谱的灵敏度——绿最亮、红次之、蓝最暗</strong></p>
<h4 id="二值化阈值-0.3">二值化（阈值 0.3）</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BW = zeros(size(Y));   % 先全黑</span><br><span class="line">BW(Y &gt; 0.3) = 1;       % 亮度&gt;0.3 的像素置 1（白）</span><br></pre></td></tr></table></figure>
<h4 id="从rgb颜色空间转换成hsi颜色空间">从RGB颜色空间转换成HSI颜色空间</h4>
<p>matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsi = rgb2hsv(img);</span><br></pre></td></tr></table></figure>
<p>HSI 颜色空间是把一幅彩色图像的<strong>每个像素</strong>拆成 3
个独立、且更符合人眼感知习惯的物理量：</p>
<ol type="1">
<li>H（Hue，色调） 用 0°–360° 的“角度”表示“到底是什么颜色”。
例：0°≈红，120°≈绿，240°≈蓝，绕一圈回到红。</li>
<li>S（Saturation，饱和度） 0–1（或 0–100%）表示“颜色有多鲜艳”。 0 →
灰，1 → 最纯、最艳。</li>
<li>I（Intensity，亮度/强度） 0–1（或
0–255）表示“有多亮”，与颜色本身无关，只反映明暗。</li>
</ol>
<ul>
<li>RGB 是“机器友好”的立方体坐标，但人眼很难从 (R,G,B)
直接说出“颜色、多艳、多亮”。</li>
</ul>
<h3 id="matlab基本操作">matlab基本操作</h3>
<h4 id="获取图像行列和通道数">获取图像行列和通道数</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N,M,~]=size(r);</span><br></pre></td></tr></table></figure>
<p><strong>把二维矩阵 <code>r</code> 的“行数”赋给
<code>N</code>，“列数”赋给 <code>M</code>。</strong></p>
<h4 id="截取图像">截取图像</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newimage=img(H/4:H*3/4,W/4:W*3/4,:);</span><br></pre></td></tr></table></figure>
<h3 id="人脸肤色检测">人脸肤色检测</h3>
<h4 id="ycrcb-阈值法">YCrCb 阈值法</h4>
<ol type="1">
<li><p>Y “Luma”——<strong>亮度</strong>（Luminance）。
对应人眼最敏感的黑↔︎白信息，决定了你看到的“明暗”。 计算公式近似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = 0.299·R + 0.587·G + 0.114·B</span><br></pre></td></tr></table></figure></li>
<li><p>Cr “Chroma-red”——<strong>红色色度</strong>。 表示
<strong>红色与亮度的差值</strong>：<code>Cr = R – Y</code></p></li>
<li><p>Cb “Chroma-blue”——<strong>蓝色色度</strong>。 表示
<strong>蓝色与亮度的差值</strong>：<code>Cb = B – Y</code></p></li>
</ol>
<p>人眼对 <strong>绿色最敏感</strong>，对
<strong>红、蓝最迟钝</strong>。 把“绿色”信息扔掉，只保留
<strong>R-Y</strong> 和 <strong>B-Y</strong> 两个差值，就能
<strong>最小化数据量</strong>，同时
<strong>还能把颜色还原回来</strong>。</p>
<ul>
<li>人类肤色在 YCrCb 颜色空间呈明显的“聚类”特性：无论人种如何，Cb、Cr
两个色度分量都落在狭长带状区域。</li>
<li>选取经验区间（Cr ∈ [133,173]，Cb ∈ [77,127]）直接做 2D 门限，亮度 Y
不参与判断，因此对光照强度变化不敏感，但对色偏敏感。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def skin_YCrCb(img):</span><br><span class="line">    #把一张 BGR 彩色图像从“蓝-绿-红”颜色空间转换到“亮度-红度-蓝度”颜色空间（YCrCb）</span><br><span class="line">    ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">    min_YCrCb = np.array([0, 133, 77])</span><br><span class="line">    max_YCrCb = np.array([255, 173, 127])</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">把落在 [min_YCrCb, max_YCrCb] 立方体内的像素标为 255（白），其余标为 0（黑），返回一张单通道掩膜图。</span><br><span class="line">执行过程（逐像素）：</span><br><span class="line">取 ycrcb 的一个像素 (y, cr, cb)</span><br><span class="line">检查是否同时满足</span><br><span class="line">min_Y ≤ y ≤ max_Y</span><br><span class="line">min_Cr ≤ cr ≤ max_Cr</span><br><span class="line">min_Cb ≤ cb ≤ max_Cb</span><br><span class="line">满足 → 输出 255；任一通道不满足 → 输出 0</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    skin = cv2.inRange(ycrcb, min_YCrCb, max_YCrCb)</span><br><span class="line">    return skin</span><br></pre></td></tr></table></figure>
<h4 id="hsv-阈值法">HSV 阈值法</h4>
<p>肤色聚类现象 大量统计表明：</p>
<ul>
<li><strong>不同人种、不同光照</strong> 的肤色在 RGB
空间里沿对角线“灰度轴”散开 → 亮度影响大。</li>
<li>转到 HSV 后，<strong>Hue 坐标紧紧挤在 0-20°
之间</strong>（红-橙-黄），<strong>S 中等偏高</strong>，<strong>V
中等偏亮</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def skin_HSV(img):</span><br><span class="line">    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">    low  = np.array([0,  30,  60])</span><br><span class="line">    high = np.array([20, 150, 255])</span><br><span class="line">    skin = cv2.inRange(hsv, low, high)</span><br><span class="line">    return skin</span><br></pre></td></tr></table></figure>
<h4 id="椭圆模型法">椭圆模型法</h4>
<p>原理：将RGB图像转换到YCRCB空间，肤色像素点会聚集到一个椭圆区域。先定义一个椭圆模型，然后将每个RGB像素点转换到YCRCB空间比对是否再椭圆区域，是的话判断为皮肤。</p>
<figure>
<img src="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/image-20250923091302411.png" alt="image-20250923091302411">
<figcaption aria-hidden="true">image-20250923091302411</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ---------------- 3. 椭圆模型法 ----------------</span><br><span class="line">def skin_ellipse(img):</span><br><span class="line">    ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">    # 如果本地没有模型图，现场画一张 256×256 查找表</span><br><span class="line">    ellipse_model = cv2.imread(&#x27;ellipse_skin_model.png&#x27;, 0)</span><br><span class="line">    if ellipse_model is None:</span><br><span class="line">        ellipse_model = np.zeros((256, 256), dtype=np.uint8)</span><br><span class="line">        cv2.ellipse(ellipse_model, (113, 155), (23, 15),</span><br><span class="line">                    43, 0, 360, 255, -1)</span><br><span class="line">    cr = ycrcb[:, :, 1].astype(np.uint16)  # 防止溢出</span><br><span class="line">    cb = ycrcb[:, :, 2].astype(np.uint16)</span><br><span class="line">    indices = cr * 256 + cb</span><br><span class="line">    skin = np.take(ellipse_model, indices)</span><br><span class="line">    return skin</span><br></pre></td></tr></table></figure>
<h3 id="将彩色图像-image1-的-rb-通道互换">将彩色图像 Image1 的 R、B
通道互换</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_swap = img(:,:,[3 1 2]);</span><br></pre></td></tr></table></figure>
<p>在 <strong>MATLAB</strong> 中，读取彩色图像（如用
<code>imread</code>）默认是 <strong>RGB 顺序</strong>：</p>
<ul>
<li>第1通道：Red（红）</li>
<li>第2通道：Green（绿）</li>
<li>第3通道：Blue（蓝）</li>
</ul>
<p>但在 <strong>OpenCV（Python/C++）</strong> 中，图像默认是 <strong>BGR
顺序</strong>：</p>
<ul>
<li>第1通道：Blue</li>
<li>第2通道：Green</li>
<li>第3通道：Red</li>
</ul>
<h3 id="使用或操作进行图像的嵌入">使用或操作，进行图像的嵌入</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">clear; clc; close all;  % 清空所有变量</span><br><span class="line">% 读取两张图片</span><br><span class="line">background = imread(&#x27;图片2.png&#x27;);   </span><br><span class="line">butterfly = imread(&#x27;图片1.png&#x27;);  </span><br><span class="line"></span><br><span class="line">% 设置缩放比例</span><br><span class="line">scale = 0.5;</span><br><span class="line">small_butterfly = imresize(butterfly, scale, &#x27;bilinear&#x27;);</span><br><span class="line"></span><br><span class="line">% 获取尺寸</span><br><span class="line">[ih, iw, ~] = size(small_butterfly);</span><br><span class="line">x = 200; y = 400;</span><br><span class="line"></span><br><span class="line">% 提取背景中对应区域</span><br><span class="line">bg_patch = background(x:x+ih-1, y:y+iw-1, :);</span><br><span class="line"></span><br><span class="line">is_black = any(small_butterfly~=0,3);   % 蝴蝶主体区域</span><br><span class="line"></span><br><span class="line">%只把背景中“蝴蝶主体对应位置”设为 0</span><br><span class="line">% 获取尺寸</span><br><span class="line">[ih, iw, ~] = size(bg_patch);</span><br><span class="line"></span><br><span class="line">% 双重循环遍历每个像素</span><br><span class="line">for i = 1:ih</span><br><span class="line">    for j = 1:iw</span><br><span class="line">        if is_black(i, j)   % 如果该位置是蝴蝶主体（非黑）</span><br><span class="line">            bg_patch(i, j, 1) = 0;  % R 通道设为 0</span><br><span class="line">            bg_patch(i, j, 2) = 0;  % G 通道设为 0</span><br><span class="line">            bg_patch(i, j, 3) = 0;  % B 通道设为 0</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%现在做 bitor：0 | butterfly = butterfly，背景黑区 | 0 = 背景</span><br><span class="line">patch_bitor = bitor(bg_patch, small_butterfly);</span><br><span class="line"></span><br><span class="line">% 写回背景</span><br><span class="line">background(x:x+ih-1, y:y+iw-1, :) = patch_bitor;</span><br><span class="line"></span><br><span class="line">% 显示结果</span><br><span class="line">figure;</span><br><span class="line">subplot(1,3,1), imshow(small_butterfly), title([&#x27;缩小后的蝴蝶 (&#x27;, num2str(scale*100), &#x27;%)&#x27;]);</span><br><span class="line">subplot(1,3,2), imshow(bg_patch), title(&#x27;处理后的背景块（蝴蝶位置清黑）&#x27;);</span><br><span class="line">subplot(1,3,3), imshow(background), title(&#x27;最终合成图（bitor）&#x27;);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/image-20251016114415946.png" alt="image-20251016114415946">
<figcaption aria-hidden="true">image-20251016114415946</figcaption>
</figure>
<h3 id="利用单尺度和多尺度-retinex-增强方法实现图像增强">利用单尺度和多尺度
Retinex 增强方法实现图像增强</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">I = imread(&#x27;gugong1.jpg&#x27;);</span><br><span class="line"></span><br><span class="line">if ndims(I) == 3</span><br><span class="line">    I_gray = rgb2gray(I);</span><br><span class="line">else</span><br><span class="line">    I_gray = I;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">I_double = double(I_gray) + eps;</span><br><span class="line"></span><br><span class="line">% SSR</span><br><span class="line">sigma = 15;</span><br><span class="line">L_ssr = log(conv2(I_double, fspecial(&#x27;gaussian&#x27;, [31, 31], sigma), &#x27;same&#x27;));</span><br><span class="line">R_ssr = log(I_double) - L_ssr;</span><br><span class="line">ssr_img = mat2gray(R_ssr);</span><br><span class="line"></span><br><span class="line">% MSR</span><br><span class="line">sigmas = [15, 80, 250];</span><br><span class="line">weights = [0.33, 0.34, 0.33];</span><br><span class="line">R_msr = zeros(size(I_double));</span><br><span class="line">for k = 1:length(sigmas)</span><br><span class="line">    sigma = sigmas(k);</span><br><span class="line">    kernel_size = round(6 * sigma) + 1;</span><br><span class="line">    if mod(kernel_size, 2) == 0</span><br><span class="line">        kernel_size = kernel_size + 1;</span><br><span class="line">    end</span><br><span class="line">    L = log(conv2(I_double, fspecial(&#x27;gaussian&#x27;, [kernel_size, kernel_size], sigma), &#x27;same&#x27;));</span><br><span class="line">    R_msr = R_msr + weights(k) * (log(I_double) - L);</span><br><span class="line">end</span><br><span class="line">msr_img = mat2gray(R_msr);</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(1,3,1); imshow(I); title(&#x27;Original&#x27;);</span><br><span class="line">subplot(1,3,2); imshow(ssr_img); title(&#x27;SSR&#x27;);</span><br><span class="line">subplot(1,3,3); imshow(msr_img); title(&#x27;MSR&#x27;);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/image-20251104095521796.png" alt="image-20251104095521796">
<figcaption aria-hidden="true">image-20251104095521796</figcaption>
</figure>
<h3 id="直方图均衡化计算"><strong>直方图均衡化计算</strong></h3>
<figure>
<img src="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/image-20251112090645146.png" alt="image-20251112090645146">
<figcaption aria-hidden="true">image-20251112090645146</figcaption>
</figure>
<figure>
<img src="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/image-20251112090723928.png" alt="image-20251112090723928">
<figcaption aria-hidden="true">image-20251112090723928</figcaption>
</figure>
<figure>
<img src="/2025/09/15/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/matlab%E4%B8%8Eopencv/image-20251112090714359.png" alt="image-20251112090714359">
<figcaption aria-hidden="true">image-20251112090714359</figcaption>
</figure>
<p>5.4代码</p>
<p>opencv</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># --- Step 1: 构造原始图像 ---</span><br><span class="line">gray_levels = np.array([0, 1/7, 2/7, 3/7, 4/7, 5/7, 6/7, 1])  # 原始灰度值 (0~1)</span><br><span class="line">pixel_counts = np.array([560, 920, 1046, 705, 356, 267, 170, 72])</span><br><span class="line">total_pixels = 64 * 64  # 4096</span><br><span class="line"></span><br><span class="line"># 将灰度值映射到整数 0~7 用于图像存储</span><br><span class="line">int_gray_levels = np.round(gray_levels * 7).astype(int)  # [0,1,2,3,4,5,6,7]</span><br><span class="line"></span><br><span class="line"># 创建图像数组</span><br><span class="line">img = np.zeros(total_pixels, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">start_idx = 0</span><br><span class="line">for i, count in enumerate(pixel_counts):</span><br><span class="line">    img[start_idx:start_idx + count] = int_gray_levels[i]</span><br><span class="line">    start_idx += count</span><br><span class="line"></span><br><span class="line">img = img.reshape((64, 64))  # 重塑为 64x64 图像</span><br><span class="line"></span><br><span class="line"># --- Step 2: 直方图均衡化 ---</span><br><span class="line">hist, _ = np.histogram(img, bins=8, range=(0, 8))</span><br><span class="line">cdf = np.cumsum(hist) / total_pixels</span><br><span class="line">mapping = np.round(cdf * 7).astype(int)</span><br><span class="line">equalized_img = mapping[img]</span><br><span class="line"></span><br><span class="line"># --- Step 3: 可视化对比 ---</span><br><span class="line">plt.figure(figsize=(8, 4))</span><br><span class="line"></span><br><span class="line">plt.subplot(1, 2, 1)</span><br><span class="line">plt.imshow(img, cmap=&#x27;gray&#x27;, vmin=0, vmax=7)</span><br><span class="line">plt.title(&#x27;Original&#x27;)</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line"></span><br><span class="line">plt.subplot(1, 2, 2)</span><br><span class="line">plt.imshow(equalized_img, cmap=&#x27;gray&#x27;, vmin=0, vmax=7)</span><br><span class="line">plt.title(&#x27;Equalized&#x27;)</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">landingpage调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-14T00:00:00+08:00">2025-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-15 23:02:07" itemprop="dateModified" datetime="2025-09-15T23:02:07+08:00">2025-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/Tosea-ai/" itemprop="url" rel="index"><span itemprop="name">Tosea.ai</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="landingpage的组成">landingpage的组成</h3>
<p>1.开始界面，大概说明产品的定位和作用，让用户可以快速注册后进入</p>
<p><a target="_blank" rel="noopener" href="https://www.grammarly.com/">Grammarly: Free AI Writing
Assistance</a></p>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914185941887.png" alt="image-20250914185941887">
<figcaption aria-hidden="true">image-20250914185941887</figcaption>
</figure>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914194430975.png" alt="image-20250914194430975">
<figcaption aria-hidden="true">image-20250914194430975</figcaption>
</figure>
<p>2.展示产品的特点功能和使用范例：1.特点功能这块可以像manus把使用过程中比较有特点的功能截屏，做成下面这样；2.范例部分结构可以参考<a target="_blank" rel="noopener" href="https://manus.im/?index=1">manus</a>或者<a target="_blank" rel="noopener" href="https://www.lovart.ai/zh">lovart</a>垂直滑动的效果，效果可以参考genspack<a target="_blank" rel="noopener" href="https://www.genspark.ai/agents?type=slides_agent">Genspark - AI
幻灯片</a></p>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914190352267.png" alt="image-20250914190352267">
<figcaption aria-hidden="true">image-20250914190352267</figcaption>
</figure>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914192344320.png" alt="image-20250914192344320">
<figcaption aria-hidden="true">image-20250914192344320</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://gamma.app/zh-cn/products/presentations">专为演示文稿打造的
Gamma | 利用 AI 立即构建演示文稿 | Gamma</a></p>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914194941544.png" alt="image-20250914194941544">
<figcaption aria-hidden="true">image-20250914194941544</figcaption>
</figure>
<p>3.用户的声音，价格。用户声音我觉得参考lovart就可以，声音这边也可以使用一个滚动的效果</p>
<p><a target="_blank" rel="noopener" href="https://www.trae.ai/">TRAE - Collaborate with
Intelligence</a></p>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914193756695.png" alt="image-20250914193756695">
<figcaption aria-hidden="true">image-20250914193756695</figcaption>
</figure>
<figure>
<img src="/2025/09/14/%E5%AE%9E%E4%B9%A0/Tosea.ai/landingpage%E8%B0%83%E7%A0%94/image-20250914200906675.png" alt="image-20250914200906675">
<figcaption aria-hidden="true">image-20250914200906675</figcaption>
</figure>
<p>我感觉我们的风格应该还是要简约大气</p>
<h3 id="pptyoda技术调用"><a target="_blank" rel="noopener" href="https://github.com/maquedexiju/PPtYoda">PPtYoda</a>技术调用</h3>
<p>这个项目的核心就是基于python-pptx的这个包，其实跟我们不是很符合。</p>
<p>他们ppt生成的逻辑核心是模板，一定要有pptx模板，并带有每个部分的备注，上传后解析，把ppt的各个结构转化成json存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file = models.FileField(</span><br><span class="line">        upload_to=get_template_path,</span><br><span class="line">        storage=ppt_storage,</span><br><span class="line">    )</span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=True)</span><br><span class="line"></span><br><span class="line">    cover_template = models.JSONField(null=True, blank=True, default=dict)</span><br><span class="line">    toc_template = models.JSONField(null=True, blank=True, default=dict)</span><br><span class="line">    chapter_L1_template = models.JSONField(null=True, blank=True, default=dict)</span><br><span class="line">    chapter_L2_template = models.JSONField(null=True, blank=True, default=dict)</span><br><span class="line">    blank_template = models.JSONField(null=True, blank=True, default=dict)</span><br><span class="line"></span><br><span class="line">    slide_templates = models.JSONField(null=True, blank=True, default=list)</span><br><span class="line">    components = models.JSONField(null=True, blank=True, default=list)</span><br><span class="line">    sections = models.JSONField(null=True, blank=True, default=dict)</span><br></pre></td></tr></table></figure>
<p>生成ppt时，也是让大模型生成符合这种规范的json，然后通过python-pptx填入。</p>
<p>这样好处确实是解决了使用python-pptx时，生成的ppt结构混乱的问题，但是这样生成的ppt完全依赖于你输入的模板，灵活性上有所缺陷。</p>
<h3 id="后续任务">后续任务</h3>
<p>1.导出speaknotes-pdf后端</p>
<p>2.生成完整presentation</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/11/%E5%AD%A6%E4%B9%A0/python-web/postgresql/postgresql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/11/%E5%AD%A6%E4%B9%A0/python-web/postgresql/postgresql/" class="post-title-link" itemprop="url">postgresql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-11T00:00:00+08:00">2025-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-07 13:56:05" itemprop="dateModified" datetime="2025-11-07T13:56:05+08:00">2025-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/" itemprop="url" rel="index"><span itemprop="name">python-web</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/postgresql/" itemprop="url" rel="index"><span itemprop="name">postgresql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="docker部署">docker部署</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgres</span><br><span class="line"></span><br><span class="line">docker run -d --name pgsql \</span><br><span class="line">  -p 5432:5432 \</span><br><span class="line">  -e POSTGRES_PASSWORD=123456 \</span><br><span class="line">  -v D:\database\postgresql:/var/lib/postgresql/data \</span><br><span class="line">  postgres</span><br><span class="line">  </span><br><span class="line">  docker run -d --name pgsql -p 5432:5432 -e POSTGRES_PASSWORD=123456 -v D:\database\postgresql:/var/lib/postgresql/data postgres</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nulixuexipython/p/18040243">docker
运行postgresql 极限简洁教程 - 刘老六 - 博客园</a></p>
<h3 id="恢复数据库">恢复数据库</h3>
<p>使用pg_restore</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1. 删除现有数据库</span><br><span class="line">psql -U postgres -c &quot;DROP DATABASE dvdrental;&quot;</span><br><span class="line"></span><br><span class="line"># 2. 重建空数据库</span><br><span class="line">psql -U postgres -c &quot;CREATE DATABASE dvdrental;&quot;</span><br><span class="line"></span><br><span class="line">pg_restore --dbname=postgresql://postgres:123456@localhost:5432/dvdrental --no-owner /workspace/dvdrental</span><br></pre></td></tr></table></figure>
<p>以下是数据库导入的原理</p>
<ol type="1">
<li>toc.dat（目录文件）</li>
</ol>
<p>作用 ：Table of Contents，包含备份的元数据信息</p>
<p>内容 ：数据库结构、表定义、索引、约束、函数等的描述</p>
<p>格式 ：二进制格式，记录了所有数据库对象的信息</p>
<ol start="2" type="1">
<li>数据文件（3038.dat, 3040.dat, …）</li>
</ol>
<p>作用 ：存储实际的表数据</p>
<p>命名规则 ：数字对应数据库对象的 OID（Object Identifier）</p>
<ol start="3" type="1">
<li>restore.sql（可选的SQL脚本）</li>
</ol>
<p>作用 ：包含恢复数据库的 SQL 命令</p>
<p>内容 ：CREATE TABLE、INSERT、索引创建等语句</p>
<p><strong>pg_restore 工作流程</strong></p>
<ol type="1">
<li>读取 toc.dat</li>
<li>创建数据库结构</li>
<li>创建约束和索引</li>
</ol>
<h3 id="sqlalchemy-orm">SQLAlchemy ORM</h3>
<p>范例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">config:</span><br><span class="line">  layout: elk</span><br><span class="line">---</span><br><span class="line">erDiagram</span><br><span class="line">    零件（Part） ||--o&#123; 库存（Inventory） : &quot;存放&quot;</span><br><span class="line">    库房（Warehouse） ||--o&#123; 库存（Inventory） : &quot;包含&quot;</span><br><span class="line">    供应商（Supplier） ||--o&#123; 采购（Purchase） : &quot;供应&quot;</span><br><span class="line">    零件（Part） ||--o&#123; 采购（Purchase） : &quot;被采购&quot;</span><br><span class="line">    库房（Warehouse） ||--o&#123; 采购（Purchase） : &quot;接收&quot;</span><br><span class="line">    库房（Warehouse） &#125;|--|| 职工（Staff） : &quot;组长&quot;</span><br><span class="line">    库房（Warehouse） ||--o&#123; 职工（Staff） : &quot;雇佣&quot;</span><br><span class="line">    零件（Part） &#123;</span><br><span class="line">        string part_id PK &quot;零件编号&quot;</span><br><span class="line">        string name &quot;名称&quot;</span><br><span class="line">        decimal unit_price &quot;单价&quot;</span><br><span class="line">        string type &quot;类型&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    供应商（Supplier） &#123;</span><br><span class="line">        string supplier_id PK &quot;供应商编号&quot;</span><br><span class="line">        string name &quot;名称&quot;</span><br><span class="line">        string address &quot;地址&quot;</span><br><span class="line">        string phone &quot;电话&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    库房（Warehouse） &#123;</span><br><span class="line">        string warehouse_id PK &quot;库房号&quot;</span><br><span class="line">        string address &quot;地址&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    职工（Staff） &#123;</span><br><span class="line">        string staff_id PK &quot;职工号&quot;</span><br><span class="line">        string name &quot;姓名&quot;</span><br><span class="line">        string gender &quot;性别&quot;</span><br><span class="line">        date hire_date &quot;进厂时间&quot;</span><br><span class="line">        string title &quot;职称&quot;</span><br><span class="line">        string warehouse_id FK &quot;所属库房&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    库存（Inventory） &#123;</span><br><span class="line">        string warehouse_id PK,FK &quot;库房号&quot;</span><br><span class="line">        string part_id PK,FK &quot;零件编号&quot;</span><br><span class="line">        int stock_quantity &quot;库存数量&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    采购（Purchase） &#123;</span><br><span class="line">        string purchase_id PK &quot;采购单号&quot;</span><br><span class="line">        string part_id FK &quot;零件编号&quot;</span><br><span class="line">        string supplier_id FK &quot;供应商编号&quot;</span><br><span class="line">        string warehouse_id FK &quot;库房号&quot;</span><br><span class="line">        date purchase_date &quot;采购日期&quot;</span><br><span class="line">        int quantity &quot;进货数量&quot;</span><br><span class="line">        decimal actual_price &quot;实际单价&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"># models.py</span><br><span class="line">from sqlalchemy import (</span><br><span class="line">    create_engine, Column, String, Integer, DECIMAL, Date, CHAR,</span><br><span class="line">    ForeignKey, CheckConstraint, UniqueConstraint</span><br><span class="line">)</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy.orm import relationship</span><br><span class="line"></span><br><span class="line"># SQLAlchemy 的基类，所有模型类都需要继承这个 Base</span><br><span class="line"># declarative_base() 创建了一个基类，用于定义数据库表结构的映射</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line">class Part(Base):</span><br><span class="line">    __tablename__ = &#x27;part&#x27;</span><br><span class="line">    </span><br><span class="line">    part_id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(100), nullable=False)</span><br><span class="line">    unit_price = Column(DECIMAL(10, 2), nullable=False)</span><br><span class="line">    type = Column(String(50), nullable=False)</span><br><span class="line">    </span><br><span class="line">    # 约束：单价 &gt;= 0</span><br><span class="line">    __table_args__ = (</span><br><span class="line">        CheckConstraint(unit_price &gt;= 0, name=&#x27;check_unit_price_positive&#x27;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">class Supplier(Base):</span><br><span class="line">    __tablename__ = &#x27;supplier&#x27;</span><br><span class="line">    </span><br><span class="line">    supplier_id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(100), nullable=False)</span><br><span class="line">    address = Column(String(200))</span><br><span class="line">    phone = Column(String(20))</span><br><span class="line"></span><br><span class="line">class Warehouse(Base):</span><br><span class="line">    __tablename__ = &#x27;warehouse&#x27;</span><br><span class="line">    </span><br><span class="line">    warehouse_id = Column(String(20), primary_key=True)</span><br><span class="line">    address = Column(String(200), nullable=False)</span><br><span class="line"></span><br><span class="line">    # 可选：未来加组长时在此添加</span><br><span class="line">    # leader_staff_id = Column(String(20), ForeignKey(&#x27;staff.staff_id&#x27;), unique=True)</span><br><span class="line"></span><br><span class="line">class Staff(Base):</span><br><span class="line">    __tablename__ = &#x27;staff&#x27;</span><br><span class="line">    </span><br><span class="line">    staff_id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(50), nullable=False)</span><br><span class="line">    gender = Column(CHAR(1))</span><br><span class="line">    hire_date = Column(Date, nullable=False)</span><br><span class="line">    title = Column(String(50))</span><br><span class="line">    warehouse_id = Column(String(20), ForeignKey(&#x27;warehouse.warehouse_id&#x27;), nullable=False)</span><br><span class="line">    </span><br><span class="line">    # 约束：性别只能是 M/F</span><br><span class="line">    __table_args__ = (</span><br><span class="line">        CheckConstraint(&quot;gender IN (&#x27;M&#x27;, &#x27;F&#x27;)&quot;, name=&#x27;check_gender&#x27;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">class Inventory(Base):</span><br><span class="line">    __tablename__ = &#x27;inventory&#x27;</span><br><span class="line">    </span><br><span class="line">    warehouse_id = Column(String(20), ForeignKey(&#x27;warehouse.warehouse_id&#x27;), primary_key=True)</span><br><span class="line">    part_id = Column(String(20), ForeignKey(&#x27;part.part_id&#x27;), primary_key=True)</span><br><span class="line">    stock_quantity = Column(Integer, nullable=False)</span><br><span class="line">    </span><br><span class="line">    # 表级约束：确保库存数量不能为负数</span><br><span class="line">    # 当尝试插入或更新为负数时会触发数据库错误</span><br><span class="line">    __table_args__ = (</span><br><span class="line">        CheckConstraint(stock_quantity &gt;= 0, name=&#x27;check_stock_non_negative&#x27;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">class Purchase(Base):</span><br><span class="line">    __tablename__ = &#x27;purchase&#x27;</span><br><span class="line">    </span><br><span class="line">    purchase_id = Column(String(30), primary_key=True)</span><br><span class="line">    part_id = Column(String(20), ForeignKey(&#x27;part.part_id&#x27;), nullable=False)</span><br><span class="line">    supplier_id = Column(String(20), ForeignKey(&#x27;supplier.supplier_id&#x27;), nullable=False)</span><br><span class="line">    warehouse_id = Column(String(20), ForeignKey(&#x27;warehouse.warehouse_id&#x27;), nullable=False)</span><br><span class="line">    purchase_date = Column(Date, nullable=False)</span><br><span class="line">    quantity = Column(Integer, nullable=False)</span><br><span class="line">    actual_price = Column(DECIMAL(10, 2), nullable=False)</span><br><span class="line">    </span><br><span class="line">    # 表级约束：确保采购业务逻辑的合理性</span><br><span class="line">    # - 采购数量必须为正数（不能为零或负数）</span><br><span class="line">    # - 实际采购价格必须为正数（不能为零或负数）</span><br><span class="line">    __table_args__ = (</span><br><span class="line">        CheckConstraint(quantity &gt; 0, name=&#x27;check_quantity_positive&#x27;),</span><br><span class="line">        CheckConstraint(actual_price &gt; 0, name=&#x27;check_price_positive&#x27;),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>建立表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_URL = &quot;postgresql://postgres:123456@localhost:5432/factory_db&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># create_tables.py</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from models import Base</span><br><span class="line">from dotenv import load_dotenv</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"># 替换为你的 Docker PostgreSQL 地址</span><br><span class="line">DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;)</span><br><span class="line"></span><br><span class="line"># 创建数据库引擎，用于连接数据库</span><br><span class="line"># create_engine 会根据 DATABASE_URL 创建对应的数据库连接池</span><br><span class="line">engine = create_engine(DATABASE_URL)</span><br><span class="line">Base.metadata.create_all(engine)  # 自动建表！</span><br><span class="line">print(&quot;✅ 所有表已创建&quot;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">rag增强技术汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-08 00:00:00 / 修改时间：12:51:22" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/rag/" itemprop="url" rel="index"><span itemprop="name">rag</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="各类-rag-增强技术">各类 RAG 增强技术</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/how_to_enhance_your_rag.md">如何提高 RAG
管道的性能 | Milvus 文档</a></p>
<p>可以通过此<a target="_blank" rel="noopener" href="https://github.com/milvus-io/bootcamp/tree/master/bootcamp/RAG/advanced_rag">GitHub
链接</a>获得本文所列主要方法的简单实现。</p>
<p>我们可以根据 RAG 管道各阶段的作用对不同的 RAG 增强方法进行分类。</p>
<ul>
<li><strong>查询增强</strong>：修改和操作 RAG
输入的查询过程，以便更好地表达或处理查询意图。</li>
<li><strong>增强索引</strong>：使用多分块、分步索引或多向索引等技术优化分块索引的创建。</li>
<li><strong>检索器增强</strong>：在检索过程中应用优化技术和策略。</li>
<li><strong>生成器增强</strong>：在为 LLM
生成提示时调整和优化提示，以提供更好的响应。</li>
<li><strong>增强 RAG 管道</strong>：在整个 RAG
管道中动态切换流程，包括使用 Agents 或工具来优化 RAG
管道中的关键步骤。</li>
</ul>
<p>接下来，我们将介绍每个类别下的具体方法。</p>
<h3 id="查询增强">查询增强</h3>
<p>共有四种方式：<strong>假设问题、假设文档嵌入、子查询和回溯提示</strong>。接下来我将选取几个具体说明。</p>
<h4 id="hyde假设文档嵌入">HyDE（假设文档嵌入）</h4>
<p>HyDE 是假设文档嵌入的缩写。它利用 LLM
制作一个<em><strong>“假设文档*</strong>”或</em><strong>虚假*</strong>答案，以回应没有上下文信息的用户查询。然后，这个假答案会被转换成向量嵌入，并用于查询向量数据库中最相关的文档块。随后，向量数据库会检索出
Top-K 最相关的文档块，并将它们传送给 LLM
和原始用户查询，从而生成最终答案。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908101159982.png" alt="image-20250908101159982">
<figcaption aria-hidden="true">image-20250908101159982</figcaption>
</figure>
<p>这种方法在解决向量搜索中的跨域不对称问题方面与假设问题技术类似。不过，它也有缺点，如增加了计算成本和生成虚假答案的不确定性。</p>
<h4 id="创建子查询">创建子查询</h4>
<p>当用户查询过于复杂时，我们可以使用 LLM
将其分解为更简单的子查询，然后再将其传递给向量数据库和
LLM。让我们来看一个例子。</p>
<p>想象一下，用户会问*<strong>“Milvus 和 Zilliz Cloud
在功能上有什么不同？*</strong>”这个问题相当复杂，在我们的知识库中可能没有直接的答案。为了解决这个问题，我们可以将其拆分成两个更简单的子查询：</p>
<ul>
<li>子查询 1：“Milvus 有哪些功能？”</li>
<li>子查询 2：“Zilliz Cloud 有哪些功能？”</li>
</ul>
<p>有了这些子查询后，我们将它们全部转换成向量嵌入后发送给向量数据库。然后，向量数据库会找出与每个子查询最相关的
Top-K 文档块。最后，LLM 利用这些信息生成更好的答案。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908122807696.png" alt="image-20250908122807696">
<figcaption aria-hidden="true">image-20250908122807696</figcaption>
</figure>
<h3 id="增强索引">增强索引</h3>
<p>增强索引是提高 RAG
应用程序性能的另一种策略。让我们来探讨三种索引增强技术：自<strong>动合并文档块，构建分层索引，混合检索和重新排名</strong></p>
<h4 id="构建分层索引">构建分层索引</h4>
<p>在创建文档索引时，我们可以建立两级索引：一级是文档摘要索引，另一级是文档块索引。向量搜索过程包括两个阶段：首先，我们根据摘要过滤相关文档，随后，我们在这些相关文档中专门检索相应的文档块。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908123520672.png" alt="image-20250908123520672">
<figcaption aria-hidden="true">image-20250908123520672</figcaption>
</figure>
<p>在涉及大量数据或数据分层的情况下，例如图书馆 Collections
中的内容检索，这种方法证明是有益的。</p>
<h4 id="混合检索和重新排名">混合检索和重新排名</h4>
<p>混合检索和重排技术将一种或多种辅助检索方法与<a target="_blank" rel="noopener" href="https://zilliz.com/learn/vector-similarity-search">向量相似性检索</a>相结合。然后，<a target="_blank" rel="noopener" href="https://zilliz.com/learn/optimize-rag-with-rerankers-the-role-and-tradeoffs#What-is-a-Reranker">Reranker</a>会根据检索结果与用户查询的相关性对检索结果重新排序。</p>
<p>常见的补充检索算法包括基于词频的方法（如<a target="_blank" rel="noopener" href="https://milvus.io/docs/embed-with-bm25.md">BM25）</a>或利用稀疏嵌入的大模型（如<a target="_blank" rel="noopener" href="https://zilliz.com/learn/discover-splade-revolutionize-sparse-data-processing">SPLADE</a>）。重新排序算法包括
RRF 或更复杂的模型，如<a target="_blank" rel="noopener" href="https://www.sbert.net/examples/applications/cross-encoder/README.html">Cross-Encoder</a>（类似于
BERT 的架构）。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908123544207.png" alt="image-20250908123544207">
<figcaption aria-hidden="true">image-20250908123544207</figcaption>
</figure>
<h3 id="改进检索器">改进检索器</h3>
<p>改进 RAG 系统中的检索器组件也能改进 RAG
应用。让我们来探讨一些增强检索器的有效方法：<strong>句子窗口检索，元数据过滤</strong></p>
<h3 id="生成器增强">生成器增强</h3>
<p>让我们通过改进 RAG 系统中的生成器来探索更多 RAG
优化技术：<strong>压缩 LLM 提示，调整提示中的块顺序</strong></p>
<h4 id="调整提示中的块顺序">调整提示中的块顺序</h4>
<p>在论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2307.03172">Lost in the
Middle</a>“中，研究人员观察到，LLMs
在推理过程中经常会忽略给定文档中间的信息。相反，他们往往更依赖于文档开头和结尾的信息。</p>
<p>根据这一观察结果，我们可以调整检索知识块的顺序来提高答案质量：在检索多个知识块时，将置信度相对较低的知识块放在中间，而将置信度相对较高的知识块放在两端。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908124338278.png" alt="image-20250908124338278">
<figcaption aria-hidden="true">image-20250908124338278</figcaption>
</figure>
<h3 id="增强-rag-管道">增强 RAG 管道</h3>
<p>我们还可以通过增强整个 RAG 管道来提高 RAG 应用程序的性能。</p>
<h4 id="自我反思">自我反思</h4>
<p>这种方法在人工智能 Agents
中融入了自我反思的概念。那么，这种技术是如何工作的呢？</p>
<p>一些最初检索到的 Top-K
文档块是模棱两可的，可能无法直接回答用户的问题。在这种情况下，我们可以进行第二轮反思，以验证这些文档块是否能真正解决查询问题。</p>
<p>我们可以使用高效的反思方法（如自然语言推理（NLI）模型）进行反思，也可以使用互联网搜索等其他工具进行验证。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908124655326.png" alt="image-20250908124655326">
<figcaption aria-hidden="true">image-20250908124655326</figcaption>
</figure>
<h4 id="使用代理进行查询路由选择">使用代理进行查询路由选择</h4>
<p>有时，我们不必使用 RAG
系统来回答简单的问题，因为它可能会导致更多的误解和对误导信息的推断。在这种情况下，我们可以在查询阶段使用代理作为路由器。这个
Agents 会评估查询是否需要通过 RAG 管道。如果需要，则启动后续的 RAG
管道；否则，LLM 直接处理查询。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/rag/rag%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/image-20250908124734144.png" alt="image-20250908124734144">
<figcaption aria-hidden="true">image-20250908124734144</figcaption>
</figure>
<p>Agents 可以有多种形式，包括 LLM、小型分类模型，甚至是一组规则。</p>
<p>通过根据用户意图路由查询，可以重新定向部分查询，从而显著提高响应时间，并明显减少不必要的噪音。</p>
<p>我们可以将查询路由技术扩展到 RAG
系统内的其他流程，例如确定何时利用网络搜索等工具、进行子查询或搜索图片。这种方法可确保
RAG
系统中的每个步骤都能根据查询的具体要求进行优化，从而提高信息检索的效率和准确性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-17 09:01:15" itemprop="dateModified" datetime="2025-11-17T09:01:15+08:00">2025-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="操作系统概论">操作系统概论</h2>
<h3 id="操作系统的主要特征">操作系统的主要特征</h3>
<h4 id="并发性-concurrency"><strong>并发性 (Concurrency)</strong></h4>
<p>🔍 核心定义</p>
<blockquote>
<p><strong>并发性</strong>是指两个或两个以上的事件或活动在<strong>同一时间间隔内</strong>发生。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：“同一时间间隔” ≠
“同一时刻”。它强调的是“看起来同时”，而不是“真正同时”。</li>
</ul>
<p>📌 操作系统中的体现</p>
<ol type="1">
<li><strong>多个 I/O 设备同时工作</strong>：
<ul>
<li>你的键盘在输入，打印机在打印，网卡在收发数据。这些设备都在“同时”工作。</li>
</ul></li>
<li><strong>I/O 和 CPU 计算同时进行</strong>：
<ul>
<li>当 CPU 在计算时，I/O 设备可能在后台传输数据。CPU 不需要等待 I/O
完成，可以去处理其他任务。</li>
</ul></li>
<li><strong>内存中多个程序交替执行</strong>：
<ul>
<li>这是最核心的体现。操作系统通过<strong>时间片轮转</strong>（Time-Slicing）等调度算法，让多个程序“轮流”使用
CPU，从而实现“宏观上的并发”。</li>
</ul></li>
</ol>
<p>🖼️ 并发 vs 并行</p>
<p>这是你 PPT 中提出的关键问题！</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 44%">
<col style="width: 44%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">并发 (Concurrency)</th>
<th style="text-align: left;">并行 (Parallelism)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>定义</strong></td>
<td style="text-align: left;">多个任务在<strong>同一时间间隔内</strong>交替执行。</td>
<td style="text-align: left;">多个任务在<strong>同一时刻</strong>真正同时执行。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>物理基础</strong></td>
<td style="text-align: left;">单 CPU 系统即可实现。</td>
<td style="text-align: left;">需要多核 CPU 或多处理器系统。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>效果</strong></td>
<td style="text-align: left;">“看起来”同时进行。</td>
<td style="text-align: left;">“真正”同时进行。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>类比</strong></td>
<td style="text-align: left;">一个人在厨房里，一会儿切菜，一会儿炒菜，一会儿洗碗。</td>
<td style="text-align: left;">三个人在厨房里，一个人切菜，一个人炒菜，一个人洗碗。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>✅
<strong>一句话总结</strong>：<strong>并行是并发的一种特例</strong>。并发是“逻辑上的同时”，并行是“物理上的同时”。</p>
</blockquote>
<h4 id="共享性-sharing"><strong>共享性 (Sharing)</strong></h4>
<p>🔍 核心定义</p>
<blockquote>
<p><strong>共享性</strong>指操作系统中的资源（包括硬件资源和软件资源）可被<strong>多个并发执行的进程共同使用</strong>，而不是被一个进程所独占。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：共享不等于“无限制访问”，它必须在<strong>操作系统管理下</strong>进行，以保证安全和有序。</li>
</ul>
<p>📌 资源共享的方式</p>
<p>1️⃣ 透明资源共享 / 同时共享方式</p>
<ul>
<li><strong>含义</strong>：允许多个进程在<strong>同一时间段内</strong>对资源进行访问，好像每个进程都独占资源一样。</li>
<li><strong>特点</strong>：
<ul>
<li>访问的次序对结果无影响。</li>
<li>通常用于<strong>可重入</strong>或<strong>只读</strong>的资源。</li>
</ul></li>
<li><strong>例子</strong>：
<ul>
<li><strong>CPU</strong>：通过时间片轮转，让多个进程“同时”使用
CPU。</li>
<li><strong>主存
(RAM)</strong>：多个进程的代码和数据可以同时存在于内存中。</li>
<li><strong>磁盘</strong>：多个进程可以同时读取磁盘上的不同文件。</li>
<li><strong>打印机</strong>：虽然物理上一次只能打印一个任务，但操作系统可以通过“打印队列”实现逻辑上的“同时共享”。</li>
</ul></li>
</ul>
<p>2️⃣ 独占资源共享 / 互斥共享方式</p>
<ul>
<li><strong>含义</strong>：在<strong>同一时间段内</strong>只允许<strong>一个进程</strong>访问资源。</li>
<li><strong>特点</strong>：
<ul>
<li>这类资源称为<strong>临界资源 (Critical Resource)</strong>。</li>
<li>必须通过<strong>互斥机制</strong>（如锁、信号量）来保护。</li>
</ul></li>
<li><strong>例子</strong>：
<ul>
<li><strong>磁带机</strong>：一次只能由一个进程控制。</li>
<li><strong>扫描仪</strong>：一次只能扫描一份文档。</li>
<li><strong>数据库中的某一行记录</strong>：如果两个事务同时修改同一行，会导致数据不一致。</li>
</ul></li>
</ul>
<p>🛠️ 操作系统如何管理共享？</p>
<ul>
<li><strong>提供显式资源共享机制</strong>：如 <code>fork()</code>,
<code>semaphore</code>, <code>mutex</code>, <code>lock</code>
等系统调用。</li>
<li><strong>将互斥访问下放给用户决策</strong>：程序员需要自己负责加锁和解锁，操作系统提供工具。</li>
</ul>
<h4 id="异步性-asynchrony">异步性 (Asynchrony)</h4>
<p>🔍 核心定义</p>
<blockquote>
<p><strong>异步性</strong>指在多道程序环境中，由于资源有限而进程众多，多数情况下，进程的执行不是一气呵成，而是“走走停停”。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：进程的执行是不可预测的，它的推进速度取决于系统调度、I/O
等待、中断等多种因素。</li>
</ul>
<p>📌 异步性的表现</p>
<ol type="1">
<li><strong>作业到达系统的时间和类型不确定</strong>：
<ul>
<li>用户随时可能启动一个新程序。</li>
</ul></li>
<li><strong>操作员发出命令或操作的时间和类型不确定</strong>：
<ul>
<li>用户可能随时按下键盘或点击鼠标。</li>
</ul></li>
<li><strong>程序运行发生错误或异常的类型和时刻不确定</strong>：
<ul>
<li>程序可能因为除零、内存溢出等原因崩溃。</li>
</ul></li>
<li><strong>中断事件发生的时刻不确定</strong>：
<ul>
<li>时钟中断、I/O 中断、硬件故障中断等都是随机发生的。</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[并发性] --&gt; B[多个任务同时执行]</span><br><span class="line">    C[共享性] --&gt; D[资源被多个任务共同使用]</span><br><span class="line">    E[异步性] --&gt; F[任务执行“走走停停”]</span><br><span class="line"></span><br><span class="line">    B &amp; D &amp; F --&gt; G[现代操作系统的核心特征]</span><br><span class="line">    G --&gt; H[实现多任务、多用户环境]</span><br></pre></td></tr></table></figure>
<h3 id="多道程序设计">多道程序设计</h3>
<h4 id="核心思想">核心思想</h4>
<blockquote>
<p><strong>多道程序设计</strong>是指允许多个程序<strong>同时</strong>驻留在内存中，并由操作系统<strong>统一管理和调度</strong>，使它们<strong>交替</strong>（并发）地使用
CPU 和其他系统资源。</p>
</blockquote>
<ul>
<li><strong>核心目的</strong>：<strong>掩盖 I/O 等待时间，提高 CPU
和系统资源的利用率</strong>。</li>
<li><strong>终极目标</strong>：让昂贵的 CPU
<strong>永远不要闲着</strong>！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 单道程序 vs 多道程序</span><br><span class="line">    dateFormat  HH:mm:ss</span><br><span class="line">    axisFormat  %Ss</span><br><span class="line"></span><br><span class="line">    section 单道程序</span><br><span class="line">    作业A-CPU     :crit, a1, 00:00:00, 2s</span><br><span class="line">    作业A-I/O     :active, a2, after a1, 8s</span><br><span class="line">    作业A-CPU     :crit, a3, after a2, 2s</span><br><span class="line">    作业A-I/O     :active, a4, after a3, 8s</span><br><span class="line"></span><br><span class="line">    section 多道程序</span><br><span class="line">    作业A-CPU     :crit, b1, 00:00:00, 2s</span><br><span class="line">    作业B-CPU     :crit, b2, after b1, 2s</span><br><span class="line">    作业C-CPU     :crit, b3, after b2, 2s</span><br><span class="line">    作业A-I/O     :active, b4, after b1, 8s</span><br><span class="line">    作业B-I/O     :active, b5, after b2, 8s</span><br><span class="line">    作业C-I/O     :active, b6, after b3, 8s</span><br></pre></td></tr></table></figure>
<p><strong>对比</strong>：在多道程序中，当作业 A 在等待 I/O 时，CPU
立刻去执行作业 B 和 C。CPU 几乎没有空闲时间，利用率接近 100%！</p>
<h4 id="cpu利用率">cpu利用率</h4>
<p><code>CPU利用率 = 1 - p^n</code></p>
<p>🔍 假设条件</p>
<ol type="1">
<li><strong>系统中有 <code>n</code> 个程序</strong> 同时在内存中。</li>
<li><strong>每个程序平均有 <code>p</code> 的概率在等待 I/O
操作</strong>。
<ul>
<li>例如，<code>p = 0.8</code> 表示一个程序有 80%
的时间在等磁盘读写、键盘输入等，只有 20% 的时间在真正使用 CPU。</li>
</ul></li>
<li><strong>各个程序的等待操作是相互独立的</strong>。
<ul>
<li>这是一个关键假设，意味着一个程序是否在等 I/O，不影响其他程序。</li>
</ul></li>
</ol>
<p>💡 公式推导</p>
<ul>
<li><strong>CPU 空闲的概率</strong>：当且仅当<strong>所有 <code>n</code>
个程序都在等待 I/O</strong> 时，CPU 才会空闲。</li>
<li>因为每个程序等待 I/O 的概率是
<code>p</code>，且它们相互独立，所以<strong>所有 <code>n</code>
个程序都等待 I/O 的概率是 <code>p^n</code></strong>。</li>
<li><strong>因此，CPU 空闲的概率 = <code>p^n</code></strong>。</li>
<li><strong>CPU 利用率 = 1 - CPU 空闲的概率 =
<code>1 - p^n</code></strong>。</li>
</ul>
<p>若进程平均花费 80% 的时间等待 I/O，则为了使得 CPU 利用率不低于
80%，应至少有多少道程序在主存中运行？</p>
<h3 id="计算过程">计算过程</h3>
<p>根据公式：</p>
<p>CPU利用率 = 1 - p^n ≥ 0.8</p>
<p>移项得：</p>
<p>p^n ≤ 0.2</p>
<p>代入 <code>p = 0.8</code>：</p>
<p>0.8^n ≤ 0.2</p>
<p>两边取对数（以 10 为底或自然对数均可）：</p>
<p>n * log(0.8) ≤ log(0.2)</p>
<p>注意：<code>log(0.8)</code>
是负数，所以在除的时候要<strong>反转不等号方向</strong>：</p>
<p>n ≥ log(0.2) / log(0.8)</p>
<p>计算数值：</p>
<ul>
<li><code>log(0.2) ≈ -0.69897</code></li>
<li><code>log(0.8) ≈ -0.09691</code></li>
<li><code>n ≥ (-0.69897) / (-0.09691) ≈ 7.21</code></li>
</ul>
<p>因为 <code>n</code> 必须是整数，且要满足
<code>n ≥ 7.21</code>，所以：</p>
<blockquote>
<p><strong><code>n = 8</code></strong></p>
</blockquote>
<p>✅ 最终答案</p>
<p><strong>为了使得 CPU 利用率不低于 80%，应至少有 8
道程序在主存中运行。</strong></p>
<h4 id="是不是同时运行的程序越多越好">是不是同时运行的程序越多越好？</h4>
<p><strong>不是！同时运行的程序（道数）并不是越多越好。存在一个最优的“道数”，超过这个值，系统的整体效率反而会下降。</strong></p>
<p>当道数 <code>n</code>
超过某个临界值后，系统性能会急剧下降。主要原因有：</p>
<p>1️⃣ <strong>上下文切换开销 (Context Switching Overhead)</strong></p>
<p><strong>什么是上下文切换？</strong></p>
<ul>
<li>当操作系统从一个进程切换到另一个进程时，它需要保存当前进程的状态（寄存器、内存映射、程序计数器等），并加载下一个进程的状态。</li>
</ul>
<p>2️⃣ <strong>内存压力 (Memory Pressure)</strong></p>
<ul>
<li><strong>每个进程都需要内存</strong>：代码段、数据段、堆、栈、页表等。</li>
</ul>
<p>3️⃣ <strong>资源竞争加剧 (Resource Contention)</strong></p>
<ul>
<li><strong>锁竞争</strong>：多个进程同时访问共享资源（如数据库连接池、文件锁），需要排队等待，增加了延迟。</li>
<li><strong>缓存失效</strong>：多个进程的指令和数据交替进入 CPU
缓存，导致缓存命中率降低，CPU 需要更频繁地从内存读取数据。</li>
</ul>
<h3 id="处理器状态">处理器状态</h3>
<h4 id="为什么需要两种处理器状态">为什么需要两种处理器状态？</h4>
<p>现代计算机是一个多用户、多任务的环境。如果所有程序都能随意执行任何指令，那么一个不小心的
bug 或一个恶意程序就可能：</p>
<ul>
<li>格式化硬盘。</li>
<li>修改系统时间。</li>
<li>访问其他用户的隐私数据。</li>
<li>导致系统崩溃。</li>
</ul>
<p>为了避免这种情况，CPU 被设计成有两种工作模式：</p>
<ol type="1">
<li><strong>用户态 (User
Mode)</strong>：普通程序运行的状态，只能执行“安全”的指令。</li>
<li><strong>核心态 (Kernel Mode / Supervisor
Mode)</strong>：操作系统内核运行的状态，可以执行所有指令，包括“危险”的特权指令。</li>
</ol>
<h4 id="程序状态字-psw">程序状态字 (PSW)</h4>
<p><strong>Program Status Word (PSW)</strong>
是一个非常重要的寄存器。</p>
<ul>
<li><strong>定义</strong>：PSW 是 CPU
内部的一个特殊寄存器，用于存储当前处理器的各种状态信息。</li>
<li><strong>关键作用</strong>：PSW
中有一个<strong>标志位</strong>（通常是最高位或某一位），用来标识当前
CPU 处于<strong>用户态还是核心态</strong>。
<ul>
<li><code>PSW[bit] = 0</code> → 用户态</li>
<li><code>PSW[bit] = 1</code> → 核心态</li>
</ul></li>
</ul>
<blockquote>
<p>✅ <strong>这就是 CPU
判断当前是否可以执行特权指令的依据！</strong></p>
</blockquote>
<p>当 CPU 执行一条指令时，它会检查 PSW 中的这个标志位：</p>
<ul>
<li>如果是<strong>用户态</strong>，并且指令是<strong>特权指令</strong>，则触发一个<strong>异常
(Exception)</strong>，操作系统会介入处理（通常是终止该程序）。</li>
<li>如果是<strong>核心态</strong>，则允许执行。</li>
</ul>
<h4 id="cpu-如何判断当前是否可以执行特权指令">CPU
如何判断当前是否可以执行特权指令？</h4>
<p><strong>答案</strong>：CPU 通过检查 <strong>程序状态字 (PSW)</strong>
中的一个特定标志位来判断。</p>
<ul>
<li>如果该标志位表示当前处于<strong>用户态</strong>，并且遇到的是<strong>特权指令</strong>，则
CPU
会触发一个<strong>异常</strong>（通常是“非法指令”或“特权指令违规”），并将控制权交给操作系统内核。</li>
<li>操作系统内核会根据情况决定是终止该程序，还是进行其他处理。</li>
</ul>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116191358137.png" alt="image-20251116191358137">
<figcaption aria-hidden="true">image-20251116191358137</figcaption>
</figure>
<h2 id="进程控制和管理">进程控制和管理</h2>
<h3 id="进程定义与属性">进程定义与属性</h3>
<p>进程（Process）是<strong>程序在计算机上的一次执行</strong>实例，是<strong>操作系统进行资源分配、调度和保护的基本单位</strong>。</p>
<h4 id="为什么要引入进程">为什么要引入“进程”？</h4>
<p>1️⃣ <strong>刻画系统的动态性（Dynamic Nature）</strong></p>
<ul>
<li><strong>问题</strong>：程序是静态的代码，无法描述“执行中”的状态。</li>
<li><strong>解决方案</strong>：进程是一个<strong>动态实体</strong>，它有生命周期（创建
→ 运行 → 阻塞 → 终止）。</li>
<li><strong>意义</strong>：操作系统可以精确跟踪每个任务的当前状态，做出调度决策。</li>
</ul>
<p>2️⃣ <strong>发挥系统的并发性（Concurrency）</strong></p>
<ul>
<li><strong>问题</strong>：CPU 和 I/O 设备速度不匹配。程序在等待
I/O（如读文件、网络请求）时，CPU 就空闲了。</li>
<li><strong>解决方案</strong>：通过<strong>进程切换</strong>，让 CPU
在等待期间去执行其他任务。</li>
<li><strong>意义</strong>：提高了 CPU 利用率和系统吞吐量。</li>
</ul>
<p>3️⃣ <strong>解决资源共享与隔离的矛盾</strong></p>
<ul>
<li><strong>问题</strong>：多个程序可能需要共享资源（如文件、打印机），但又不能互相干扰。</li>
<li><strong>解决方案</strong>：
<ul>
<li><strong>共享性</strong>：进程可以通过合法机制（如共享内存、消息队列）共享资源。</li>
<li><strong>独立性/保护性</strong>：每个进程拥有独立的地址空间，操作系统通过内存管理单元（MMU）确保
A 进程不能访问 B 进程的内存。</li>
</ul></li>
<li><strong>意义</strong>：既实现了协作，又保证了安全和稳定。</li>
</ul>
<h4 id="进程的五大核心属性">进程的五大核心属性</h4>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 45%">
<col style="width: 43%">
</colgroup>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 动态性</strong></td>
<td>进程是动态的，有生命周期（创建 → 运行 → 阻塞 → 终止）。</td>
<td><code>uvicorn</code> 启动时创建进程，<code>Ctrl+C</code>
终止时销毁进程。</td>
</tr>
<tr>
<td><strong>2. 并发性</strong></td>
<td>多个进程可以“同时”运行（宏观并发，微观交替）。</td>
<td>一台服务器同时处理成百上千个用户的 HTTP 请求。</td>
</tr>
<tr>
<td><strong>3. 独立性</strong></td>
<td>每个进程有独立的地址空间和资源，互不干扰。</td>
<td>一个 Python 进程崩溃，不会导致另一个 Python 进程退出。</td>
</tr>
<tr>
<td><strong>4. 制约性</strong></td>
<td>进程间可能存在同步或互斥关系（如竞争资源、等待结果）。</td>
<td>多个进程写同一个日志文件，需要用文件锁避免内容错乱。</td>
</tr>
<tr>
<td><strong>5. 共享性</strong></td>
<td>进程可以通过操作系统提供的机制共享资源（如内存、文件）。</td>
<td>多个 FastAPI worker 进程共享一个 Redis 缓存连接池。</td>
</tr>
</tbody>
</table>
<h3 id="进程状态转换">进程状态转换</h3>
<h4 id="五态模型">五态模型</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204410504.png" alt="image-20251115204410504">
<figcaption aria-hidden="true">image-20251115204410504</figcaption>
</figure>
<h4 id="七态模型">七态模型</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204451732.png" alt="image-20251115204451732">
<figcaption aria-hidden="true">image-20251115204451732</figcaption>
</figure>
<p>七态模型在五态模型的基础上，<strong>显式增加了“挂起（Suspend）”的概念</strong></p>
<blockquote>
<p>挂起 = 进程被换出到外存（Swap）</p>
<ul>
<li><strong>目的</strong>：当系统内存紧张时，操作系统会将一些<strong>暂时不活跃</strong>的进程（比如长时间阻塞的进程）从内存移到硬盘上的“交换区（Swap
Space）”，以腾出内存给更紧急的任务。</li>
</ul>
</blockquote>
<p><strong>挂起就绪态 (Ready/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程具备运行条件（即它已经准备好执行），但目前在外存中。只有当它被换入内存后，才能被调度器选中运行。</strong></p>
</blockquote>
<p><strong>挂起等待态 (Blocked/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程正在等待某一个事件发生（如 I/O
完成、用户输入、网络响应），并且目前在外存中。</strong></p>
</blockquote>
<h3 id="进程描述和组成">进程描述和组成</h3>
<h4 id="进程映像">进程映像</h4>
<p><strong>进程映像（Process
Image）是指进程在内存中的完整内容，包括代码、数据、堆、栈以及内核数据结构（如
PCB）等所有组成部分的集合。</strong></p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210257885.png" alt="image-20251115210257885">
<figcaption aria-hidden="true">image-20251115210257885</figcaption>
</figure>
<h4 id="进程上下文">进程上下文</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210715693.png" alt="image-20251115210715693">
<figcaption aria-hidden="true">image-20251115210715693</figcaption>
</figure>
<blockquote>
<p>寄存器上下文 (Register Context)<strong>存储在 PCB 中</strong>
<strong>包含：通用寄存器、程序计数器、栈指针、程序状态字</strong></p>
<p>这是进程“灵魂”的一部分——CPU 执行时最直接依赖的状态。</p>
</blockquote>
<h4 id="pcbprocess-control-block进程控制块"><strong>PCB（Process Control
Block，进程控制块）</strong></h4>
<p><strong>PCB
是操作系统为每个进程创建的一个数据结构，用来记录和刻画该进程的所有状态和相关信息。</strong></p>
<p>1️⃣ <strong>进程标识信息 (Identification Information)</strong></p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PID (Process ID)</strong></td>
<td>进程的唯一数字标识，如 <code>12345</code>。</td>
</tr>
<tr>
<td><strong>PPID (Parent PID)</strong></td>
<td>父进程的 PID，用于构建进程树。</td>
</tr>
<tr>
<td><strong>UID/GID (User/Group ID)</strong></td>
<td>进程所属用户的 ID 和组 ID，用于权限控制。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🌰 <strong>你的例子</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前进程 PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;父进程 PID: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure> 这些值就是从 PCB
中读取的！</p>
</blockquote>
<p>2️⃣ <strong>处理器状态信息 (Processor State Information)</strong> ——
<strong>这就是“寄存器上下文”</strong></p>
<p>这是 PCB 最关键的部分，用于<strong>上下文切换</strong>。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>程序计数器 (PC)</strong></td>
<td>下一条要执行的指令地址。</td>
</tr>
<tr>
<td><strong>通用寄存器 (AX, BX, CX…)</strong></td>
<td>存放临时计算结果、变量地址等。</td>
</tr>
<tr>
<td><strong>程序状态字 (PSW)</strong></td>
<td>包含标志位（零标志 Z、进位标志 C、溢出标志 O
等）、中断允许位、特权级别。</td>
</tr>
<tr>
<td><strong>栈指针 (SP)</strong></td>
<td>指向当前函数调用栈的顶部。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚡ <strong>关键点</strong>：每次进程切换时，操作系统都会将当前 CPU
寄存器的值“倾倒”进 PCB，再从新进程的 PCB
“倒回”寄存器。这就是“上下文切换”的核心开销。</p>
</blockquote>
<p>3️⃣ <strong>进程调度信息 (Scheduling Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程状态</strong></td>
<td>就绪、运行、阻塞、挂起等。</td>
</tr>
<tr>
<td><strong>进程优先级</strong></td>
<td>决定调度顺序。</td>
</tr>
<tr>
<td><strong>时间片剩余量</strong></td>
<td>用于时间片轮转调度。</td>
</tr>
<tr>
<td><strong>等待事件</strong></td>
<td>如等待键盘输入、网络数据包到达等。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🌰 <strong>你的例子</strong>： 在 FastAPI 中，当一个请求在
<code>await httpx.get(...)</code>
时，其对应协程/线程的状态会被标记为“阻塞”，并被放入等待队列。这就是 PCB
中“进程状态”字段的作用。</p>
</blockquote>
<p>4️⃣ <strong>内存管理信息 (Memory Management Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>页表基址 / 段表指针</strong></td>
<td>用于虚拟内存到物理内存的地址转换。</td>
</tr>
<tr>
<td><strong>内存分配情况</strong></td>
<td>代码段、数据段、堆、栈的起始地址和大小。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>💡
<strong>关键点</strong>：确保进程访问的是自己的内存空间，实现“内存保护”。</p>
</blockquote>
<p>5️⃣ <strong>I/O 状态信息 (I/O Status Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>打开的文件列表</strong></td>
<td>文件描述符（fd）、文件指针、访问模式等。</td>
</tr>
<tr>
<td><strong>分配的 I/O 设备</strong></td>
<td>如打印机、网卡等。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🌰 <strong>你的例子</strong>： 当你在 Python 中
<code>f = open("log.txt", "a")</code> 时，操作系统会在 PCB
的“打开文件列表”中添加一条记录，记录这个文件句柄 <code>f</code> 对应的
fd。</p>
</blockquote>
<p>6️⃣ <strong>记账信息 (Accounting Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU 使用时间</strong></td>
<td>进程已使用的 CPU 时间总和。</td>
</tr>
<tr>
<td><strong>累计运行时间</strong></td>
<td>从创建到现在的总时间。</td>
</tr>
<tr>
<td><strong>最大内存使用量</strong></td>
<td>历史峰值。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📊 <strong>用途</strong>：用于性能监控、计费、调试等。</p>
</blockquote>
<h3 id="进程队列">进程队列</h3>
<h4 id="链接方式">链接方式</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212223846.png" alt="image-20251115212223846">
<figcaption aria-hidden="true">image-20251115212223846</figcaption>
</figure>
<h4 id="索引方式">索引方式</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212241091.png" alt="image-20251115212241091">
<figcaption aria-hidden="true">image-20251115212241091</figcaption>
</figure>
<h3 id="进程切换和处理器状态转换">进程切换和处理器状态转换</h3>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212521578.png" alt="image-20251115212521578">
<figcaption aria-hidden="true">image-20251115212521578</figcaption>
</figure>
<h4 id="模式切换-vs.-进程切换">模式切换 vs. 进程切换</h4>
<ol type="1">
<li>模式切换 (Mode Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：CPU 在“用户态（User Mode）”和“核心态（Kernel
Mode）”之间的切换。
<strong>触发方式</strong>：由<strong>中断（Interrupt）或系统调用（System
Call）</strong> 引起。
<strong>目的</strong>：让操作系统获得控制权，执行特权指令（如访问硬件、修改内存映射）。</p>
</blockquote>
<ol start="2" type="1">
<li>进程切换 (Process Switch / Context Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：操作系统暂停当前正在运行的进程，保存其状态，并加载另一个进程的状态，使其开始运行。
<strong>触发方式</strong>：通常发生在<strong>核心态</strong>下，由中断或系统调用引发。
<strong>目的</strong>：实现多任务并发，公平分配 CPU 时间。</p>
</blockquote>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115215300054.png" alt="image-20251115215300054">
<figcaption aria-hidden="true">image-20251115215300054</figcaption>
</figure>
<h4 id="当进程开始运行时操作系统如何重新获得控制">当进程开始运行时，操作系统如何重新获得控制？</h4>
<p>果进程一直在运行，操作系统就永远没机会调度其他进程了，系统就会卡死。</p>
<p><strong>答案：中断 (Interrupt) 是关键！</strong></p>
<ul>
<li><strong>什么是中断？</strong>
中断就像一个“<strong>紧急电话</strong>”，它能打断 CPU
当前正在执行的程序，强制 CPU
去处理一个更高优先级的事情——通常是操作系统内核。
<ul>
<li><strong>硬件中断</strong>：由外部设备触发，比如键盘敲击、鼠标移动、网络数据包到达、定时器到期。</li>
<li><strong>软件中断/异常</strong>：由程序自身触发，比如除零错误、访问非法内存地址、或者程序主动发起的<strong>系统调用</strong>（如
<code>open()</code>, <code>read()</code>）。</li>
</ul></li>
</ul>
<h4 id="进程需要保存哪些状态">进程需要保存哪些状态？</h4>
<p>当操作系统获得控制权后，它必须把当前正在运行的进程（比如进程0）的“工作状态”完整地记录下来，以便将来能恢复执行。这个过程叫做“<strong>保存现场
(Save Context)</strong>”。</p>
<p><strong>需要保存哪些状态？</strong></p>
<p>这些状态主要存储在一个叫做 <strong>PCB (Process Control Block,
进程控制块)</strong> 的数据结构里。PCB 就像是进程的“<strong>身份证 +
工作日志 + 资源清单</strong>”。</p>
<h4 id="如何选择下一个待执行的进程线程">如何选择下一个待执行的进程/线程？</h4>
<p>当操作系统保存完当前进程的状态后，它需要决定“<strong>接下来该让谁干活</strong>”。这个决策过程叫做“<strong>进程调度
(Process Scheduling)</strong>”。</p>
<p><strong>如何选择？</strong></p>
<p>这取决于操作系统的<strong>调度算法 (Scheduling
Algorithm)</strong>。</p>
<h3 id="线程">线程</h3>
<h4 id="为什么需要线程-引入线程的动机">为什么需要线程？——
引入线程的动机</h4>
<p>❓ 问题：进程模型有什么不足？</p>
<ol type="1">
<li><strong>切换开销大</strong>：进程切换需要保存/恢复整个内存空间（代码、数据、堆、栈）和
PCB，开销大。</li>
<li><strong>通信困难</strong>：进程间通信（IPC）需要管道、消息队列、共享内存等复杂机制，效率低。</li>
<li><strong>不适合细粒度并发</strong>：比如一个 Web
服务器，每个请求都创建一个进程，成本太高。</li>
</ol>
<p>✅ 解决方案：引入线程！</p>
<blockquote>
<p><strong>线程是进程内的一个执行单元，是 CPU
调度和分派的基本单位。</strong></p>
</blockquote>
<ul>
<li><strong>同一个进程内的所有线程</strong>：
<ul>
<li><strong>共享</strong>：代码段、数据段、堆、打开的文件等<strong>进程资源</strong>。</li>
<li><strong>私有</strong>：各自的<strong>栈</strong>和<strong>寄存器上下文</strong>。</li>
</ul></li>
</ul>
<blockquote>
<p>💡
<strong>核心价值</strong>：<strong>实现进程内部的并发，降低切换和通信开销</strong>。</p>
</blockquote>
<h4 id="什么是线程-核心定义">什么是线程？—— 核心定义</h4>
<blockquote>
<p><strong>线程（Thread）是进程中一个可并发执行的控制流，它拥有自己独立的栈和寄存器状态，但与其他线程共享进程的地址空间和资源。</strong></p>
</blockquote>
<h4 id="线程如何工作-线程的生命周期与切换">线程如何工作？——
线程的生命周期与切换</h4>
<ol type="1">
<li><strong>线程的生命周期状态</strong></li>
</ol>
<p>和进程类似，线程也有状态：<strong>新建 → 就绪 → 运行 → 阻塞 →
终止</strong>。</p>
<ol start="2" type="1">
<li><strong>线程切换（Thread Switching）</strong></li>
</ol>
<ul>
<li><strong>开销远小于进程切换</strong>！因为不需要切换地址空间（页表），只需要保存/恢复<strong>寄存器上下文和栈指针</strong>。</li>
<li>切换由<strong>线程调度器</strong>（在 OS
内核或用户态库中）管理。</li>
</ul>
<ol start="3" type="1">
<li><strong>线程的实现方式</strong></li>
</ol>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 45%">
<col style="width: 24%">
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用户级线程 (User-Level Threads)</strong></td>
<td>由用户态线程库（如 Java Green Threads）管理，内核 unaware</td>
<td>Python 的 <code>greenlet</code>（非标准）</td>
</tr>
<tr>
<td><strong>内核级线程 (Kernel-Level Threads)</strong></td>
<td>由操作系统内核直接管理，每个线程对应一个内核调度实体</td>
<td>Python 的 <code>threading</code> 模块</td>
</tr>
<tr>
<td><strong>混合模式</strong></td>
<td>用户级线程映射到少量内核线程</td>
<td>Go 的 Goroutine</td>
</tr>
</tbody>
</table>
<blockquote>
<p>💡 <strong>Python 的 <code>threading</code>
是内核级线程</strong>，但受 GIL 限制，无法真正并行执行 Python
字节码。</p>
</blockquote>
<h2 id="处理器调度">处理器调度</h2>
<h3 id="调度层次">调度层次</h3>
<p>1️⃣ 高级调度（High-Level Scheduling）—— 作业调度 / 长程调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪些“作业”被允许进入系统参与 CPU 竞争。
<strong>对象</strong>：作业（Job）→
通常是一个完整的程序或任务（如编译一个文件、运行一个脚本）。
<strong>发生频率</strong>：<strong>低</strong>（几分钟到几小时一次）。
<strong>执行者</strong>：操作系统内核。</p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选作业进内存</strong>：从后备队列中选择作业，将其加载到内存，创建进程。</li>
<li><strong>控制多道程序的道数</strong>：决定同时在内存中运行多少个作业（即并发度）。太多会耗尽内存，太少会浪费
CPU。</li>
</ul>
<p>2️⃣ 中级调度（Medium-Level Scheduling）—— 平衡调度 / 内存调度</p>
<blockquote>
<p><strong>目标</strong>：根据内存状态，决定哪些进程可以在内存中运行，哪些需要换出到外存。
<strong>对象</strong>：进程（Process）。
<strong>发生频率</strong>：<strong>中等</strong>（几秒到几分钟一次）。
<strong>执行者</strong>：操作系统内核。</p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程进出内存</strong>：当内存紧张时，将一些不活跃的进程（如长时间阻塞的进程）换出到
Swap 分区；当内存空闲时，再换回。</li>
<li><strong>平衡系统负载</strong>：防止内存溢出，提高系统吞吐量。</li>
</ul>
<p>3️⃣ 低级调度（Low-Level Scheduling）—— 进程调度 / CPU 调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪个就绪队列中的进程/线程获得 CPU 执行权。
<strong>对象</strong>：进程或线程（内核级线程）。
<strong>发生频率</strong>：<strong>高</strong>（毫秒级，每几十到几百毫秒一次）。
<strong>执行者</strong>：操作系统内核 →
<strong>这是操作系统最核心的部分</strong>！</p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程分配
CPU</strong>：从就绪队列中选出下一个要运行的进程/线程。</li>
<li><strong>执行上下文切换</strong>：保存当前进程上下文，恢复新进程上下文。</li>
<li><strong>实现公平与效率</strong>：通过调度算法（如
RR、优先级、MLFQ）保证所有进程都能得到 CPU 时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[高级调度] --&gt;|选作业进内存| B[中级调度]</span><br><span class="line">    B --&gt;|选进程进出内存| C[低级调度]</span><br><span class="line">    C --&gt;|选进程分配 CPU| D[CPU 执行]</span><br><span class="line"></span><br><span class="line">    style A fill:#f9d5e5,stroke:#333</span><br><span class="line">    style B fill:#e3eaa7,stroke:#333</span><br><span class="line">    style C fill:#b2d3c2,stroke:#333</span><br></pre></td></tr></table></figure>
<h3 id="调度算法评价指标">调度算法评价指标</h3>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116131448708.png" alt="image-20251116131448708">
<figcaption aria-hidden="true">image-20251116131448708</figcaption>
</figure>
<h3 id="七种调度策略">七种调度策略</h3>
<h4 id="先来先服务-first-come-first-serverd-fcfs">先来先服务 (First Come
First Serverd, FCFS)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132753390.png" alt="image-20251116132753390">
<figcaption aria-hidden="true">image-20251116132753390</figcaption>
</figure>
<h4 id="短作业优先-shortest-job-first-sjf">短作业优先 (Shortest Job
First, SJF)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132925377.png" alt="image-20251116132925377">
<figcaption aria-hidden="true">image-20251116132925377</figcaption>
</figure>
<h4 id="最短剩余时间优先-shortest-remaining-time-first-srtf">最短剩余时间优先
(Shortest Remaining Time First, SRTF)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133352988.png" alt="image-20251116133352988">
<figcaption aria-hidden="true">image-20251116133352988</figcaption>
</figure>
<h4 id="最高响应比优先-highest-response-ratio-first-hrrf">最高响应比优先
(Highest Response Ratio First, HRRF)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133432719.png" alt="image-20251116133432719">
<figcaption aria-hidden="true">image-20251116133432719</figcaption>
</figure>
<h4 id="优先级调度-priority-scheduling">优先级调度 (Priority
Scheduling)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141512909.png" alt="image-20251116141512909">
<figcaption aria-hidden="true">image-20251116141512909</figcaption>
</figure>
<h4 id="轮转调度-round-robin-scheduling-rr">轮转调度 (Round Robin
Scheduling, RR)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141611150.png" alt="image-20251116141611150">
<figcaption aria-hidden="true">image-20251116141611150</figcaption>
</figure>
<h4 id="多级反馈队列调度-multi-level-feedback-queue-mlfq">多级反馈队列调度
(Multi-Level Feedback Queue, MLFQ)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116144745818.png" alt="image-20251116144745818">
<figcaption aria-hidden="true">image-20251116144745818</figcaption>
</figure>
<h2 id="并发互斥与同步">并发：互斥与同步</h2>
<h3 id="进程交互"><strong>进程交互</strong></h3>
<h4 id="为什么需要进程交互">为什么需要“进程交互”？</h4>
<p>在单进程时代，程序是“独占”的——它不需要考虑别人。但在现代操作系统中：</p>
<ul>
<li>多个进程/线程同时运行。</li>
<li>它们可能共享资源（如内存、文件、数据库连接）。</li>
<li>它们可能需要协同完成一个复杂任务（如一个 Web
请求涉及多个微服务）。</li>
</ul>
<p>这就产生了两个根本性问题：</p>
<ol type="1">
<li><strong>竞争（Competition）</strong>：多个进程争抢同一个资源，导致结果不可预测。</li>
<li><strong>协作（Cooperation）</strong>：多个进程需要按特定顺序执行，才能完成共同目标。</li>
</ol>
<blockquote>
<p>✅ <strong>进程交互就是解决这两个问题的机制</strong>。</p>
</blockquote>
<h4 id="竞争关系进程互斥">竞争关系（进程互斥）</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程互斥是指若干进程因相互争夺独占型资源而产生的竞争制约关系。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“相互争夺”</strong>：多个进程都想使用同一个资源。</li>
<li><strong>“独占型资源”</strong>：一次只能被一个进程使用的资源，如打印机、临界区代码、全局变量、数据库连接等。</li>
<li><strong>“竞争制约关系”</strong>：一个进程的执行会制约另一个进程的执行。</li>
</ul>
<p>🧱 两个核心控制问题：</p>
<ol type="1">
<li><strong>死锁问题（Deadlock）</strong>
<ul>
<li><strong>定义</strong>：多个进程互相等待对方释放资源，导致所有进程都无法继续执行。</li>
<li><strong>经典例子</strong>：“哲学家就餐问题”——五个哲学家围坐圆桌，每人左右各有一根筷子。他们必须拿到两根筷子才能吃饭。如果每个人都拿起左边的筷子，然后等待右边的筷子，就会陷入死锁。</li>
<li><strong>四个必要条件</strong>：
<ul>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul></li>
</ul></li>
<li><strong>饥饿问题（Starvation）</strong>
<ul>
<li><strong>定义</strong>：某个进程因为优先级低或资源分配策略不当，长时间得不到所需资源，导致无法执行。</li>
<li><strong>例子</strong>：在一个高优先级任务永远不结束的系统中，低优先级任务可能永远得不到
CPU。</li>
</ul></li>
</ol>
<h4 id="协作关系进程同步">协作关系（进程同步）</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程同步是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“完成共同任务”</strong>：多个进程/线程需要合作才能达成目标。</li>
<li><strong>“协调活动”</strong>：它们需要按特定顺序执行。</li>
<li><strong>“排定执行先后次序”</strong>：比如 A 必须在 B 之前执行。</li>
<li><strong>“等待、传递信号或消息”</strong>：通过同步机制（如信号量、条件变量、管道）实现通信和协调。</li>
</ul>
<p>🧱 核心思想：</p>
<ul>
<li><strong>“生产者-消费者”模型</strong>：生产者生成数据，消费者消费数据，它们必须同步。</li>
<li><strong>“读者-写者”模型</strong>：读者可以同时读，但写者必须独占。</li>
<li><strong>“屏障（Barrier）”</strong>：所有进程到达某个点后才能继续执行。</li>
</ul>
<h3 id="临界区管理">临界区管理</h3>
<h4 id="什么是临界区">什么是“临界区”？</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>并发进程中，与共享变量有关的程序段叫做“临界区”（Critical
Section）。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“并发进程”</strong>：多个进程/线程同时运行。</li>
<li><strong>“共享变量”</strong>：多个进程都能访问和修改的变量（如全局变量、数据库连接、文件句柄）。</li>
<li><strong>“程序段”</strong>：一段代码，比如 <code>counter += 1</code>
这样的操作。</li>
</ul>
<blockquote>
<p>💡 <strong>简单说</strong>：<strong>临界区 =
操作共享资源的那一小段代码。</strong></p>
</blockquote>
<p>🎯 为什么重要？</p>
<p>因为这段代码如果被多个进程同时执行，会导致<strong>竞态条件（Race
Condition）</strong>，产生不可预测的结果。</p>
<h4 id="如何避免错误-互斥访问临界区">如何避免错误？——
互斥访问临界区</h4>
<blockquote>
<p><strong>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误。</strong></p>
</blockquote>
<p>这就是“<strong>进程互斥</strong>”的核心思想。</p>
<h4 id="临界区调度的三个原则经典">临界区调度的三个原则（经典！）</h4>
<p>这是解决临界区问题的黄金法则，任何同步机制都必须满足这三个条件：</p>
<p>✅ 原则 1：一次至多一个进程能够进入临界区内执行</p>
<blockquote>
<p><strong>互斥性（Mutual Exclusion）</strong></p>
</blockquote>
<ul>
<li>这是最基本的要求。任何时候，最多只能有一个进程在临界区内。</li>
<li>如果 A 在临界区，B 就不能进入，必须等待。</li>
</ul>
<p>✅ 原则 2：如果已有进程在临界区，其他试图进入的进程应等待</p>
<blockquote>
<p><strong>忙则等待（Progress）</strong></p>
</blockquote>
<ul>
<li>如果临界区空闲，想进入的进程可以立即进入。</li>
<li>如果临界区被占用，其他进程必须等待，不能“自旋”浪费
CPU（虽然有些实现会自旋，但理想情况下应该阻塞等待）。</li>
</ul>
<p>✅ 原则
3：进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</p>
<blockquote>
<p><strong>有限等待（Bounded Waiting）</strong></p>
</blockquote>
<ul>
<li>防止“饥饿”。不能让某个进程永远等下去。</li>
<li>例如，使用队列来管理等待的进程，确保每个进程最终都能获得进入临界区的机会。</li>
</ul>
<h3 id="实现临界区管理的软件方法一peterson方法">实现临界区管理的软件方法一Peterson方法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int turn;           // turn 表示轮到谁进入</span><br><span class="line">boolean flag[2];   // flag[i] 表示进程 i 想进入临界区</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">flag[0] = flag[1] = false;</span><br><span class="line"></span><br><span class="line">Process P0() &#123;</span><br><span class="line">    flag[0] = true;</span><br><span class="line">    turn = 1;       // 谦让给 P1</span><br><span class="line">    while (flag[1] &amp;&amp; turn == 1); // 等待 P1 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process P1() &#123;</span><br><span class="line">    flag[1] = true;</span><br><span class="line">    turn = 0;       // 谦让给 P0</span><br><span class="line">    while (flag[0] &amp;&amp; turn == 0); // 等待 P0 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[1] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 1. 互斥性 (Mutual Exclusion)</p>
<blockquote>
<p><strong>定义</strong>：一次至多一个进程能进入临界区。</p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 和 P1 同时进入临界区。</li>
<li>那么 <code>flag[0] = true</code> 且
<code>flag[1] = true</code>。</li>
<li>根据算法，P0 在进入前设置了 <code>turn = 1</code>，P1 设置了
<code>turn = 0</code>。</li>
<li>由于 <code>turn</code> 只能取值 0 或 1，不可能同时为 0 和 1。</li>
<li>所以，当 P0 检查 <code>while (flag[1] &amp;&amp; turn == 1)</code>
时，如果 <code>turn == 0</code>，它就会阻塞。</li>
<li>同理，P1 也会被阻塞。</li>
<li><strong>结论</strong>：不可能同时进入。</li>
</ul>
<p>✅ 2. 空闲让进 (Progress)</p>
<blockquote>
<p><strong>定义</strong>：如果临界区空闲，且有进程想进入，则该进程应该能进入。</p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>如果 P1 不想进入临界区，则 <code>flag[1] = false</code>。</li>
<li>此时，无论 <code>turn</code> 是多少，P0 的
<code>while (flag[1] &amp;&amp; turn == 1)</code> 条件都会失败（因为
<code>flag[1]</code> 是 <code>false</code>），所以 P0
可以立即进入临界区。</li>
</ul>
<p>✅ 3. 有限等待 (Bounded Waiting)</p>
<blockquote>
<p><strong>定义</strong>：一个进程最多等待另一个进程执行完临界区一次，就能获得进入的机会。</p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 被阻塞，说明 <code>turn = 1</code> 且
<code>flag[1] = true</code>，即 P1 在临界区。</li>
<li>当 P1 执行完临界区后，它会设置 <code>flag[1] = false</code>。</li>
<li>此时，如果 P0 还想进入，它的 <code>while</code>
条件会失败，从而进入临界区。</li>
<li>如果 P1 在 <code>flag[1] = false</code> 后又想进入，则它会设置
<code>flag[1] = true</code> 和 <code>turn = 0</code>。</li>
<li>此时，P0 会被阻塞，但 P1 执行完后，P0 就能进入。</li>
<li><strong>结论</strong>：P0 最多等待 P1
执行一次临界区，就能进入。</li>
</ul>
<h3 id="信号量与pv操作">信号量与PV操作</h3>
<h4 id="信号量semaphore">信号量（Semaphore）</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>信号量是一种软件资源，用于表示物理资源的实体，是一个与队列有关的整型变量。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“表示物理资源”</strong>：比如打印机、数据库连接池、线程池中的可用线程数。</li>
<li><strong>“整型变量”</strong>：信号量的值代表当前<strong>可用资源的数量</strong>。</li>
<li><strong>“与队列有关”</strong>：当资源不足时，等待的进程会被放入一个<strong>等待队列</strong>。</li>
</ul>
<h4 id="pv-操作信号量的原子操作">P/V 操作：信号量的“原子操作”</h4>
<p>✅ 定义：</p>
<blockquote>
<p><strong>P (Proberen, 尝试) 和 V (Verhogen, 增加)
是对信号量进行操作的原语。</strong></p>
</blockquote>
<ul>
<li><strong>P 操作</strong>：尝试获取资源。如果资源可用（信号量 &gt;
0），则减 1；否则，进程进入等待队列。</li>
<li><strong>V
操作</strong>：释放资源。增加信号量值，并唤醒一个等待的进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// P 操作 (Wait)</span><br><span class="line">void P(semaphore s) &#123;</span><br><span class="line">    s.value = s.value - 1;</span><br><span class="line">    if (s.value &lt; 0) &#123;</span><br><span class="line">        // 资源不足，将当前进程加入等待队列并阻塞</span><br><span class="line">        block(current_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// V 操作 (Signal)</span><br><span class="line">void V(semaphore s) &#123;</span><br><span class="line">    s.value = s.value + 1;</span><br><span class="line">    if (s.value &lt;= 0) &#123;</span><br><span class="line">        // 有进程在等待，唤醒一个</span><br><span class="line">        wakeup(one_waiting_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ <strong>关键点</strong>：P/V 操作必须是<strong>原子操作（Atomic
Operation）</strong>，即在执行过程中不能被中断。否则会导致竞态条件。</p>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<h4 id="哲学家进餐问题核心描述">哲学家进餐问题：核心描述</h4>
<p>✅ 问题设定：</p>
<ul>
<li>有 <strong>5 位哲学家</strong> 围坐在一张圆桌旁。</li>
<li>每位哲学家面前有一盘<strong>意大利面</strong>。</li>
<li>桌子上有 <strong>5 把叉子</strong>，每两位哲学家之间放一把。</li>
<li>哲学家的生活只有两件事：
<ul>
<li><strong>思考（Think）</strong>：什么都不做。</li>
<li><strong>吃饭（Eat）</strong>：必须同时拿到<strong>左右两边的叉子</strong>才能吃。</li>
</ul></li>
<li>吃完后，会放下叉子，继续思考。</li>
</ul>
<blockquote>
<p>💡
<strong>目标</strong>：设计一个算法，让所有哲学家都能吃饱，且不会发生死锁或饥饿。</p>
</blockquote>
<h4 id="为什么会出现死锁">为什么会出现死锁？</h4>
<p>📌 死锁的四个必要条件：</p>
<ol type="1">
<li><strong>互斥条件</strong>：叉子一次只能被一个人使用。</li>
<li><strong>请求与保持条件</strong>：哲学家拿起一把叉子后，会继续等待另一把。</li>
<li><strong>不剥夺条件</strong>：不能强行从哲学家手中拿走叉子。</li>
<li><strong>环路等待条件</strong>：每位哲学家都在等右边的人放下叉子，形成一个循环等待链。</li>
</ol>
<h4 id="解决方案打破死锁的四个条件之一">解决方案：打破死锁的四个条件之一</h4>
<p>要避免死锁，只需破坏其中一个必要条件即可。以下是几种经典的解决方案：</p>
<p>✅ 解决方案 1：限制同时就餐的哲学家数量（破坏“环路等待”）</p>
<blockquote>
<p><strong>最多允许 4 位哲学家同时吃面。</strong></p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>如果只有 4 个人尝试拿叉子，那么至少有一把叉子是空闲的。</li>
<li>这样，总会有一个人能拿到两把叉子并吃完，从而释放资源。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 5 把叉子（信号量）</span><br><span class="line">forks = [threading.Semaphore(1) for _ in range(5)]</span><br><span class="line"># 限制同时就餐人数为 4</span><br><span class="line">dining_room = threading.Semaphore(4)</span><br><span class="line"></span><br><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        dining_room.acquire()  # 进入餐厅（最多 4 人）</span><br><span class="line">        </span><br><span class="line">        forks[i].acquire()       # 拿起左边叉子</span><br><span class="line">        forks[(i + 1) % 5].acquire()  # 拿起右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()       # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()  # 放下右边叉子</span><br><span class="line">        </span><br><span class="line">        dining_room.release()    # 离开餐厅</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">def eat(i):</span><br><span class="line">    print(f&quot;Philosopher &#123;i&#125; is eating...&quot;)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line"># 创建 5 个哲学家线程</span><br><span class="line">threads = []</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=philosopher, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 2：奇偶号哲学家取叉子顺序不同（破坏“环路等待”）</p>
<blockquote>
<p><strong>奇数号哲学家先取左边叉子，再取右边；偶数号哲学家先取右边叉子，再取左边。</strong></p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>这样就不会形成环路等待。</li>
<li>例如，哲学家 0（偶数）先拿右边叉子（叉子 1），哲学家
1（奇数）先拿左边叉子（叉子 1）→
他们争抢同一把叉子，但最终只会有一个成功，另一个等待，从而打破环路。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        </span><br><span class="line">        if i % 2 == 0:  # 偶数号哲学家</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 先拿右边叉子</span><br><span class="line">            forks[i].acquire()             # 再拿左边叉子</span><br><span class="line">        else:  # 奇数号哲学家</span><br><span class="line">            forks[i].acquire()             # 先拿左边叉子</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 再拿右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()                 # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()      # 放下右边叉子</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 3：拿起两把叉子才开始吃（破坏“请求与保持”）</p>
<blockquote>
<p><strong>每位哲学家必须同时拿到两把叉子才能开始吃，否则一把也不拿。</strong></p>
</blockquote>
<p>1️⃣ 全局变量定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"></span><br><span class="line">semaphore s[<span class="number">5</span>];     <span class="comment">// 用于阻塞哲学家的信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥锁，保护 state 和 s</span></span><br><span class="line"><span class="type">int</span> state[<span class="number">5</span>];      <span class="comment">// 哲学家的状态</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>s[i]</code> 初始值为 0，因为一开始没有人需要等待。</li>
<li><code>state[i]</code> 初始化为 <code>THINKING</code>。</li>
</ul>
<p>2️⃣ <code>take_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">take_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = HUNGRY;  <span class="comment">// 哲学家 i 变成饥饿状态</span></span><br><span class="line">    test(i);            <span class="comment">// 尝试让 i 吃饭</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">    P(s[i]);            <span class="comment">// 如果 test(i) 没有让 i 吃上饭，这里会阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = HUNGRY</code></strong>:
告诉“管家”，我饿了。</li>
<li><strong><code>test(i)</code></strong>: “管家”检查我是否能吃。
<ul>
<li>如果能吃，<code>test(i)</code> 会执行
<code>V(s[i])</code>，唤醒我。</li>
<li>如果不能吃，<code>test(i)</code> 不做任何事。</li>
</ul></li>
<li><strong><code>P(s[i])</code></strong>:
如果我没被唤醒，我就在这里阻塞，等待邻居放叉子。</li>
</ul>
<blockquote>
<p>✅
<strong>这个函数是“非阻塞”的</strong>：它只负责声明“我饿了”，然后立即返回。真正的等待发生在
<code>P(s[i])</code>。</p>
</blockquote>
<p>3️⃣ <code>put_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = THINKING; <span class="comment">// 哲学家 i 变成思考状态</span></span><br><span class="line">    test((i + <span class="number">1</span>) % <span class="number">5</span>);  <span class="comment">// 检查右边邻居</span></span><br><span class="line">    test((i + <span class="number">4</span>) % <span class="number">5</span>);  <span class="comment">// 检查左边邻居（(i+4)%5 == (i-1)%5）</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = THINKING</code></strong>:
我吃饱了，不再占用叉子。</li>
<li><strong><code>test((i+1)%5)</code> 和
<code>test((i+4)%5)</code></strong>:
告诉“管家”，我的邻居们可能现在可以吃饭了。
<ul>
<li>例如，哲学家 0 放下叉子后，哲学家 1 和 4
可能现在能拿到两把叉子了。</li>
<li>“管家”会检查他们是否处于 <code>HUNGRY</code>
状态，并且邻居都不在吃，如果是，就唤醒他们。</li>
</ul></li>
</ul>
<p>4️⃣ <code>test(int i)</code> 函数 —— 核心逻辑！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;  <span class="comment">// 可以吃了！</span></span><br><span class="line">        V(s[i]);            <span class="comment">// 唤醒哲学家 i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong>检查三个条件</strong>：
<ol type="1">
<li><code>state[i] == HUNGRY</code>: 我确实想吃饭。</li>
<li><code>state[(i+1)%5] != EATING</code>: 我右边的邻居没在吃。</li>
<li><code>state[(i+4)%5] != EATING</code>: 我左边的邻居没在吃。</li>
</ol></li>
<li><strong>如果都满足</strong>：说明我现在可以拿到两把叉子！
<ul>
<li>设置 <code>state[i] = EATING</code>。</li>
<li>执行 <code>V(s[i])</code>，唤醒我自己（因为我在
<code>take_fork</code> 中 <code>P(s[i])</code> 阻塞了）。</li>
</ul></li>
</ul>
<blockquote>
<p>✅ <strong>这个函数是“原子”的</strong>：因为它在 <code>mutex</code>
保护下执行，不会被其他哲学家打断。</p>
</blockquote>
<h3 id="生产者消费者问题">生产者消费者问题</h3>
<p><code>mutex</code> 的作用就是：</p>
<blockquote>
<p><strong>保护对共享变量（或临界区）的访问</strong>，
<strong>只在真正操作这些共享资源的前后“加锁”和“解锁”</strong>。</p>
</blockquote>
<p>（防死锁铁律）：</p>
<blockquote>
<p><strong>永远不要在持有互斥锁（mutex）的情况下，调用可能阻塞的操作（如
P(empty)、P(full)、sleep、wait 等）。</strong></p>
</blockquote>
<h3 id="什么是生产者-消费者问题">什么是生产者-消费者问题？</h3>
<p>这是一个经典的<strong>多线程同步问题</strong>，用于模拟现实中的“生产”与“消费”场景：</p>
<ul>
<li><strong>生产者 (Producer)</strong>：负责制造数据或产品。</li>
<li><strong>消费者
(Consumer)</strong>：负责处理或消费这些数据/产品。</li>
<li><strong>缓冲区
(Buffer)</strong>：一个有限大小的共享空间，用来暂存生产者的产品，供消费者取用。</li>
</ul>
<p>📌 核心挑战</p>
<ol type="1">
<li><strong>互斥 (Mutual
Exclusion)</strong>：多个生产者/消费者不能同时操作缓冲区的同一个位置，否则数据会错乱。</li>
<li><strong>同步 (Synchronization)</strong>：
<ul>
<li>生产者不能在缓冲区满时继续生产（要等待）。</li>
<li>消费者不能在缓冲区空时继续消费（要等待）。</li>
</ul></li>
</ol>
<h4 id="代码">代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">item B[n];</span><br><span class="line">Semaphore empty;  /*可用的空缓冲区个数*/</span><br><span class="line">Semaphore full;   /*可用的产品数*/</span><br><span class="line">Semaphore mutex;  /*互斥信号量*/</span><br><span class="line">empty = n; full = 0; mutex = 1;</span><br><span class="line">int in = 0; out = 0;  /*in为放入缓冲区指针, out为取出缓冲区指针*/</span><br><span class="line"></span><br><span class="line">Process producer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        item product = produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        B[in] = product;</span><br><span class="line">        in = (in+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process consumer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Item product = B[out];</span><br><span class="line">        out = (out+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        consume(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题如果将p操作的顺序交换会出现什么情况">问题：如果将P操作的顺序交换，会出现什么情况？</h4>
<p><strong>生产者霸占着 <code>mutex</code> 锁，等待
<code>empty</code>，消费者等待 <code>mutex</code>
锁，导致死锁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Producer as 生产者 P1</span><br><span class="line">    participant Consumer as 消费者 C1</span><br><span class="line">    participant Mutex as 互斥锁 (mutex)</span><br><span class="line">    participant Empty as 空闲缓冲区 (empty)</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 初始状态: empty=0 (缓冲区满), mutex=1</span><br><span class="line"></span><br><span class="line">    Producer-&gt;&gt;Mutex: P(mutex) // 成功获取锁，mutex=0</span><br><span class="line">    Producer-&gt;&gt;Empty: P(empty) // empty=0，阻塞！等待空位...</span><br><span class="line">    Note over Producer: 生产者 P1 霸占 mutex 锁，等待 empty</span><br><span class="line"></span><br><span class="line">    Consumer-&gt;&gt;Full: P(full) // full=1，成功，full=0</span><br><span class="line">    Consumer-&gt;&gt;Mutex: P(mutex) // mutex=0，阻塞！等待锁...</span><br><span class="line">    Note over Consumer: 消费者 C1 等待 mutex 锁</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 💥 死锁！</span><br><span class="line">    Note right of Producer: 我要等 empty (需 C1 消费)</span><br><span class="line">    Note left of Consumer: 我要等 mutex (需 P1 释放)</span><br></pre></td></tr></table></figure>
<h4 id="问题当前生产者消费者共用一个互斥锁会造成竞争">问题：当前生产者消费者共用一个互斥锁会造成竞争</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore pmutex, cmutex; // 两个独立的互斥锁</span><br><span class="line">...</span><br><span class="line">P(pmutex); // 生产者只锁自己的写入区域</span><br><span class="line">P(cmutex); // 消费者只锁自己的读取区域</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>生产者之间</strong>：仍然需要 <code>pmutex</code>
来互斥，因为多个生产者可能同时想写入 <code>in</code>
指针指向的位置。</li>
<li><strong>消费者之间</strong>：仍然需要 <code>cmutex</code>
来互斥，因为多个消费者可能同时想读取 <code>out</code>
指针指向的位置。</li>
<li><strong>生产者 vs 消费者</strong>：<strong>它们可以并行！</strong>
只要生产者在写一个位置，消费者在读另一个位置，两者互不干扰，完全可以同时进行。</li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="死锁产生">死锁产生</h3>
<h4 id="什么是死锁">什么是死锁</h4>
<p>在多进程/多线程系统中，<strong>死锁</strong>是指两个或多个进程因竞争资源而造成的一种互相等待的现象，若无外力作用，它们都将无法向前推进。</p>
<blockquote>
<p><strong>简单说：A 等 B，B 等 C，C 又等
A，大家谁也不让步，结果全都卡住。</strong></p>
</blockquote>
<h4 id="死锁的4个必要条件">死锁的4个必要条件</h4>
<p>只要系统发生死锁，以下4个条件<strong>必然同时成立</strong>。缺一不可！</p>
<p>1️⃣ 互斥访问 (Mutual Exclusion)</p>
<ul>
<li><strong>定义</strong>：系统中存在临界资源，进程应互斥地使用这些资源。</li>
<li><strong>通俗解释</strong>：资源一次只能被一个进程使用。比如，打印机、文件、数据库连接、内存中的某个变量等。</li>
<li><strong>为什么是必要条件</strong>？如果资源可以被多个进程同时共享（如只读文件），那就不存在竞争，也就不会死锁。</li>
</ul>
<p>2️⃣ 占有和等待 (Hold and Wait)</p>
<ul>
<li><strong>定义</strong>：进程在请求资源得不到满足而等待时，不释放已占有的资源。</li>
<li><strong>通俗解释</strong>：一个进程已经拿着一些资源，但它还需要其他资源才能完成工作，于是它一边等着新资源，一边还紧紧攥着自己手里的旧资源，不肯放手。</li>
<li><strong>为什么是必要条件</strong>？如果一个进程在等待新资源时能主动释放旧资源，那么它就不会阻塞别人，死锁也就不会形成。</li>
</ul>
<p>3️⃣ 不剥夺 (No Preemption)</p>
<ul>
<li><strong>定义</strong>：已被占用的资源只能由属主进程自愿释放，而不允许被其他进程剥夺。</li>
<li><strong>通俗解释</strong>：资源一旦被某个进程拿走，除非它自己愿意还回来，否则谁也不能强行抢走。这保证了进程的“自主性”，但也为死锁埋下了隐患。</li>
<li><strong>为什么是必要条件</strong>？如果系统能强行剥夺资源（比如操作系统强制回收），那么就可以打破死锁链。</li>
</ul>
<p>4️⃣ 循环等待 (Circular Wait)</p>
<ul>
<li><strong>定义</strong>：存在循环等待链，每个进程在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li>
<li><strong>通俗解释</strong>：这是一个闭环。A 等 B 的资源，B 等 C
的资源，C 又等 A 的资源，形成了一个“等待环”。</li>
<li><strong>为什么是必要条件</strong>？如果没有循环，等待链最终会指向一个“不等待”的进程，这个进程完成后会释放资源，从而解开整个等待链。</li>
</ul>
<h3 id="死锁防止">死锁防止</h3>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116173459401.png" alt="image-20251116173459401">
<figcaption aria-hidden="true">image-20251116173459401</figcaption>
</figure>
<h3 id="死锁避免">死锁避免</h3>
<h4 id="银行家算法">银行家算法</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116181426684.png" alt="image-20251116181426684">
<figcaption aria-hidden="true">image-20251116181426684</figcaption>
</figure>
<h3 id="死锁检测和解除">死锁检测和解除</h3>
<h4 id="资源分配图">资源分配图</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182605135.png" alt="image-20251116182605135">
<figcaption aria-hidden="true">image-20251116182605135</figcaption>
</figure>
<ul>
<li><strong>阻塞节点 (Blocked
Node)</strong>：一个进程，它<strong>正在请求一个或多个资源，但这些资源当前都被其他进程占用，且没有空闲实例可用</strong>。它必须等待。</li>
<li><strong>非阻塞节点 (Non-blocked
Node)</strong>：一个进程，它<strong>要么没有请求任何资源，要么它请求的资源当前有空闲实例可以立即满足</strong>。它可以继续执行。</li>
</ul>
<h4 id="如何通过资源分配图判断死锁">如何通过资源分配图判断死锁？</h4>
<p>✅ 死锁的充分条件（当资源类型只有一个实例时）</p>
<blockquote>
<p><strong>如果资源分配图中存在一个环，则系统一定发生死锁。</strong></p>
</blockquote>
<ul>
<li><strong>原因</strong>：在一个环中，每个进程都在等待下一个进程所持有的资源，而下一个进程又在等待再下一个……形成一个无限等待的闭环。</li>
</ul>
<p>⚠️ 当资源类型有多个实例时</p>
<blockquote>
<p><strong>环的存在是死锁的必要条件，但不是充分条件。</strong></p>
</blockquote>
<ul>
<li><strong>原因</strong>：即使图中有环，但如果环中的某个资源类型有多个实例，那么可能还有空闲实例可以满足某个进程的需求，从而打破死锁。</li>
</ul>
<h4 id="资源分配图的简化">资源分配图的简化</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182901353.png" alt="image-20251116182901353">
<figcaption aria-hidden="true">image-20251116182901353</figcaption>
</figure>
<h4 id="死锁检测算法">死锁检测算法</h4>
<p>与银行家算法的安全性检测类似</p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116184516361.png" alt="image-20251116184516361">
<figcaption aria-hidden="true">image-20251116184516361</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2025/">操作系统原理 (2025
春季学期)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XZAbeqEyt/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">01
- AI 时代的操作系统课2025
南京大学操作系统原理]_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">深度学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-24 16:16:42" itemprop="dateModified" datetime="2025-10-24T16:16:42+08:00">2025-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="交叉熵">交叉熵</h3>
<p>交叉熵（Cross-Entropy）主要用于衡量两个概率分布之间的差异。在分类任务中，它被广泛用作<strong>损失函数</strong>，来评估模型预测结果与真实标签之间的“不匹配程度”。</p>
<ol type="1">
<li><strong>信息量（Information Content）</strong></li>
</ol>
<p>一个事件 ( x ) 发生的概率为 ( p(x)
)，其<strong>信息量</strong>定义为： [ I(x) = -p(x) ] -
概率越小的事件，发生时带来的信息量越大（比如“太阳从西边升起”）。 -
单位通常是 <strong>比特（bit）</strong>（以 2 为底）或
<strong>纳特（nat）</strong>（以自然对数 ( e ) 为底）。</p>
<ol start="2" type="1">
<li><strong>熵（Entropy）</strong></li>
</ol>
<p>熵是<strong>一个概率分布的平均信息量</strong>，表示该分布的不确定性：
[ H(p) = -_{x} p(x) p(x) ] -
熵越大，不确定性越高（比如公平硬币的熵比偏硬币大）。</p>
<ol start="3" type="1">
<li><strong>交叉熵（Cross-Entropy）</strong></li>
</ol>
<p>现在有两个分布： - <strong>真实分布</strong> ( p(x) )（比如真实标签）
- <strong>模型预测分布</strong> ( q(x) )（比如神经网络输出的概率）</p>
<p>交叉熵衡量的是：<strong>当我们用分布 ( q ) 来编码来自分布 ( p )
的事件时，平均需要多少比特</strong>。</p>
<p>数学定义为： [ H(p, q) = -_{x} p(x) q(x) ]</p>
<blockquote>
<p>🔍 注意：交叉熵 ≠ 熵。<br>
- 熵：( H(p) = -p p )<br>
- 交叉熵：( H(p, q) = -p q )</p>
</blockquote>
<h4 id="sigmoid的交叉熵损失函数">Sigmoid的交叉熵损失函数</h4>
<p>Sigmoid 的交叉熵损失函数（通常称为
<strong>二元交叉熵损失</strong>，Binary Cross-Entropy
Loss）是用于二分类问题中，结合 Sigmoid 激活函数使用的损失函数。</p>
<ul>
<li><p>在二分类任务中，模型输出一个实数值 ( z )（logit）。</p></li>
<li><p>通过 Sigmoid 函数将其映射到概率区间 ([0, 1])： [ = (z) = ] 其中
() 表示预测为正类（标签为 1）的概率。</p></li>
<li><p>真实标签 ( y {0, 1} )。</p></li>
</ul>
<h5 id="二元交叉熵损失binary-cross-entropy-bce">二元交叉熵损失（Binary
Cross-Entropy, BCE）</h5>
<p>对于单个样本，损失函数定义为：</p>
<p>[ (y, ) = -]</p>
<p>其中： - 若 ( y = 1 )，损失为 ( -() ) - 若 ( y = 0 )，损失为 ( -(1 -
) )</p>
<h4 id="softmax-的交叉熵损失函数"><strong>Softmax
的交叉熵损失函数</strong></h4>
<p><strong>Softmax 函数</strong></p>
<p>给定 logits 向量 ( = [z_1, z_2, …, z_C] )（C 为类别数），Softmax
输出预测概率：</p>
<p>[ _i = (z_i) = ]</p>
<p><strong>交叉熵损失（单个样本）</strong></p>
<p>真实标签为 one-hot 向量 ( = [y_1, y_2, …, y_C]
)，其中只有真实类别位置为 1，其余为 0。</p>
<p>损失函数为：</p>
<p>[ = -_{i=1}^{C} y_i (_i) ]</p>
<p>由于 ( y_i ) 只有一个为 1（设真实类别为 ( c )），上式简化为：</p>
<p>[ = -(_c) = -( ) ]</p>
<p>进一步化简：</p>
<p>[ = -z_c + ( _{j=1}^{C} e^{z_j} ) ]</p>
<h4 id="sigmoid和softmax区别">Sigmoid和Softmax区别</h4>
<p><strong>1.Sigmoid（逐元素</strong>）</p>
<p>对输入 ( x )（标量或向量中的每个元素）： [ (x) = (0, 1) ]</p>
<blockquote>
<p>📌 如果输入是向量 ( = [x_1, x_2, …, x_n] )，则输出： [ [(x_1), (x_2),
…, (x_n)] ] <strong>每个元素独立计算，彼此无关</strong>。</p>
</blockquote>
<p><strong>2. Softmax（整体归一化）</strong></p>
<p>对输入向量 ( = [z_1, z_2, …, z_C] )： [ (z_i) = (0, 1) ]</p>
<blockquote>
<p>✅ 满足：( _{i=1}^{C} (z_i) = 1 )</p>
</blockquote>
<p><strong>应用场景对比</strong></p>
<p><strong>Sigmoid 适用场景：</strong></p>
<p><strong>多标签分类（Multi-label）</strong></p>
<ul>
<li>每个样本可属于多个类别（如一张图同时有“猫”和“狗”）</li>
<li>输出 C 个独立概率，每个用 Sigmoid 判断是否属于该类</li>
<li>例如：输出 <code>[0.9, 0.2, 0.8]</code> 表示属于类别 0 和 2</li>
</ul>
<p><strong>Softmax 适用场景：</strong></p>
<p><strong>多分类问题（Multi-class, 互斥）</strong></p>
<ul>
<li>每个样本<strong>只属于一个类别</strong>（如 MNIST 手写数字
0~9）</li>
<li>输出 C 个概率，<strong>和为 1</strong>，最大值对应预测类别</li>
<li>例如：输出 <code>[0.1, 0.7, 0.2]</code> 表示最可能是类别 1</li>
</ul>
<blockquote>
<p>简单来说</p>
<ul>
<li><strong>“多选一” → Softmax</strong></li>
<li><strong>“可多选” 或 “是/否” → Sigmoid</strong></li>
</ul>
</blockquote>
<h4 id="为什么多分类要用-softmax而不是对每个类别用-sigmoid-再取最大值"><strong>为什么多分类要用
Softmax，而不是对每个类别用 Sigmoid 再取最大值？</strong></h4>
<p>问题在于 <strong>损失函数</strong>：</p>
<p>如果你用 <strong>Binary Cross-Entropy (BCE)</strong>（Sigmoid
的配套损失）：</p>
<ul>
<li>损失 = <code>- [y₁·log(p₁) + y₂·log(p₂) + y₃·log(p₃)]</code></li>
<li>对于标签 <code>[0, 1, 0]</code>，损失只惩罚“狗”的预测（希望
p₂→1），但<strong>不惩罚“猫”和“鸟”是否太高</strong>！</li>
<li>结果：模型可能输出
<code>[0.9, 0.95, 0.8]</code>，虽然选对了“狗”，但对其他类也过于自信，泛化差。</li>
</ul>
<p>而 <strong>Softmax + Cross-Entropy</strong>：</p>
<ul>
<li>损失 = <code>-log(p₂)</code></li>
<li>但因为 <code>p₂ = e^&#123;z₂&#125;/(e^&#123;z₁&#125;+e^&#123;z₂&#125;+e^&#123;z₃&#125;)</code>，<strong>要让
p₂ 变大，必须让 z₂ 相对于 z₁、z₃ 更大</strong>。</li>
<li>所以模型会<strong>主动压制错误类别的
logit</strong>，学习更清晰的决策边界。</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://zh.d2l.ai/index.html">《动手学深度学习》 —
动手学深度学习 2.0.0 documentation</a></p>
<p><a target="_blank" rel="noopener" href="https://courses.d2l.ai/zh-v2/">课程安排 -
动手学深度学习课程</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-31 17:21:31" itemprop="dateModified" datetime="2025-10-31T17:21:31+08:00">2025-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="section"></h3>
<p>奇偶校验法</p>
<p>海明校验码（略有涉及）</p>
<p>原码补码乘除法</p>
<h3 id="布斯算法">布斯算法</h3>
<p>布斯算法是一种<strong>用于补码乘法</strong>的算法。 它的优点是：</p>
<ul>
<li><strong>直接处理补码</strong>（无需转成原码）</li>
<li><strong>减少加减次数</strong>（尤其当乘数中有连续1时）</li>
<li><strong>统一处理正负数</strong></li>
</ul>
<blockquote>
<p>💡 传统乘法：遇到1就加被乘数；遇到0就跳过。
布斯算法：看<strong>相邻两位的变化</strong>，决定是否加/减。</p>
</blockquote>
<p>布斯算法观察<strong>乘数的相邻两位</strong>（包括一个额外的最低位 Q₋₁
= 0），根据以下规则操作：</p>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 14%">
<col style="width: 17%">
<col style="width: 53%">
</colgroup>
<thead>
<tr>
<th>当前位 Q₀</th>
<th>前一位 Q₋₁</th>
<th>操作</th>
<th>原因（数学本质）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td><strong>无操作</strong></td>
<td>连续0，无需累加</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><strong>无操作</strong></td>
<td>连续1，已在前面处理过</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><strong>+ 被乘数</strong></td>
<td>从1→0，表示一个“正的块”结束 → 加一次</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td><strong>− 被乘数</strong></td>
<td>从0→1，表示一个“负的块”开始 → 减一次</td>
</tr>
</tbody>
</table>
<p><strong>布斯算法在右移时，必须使用「算术右移（Arithmetic Right
Shift）」，即：</strong></p>
<ul>
<li><strong>符号位（最高位）保持不变</strong></li>
<li><strong>左边补的是符号位的值（正数补0，负数补1）</strong></li>
</ul>
<h3 id="加减交替法">加减交替法</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DY4y177dV/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">原码除法
恢复余数法和不恢复余数法(加减交替法) 计组_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yToCYjEUK?spm_id_from=333.788.videopod.episodes&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11&amp;p=2">整数除法处理过程_哔哩哔哩_bilibili</a></p>
<p><strong>整数不恢复余数除法</strong>中，<strong>被除数通常要进行位扩展</strong></p>
<p>在<strong>不恢复余数除法（加减交替法）*<em>中，**整数除法**和*</em>小数除法</strong>的核心算法是一样的，都是根据余数的正负决定商位和下一步操作。但它们在<strong>初始设置、精度控制、终止条件、结果处理</strong>等方面有明显区别。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/417008434">定点整数的除法 -
知乎</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">计算机组成原理作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-31 17:20:09" itemprop="dateModified" datetime="2025-10-31T17:20:09+08:00">2025-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="第一章作业">第一章作业</h3>
<h4 id="section">1</h4>
<p>假设同一套指令集用不同的方法设计了两种机器 M1 和 M2。机器 M1
的时钟周期为 0.8ns，机器 M2 的时钟周期为 1.2ns。某个程序 P 在机器 M1
上运行时的 CPI 为 4，在 M2 上的 CPI 为 2。对于程序 P
来说，哪台机器的执行速度更快？快多少？</p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140015756.png" alt="image-20251011140015756">
<figcaption aria-hidden="true">image-20251011140015756</figcaption>
</figure>
<h4 id="section-1">2</h4>
<p>假定编译器对某段高级语言程序编译生成两种不同的指令序列 S1 和
S2，在时钟频率为 500MHz 的机器 M 上运行，目标指令序列中用到的指令类型有
A、B、C 和 D 四类。每类指令在 M 上的 CPI
和两个指令序列所用的各类指令条数如下表所示。</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>各指令的 CPI</strong></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>S1 的指令条数</strong></td>
<td>5</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td><strong>S2 的指令条数</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140100523.png" alt="image-20251011140100523">
<figcaption aria-hidden="true">image-20251011140100523</figcaption>
</figure>
<h4 id="section-2">3</h4>
<p>假定机器 M 在运行程序 P 的过程中，共执行了 500×10⁶
条浮点数指令、4000×10⁶ 条整数指令、3000×10⁶ 条访存指令、1000×10⁶
条分支指令，这 4 种指令的 CPI 分别是 2、1、4、1。若要使程序 P
的执行时间减少一半，浮点指令的 CPI 应如何改进？若要使程序 P
的执行时间减少一半，访存指令和分支指令的 CPI
应如何改进？若浮点指令和整数指令的 CPI 减少 20%，访存指令和分支指令的
CPI 减少 40%，则程序 P 的执行时间会减少多少？</p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140106600.png" alt="image-20251011140106600">
<figcaption aria-hidden="true">image-20251011140106600</figcaption>
</figure>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140123204.png" alt="image-20251011140123204">
<figcaption aria-hidden="true">image-20251011140123204</figcaption>
</figure>
<h3 id="第二章作业">第二章作业</h3>
<h4 id="section-3">1</h4>
<p>假定某计算机的总线采用奇校验，每8位数据有一位校验位，若在32位数据线上传输的信息是
<code>8F 3C AB 96H</code>，则对应的4个校验位应为什么？
若接收方收到的数据信息和校验位分别为<code>87 3C AB 96H</code> 和
<code>0101B</code>，则说明发生了什么情况，并给出验证过程。</p>
<p><strong>第一部分：计算原始数据 <code>8F 3C AB 96H</code> 对应的 4
个校验位</strong></p>
<p><strong>前提条件：</strong> -
使用<strong>奇校验</strong>：每个字节（8位）中，1的个数必须是<strong>奇数</strong>。
- 每8位数据配1位校验位，所以32位数据分成4个字节，对应4个校验位。 -
数据是十六进制：<code>8F 3C AB 96H</code></p>
<p>我们需要对每一个字节单独计算其奇校验位。</p>
<p><strong>第一步：把每个十六进制字节转换成二进制</strong></p>
<ul>
<li><code>8F H</code> = <code>1000 1111</code></li>
<li><code>3C H</code> = <code>0011 1100</code></li>
<li><code>AB H</code> = <code>1010 1011</code></li>
<li><code>96 H</code> = <code>1001 0110</code></li>
</ul>
<p><strong>第二步：数每个字节中“1”的个数，然后确定校验位</strong></p>
<blockquote>
<p><strong>奇校验规则：</strong>
如果当前字节中“1”的个数是<strong>偶数</strong>，则校验位设为
<code>1</code>，使总数变为奇数；如果是<strong>奇数</strong>，则校验位设为
<code>0</code>，保持奇数。</p>
</blockquote>
<p>我们逐个来看：</p>
<ol type="1">
<li><strong>字节 <code>8F</code> = <code>1000 1111</code></strong>
<ul>
<li>数“1”：位置0, 4,5,6,7 → 共 <strong>5个1</strong> →
是<strong>奇数</strong></li>
<li>所以校验位 = <code>0</code></li>
</ul></li>
<li><strong>字节 <code>3C</code> = <code>0011 1100</code></strong>
<ul>
<li>数“1”：位置2,3,4,5 → 共 <strong>4个1</strong> →
是<strong>偶数</strong></li>
<li>所以校验位 = <code>1</code></li>
</ul></li>
<li><strong>字节 <code>AB</code> = <code>1010 1011</code></strong>
<ul>
<li>数“1”：位置0,2,4,6,7 → 共 <strong>5个1</strong> →
是<strong>奇数</strong></li>
<li>所以校验位 = <code>0</code></li>
</ul></li>
<li><strong>字节 <code>96</code> = <code>1001 0110</code></strong>
<ul>
<li>数“1”：位置0,3,5,6 → 共 <strong>4个1</strong> →
是<strong>偶数</strong></li>
<li>所以校验位 = <code>1</code></li>
</ul></li>
</ol>
<hr>
<p>✅ <strong>所以，对应的4个校验位是：<code>0 1 0 1</code>，即
<code>0101B</code></strong></p>
<p><strong>第二部分：接收方收到的数据是 <code>87 3C AB 96H</code>
和校验位 <code>0101B</code>，发生了什么？验证过程</strong></p>
<p>现在接收方收到： - 数据：<code>87 3C AB 96H</code> -
校验位：<code>0101B</code></p>
<p>我们怀疑有错误，因为原始发送的是 <code>8F</code>，但收到的是
<code>87</code> —— 很可能第一个字节出错了！</p>
<p>我们来<strong>逐字节验证奇校验是否成立</strong>。</p>
<p><strong>第一步：将接收到的数据转为二进制</strong></p>
<ul>
<li><code>87 H</code> = <code>1000 0111</code></li>
<li><code>3C H</code> = <code>0011 1100</code> （没变）</li>
<li><code>AB H</code> = <code>1010 1011</code> （没变）</li>
<li><code>96 H</code> = <code>1001 0110</code> （没变）</li>
</ul>
<p>校验位：<code>0101B</code> → 对应四个字节的校验位分别是：第1字节
<code>0</code>，第2字节 <code>1</code>，第3字节 <code>0</code>，第4字节
<code>1</code></p>
<p><strong>第二步：验证每个字节 + 校验位 是否满足奇校验</strong></p>
<blockquote>
<p>注意：我们验证的是“数据位 + 校验位”一共9位中，1的个数是否为奇数。</p>
</blockquote>
<ol type="1">
<li><strong>第一字节 <code>87</code> + 校验位 <code>0</code></strong>
<ul>
<li>数据位：<code>1000 0111</code> → “1”的个数：位置0, 5,6,7 →
<strong>4个1</strong></li>
<li>加上校验位 <code>0</code> → 总共还是 <strong>4个1</strong> →
是<strong>偶数</strong> ❌</li>
<li>不满足奇校验！→ <strong>出错！</strong></li>
</ul></li>
<li><strong>第二字节 <code>3C</code> + 校验位 <code>1</code></strong>
<ul>
<li>数据位：<code>0011 1100</code> → “1”的个数：4个（偶数）</li>
<li>加上校验位 <code>1</code> → 总共 4+1=5 → <strong>奇数</strong>
✅</li>
<li>正确</li>
</ul></li>
<li><strong>第三字节 <code>AB</code> + 校验位 <code>0</code></strong>
<ul>
<li>数据位：<code>1010 1011</code> → “1”的个数：5个（奇数）</li>
<li>加上校验位 <code>0</code> → 总共 5 → <strong>奇数</strong> ✅</li>
<li>正确</li>
</ul></li>
<li><strong>第四字节 <code>96</code> + 校验位 <code>1</code></strong>
<ul>
<li>数据位：<code>1001 0110</code> → “1”的个数：4个（偶数）</li>
<li>加上校验位 <code>1</code> → 总共 5 → <strong>奇数</strong> ✅</li>
<li>正确</li>
</ul></li>
</ol>
<hr>
<p>✅
<strong>结论：只有第一个字节校验失败！说明在传输过程中，第一个字节发生了错误。</strong></p>
<p><strong>进一步分析：哪里出错了？</strong></p>
<p>原始发送的是 <code>8F H = 1000 1111</code></p>
<p>接收的是 <code>87 H = 1000 0111</code></p>
<p>对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始: 1 0 0 0  1 1 1 1</span><br><span class="line">接收: 1 0 0 0  0 1 1 1</span><br><span class="line">             ↑</span><br><span class="line">            第5位（从左数第5位，或从右数第4位）由1变成了0</span><br></pre></td></tr></table></figure>
<p>所以，<strong>第5位发生了翻转错误（bit flip）</strong>。</p>
<p>🧠 总结</p>
<ol type="1">
<li><strong>原始数据 <code>8F 3C AB 96H</code> 的校验位是
<code>0101B</code>。</strong></li>
<li><strong>接收方收到 <code>87 3C AB 96H</code> 和 <code>0101B</code>
后，发现第一个字节校验失败，说明该字节在传输中发生了错误（具体是第5位由1变0）。</strong></li>
<li>奇校验能<strong>检测单个比特错误</strong>，但不能纠正它，也不能检测偶数个比特错误。</li>
</ol>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/IMG_20251029_093747.jpg" alt="IMG_20251029_093747">
<figcaption aria-hidden="true">IMG_20251029_093747</figcaption>
</figure>
<h3 id="第三章作业">第三章作业</h3>
<p>已知 <code>x = 10</code>, <code>y = -6</code>，采用
<strong>6位机器数表示</strong>。请按如下要求计算并把结果还原成真值。</p>
<p>（1）求 <code>[x + y]补</code>，<code>[x - y]补</code>
（2）用原码一位乘法计算 <code>[x × y]原</code> （3）用布斯算法计算
<code>[x × y]补</code> （4）用加减交替法计算 <code>[x / y]原</code>
的商和余数</p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251029194504411.png" alt="image-20251029194504411">
<figcaption aria-hidden="true">image-20251029194504411</figcaption>
</figure>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251029185146990.png" alt="image-20251029185146990">
<figcaption aria-hidden="true">image-20251029185146990</figcaption>
</figure>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/IMG_20251031_171709.jpg" alt="IMG_20251031_171709">
<figcaption aria-hidden="true">IMG_20251031_171709</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/" class="post-title-link" itemprop="url">milvus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-20 19:28:13" itemprop="dateModified" datetime="2025-09-20T19:28:13+08:00">2025-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/" itemprop="url" rel="index"><span itemprop="name">python-web</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/milvus/" itemprop="url" rel="index"><span itemprop="name">milvus</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="为什么使用milvus">为什么使用milvus</h3>
<p>非结构化数据（如文本、图像和音频）格式各异，蕴含丰富的潜在语义，因此分析起来极具挑战性。为了处理这种复杂性，Embeddings
被用来将非结构化数据转换成能够捕捉其基本特征的数字向量。然后将这些向量存储在向量数据库中，从而实现快速、可扩展的搜索和分析。</p>
<p>Milvus
提供强大的数据建模功能，使您能够将非结构化或多模式数据组织成结构化的
Collections。它支持多种数据类型，适用于不同的属性模型，包括常见的数字和字符类型、各种向量类型、数组、集合和
JSON，为您节省了维护多个数据库系统的精力。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908091053654.png" alt="image-20250908091053654">
<figcaption aria-hidden="true">image-20250908091053654</figcaption>
</figure>
<h3 id="部署windows">部署（windows）</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/install_standalone-windows.md">在
Docker（Linux）中运行 Milvus | Milvus 文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Download the configuration file and rename it as docker-compose.yml</span><br><span class="line">C:\&gt;Invoke-WebRequest https://github.com/milvus-io/milvus/releases/download/v2.6.0/milvus-standalone-docker-compose.yml -OutFile docker-compose.yml</span><br><span class="line"></span><br><span class="line"># Start Milvus</span><br><span class="line">C:\&gt;docker compose up -d</span><br></pre></td></tr></table></figure>
<p>注意设置环境变量DOCKER_VOLUME_DIRECTORY来决定卷映射的路径</p>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 31%">
<col style="width: 14%">
<col style="width: 46%">
</colgroup>
<thead>
<tr>
<th>容器</th>
<th>镜像</th>
<th>在 Milvus 中的角色</th>
<th>一句话说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd</td>
<td>quay.io/coreos/etcd:v3.5.18</td>
<td>元数据与协调中心</td>
<td>负责“记帐”——存索引结构、集合信息、节点心跳等，相当于 Milvus
的“大脑备忘录”。</td>
</tr>
<tr>
<td>minio</td>
<td>minio/minio:RELEASE.2024-12-18T13-15-44Z</td>
<td>对象存储</td>
<td>负责“存文件”——把向量索引文件、大字段、日志快照等落地成对象，相当于
Milvus 的“硬盘”。</td>
</tr>
<tr>
<td>standalone</td>
<td>milvusdb/milvus:v2.6.0</td>
<td>计算节点（单机版）</td>
<td>负责“干活”——接受 SDK 请求、做向量检索、构建索引，相当于 Milvus
的“工人”。</td>
</tr>
</tbody>
</table>
<h3 id="安装">安装</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pymilvus</span><br></pre></td></tr></table></figure>
<h3 id="基本概念">基本概念</h3>
<h4 id="数据库">数据库</h4>
<p>在 Milvus
中，数据库是组织和管理数据的逻辑单元。为了提高数据安全性并实现多租户，你可以创建多个数据库，为不同的应用程序或租户从逻辑上隔离数据。例如，创建一个数据库用于存储用户
A 的数据，另一个数据库用于存储用户 B 的数据。</p>
<h4 id="collections">collections</h4>
<p>在 Milvus 上，您可以创建多个 Collections
来管理数据，并将数据作为实体插入到 Collections 中。Collections
和实体<strong>类似于关系数据库中的表和记录</strong>。</p>
<p>Collection
是一个二维表，具有固定的列和变化的行。每列代表一个字段，每行代表一个实体。</p>
<p>下图显示了一个有 8 列和 6 个实体的 Collection。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908094418551.png" alt="image-20250908094418551">
<figcaption aria-hidden="true">image-20250908094418551</figcaption>
</figure>
<h4 id="schema">schema</h4>
<p>Schema 定义了 Collections 的数据结构。在创建一个 Collection
之前，你需要设计出它的 Schema。</p>
<p>设计良好的 Schema
至关重要，因为它抽象了数据模型，并决定能否通过搜索实现业务目标。此外，由于插入
Collections 的每一行数据都必须遵循
Schema，因此有助于保持数据的一致性和长期质量。从技术角度看，定义明确的
Schema
会带来组织良好的列数据存储和更简洁的索引结构，从而提升搜索性能。</p>
<p>一个 Collection Schema
有一个主键、最多四个向量字段和几个标量字段。下图说明了如何将文章映射到模式字段列表。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908094645183.png" alt="image-20250908094645183">
<figcaption aria-hidden="true">image-20250908094645183</figcaption>
</figure>
<h3 id="与langchain集成">与langchain集成</h3>
<p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/vectorstores/milvus/#query-directly">Milvus
| 🦜️🔗 LangChain</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/integrate_with_langchain.md">使用
Milvus 和 LangChain 的检索增强生成（RAG） | Milvus 文档</a></p>
<p>本人实现的用于分块后存储入milvus的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">class MilvusStorage:</span><br><span class="line">    &quot;&quot;&quot;Milvus向量存储管理类</span><br><span class="line">    </span><br><span class="line">    负责将分块后的文档内容存储到Milvus向量数据库中，</span><br><span class="line">    支持向量检索和BM25全文检索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    def __init__(self, </span><br><span class="line">                 embedding_function: Embeddings,</span><br><span class="line">                 uri: Optional[str] = None, </span><br><span class="line">                 db_name: Optional[str] = None,</span><br><span class="line">                 token: Optional[str] = None,</span><br><span class="line">                 collection_name: Optional[str] = None):</span><br><span class="line">        &quot;&quot;&quot;初始化Milvus存储客户端</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            embedding_function: LangChain embedding模型实例（必需）</span><br><span class="line">            uri: Milvus服务地址，默认从环境变量MILVUS_URI获取</span><br><span class="line">            db_name: 数据库名称，默认从环境变量MILVUS_DB_NAME获取</span><br><span class="line">            token: 认证令牌，默认从环境变量MILVUS_TOKEN获取（可选）</span><br><span class="line">            collection_name: 集合名称，默认从环境变量MILVUS_COLLECTION_NAME获取</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 验证必需参数</span><br><span class="line">        if not embedding_function:</span><br><span class="line">            raise ValueError(&quot;embedding_function是必需参数，必须提供LangChain Embeddings实例&quot;)</span><br><span class="line">        </span><br><span class="line">        # 从环境变量读取配置，如果参数没有提供的话</span><br><span class="line">        self.uri = uri or os.getenv(&#x27;MILVUS_URI&#x27;, &#x27;http://localhost:19530&#x27;)</span><br><span class="line">        self.db_name = db_name or os.getenv(&#x27;MILVUS_DB_NAME&#x27;, &#x27;rag&#x27;)</span><br><span class="line">        self.token = token or os.getenv(&#x27;MILVUS_TOKEN&#x27;) or None</span><br><span class="line">        self.collection_name = collection_name or os.getenv(&#x27;MILVUS_COLLECTION_NAME&#x27;, &#x27;chunks&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 设置embedding函数</span><br><span class="line">        self.embedding_function = embedding_function</span><br><span class="line">        </span><br><span class="line">        # 初始化LangChain Milvus向量存储</span><br><span class="line">        self.vector_store = Milvus(</span><br><span class="line">            embedding_function=self.embedding_function,</span><br><span class="line">            connection_args=&#123;</span><br><span class="line">                &quot;uri&quot;: self.uri,</span><br><span class="line">                &quot;db_name&quot;: self.db_name,</span><br><span class="line">                &quot;token&quot;: self.token</span><br><span class="line">            &#125; if self.token else &#123;</span><br><span class="line">                &quot;uri&quot;: self.uri,</span><br><span class="line">                &quot;db_name&quot;: self.db_name</span><br><span class="line">            &#125;,</span><br><span class="line">            collection_name=self.collection_name,</span><br><span class="line">            index_params=&#123;&quot;index_type&quot;: &quot;HNSW&quot;, &quot;metric_type&quot;: &quot;COSINE&quot;, &quot;params&quot;: &#123;&quot;M&quot;: 16, &quot;efConstruction&quot;: 200&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    def store_chunks(self, chunk_result: ChunkResult) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;存储分块结果到Milvus</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_result: 分块结果对象</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 插入结果，包含插入状态和记录数</span><br><span class="line">            </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当向量存储未初始化时</span><br><span class="line">            Exception: Milvus操作异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not self.vector_store:</span><br><span class="line">            raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">        </span><br><span class="line">        if not chunk_result.chunks:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;, </span><br><span class="line">                &quot;inserted_count&quot;: 0,</span><br><span class="line">                &quot;message&quot;: &quot;无数据需要插入&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            # 转换为LangChain Document格式</span><br><span class="line">            documents = self._convert_chunks_to_langchain_docs(chunk_result)</span><br><span class="line">            </span><br><span class="line">            # 为每个文档生成UUID作为主键</span><br><span class="line">            from uuid import uuid4</span><br><span class="line">            uuids = [str(uuid4()) for _ in range(len(documents))]</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus添加文档，指定IDs</span><br><span class="line">            ids = self.vector_store.add_documents(documents=documents, ids=uuids)</span><br><span class="line">            </span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;inserted_count&quot;: len(documents),</span><br><span class="line">                &quot;document_ids&quot;: ids,</span><br><span class="line">                &quot;document_name&quot;: chunk_result.document_name,</span><br><span class="line">                &quot;strategy&quot;: chunk_result.strategy.value,</span><br><span class="line">                &quot;collection_name&quot;: self.collection_name</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            raise Exception(f&quot;Milvus插入失败: &#123;str(e)&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def _convert_chunks_to_langchain_docs(self, chunk_result: ChunkResult) -&gt; List[Document]:</span><br><span class="line">        &quot;&quot;&quot;为现有Documents添加存储所需的元数据</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_result: 分块结果，chunks已经是Document列表</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            List[Document]: 添加了元数据的Document列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        documents = []</span><br><span class="line">        </span><br><span class="line">        for idx, chunk in enumerate(chunk_result.chunks):</span><br><span class="line">            # 创建符合Milvus集合schema的元数据</span><br><span class="line">            # 注意：page_content会自动映射到text_content字段</span><br><span class="line">            updated_metadata = &#123;</span><br><span class="line">                **chunk.metadata,  # 保留原有元数据</span><br><span class="line">                &quot;document_name&quot;: chunk_result.document_name,</span><br><span class="line">                &quot;chunk_index&quot;: idx,</span><br><span class="line">                &quot;chunk_size&quot;: len(chunk.page_content)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            # 创建新Document以避免修改原始数据</span><br><span class="line">            # LangChain会自动将page_content映射到Milvus的text_content字段</span><br><span class="line">            # embedding字段会由embedding_function自动生成</span><br><span class="line">            doc = Document(</span><br><span class="line">                page_content=chunk.page_content,</span><br><span class="line">                metadata=updated_metadata</span><br><span class="line">            )</span><br><span class="line">            documents.append(doc)</span><br><span class="line">        </span><br><span class="line">        return documents</span><br><span class="line">    </span><br><span class="line">    def store_chunks_batch(self, chunk_results: List[ChunkResult]) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;批量存储多个分块结果到Milvus</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_results: 分块结果列表</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 批量插入结果</span><br><span class="line">            </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当向量存储未初始化时</span><br><span class="line">            Exception: Milvus操作异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not self.vector_store:</span><br><span class="line">            raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">        </span><br><span class="line">        if not chunk_results:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;没有分块结果需要存储&quot;,</span><br><span class="line">                &quot;total_chunks&quot;: 0,</span><br><span class="line">                &quot;document_count&quot;: 0</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            # 收集所有文档</span><br><span class="line">            all_documents = []</span><br><span class="line">            total_chunks = 0</span><br><span class="line">            </span><br><span class="line">            for chunk_result in chunk_results:</span><br><span class="line">                if chunk_result.chunks:</span><br><span class="line">                    documents = self._convert_chunks_to_langchain_docs(chunk_result)</span><br><span class="line">                    all_documents.extend(documents)</span><br><span class="line">                    total_chunks += len(documents)</span><br><span class="line">            </span><br><span class="line">            if not all_documents:</span><br><span class="line">                return &#123;</span><br><span class="line">                    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                    &quot;message&quot;: &quot;没有文档需要存储&quot;,</span><br><span class="line">                    &quot;total_chunks&quot;: 0,</span><br><span class="line">                    &quot;document_count&quot;: len(chunk_results)</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            # 为所有文档生成UUID作为主键</span><br><span class="line">            from uuid import uuid4</span><br><span class="line">            uuids = [str(uuid4()) for _ in range(len(all_documents))]</span><br><span class="line">            </span><br><span class="line">            # 批量添加所有文档，指定IDs</span><br><span class="line">            ids = self.vector_store.add_documents(documents=all_documents, ids=uuids)</span><br><span class="line">            </span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;message&quot;: f&quot;成功存储 &#123;len(chunk_results)&#125; 个文档的 &#123;total_chunks&#125; 个分块&quot;,</span><br><span class="line">                &quot;total_chunks&quot;: total_chunks,</span><br><span class="line">                &quot;document_count&quot;: len(chunk_results),</span><br><span class="line">                &quot;ids&quot;: ids,</span><br><span class="line">                &quot;collection_name&quot;: self.collection_name</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            raise Exception(f&quot;Milvus批量插入失败: &#123;str(e)&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def delete_document(self, </span><br><span class="line">                       document_name: str, </span><br><span class="line">                       collection_name: Optional[str] = None) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;删除指定文档的所有chunks</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            document_name: 文档名称</span><br><span class="line">            collection_name: collection名称</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 删除结果</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        target_collection = collection_name or self.collection_name</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not self.vector_store:</span><br><span class="line">                raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus删除功能</span><br><span class="line">            # 注意：LangChain Milvus可能不支持按元数据过滤删除，这里提供基本实现</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;,</span><br><span class="line">                &quot;document_name&quot;: document_name,</span><br><span class="line">                &quot;error&quot;: &quot;LangChain Milvus不支持按文档名删除，请使用其他方式&quot;,</span><br><span class="line">                &quot;collection_name&quot;: target_collection</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;, </span><br><span class="line">                &quot;document_name&quot;: document_name,</span><br><span class="line">                &quot;error&quot;: str(e)</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    def get_document_stats(self, </span><br><span class="line">                          document_name: Optional[str] = None,</span><br><span class="line">                          collection_name: Optional[str] = None) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;获取文档统计信息</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            document_name: 文档名称，None则统计所有文档</span><br><span class="line">            collection_name: collection名称</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 统计信息</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        target_collection = collection_name or self.collection_name</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not self.vector_store:</span><br><span class="line">                raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus获取基本信息</span><br><span class="line">            # 注意：LangChain Milvus没有直接的统计方法，这里提供基本信息</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;collection_name&quot;: target_collection,</span><br><span class="line">                &quot;vector_store_type&quot;: &quot;LangChain Milvus&quot;,</span><br><span class="line">                &quot;embedding_function&quot;: str(type(self.embedding_function).__name__),</span><br><span class="line">                &quot;connection_uri&quot;: self.uri,</span><br><span class="line">                &quot;database_name&quot;: self.db_name,</span><br><span class="line">                &quot;message&quot;: &quot;详细统计信息需要通过其他方式获取&quot;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        except Exception as e:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;,</span><br><span class="line">                &quot;error&quot;: str(e)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本ann搜索">基本ANN搜索</h3>
<p>近似近邻（ANN）搜索以记录向量嵌入排序顺序的索引文件为基础，根据接收到的搜索请求中携带的查询向量查找向量嵌入子集，将查询向量与子群中的向量进行比较，并返回最相似的结果。</p>
<p>ANN 和 k-Nearest Neighbors (kNN) 搜索是向量相似性搜索的常用方法。在
kNN
搜索中，必须将向量空间中的所有向量与搜索请求中携带的查询向量进行比较，然后找出最相似的向量，这既耗时又耗费资源。</p>
<p>与 kNN 搜索不同，ANN
搜索算法要求提供一个<strong>索引</strong>文件，记录向量 Embeddings
的排序顺序。当收到搜索请求时，可以使用索引文件作为参考，快速找到可能包含与查询向量最相似的向量嵌入的子组。然后，你可以使用指定的<strong>度量类型</strong>来测量查询向量与子组中的向量之间的相似度，根据与查询向量的相似度对组成员进行排序，并找出<strong>前
K 个</strong>组成员。</p>
<p>ANN
搜索依赖于预建索引，搜索吞吐量、内存使用量和搜索正确性可能会因选择的索引类型而不同。您需要在搜索性能和正确性之间取得平衡。</p>
<h3 id="混合检索">混合检索</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multi-vector-search.md">多向量混合搜索 |
Milvus 文档</a></p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092720695.png" alt="image-20250908092720695">
<figcaption aria-hidden="true">image-20250908092720695</figcaption>
</figure>
<p>让我们考虑一个真实世界的使用案例，其中每个产品都包含文字描述和图片。根据可用数据，我们可以进行三种类型的搜索：</p>
<ul>
<li><strong>语义文本搜索：</strong>这涉及使用密集向量查询产品的文本描述。可以使用<a target="_blank" rel="noopener" href="https://zilliz.com/learn/explore-colbert-token-level-embedding-and-ranking-model-for-similarity-search?_gl=1*d243m9*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#A-Quick-Recap-of-BERT">BERT</a>和<a target="_blank" rel="noopener" href="https://zilliz.com/learn/NLP-essentials-understanding-transformers-in-AI?_gl=1*d243m9*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">Transformers</a>等模型或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/guide-to-using-openai-text-embedding-models?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">OpenAI</a>
等服务生成文本嵌入。</li>
<li><strong>全文搜索</strong>：在这里，我们使用稀疏向量的关键词匹配来查询产品的文本描述。<a target="_blank" rel="noopener" href="https://zilliz.com/learn/mastering-bm25-a-deep-dive-into-the-algorithm-and-application-in-milvus?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">BM25</a>等算法或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings?_gl=1*1cde1oq*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#BGE-M3">BGE-M3</a>或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings?_gl=1*ov2die*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#SPLADE">SPLADE</a>等稀疏嵌入模型可用于此目的。</li>
<li><strong>多模态图像搜索：</strong>这种方法使用带有密集向量的文本查询对图像进行查询。可以使用<a target="_blank" rel="noopener" href="https://zilliz.com/learn/exploring-openai-clip-the-future-of-multimodal-ai-learning?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879&amp;_gl=1*90lcis*_gcl_au*MTI2OTI1Njc4OS4xNzU3MTYxMTEz*_ga*NTMyMTM0NTIwLjE3NTcxNjExMTM.*_ga_KKMVYG8YF2*czE3NTcyOTM4NzUkbzUkZzEkdDE3NTcyOTQ4MTMkajYwJGwwJGgw">CLIP</a>
等模型生成图像嵌入。</li>
</ul>
<p>混合检索的构建流程：</p>
<ol type="1">
<li><p>创建具有多个向量场的 Collections</p>
<ul>
<li>定义 Collections Schema</li>
<li>配置索引参数</li>
<li>创建 Collections</li>
</ul></li>
<li><p>插入数据‘</p></li>
<li><p>执行混合搜索</p>
<ul>
<li><p>创建多个 AnnSearchRequest 实例</p>
<p>混合搜索是通过在<code>hybrid_search()</code>
函数中创建多个<code>AnnSearchRequest</code>
来实现的，其中每个<code>AnnSearchRequest</code> 代表一个特定向量场的基本
ANN
搜索请求。因此，在进行混合搜索之前，有必要为每个向量场创建一个<code>AnnSearchRequest</code>
。</p></li>
<li><p>配置 Rerankers 策略</p></li>
</ul></li>
</ol>
<h3 id="rerankers-策略">Rerankers 策略</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/rrf-ranker.md">RRF 排序器 | Milvus
文档</a></p>
<p>要对 ANN
搜索结果集进行合并和重新排序，选择适当的重新排序策略至关重要。Milvus
提供两种重排策略：</p>
<ul>
<li><strong>加权排名</strong>：如果结果需要强调某个向量场，请使用该策略。WeightedRanker
可以为某些向量场赋予更大的权重，使其更加突出。</li>
<li><strong>RRFRanker（互易排名融合排名器）</strong>：在不需要特别强调的情况下选择此策略。RRFRanker
能有效平衡每个向量场的重要性。</li>
</ul>
<h4 id="加权排名">加权排名</h4>
<p>加权排名器通过为每个搜索路径分配不同的重要性权重，智能地组合来自多个搜索路径的结果并确定其优先级。与技艺高超的厨师平衡多种配料以制作完美菜肴的方式类似，加权排名器也会平衡不同的搜索结果，以提供最相关的综合结果。这种方法非常适合在多个向量场或模式中进行搜索，其中某些场对最终排名的贡献应比其他场更大。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092538807.png" alt="image-20250908092538807">
<figcaption aria-hidden="true">image-20250908092538807</figcaption>
</figure>
<h4 id="rrfranker">RRFRanker</h4>
<p>互惠排名融合（RRF）排名器是 Milvus
混合搜索的一种重新排名策略，它根据多个向量搜索路径的排名位置而不是原始相似度得分来平衡搜索结果。就像体育比赛考虑的是球员的排名而不是个人统计数据一样，RRF
Ranker
根据每个项目在不同搜索路径中的排名高低来组合搜索结果，从而创建一个公平、均衡的最终排名。</p>
<p>RRF Ranker
专门设计用于<strong>混合搜索场景</strong>，在这种场景中，您需要平衡来自多个向量搜索路径的结果，而无需分配明确的重要性权重。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092346065.png" alt="image-20250908092346065">
<figcaption aria-hidden="true">image-20250908092346065</figcaption>
</figure>
<h3 id="多租户">多租户</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multi_tenancy.md#Partition-key-based-multi-tenancy">实施多租户
| Milvus 文档</a></p>
<p>Milvus
支持四个级别的多租户：<strong>数据库</strong>、<strong>Collection</strong>、<strong>Partition</strong>
和<strong>Partition Key</strong>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%">
<col style="width: 28%">
<col style="width: 28%">
<col style="width: 14%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th>** 数据库级**</th>
<th><strong>Collections 级</strong></th>
<th><strong>分区级</strong></th>
<th><strong>分区 Key 级</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据隔离</strong></td>
<td>物理</td>
<td>物理</td>
<td>物理</td>
<td>物理 + 逻辑</td>
</tr>
<tr>
<td><strong>最大租户数</strong></td>
<td>默认为 64 个。您可以通过修改 Milvus.yaml
配置文件中的<code>maxDatabaseNum</code> 参数来增加租户数。</td>
<td>默认为 65,536。可以通过修改 Milvus.yaml
配置文件中的<code>maxCollectionNum</code> 参数来增加。</td>
<td>每个 Collection 最多 1,024 个。</td>
<td>百万</td>
</tr>
<tr>
<td><strong>数据 Schema 灵活性</strong></td>
<td>高</td>
<td>中</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><strong>RBAC 支持</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>搜索性能</strong></td>
<td>强</td>
<td>强</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td><strong>跨租户搜索支持</strong></td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>是</td>
</tr>
<tr>
<td><strong>支持有效处理冷热数据</strong></td>
<td>是</td>
<td>是</td>
<td>支持</td>
<td>否 目前不支持 Partition Key 级策略。</td>
</tr>
</tbody>
</table>
<h3 id="比较有意思的教程">比较有意思的教程</h3>
<p>多模态rag<a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multimodal_rag_with_milvus.md">用 Milvus
制作多模态 RAG | Milvus 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/text_image_search.md">使用 Milvus
进行文本到图像搜索 | Milvus 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/image_similarity_search.md">使用
Milvus 搜索图像 | Milvus 文档</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/05/%E5%AE%9E%E4%B9%A0/Tosea.ai/api%E8%B0%83%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/05/%E5%AE%9E%E4%B9%A0/Tosea.ai/api%E8%B0%83%E6%9F%A5/" class="post-title-link" itemprop="url">api调查</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-05T00:00:00+08:00">2025-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-06 22:53:32" itemprop="dateModified" datetime="2025-09-06T22:53:32+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/Tosea-ai/" itemprop="url" rel="index"><span itemprop="name">Tosea.ai</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="convertapi">convertapi</h3>
<p><a target="_blank" rel="noopener" href="https://www.convertapi.com/">ConvertAPI: Powerful File
Conversion API for Developers &amp; Businesses</a></p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 15%">
<col style="width: 16%">
<col style="width: 27%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr>
<th>档次</th>
<th>官方名称</th>
<th>月费 (CNY)</th>
<th>每月包含转换次数</th>
<th>单文件上限</th>
<th>并发任务数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Developer</td>
<td>¥249</td>
<td>1,000 次</td>
<td>200 MB</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Startup</td>
<td>¥677</td>
<td>5,000 次</td>
<td>300 MB</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>Growth</td>
<td>¥1,247</td>
<td>15,000 次</td>
<td>500 MB</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>Business</td>
<td>¥2,495</td>
<td>50,000 次</td>
<td>1 GB</td>
<td>无限制</td>
</tr>
</tbody>
</table>
<h3 id="cloudconvert">CloudConvert</h3>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 22%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>模式</th>
<th>价格</th>
<th>包含内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一次性购买积分</strong></td>
<td><strong>$9 美元</strong> 起</td>
<td>500 个转换积分</td>
</tr>
<tr>
<td><strong>月度订阅</strong></td>
<td><strong>$9 美元/月</strong></td>
<td>每月 1000 个转换积分，未用完可滚存</td>
</tr>
</tbody>
</table>
<p>每天免费 10 次转换</p>
<p>pdf转ppt，一次要花费4积分，平均下来一份需要0.47元，付费情况下可以做到
5个并发任务</p>
<p><a target="_blank" rel="noopener" href="https://cloudconvert.com/pricing">定价 |云转换</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudconvert.com/pdf-to-pptx">PDF to PowerPoint |
CloudConvert</a></p>
<h3 id="groupdocs.conversionaspose.pdf-cloud">GroupDocs.Conversion/Aspose.PDF
Cloud</h3>
<p>每个月1000次以内的api调用是30美金，平均下来是一份0.21元，但是如果超过1000次每个月，就要0.09美金一次转换</p>
<p>付费默认5并发</p>
<p>https://products.groupdocs.cloud/conversion/python/pdf-to-ppt/</p>
<p><a target="_blank" rel="noopener" href="https://dashboard.groupdocs.cloud/#/">Dashboard</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.aspose.cloud/#/">Dashboard</a></p>
<p><a target="_blank" rel="noopener" href="https://purchase.groupdocs.cloud/pricing/">Pricing Guide -
Purchase - groupdocs.cloud</a></p>
<h3 id="adobe-pdf">Adobe PDF</h3>
<p>每个月五百次的免费转换</p>
<p><a target="_blank" rel="noopener" href="https://developer.adobe.com/document-services/pricing/main/">Adobe
PDF Services API Pricing | PDF Embed API Pricing | Adobe Acrobat
Services Pricing - Adobe Developers</a></p>
<h3 id="度慧科技">度慧科技</h3>
<p>这个很便宜，我在腾讯云上看，300r可以买五千次，500r可以买5万次转换。阿里云，100r可以买3000次，有效期一个月</p>
<p>并发数为200</p>
<p><a target="_blank" rel="noopener" href="https://try.dhconvert.com/">度慧文档转换</a></p>
<p>[<a target="_blank" rel="noopener" href="https://market.cloud.tencent.com/products/24078?keyword=度慧">度慧]PDF转Word,PPT,Excel,TXT,OFD（OCR高级版）-腾讯云市场</a></p>
<p><a target="_blank" rel="noopener" href="https://market.aliyun.com/detail/cmapi00044824#sku=yuncode3882400007">【度慧文档转换】PDF转Word/PPT/Excel/TXT/OFD
- 支持扫描版OCR【最新版】_数据API_OCR_API-_云市场-阿里云</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
