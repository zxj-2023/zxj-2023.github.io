<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zxj Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang XiJun">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="zxj Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="zxj">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang XiJun</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">算法期末复习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-12T00:00:00+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-14 22:26:13" itemprop="dateModified" datetime="2025-06-14T22:26:13+08:00">2025-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="贪心问题"><a href="#贪心问题" class="headerlink" title="贪心问题"></a>贪心问题</h3><h4 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h4><p>用最少数量的钱币凑出目标金额 m 元。</p>
<p><strong>核心思想</strong> ：<br>每次选择<strong>不超过剩余金额的最大面值</strong> ，直到凑够目标金额。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>将钱币面值按从大到小排序。</li>
<li>对于当前剩余金额，不断减去最大可用面值，直到金额为 0。</li>
</ol>
<p><strong>贪心策略的适用性</strong></p>
<p><strong>仅当钱币面值满足以下条件时有效</strong> ：</p>
<ul>
<li>面值序列中每个元素都是前一个元素的因数（如 <code>1, 2, 5, 10</code>）。</li>
<li>否则，贪心可能失败（例如面值 <code>[1, 3, 4]</code>，目标 <code>6</code>：贪心选 <code>4+1+1</code> 需 3 枚，而最优解是 <code>3+3</code> 需 2 枚）。</li>
</ul>
<p><strong>代码问题分析</strong></p>
<p>用户提供的代码是一个基于贪心策略的找零钱实现，但在<strong>硬币面值不满足贪心条件</strong>时可能无法得到最优解。以下是具体分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findMinCoins</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    coins.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序排序</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">        <span class="keyword">while</span> amount &gt;= coins[i]:</span><br><span class="line">            res.append(coins[i])</span><br><span class="line">            amount -= coins[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line">amount = <span class="number">1136</span></span><br><span class="line">out = findMinCoins(coins, amount)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;钱币数量为<span class="subst">&#123;<span class="built_in">len</span>(out)&#125;</span>.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>问题点：</strong></p>
<ol>
<li><p><strong>贪心策略的局限性</strong><br>仅当硬币面值满足 <strong>每种面值是前一种面值的因数</strong>（如 <code>[1, 2, 5, 10, 50, 100]</code>）时，贪心算法才能保证最优解。若面值不满足此条件（如 <code>[1, 3, 4]</code>），则可能失败。</p>
</li>
<li><p><strong>未处理特殊情况</strong>  </p>
<ul>
<li>若 <code>amount</code> 无法被硬币组合凑出（如硬币为 <code>[2, 5]</code>，目标 <code>3</code>），代码会返回非最优解或死循环。</li>
</ul>
</li>
</ol>
<p><strong>改进方案</strong></p>
<p>适用于任意硬币面值，确保最优解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_coins_dp</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> a &gt;= coin <span class="keyword">and</span> dp[a - coin] + <span class="number">1</span> &lt; dp[a]:</span><br><span class="line">                dp[a] = dp[a - coin] + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line">amount = <span class="number">1136</span></span><br><span class="line"><span class="built_in">print</span>(min_coins_dp(coins, amount))  <span class="comment"># 输出 16</span></span><br></pre></td></tr></table></figure></p>
<h4 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h4><p>🧮 问题描述</p>
<p>给定一个集装箱重量列表 <code>weights</code> 和轮船的最大载重 <code>W</code>，目标是 <strong>尽可能多地装载集装箱</strong>（不考虑体积限制）。</p>
<p>✅ 算法思路</p>
<ol>
<li><strong>排序</strong>：将所有集装箱按重量从小到大排序。</li>
<li><strong>贪心装载</strong>：依次尝试装载每个集装箱，若当前总重量加上该集装箱的重量不超过 <code>W</code>，则装载；否则停止。</li>
<li><strong>返回结果</strong>：返回成功装载的集装箱数量。</li>
</ol>
<p>🧾 Python 实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_loaded_containers</span>(<span class="params">weights, W</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回在总载重 W 下，最多可以装载的集装箱数量。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    weights (list of int/float): 集装箱重量列表</span></span><br><span class="line"><span class="string">    W (int/float): 轮船的最大载重</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    int: 最多可以装载的集装箱数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 按重量从小到大排序</span></span><br><span class="line">    weights.sort()</span><br><span class="line">    </span><br><span class="line">    total_weight = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> weight <span class="keyword">in</span> weights:</span><br><span class="line">        <span class="keyword">if</span> total_weight + weight &lt;= W:</span><br><span class="line">            total_weight += weight</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    weights = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    W = <span class="number">10</span></span><br><span class="line">    result = max_loaded_containers(weights, W)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最多可以装载 <span class="subst">&#123;result&#125;</span> 个集装箱&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="活动选择问题（最大相容活动子集）"><a href="#活动选择问题（最大相容活动子集）" class="headerlink" title="活动选择问题（最大相容活动子集）"></a>活动选择问题（最大相容活动子集）</h4><p>📌 问题描述</p>
<p>给定 $ n $ 个活动的集合 $ C = {1, 2, …, n} $，每个活动 $ i $ 都有起始时间 $ s_i $ 和结束时间 $ f_i $（满足 $ s_i &lt; f_i $）。要求选择一个<strong>最大相容活动子集</strong>，使得被选中的活动之间<strong>时间互不重叠</strong>。</p>
<p>两个活动 $ i $ 和 $ j $ 相容的条件为：</p>
<script type="math/tex; mode=display">
s_i \geq f_j \quad \text{或} \quad s_j \geq f_i</script><p>✅ 贪心策略与正确性</p>
<p><strong>贪心策略</strong>：  </p>
<ol>
<li><strong>按活动结束时间 $ f_i $ 从小到大排序</strong>。</li>
<li><strong>依次选择结束最早的活动</strong>，并跳过与其冲突的所有活动。</li>
</ol>
<p><strong>正确性证明（归纳法）</strong>：</p>
<ul>
<li><strong>基础情况</strong>：当只有一项活动时，显然选择它是最优的。</li>
<li><strong>归纳假设</strong>：对于前 $ k $ 个活动，该策略能得到最大相容子集。</li>
<li><strong>归纳步骤</strong>：考虑第 $ k+1 $ 个活动。若选择结束最早的活动 $ A $，则剩下的可用时间区间为 $ [f_A, +\infty) $，此时在该区间内继续应用该策略，仍能得到最大子集。若不选 $ A $ 而选其他活动，则剩余时间更少，无法容纳更多活动。</li>
</ul>
<p>🧾 Python 实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_compatible_activities</span>(<span class="params">activities</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回最大相容活动子集的数量及具体活动列表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    activities (list of tuples): 每个元素为 (s_i, f_i)，表示活动的起始和结束时间</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    tuple: (最大活动数量, 相容活动列表)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 按结束时间从小到大排序</span></span><br><span class="line">    sorted_activities = <span class="built_in">sorted</span>(activities, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    selected = []</span><br><span class="line">    last_end = -<span class="number">1</span>  <span class="comment"># 上一个选中的活动的结束时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> activity <span class="keyword">in</span> sorted_activities:</span><br><span class="line">        s, f = activity</span><br><span class="line">        <span class="keyword">if</span> s &gt;= last_end:</span><br><span class="line">            selected.append(activity)</span><br><span class="line">            last_end = f</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(selected), selected</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    activities = [</span><br><span class="line">        (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">0</span>, <span class="number">6</span>), (<span class="number">5</span>, <span class="number">7</span>), </span><br><span class="line">        (<span class="number">3</span>, <span class="number">8</span>), (<span class="number">5</span>, <span class="number">9</span>), (<span class="number">6</span>, <span class="number">10</span>), (<span class="number">8</span>, <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    count, selected = max_compatible_activities(activities)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最大相容活动数: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所选活动:&quot;</span>, selected)</span><br></pre></td></tr></table></figure>
<h4 id="使用堆优化的-Dijkstra-算法（Python-实现）"><a href="#使用堆优化的-Dijkstra-算法（Python-实现）" class="headerlink" title="使用堆优化的 Dijkstra 算法（Python 实现）"></a>使用堆优化的 Dijkstra 算法（Python 实现）</h4><p>🧠 <strong>核心思想</strong></p>
<ul>
<li>使用<strong>最小堆</strong>（优先队列）高效选择当前距离最小的节点，避免暴力遍历。</li>
<li>每次从堆中取出当前最短路径的节点，进行<strong>松弛操作</strong>（Relaxation）。</li>
<li>若发现堆中存在过时的路径记录，则跳过（因为已找到更优路径）。</li>
</ul>
<p>📦 <strong>图的表示</strong></p>
<p>使用邻接表（字典嵌套列表）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [(<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>)],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">5</span>)],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: [(<span class="string">&#x27;A&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">1</span>)],</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: [(<span class="string">&#x27;B&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>🧾 <strong>Python 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra_with_heap</span>(<span class="params">graph, start</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用堆优化的 Dijkstra 算法求单源最短路径。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    graph (dict): 邻接表形式的图，格式为 &#123;节点: [(邻接节点, 权重), ...]&#125;</span></span><br><span class="line"><span class="string">    start (str/int): 起始节点</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    dict: 从起始节点到所有节点的最短路径长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化距离字典，所有节点初始距离为无穷大</span></span><br><span class="line">    distances = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distances[start] = <span class="number">0</span>  <span class="comment"># 起始节点到自身的距离为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 优先队列（最小堆），存储 (距离, 节点)</span></span><br><span class="line">    heap = [(<span class="number">0</span>, start)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        current_distance, current_node = heapq.heappop(heap)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果当前弹出的距离大于记录的距离，说明该节点已被处理过，跳过</span></span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distances[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历当前节点的所有邻接边</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_node]:</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果找到更短路径，更新距离并推入堆</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                heapq.heappush(heap, (distance, neighbor))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    graph = &#123;</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: [(<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>)],</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: [(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">5</span>)],</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: [(<span class="string">&#x27;A&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">1</span>)],</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: [(<span class="string">&#x27;B&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">    start_node = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    shortest_paths = dijkstra_with_heap(graph, start_node)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;从节点 <span class="subst">&#123;start_node&#125;</span> 出发的最短路径：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> node, dist <span class="keyword">in</span> shortest_paths.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;start_node&#125;</span> → <span class="subst">&#123;node&#125;</span> : <span class="subst">&#123;dist&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a><strong>哈夫曼编码</strong></h4><p><strong>2. 构建哈夫曼树的步骤</strong></p>
<p><strong>步骤 1：统计字符频率</strong></p>
<p>假设输入字符串为 <code>&quot;BCCABBDDAECCBAAAEC&quot;</code>，统计每个字符的出现次数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: 6, B: 4, C: 5, D: 2, E: 1</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 2：创建最小堆（优先队列）</strong></p>
<ul>
<li>将每个字符及其频率构建成节点，并按频率升序排列。</li>
<li>初始堆：<code>[E(1), D(2), B(4), C(5), A(6)]</code></li>
</ul>
<p><strong>步骤 3：合并节点，构建哈夫曼树</strong></p>
<ol>
<li>取出两个频率最小的节点 <code>E(1)</code> 和 <code>D(2)</code>，合并为新节点 <code>ED(3)</code>。</li>
<li>将新节点插入堆：<code>[B(4), C(5), ED(3), A(6)]</code> → 重新排序为 <code>[ED(3), B(4), C(5), A(6)]</code></li>
<li>重复上述步骤，直到堆中只剩一个根节点（哈夫曼树）。</li>
</ol>
<p>最终树结构示意图（频率越小越靠近叶子）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        (18)</span><br><span class="line">       /    \</span><br><span class="line">     (8)    A(6)</span><br><span class="line">    /   \</span><br><span class="line"> (4)   (4)</span><br><span class="line">B     C(5)</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 4：生成哈夫曼编码表</strong></p>
<p>从根节点出发，左子树标记为 <code>0</code>，右子树标记为 <code>1</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A: 11</span><br><span class="line">B: 00</span><br><span class="line">C: 01</span><br><span class="line">D: 100</span><br><span class="line">E: 101</span><br></pre></td></tr></table></figure></p>
<p><strong>4. Python 实现哈夫曼编码</strong></p>
<p>以下代码展示如何用 Python 构建哈夫曼树并生成编码表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, char, freq</span>):</span><br><span class="line">        <span class="variable language_">self</span>.char = char</span><br><span class="line">        <span class="variable language_">self</span>.freq = freq</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.freq &lt; other.freq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># 统计频率</span></span><br><span class="line">    frequency = Counter(text)</span><br><span class="line">    <span class="comment"># 创建最小堆</span></span><br><span class="line">    heap = [HuffmanNode(char, freq) <span class="keyword">for</span> char, freq <span class="keyword">in</span> frequency.items()]</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并节点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(heap) &gt; <span class="number">1</span>:</span><br><span class="line">        left = heapq.heappop(heap)</span><br><span class="line">        right = heapq.heappop(heap)</span><br><span class="line">        merged = HuffmanNode(<span class="literal">None</span>, left.freq + right.freq)</span><br><span class="line">        merged.left = left</span><br><span class="line">        merged.right = right</span><br><span class="line">        heapq.heappush(heap, merged)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> heapq.heappop(heap) <span class="keyword">if</span> heap <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_codes</span>(<span class="params">root</span>):</span><br><span class="line">    codes = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, current_code</span>):</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                codes[node.char] = current_code</span><br><span class="line">            dfs(node.left, current_code + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">            dfs(node.right, current_code + <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    dfs(root, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">text = <span class="string">&quot;BCCABBDDAECCBAAAEC&quot;</span></span><br><span class="line">root = build_huffman_tree(text)</span><br><span class="line">codes = build_huffman_codes(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈夫曼编码表:&quot;</span>, codes)</span><br></pre></td></tr></table></figure>
<p><strong>输出示例：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼编码表: &#123;&#x27;B&#x27;: &#x27;0&#x27;, &#x27;C&#x27;: &#x27;10&#x27;, &#x27;A&#x27;: &#x27;11&#x27;, &#x27;D&#x27;: &#x27;110&#x27;, &#x27;E&#x27;: &#x27;111&#x27;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><p>以下是 <strong>朴素 Prim 算法</strong> 的实现与详解，适用于稠密图（如邻接矩阵存储的图）：</p>
<p><strong>Prim 算法核心思想</strong></p>
<ol>
<li>从任意顶点开始（如 <code>start=0</code>）。</li>
<li>维护一个集合 <code>selected</code>，记录已加入生成树的顶点。</li>
<li>每次从未选顶点中选择到当前生成树的最小权重边的顶点。</li>
<li>重复步骤 3，直到所有顶点加入生成树。</li>
</ol>
<p>时间复杂度：<strong>O(V²)</strong>，其中 V 是顶点数。</p>
<p><strong>Python 实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prim</span>(<span class="params">graph, start=<span class="number">0</span></span>):</span><br><span class="line">    V = <span class="built_in">len</span>(graph)  <span class="comment"># 顶点数量</span></span><br><span class="line">    selected = [<span class="literal">False</span>] * V  <span class="comment"># 标记顶点是否已加入生成树</span></span><br><span class="line">    key = [sys.maxsize] * V  <span class="comment"># 记录各顶点到生成树的最小权重</span></span><br><span class="line">    parent = [-<span class="number">1</span>] * V         <span class="comment"># 记录最小生成树的父节点</span></span><br><span class="line"></span><br><span class="line">    key[start] = <span class="number">0</span>  <span class="comment"># 起始顶点的权值设为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">        <span class="comment"># 找到当前未选顶点中 key 最小的顶点 u</span></span><br><span class="line">        min_key = sys.maxsize</span><br><span class="line">        u = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> selected[v] <span class="keyword">and</span> key[v] &lt; min_key:</span><br><span class="line">                min_key = key[v]</span><br><span class="line">                u = v</span><br><span class="line">        <span class="keyword">if</span> u == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 无连通顶点，生成树结束</span></span><br><span class="line">        </span><br><span class="line">        selected[u] = <span class="literal">True</span>  <span class="comment"># 将 u 加入生成树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新 u 的所有邻接顶点的 key 值</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">            <span class="keyword">if</span> graph[u][v] &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> selected[v] <span class="keyword">and</span> graph[u][v] &lt; key[v]:</span><br><span class="line">                key[v] = graph[u][v]</span><br><span class="line">                parent[v] = u  <span class="comment"># 记录 v 的父节点为 u</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key, parent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：邻接矩阵表示的图</span></span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">key, parent = prim(graph)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最小生成树的总权重:&quot;</span>, <span class="built_in">sum</span>(key))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;父节点数组:&quot;</span>, parent)</span><br></pre></td></tr></table></figure>
<h4 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h4><p><strong>2. Kruskal 算法的核心思想</strong></p>
<ol>
<li><strong>按权重从小到大排序所有边</strong>。</li>
<li><strong>依次选择边</strong>：<ul>
<li>如果这条边的两个顶点不在同一个连通分量中（即不形成环），则将这条边加入生成树。</li>
<li>否则跳过这条边。</li>
</ul>
</li>
<li><strong>重复步骤2，直到生成树中有 <code>V-1</code> 条边</strong>（<code>V</code> 是顶点数）。</li>
</ol>
<p><strong>6. Python 实现示例</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.parent[x] != x:</span><br><span class="line">            <span class="variable language_">self</span>.parent[x] = <span class="variable language_">self</span>.find(<span class="variable language_">self</span>.parent[x])  <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.parent[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        rootX = <span class="variable language_">self</span>.find(x)</span><br><span class="line">        rootY = <span class="variable language_">self</span>.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX == rootY:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 已在同一个集合</span></span><br><span class="line">        <span class="variable language_">self</span>.parent[rootY] = rootX  <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kruskal</span>(<span class="params">n, edges</span>):</span><br><span class="line">    <span class="comment"># edges: [(权重, u, v), ...]</span></span><br><span class="line">    edges.sort()</span><br><span class="line">    uf = UnionFind(n)</span><br><span class="line">    mst = []</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> weight, u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> uf.union(u, v):</span><br><span class="line">            mst.append((u, v))</span><br><span class="line">            cost += weight</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(mst) == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 已选够 n-1 条边</span></span><br><span class="line">    <span class="keyword">return</span> mst, cost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">n = <span class="number">5</span>  <span class="comment"># 顶点数（0~4）</span></span><br><span class="line">edges = [</span><br><span class="line">    (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),  <span class="comment"># A(0)-B(1)</span></span><br><span class="line">    (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>),  <span class="comment"># B(1)-C(2)</span></span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>),  <span class="comment"># C(2)-D(3)</span></span><br><span class="line">    (<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>),  <span class="comment"># D(3)-E(4)</span></span><br><span class="line">    (<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>),  <span class="comment"># A(0)-E(4)</span></span><br><span class="line">    (<span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>)   <span class="comment"># B(1)-D(3)</span></span><br><span class="line">]</span><br><span class="line">mst, total = kruskal(n, edges)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MST 边：&quot;</span>, mst)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总权重：&quot;</span>, total)</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def unbounded_knapsack_2d(weights, values, capacity):</span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [[0] * (capacity + 1) for _ in range(n + 1)]</span><br><span class="line"></span><br><span class="line">    for i in range(1, n + 1):</span><br><span class="line">        for j in range(1, capacity + 1):</span><br><span class="line">            if weights[i-1] &lt;= j:</span><br><span class="line">                dp[i][j] = max(</span><br><span class="line">                    dp[i-1][j],</span><br><span class="line">                    dp[i][j - weights[i-1]] + values[i-1]</span><br><span class="line">                )</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = dp[i-1][j]</span><br><span class="line">    </span><br><span class="line">    return dp[n][capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">weights = [1, 2, 3]</span><br><span class="line">values = [15, 20, 50]</span><br><span class="line">capacity = 5</span><br><span class="line">print(unbounded_knapsack_2d(weights, values, capacity))  # 输出 80</span><br></pre></td></tr></table></figure>
<h4 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def optimal_bst(p, q, n):</span><br><span class="line">    # 初始化 dp 和 w 数组（大小为 (n+2) x (n+2)，避免越界）</span><br><span class="line">    dp = [[0] * (n+2) for _ in range(n+2)]</span><br><span class="line">    w = [[0] * (n+2) for _ in range(n+2)]</span><br><span class="line">    root = [[0] * (n+2) for _ in range(n+2)]</span><br><span class="line"></span><br><span class="line">    # 初始化虚拟键的权重</span><br><span class="line">    for i in range(n+1):</span><br><span class="line">        w[i][i] = q[i]</span><br><span class="line">    </span><br><span class="line">    # 填表顺序：链长从 1 到 n</span><br><span class="line">    for l in range(1, n+1):  # l 为关键字数量</span><br><span class="line">        for i in range(n - l + 1):</span><br><span class="line">            j = i + l</span><br><span class="line">            w[i][j] = w[i][j-1] + p[j] + q[j]</span><br><span class="line">            dp[i][j] = float(&#x27;inf&#x27;)</span><br><span class="line">            # 枚举根节点 r（i &lt; r ≤ j）</span><br><span class="line">            for r in range(i+1, j+1):</span><br><span class="line">                cost = dp[i][r-1] + dp[r][j]</span><br><span class="line">                if cost &lt; dp[i][j]:</span><br><span class="line">                    dp[i][j] = cost</span><br><span class="line">                    root[i][j] = r</span><br><span class="line">    </span><br><span class="line">    return dp[0][n], root</span><br><span class="line"></span><br><span class="line"># 示例输入</span><br><span class="line">p = [0, 0.15, 0.1, 0.05]  # 关键字概率（从 k₁ 开始）</span><br><span class="line">q = [0.05, 0.1, 0.05, 0.05]  # 虚拟键概率（从 d₀ 开始）</span><br><span class="line">n = 3  # 关键字数量</span><br><span class="line">min_cost, root = optimal_bst(p, q, n)</span><br><span class="line">print(&quot;最小期望搜索代价:&quot;, min_cost)</span><br></pre></td></tr></table></figure>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h4 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">https://leetcode.cn/problems/n-queens/</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n=4</span><br><span class="line">ans=[]</span><br><span class="line">path=[]</span><br><span class="line">onpath=[False]*n#记录哪一列有皇后</span><br><span class="line">diag1=[False]*(2*n-1)#记录主对角线是否有皇后</span><br><span class="line">diag2=[False]*(2*n-1)#记录副对角线是否有皇后</span><br><span class="line">def dfs(row,path:list):</span><br><span class="line">    if row==n:</span><br><span class="line">        #print(path)</span><br><span class="line">        chess=[]</span><br><span class="line">        # 生成棋盘</span><br><span class="line">        for i in range(n):</span><br><span class="line">            chess.append(&quot;.&quot;*path[i]+&quot;Q&quot;+&quot;.&quot;*(n-path[i]-1))</span><br><span class="line">        ans.append(chess)</span><br><span class="line">        return</span><br><span class="line">    for col in range(n):</span><br><span class="line">        if isvalid(row,col):</span><br><span class="line">            path.append(col)#放置皇后</span><br><span class="line">            onpath[col]=diag1[row+col]=diag2[row-col+n-1]=True</span><br><span class="line">            dfs(row+1,path)#递归下一行</span><br><span class="line">            path.pop()#回溯，取消放置</span><br><span class="line">            onpath[col]=diag1[row+col]=diag2[row-col+n-1]=False</span><br><span class="line">    </span><br><span class="line">def isvalid(row,col):</span><br><span class="line">    if onpath[col] or diag1[row+col] or diag2[row-col+n-1]:</span><br><span class="line">        return False</span><br><span class="line">    return True</span><br><span class="line">dfs(0,path)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/10/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/10/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/" class="post-title-link" itemprop="url">机器学习——期末复习（查漏补缺）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-10T00:00:00+08:00">2025-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-16 07:35:40" itemprop="dateModified" datetime="2025-06-16T07:35:40+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/" itemprop="url" rel="index"><span itemprop="name">大二下</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="高斯核（RBF核）中-σ²-的作用及其对模型的影响"><a href="#高斯核（RBF核）中-σ²-的作用及其对模型的影响" class="headerlink" title="高斯核（RBF核）中 σ² 的作用及其对模型的影响"></a>高斯核（RBF核）中 σ² 的作用及其对模型的影响</h3><p>高斯核（RBF核）的形式为：</p>
<script type="math/tex; mode=display">
K(x, x') = \exp\left(-\frac{\|x - x'\|^2}{2\sigma^2}\right)</script><p>其中 $ |x - x’| $ 是两个样本点之间的欧氏距离，$ \sigma^2 $ 是高斯核的方差参数，控制核函数的“宽度”或“局部性”。</p>
<p><strong>1. σ² 的几何意义：核函数的“影响范围”</strong></p>
<ul>
<li><p><strong>σ² 较小时</strong>：<br>分母较小，指数项中的 $ \frac{|x - x’|^2}{2\sigma^2} $ 会更大，导致指数函数值快速衰减。<br><strong>结果</strong>：只有当 $ x $ 和 $ x’ $ 非常接近时，核函数值才接近1；稍远一点的距离会导致核函数值迅速趋近于0。<br><strong>直观理解</strong>：模型只关注局部区域内的样本点，决策边界会围绕每个样本点“弯曲”，形成复杂的非线性形状。</p>
</li>
<li><p><strong>σ² 较大时</strong>：<br>分母较大，指数项中的 $ \frac{|x - x’|^2}{2\sigma^2} $ 会更小，指数函数值衰减缓慢。<br><strong>结果</strong>：即使 $ x $ 和 $ x’ $ 相距较远，核函数值仍可能较大。<br><strong>直观理解</strong>：模型会考虑更大范围的样本点，决策边界更平滑，接近线性分隔。</p>
</li>
</ul>
<p><strong>2. σ² 如何影响模型的复杂度</strong></p>
<ul>
<li><p><strong>σ² 小 → 局部敏感，高复杂度</strong>：  </p>
<ul>
<li>每个样本点的影响范围有限，模型需要“记住”每个局部区域的细节。  </li>
<li>决策边界会围绕每个样本点剧烈弯曲，甚至形成孤立的环形区域（如图1）。  </li>
<li>容易过拟合：模型过度适应训练数据的噪声和细节。</li>
</ul>
</li>
<li><p><strong>σ² 大 → 全局平滑，低复杂度</strong>：  </p>
<ul>
<li>样本点的影响范围扩大，模型倾向于用简单的全局模式区分数据。  </li>
<li>决策边界接近线性（如图2），可能无法捕捉数据中的非线性结构。  </li>
<li>容易欠拟合：模型无法拟合数据中的局部特征。</li>
</ul>
</li>
</ul>
<p><strong>3. 数学与直观示例</strong></p>
<p>假设两个样本点 $ x_1 $ 和 $ x_2 $ 距离为 $ d $，核函数值 $ K(x_1, x_2) $ 随 $ \sigma^2 $ 的变化如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$ \sigma^2 $</th>
<th>$ d = 1 $</th>
<th>$ d = 2 $</th>
<th>$ d = 3 $</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ \sigma^2 = 0.1 $</td>
<td>$ \exp(-5) \approx 0.0067 $</td>
<td>$ \exp(-20) \approx 2.06 \times 10^{-9} $</td>
<td>$ \exp(-45) \approx 2.87 \times 10^{-20} $</td>
</tr>
<tr>
<td>$ \sigma^2 = 1 $</td>
<td>$ \exp(-0.5) \approx 0.6065 $</td>
<td>$ \exp(-2) \approx 0.1353 $</td>
<td>$ \exp(-4.5) \approx 0.0111 $</td>
</tr>
<tr>
<td>$ \sigma^2 = 10 $</td>
<td>$ \exp(-0.05) \approx 0.9512 $</td>
<td>$ \exp(-0.2) \approx 0.8187 $</td>
<td>$ \exp(-0.45) \approx 0.6376 $</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>σ² 小（如 0.1）</strong>：距离稍大的样本点之间几乎无关联，模型仅依赖极邻近的点做决策。  </li>
<li><strong>σ² 大（如 10）</strong>：即使距离较远的样本点仍有显著关联，模型决策边界更平滑。</li>
</ul>
<h3 id="为什么使用高斯核之前要归一化"><a href="#为什么使用高斯核之前要归一化" class="headerlink" title="为什么使用高斯核之前要归一化"></a>为什么使用高斯核之前要归一化</h3><p>在使用高斯核（RBF核）之前对数据进行归一化，是机器学习中至关重要的预处理步骤。其核心原因是<strong>高斯核对特征的尺度（scale）极度敏感</strong>，而归一化能消除特征间尺度差异带来的负面影响。以下是详细解释：</p>
<ol>
<li><strong>高斯核的本质依赖距离计算</strong></li>
</ol>
<p>高斯核的公式为：</p>
<script type="math/tex; mode=display">
K(x, x') = \exp\left(-\frac{\|x - x'\|^2}{2\sigma^2}\right)</script><p>其中 $|x - x’|$ 是两个样本点之间的欧氏距离。<br><strong>问题</strong>：欧氏距离的计算受特征尺度影响极大。例如：</p>
<ul>
<li>假设特征A的取值范围是 [0,1]，特征B的取值范围是 [0,1000]。</li>
<li>此时特征B的差异会主导距离计算（如 $ (0.5)^2 + (500)^2 \approx 250000 $），特征A的贡献几乎被忽略。</li>
</ul>
<p><strong>结果</strong>：模型决策边界会过度依赖尺度大的特征，导致性能下降。</p>
<ol>
<li><strong>归一化消除特征尺度差异</strong></li>
</ol>
<p>归一化（如标准化或最小-最大缩放）将所有特征调整到相似的数值范围（如 [0,1] 或均值为0、方差为1）。<br><strong>效果</strong>：</p>
<ul>
<li><strong>公平比较特征</strong>：每个特征对距离的贡献权重均衡。</li>
<li><strong>防止“大尺度特征主导”</strong>：避免模型因某些特征数值过大而忽略其他重要特征。</li>
</ul>
<p><strong>示例</strong>：<br>假设两个样本：  </p>
<ul>
<li>未归一化：$ x_1 = [1, 100], x_2 = [2, 200] $，距离为 $ \sqrt{(1)^2 + (100)^2} \approx 100.005 $。  </li>
<li>归一化后（假设缩放到 [0,1]）：$ x_1 = [0.1, 0.1], x_2 = [0.2, 0.2] $，距离为 $ \sqrt{(0.1)^2 + (0.1)^2} \approx 0.141 $。<br>此时两个特征的贡献比例从 1:100 变为 1:1。</li>
</ul>
<ol>
<li><strong>高斯核参数 σ² 的有效性依赖归一化</strong></li>
</ol>
<p>高斯核的参数 σ²（或 γ = 1/σ²）决定了核函数的“局部性”（即模型关注局部还是全局模式）。  </p>
<ul>
<li><strong>未归一化时</strong>：σ² 的选择必须同时适应不同尺度的特征，导致参数调优困难。<ul>
<li>例如：若某特征尺度极大，需要极小的 σ² 才能捕捉其局部变化，但这可能使其他小尺度特征的核函数失效。</li>
</ul>
</li>
<li><strong>归一化后</strong>：所有特征尺度一致，σ² 的调参只需关注数据整体分布，而非单个特征的尺度。</li>
</ul>
<h3 id="SVM的Hinge损失函数"><a href="#SVM的Hinge损失函数" class="headerlink" title="SVM的Hinge损失函数"></a>SVM的Hinge损失函数</h3><p>Hinge损失函数是支持向量机（SVM）中用于分类任务的核心损失函数，其核心思想是<strong>最大化分类间隔</strong>，同时惩罚分类错误或置信度不足的样本。以下是详细解析：</p>
<p><strong>1. 数学定义</strong></p>
<p>对于二分类问题，假设真实标签 $ y \in {+1, -1} $，模型输出 $ f(x) = w^T x + b $，则 <strong>Hinge损失</strong> 的定义为：</p>
<script type="math/tex; mode=display">
\mathcal{L}(y, f(x)) = \max(0, 1 - y \cdot f(x))</script><ul>
<li><strong>关键含义</strong>：<ul>
<li>当 $ y \cdot f(x) \geq 1 $：样本被正确分类且置信度足够（位于间隔边界外），损失为0。</li>
<li>当 $ y \cdot f(x) &lt; 1 $：样本位于间隔内或被错误分类，损失随 $ y \cdot f(x) $ 线性增长。</li>
</ul>
</li>
</ul>
<p><strong>2. 几何意义：最大化间隔</strong></p>
<p>Hinge损失的设计与SVM的<strong>硬间隔（Hard Margin）</strong>和<strong>软间隔（Soft Margin）</strong>目标直接相关：</p>
<ul>
<li><strong>硬间隔</strong>：要求所有样本严格满足 $ y_i (w^T x_i + b) \geq 1 $，即完全线性可分。</li>
<li><strong>软间隔</strong>：允许部分样本违反间隔约束，通过Hinge损失将约束转化为优化目标：<script type="math/tex; mode=display">
\min_{w,b} \left( \frac{1}{2} \|w\|^2 + C \sum_{i=1}^n \max(0, 1 - y_i (w^T x_i + b)) \right)</script><ul>
<li><strong>第一项</strong> $ \frac{1}{2} |w|^2 $：最大化间隔（间隔宽度与 $ |w| $ 成反比）。</li>
<li><strong>第二项</strong> Hinge损失：惩罚违反间隔约束的样本，$ C $ 控制惩罚强度。</li>
</ul>
</li>
</ul>
<h3 id="为什么树的数量增加不会导致过拟合？"><a href="#为什么树的数量增加不会导致过拟合？" class="headerlink" title="为什么树的数量增加不会导致过拟合？"></a>为什么树的数量增加不会导致过拟合？</h3><p><strong>核心原因</strong>：随机森林通过<strong>集成学习</strong>和<strong>多样性机制</strong>抑制了单棵决策树的过拟合风险。具体来说：</p>
<ol>
<li><p><strong>Bagging（自助聚合）机制</strong>：<br>每棵树的训练数据是通过有放回采样（Bootstrap）得到的子集，这意味着每棵树看到的数据略有不同，减少了对训练数据的“记忆”依赖。</p>
</li>
<li><p><strong>特征随机选择</strong>：<br>每次分裂节点时，仅从随机选择的特征子集中挑选最优特征，进一步降低了各树之间的相关性。</p>
</li>
<li><p><strong>投票/平均机制</strong>：<br>多棵树的预测结果通过投票（分类）或平均（回归）结合，高方差的个体树被平滑，整体模型的泛化能力增强。</p>
</li>
<li><p><strong>收敛性保证</strong>：<br>随着树的数量增加，模型性能逐渐收敛到一个稳定值。即使继续增加树的数量，也不会显著提升训练集性能，更不会过拟合。</p>
</li>
</ol>
<h3 id="欧式距离的特性分析"><a href="#欧式距离的特性分析" class="headerlink" title="欧式距离的特性分析"></a>欧式距离的特性分析</h3><p><strong>欧式距离</strong>（Euclidean Distance）是衡量欧几里得空间中两点之间直线距离的常用方法，其公式为：</p>
<script type="math/tex; mode=display">
d(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2}</script><p>以下是对其特性的详细分析：</p>
<p><strong>A. 旋转不变性</strong>  </p>
<p><strong>正确</strong>  </p>
<ul>
<li><strong>定义</strong>：若坐标系旋转，两点间的欧式距离保持不变。  </li>
<li><strong>原因</strong>：旋转是刚性变换（rigid transformation），仅改变点的坐标表示，但不改变几何距离。  </li>
<li><strong>示例</strong>：在二维平面中，将坐标系旋转θ角度，两点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 的旋转后坐标分别为：<script type="math/tex; mode=display">
(x_1', y_1') = (x_1\cos\theta - y_1\sin\theta, x_1\sin\theta + y_1\cos\theta)</script><script type="math/tex; mode=display">
(x_2', y_2') = (x_2\cos\theta - y_2\sin\theta, x_2\sin\theta + y_2\cos\theta)</script>计算旋转后的距离仍等于原始距离。</li>
</ul>
<p><strong>B. 尺度缩放不变性</strong>  </p>
<p><strong>错误</strong>  </p>
<ul>
<li><strong>定义</strong>：若对坐标轴进行非均匀或均匀缩放，欧式距离会发生变化。  </li>
<li><strong>反例</strong>：假设对某维特征缩放 $k$ 倍（如将 $x_i$ 变为 $k x_i$），则距离变为原来的 $k$ 倍。  </li>
<li><strong>结论</strong>：欧式距离<strong>依赖于特征的绝对尺度</strong>，不具备缩放不变性。</li>
</ul>
<p><strong>C. 不受量纲影响的特性</strong>  </p>
<p><strong>错误</strong>  </p>
<ul>
<li><strong>定义</strong>：若不同特征的量纲不同（如身高[m]与体重[kg]），欧式距离的计算会因量纲差异而失真。  </li>
<li><strong>反例</strong>：  <ul>
<li>点A：(1.8m, 70kg)，点B：(1.7m, 65kg)  </li>
<li>若不标准化，身高差（0.1m）与体重差（5kg）的贡献会被直接相加，但两者量纲不同，结果无实际意义。  </li>
</ul>
</li>
<li><strong>解决方法</strong>：需通过标准化（如Z-score归一化）消除量纲影响。</li>
</ul>
<h3 id="下列哪个不属于特征提取"><a href="#下列哪个不属于特征提取" class="headerlink" title="下列哪个不属于特征提取"></a>下列哪个不属于特征提取</h3><p><strong>答案：D. 主成分分析</strong></p>
<p><strong>解析：</strong></p>
<p>在文本分类的特征选择中，常用的方法包括：</p>
<ul>
<li><strong>A. 卡方检验值</strong>：通过统计检验评估特征与类别的相关性，属于过滤式特征选择方法。</li>
<li><strong>B. 互信息</strong>：基于信息论，衡量特征与类别的依赖关系，属于无监督或半监督的特征选择方法。</li>
<li><strong>C. 信息增益</strong>：基于熵的指标，评估特征对分类的贡献，常用于决策树等算法中的特征选择。</li>
</ul>
<p>而 <strong>D. 主成分分析（PCA）</strong> 是一种 <strong>降维技术</strong>，通过线性变换将高维数据映射到低维空间，其核心目标是保留数据的主要方差，而非直接选择原始特征。它属于 <strong>特征提取</strong>（Feature Extraction）而非传统意义上的 <strong>特征选择</strong>（Feature Selection）。因此，主成分分析不属于常用的文本分类特征选择算法。</p>
<h3 id="ridge回归和lasso回归"><a href="#ridge回归和lasso回归" class="headerlink" title="ridge回归和lasso回归"></a>ridge回归和lasso回归</h3><p>Ridge回归（岭回归）和Lasso回归（套索回归）是两种常用的<strong>正则化线性回归方法</strong>，主要用于解决线性回归中的<strong>过拟合问题</strong>和<strong>特征选择问题</strong>。它们的核心思想是在损失函数中添加正则化项（惩罚项），从而限制模型参数的大小，提升模型的泛化能力。</p>
<p><strong>1. Ridge回归（岭回归）</strong></p>
<p><strong>目标函数</strong></p>
<script type="math/tex; mode=display">
\min_{\mathbf{w}} \left\{ \sum_{i=1}^n (y_i - \mathbf{w}^T \mathbf{x}_i)^2 + \lambda \|\mathbf{w}\|_2^2 \right\}</script><ul>
<li>第一项是普通线性回归的均方误差（MSE）。</li>
<li>第二项是L2正则化项（权重平方的和），$\lambda \geq 0$ 是正则化系数，控制惩罚强度。</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><strong>L2正则化</strong>：通过缩小权重系数（但不会完全置零）来减少模型复杂度。</li>
<li><strong>解决多重共线性</strong>：当特征之间存在高度相关性时，Ridge回归能稳定回归系数。</li>
<li><strong>唯一解</strong>：目标函数是凸函数，且严格凸，因此有唯一最优解。</li>
<li><strong>计算效率高</strong>：可以通过解析解（闭式解）求解：<script type="math/tex; mode=display">
\mathbf{w}_{\text{Ridge}} = (\mathbf{X}^T \mathbf{X} + \lambda \mathbf{I})^{-1} \mathbf{X}^T \mathbf{y}</script></li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>特征维度较低，但存在多重共线性。</li>
<li>需要保留所有特征，但希望抑制其影响（如基因数据分析）。</li>
</ul>
<p><strong>2. Lasso回归（套索回归）</strong></p>
<p><strong>目标函数</strong></p>
<script type="math/tex; mode=display">
\min_{\mathbf{w}} \left\{ \sum_{i=1}^n (y_i - \mathbf{w}^T \mathbf{x}_i)^2 + \lambda \|\mathbf{w}\|_1 \right\}</script><ul>
<li>第一项是均方误差。</li>
<li>第二项是L1正则化项（权重绝对值的和），$\lambda \geq 0$ 是正则化系数。</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><strong>L1正则化</strong>：强制部分权重系数为零，实现特征选择。</li>
<li><strong>稀疏模型</strong>：适用于高维数据（如文本分类、基因数据），自动筛选关键特征。</li>
<li><strong>非唯一解</strong>：目标函数是凸函数，但可能有多个解（当特征高度相关时）。</li>
<li><strong>计算复杂度较高</strong>：通常需要迭代优化算法（如坐标下降法、近端梯度下降）。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>特征维度极高（如万维以上），需降维。</li>
<li>需要可解释性强的模型（如金融风控中的关键特征筛选）。</li>
</ul>
<p><strong>3. 总结</strong></p>
<ul>
<li><strong>Ridge回归</strong>：适合特征较少且需要稳定系数的场景。</li>
<li><strong>Lasso回归</strong>：适合高维数据和特征选择场景。</li>
<li><strong>实际选择</strong>：<ul>
<li>如果特征数量远大于样本数量（$p \gg n$），优先使用Lasso。</li>
<li>如果特征间存在强相关性，优先使用Ridge或弹性网络。</li>
</ul>
</li>
</ul>
<p>通过调整正则化系数 $\lambda$，可以控制模型的复杂度与泛化能力。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">概率论期末笔记汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-09 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-09T00:00:00+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-02 22:47:47" itemprop="dateModified" datetime="2025-08-02T22:47:47+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/" itemprop="url" rel="index"><span itemprop="name">大二下</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">概率论</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175733.jpg" alt="IMG_20250627_175733"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175736.jpg" alt="IMG_20250627_175736"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175740.jpg" alt="IMG_20250627_175740"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175743.jpg" alt="IMG_20250627_175743"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175748.jpg" alt="IMG_20250627_175748"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175752.jpg" alt="IMG_20250627_175752"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175755.jpg" alt="IMG_20250627_175755"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0/IMG_20250627_175759.jpg" alt="IMG_20250627_175759"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">计算机系统基础——期末复习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-09 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-09T00:00:00+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-30 11:46:47" itemprop="dateModified" datetime="2025-06-30T11:46:47+08:00">2025-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/" itemprop="url" rel="index"><span itemprop="name">大二下</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机系统基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p><strong>时钟频率（f）</strong> ：单位时间内完成的时钟周期数，单位为赫兹（Hz）。<br>例如：800MHz 表示每秒完成 800×106 个周期。</p>
<p><strong>时钟周期（T）</strong> ：完成一个时钟周期所需的时间，单位为秒（s）。<br>例如：800MHz 的时钟周期为 <em>T</em>=800×1061​s=1.25ns （纳秒）。</p>
<p><strong>CPI</strong>（<strong>Cycles Per Instruction</strong>，每条指令所需的时钟周期数）是衡量计算机体系结构性能的关键指标之一，用于描述<strong>CPU执行一条指令平均需要多少个时钟周期</strong>。它直接影响程序的执行速度和系统性能。</p>
<ul>
<li><strong>CPI</strong> 表示每条指令执行所需的平均时钟周期数，计算公式为：<script type="math/tex; mode=display">
\text{CPI} = \frac{\text{总时钟周期数}}{\text{总指令数}}</script></li>
<li><strong>执行时间</strong> 与 CPI 的关系：<script type="math/tex; mode=display">
\text{执行时间} = \text{指令数} \times \text{CPI} \times \text{时钟周期时间}</script>其中，时钟周期时间 = 1 / 时钟频率。</li>
</ul>
<p><strong>MIPS（Million Instructions Per Second）</strong> 是衡量计算机处理器性能的一个经典指标，表示 <strong>每秒执行的百万条指令数</strong>，用于量化 CPU 的指令处理能力。其核心思想是：<strong>数值越大，性能越强</strong>，但需注意其局限性。</p>
<ul>
<li><strong>MIPS</strong> = 指令数 / (执行时间 × 10⁶)  </li>
<li>或通过 <strong>时钟频率</strong> 和 <strong>CPI（Cycles Per Instruction）</strong> 计算：  <script type="math/tex; mode=display">
\text{MIPS} = \frac{\text{时钟频率（Hz）}}{\text{CPI} \times 10^6}</script></li>
</ul>
<p><strong>举例</strong>：  </p>
<ul>
<li>若 CPU 主频为 <strong>2 GHz</strong>（2×10⁹ Hz），平均 CPI=4，则：  <script type="math/tex; mode=display">
\text{MIPS} = \frac{2 \times 10^9}{4 \times 10^6} = 500 \text{ MIPS}</script></li>
</ul>
<p>数量级：</p>
<p>G，吉，十的九次方</p>
<p>n，纳，十的负九次方</p>
<p><strong>m（milli，毫）的数量级是 10−3 （千分之一）</strong> 。</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p><strong>1. 补码的定义</strong></p>
<p>补码（Two’s Complement）是计算机中表示有符号整数的标准方法，其核心作用是将减法运算转化为加法运算，从而简化硬件设计。</p>
<p><strong>2. 如何求一个数的补码？</strong></p>
<p>以 <strong>8位二进制</strong> 为例：</p>
<ul>
<li><p><strong>正数</strong>：补码 = 原码（符号位为0，其余位直接表示数值）。<br>例如：<code>+5</code> 的补码是 <code>00000101</code>。</p>
</li>
<li><p><strong>负数</strong>：补码 = 原码的符号位不变，其余位取反（反码），然后末位加1。<br>例如：求 <code>-5</code> 的补码：</p>
<ol>
<li>原码：<code>10000101</code>（符号位为1，其余位为5的二进制）。</li>
<li>取反（符号位保留）：<code>11111010</code>（反码）。</li>
<li>加1：<code>11111010 + 1 = 11111011</code>（补码）。</li>
</ol>
</li>
</ul>
<p><strong>3. 数学原理：模运算</strong></p>
<p>补码的本质是基于 <strong>模（Modulo）运算</strong>。  </p>
<ul>
<li>对于 <strong>n位二进制数</strong>，其模为 $2^n$。  </li>
<li>负数的补码表示为：  <script type="math/tex; mode=display">
-x \equiv 2^n - x \ (\text{mod} \ 2^n)</script>例如，8位二进制数的模是 $2^8 = 256$，因此：<br>$-5$ 的补码 = $256 - 5 = 251$，二进制表示为 <code>11111011</code>。</li>
</ul>
<p><strong>4. 为什么“取反 + 1”有效？</strong></p>
<ul>
<li><strong>取反</strong>：相当于将数值部分取反（即 $x \rightarrow (2^{n-1} - 1 - x)$）。</li>
<li><strong>加1</strong>：最终得到 $2^n - x$，即补码的数学定义。</li>
</ul>
<p>以 <code>-5</code> 为例（8位）：</p>
<ol>
<li>原码：<code>10000101</code>（符号位为1，数值部分为5）。</li>
<li>取反：<code>11111010</code>（数值部分取反，符号位保留）。</li>
<li>加1：<code>11111010 + 1 = 11111011</code>，即 $251 = 256 - 5$。</li>
</ol>
<p><strong>5. 补码的优势</strong></p>
<ul>
<li><strong>唯一零表示</strong>：补码中只有 <strong>一个零</strong>（<code>00000000</code>），而原码和反码存在 <code>+0</code> 和 <code>-0</code> 的问题。</li>
<li><strong>加减统一</strong>：所有加减运算均通过加法器完成，无需单独的减法器。<br>例如：<code>5 - 3 = 5 + (-3)</code>，直接通过补码相加即可。</li>
<li><strong>溢出自动处理</strong>：超过范围的高位会自然丢弃（模运算特性）。</li>
</ul>
<p><strong>6. 特殊情况：最小负数</strong></p>
<p>对于 <strong>n位补码</strong>，能表示的范围是：  </p>
<script type="math/tex; mode=display">
[-2^{n-1}, \ 2^{n-1} - 1]</script><ul>
<li>例如，8位补码范围是：<code>-128</code>（<code>10000000</code>）到 <code>+127</code>（<code>01111111</code>）。</li>
<li><strong>最小负数（-128）</strong> 没有对应的正数（因为 $+128$ 超出范围），其补码直接定义为 <code>10000000</code>，无法通过“取反 + 1”从原码推导（因为原码中不存在 <code>+128</code>）。</li>
</ul>
<h4 id="移码（Offset-Binary）详解"><a href="#移码（Offset-Binary）详解" class="headerlink" title="移码（Offset Binary）详解"></a><strong>移码（Offset Binary）详解</strong></h4><p><strong>1. 移码的定义</strong></p>
<p>移码是一种<strong>带偏移量的编码方式</strong>，主要用于表示<strong>浮点数的阶码</strong>（Exponent）。其核心思想是将真值（实际数值）加上一个固定的偏移量（Bias），使得所有数值映射到<strong>非负数范围</strong>，从而简化比较和运算。</p>
<p><strong>公式</strong>：  </p>
<script type="math/tex; mode=display">
\text{移码} = \text{真值} + \text{偏移量}</script><p><strong>2. 移码的核心作用</strong></p>
<ul>
<li><p><strong>简化比较</strong>：<br>移码将负数范围映射到正数范围，使得可以直接通过<strong>无符号整数比较</strong>来判断阶码的大小。  </p>
<ul>
<li>例如：<br>在浮点数中，阶码 $-3$ 和 $+2$ 的移码分别为 $125$ 和 $130$（偏移量为127），直接比较 $125 &lt; 130$ 即可得出 $-3 &lt; +2$。</li>
</ul>
</li>
<li><p><strong>消除负数表示</strong>：<br>移码将负数转换为正数表示，避免了补码中负数符号位的影响。</p>
</li>
</ul>
<p><strong>3. 偏移量的选择</strong></p>
<p>偏移量通常为 $2^{n-1}$ 或 $2^{n-1}-1$（$n$ 为位数）：</p>
<ul>
<li><strong>单精度浮点数（32位）</strong>：偏移量为 $127$（即 $2^7 - 1$）。  </li>
<li><strong>双精度浮点数（64位）</strong>：偏移量为 $1023$（即 $2^{10} - 1$）。</li>
</ul>
<p><strong>4. 移码与补码的关系</strong></p>
<ul>
<li><p><strong>符号位取反</strong>：<br>移码可以看作是<strong>补码的符号位取反</strong>。例如：  </p>
<ul>
<li>补码 <code>10000000</code>（$-128$）的移码为 <code>00000000</code>（$-128 + 128 = 0$）。  </li>
<li>补码 <code>00000000</code>（$0$）的移码为 <code>10000000</code>（$0 + 128 = 128$）。</li>
</ul>
</li>
<li><p><strong>本质区别</strong>：  </p>
<ul>
<li><strong>补码</strong>：用于定点数的加减运算，支持负数和正数的统一处理。  </li>
<li><strong>移码</strong>：用于浮点数阶码的表示，便于直接比较大小。</li>
</ul>
</li>
</ul>
<p><strong>5. 移码的应用场景</strong></p>
<ul>
<li><strong>IEEE 754浮点数标准</strong>：<br>移码用于表示浮点数的阶码（Exponent），使得阶码可以直接按无符号整数比较。  <ul>
<li><strong>单精度（32位）</strong>：<br>阶码占8位，偏移量为127。<br>真值 $E$ 的移码为 $E + 127$。  </li>
<li><strong>双精度（64位）</strong>：<br>阶码占11位，偏移量为1023。<br>真值 $E$ 的移码为 $E + 1023$。</li>
</ul>
</li>
</ul>
<h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VK4y1f7o6?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】2-4.浮点数(上)_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Le4y137gU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【计算机知识】定点数与浮点数（2）浮点数法表示方法！_哔哩哔哩_bilibili</a></p>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ke411T7Qr?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【计算机基础】进制转换(3) 小数部分如何进行转换？_哔哩哔哩_bilibili</a></p>
<h4 id="整数加减"><a href="#整数加减" class="headerlink" title="整数加减"></a>整数加减</h4><h4 id="浮点数加减"><a href="#浮点数加减" class="headerlink" title="浮点数加减"></a>浮点数加减</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1894y1C7br/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">浮点数加减法运算 白中英计算机组成原理期末速成_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ue4y1s71Z/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">(自用)计算机组成原理 题型三 浮点数加减法运算题_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ej411J71a/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">浮点运算（浮点数加减运算）计算机组成原理（看了包会）_哔哩哔哩_bilibili</a></p>
<p>ieee</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nwTXz7EVi/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">计算机组成原理期末复习（5分钟）：IEEE754浮点数加减计算！_哔哩哔哩_bilibili</a></p>
<h4 id="位数"><a href="#位数" class="headerlink" title="位数"></a>位数</h4><p>short 16位</p>
<h3 id="第三章-程序的转换与机器级表示"><a href="#第三章-程序的转换与机器级表示" class="headerlink" title="第三章 程序的转换与机器级表示"></a><strong>第三章 程序的转换与机器级表示</strong></h3><h4 id="结构体与联合体"><a href="#结构体与联合体" class="headerlink" title="结构体与联合体"></a>结构体与联合体</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1754y1Y7Ut?spm_id_from=333.788.player.switch&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】3-9.结构体与联合体_哔哩哔哩_bilibili</a></p>
<h4 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ho4y1d7J6?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】3-8.数组的分配和访问_哔哩哔哩_bilibili</a></p>
<h4 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1By4y1x7Yh/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">C程序在内存中的栈_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19X4y1P7Pn?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】3-7. 过程（函数调用）_哔哩哔哩_bilibili</a></p>
<h4 id="AT-amp-T格式"><a href="#AT-amp-T格式" class="headerlink" title="AT&amp;T格式"></a>AT&amp;T格式</h4><p>AT&amp;T格式是汇编语言中的一种语法风格，主要用于x86/x64架构的汇编代码编写。它与Intel格式并列为最常见的两种汇编语法，两者在语法细节上有显著差异。以下是AT&amp;T格式的核心特点、示例及常见用途：</p>
<p><strong>主要特点</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>AT&amp;T格式语法</th>
<th>对比Intel格式语法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>寄存器</strong></td>
<td>前缀 <code>%</code>（如 <code>%eax</code>）</td>
<td>无前缀（如 <code>eax</code>）</td>
</tr>
<tr>
<td><strong>立即数</strong></td>
<td>前缀 <code>$</code>（如 <code>$0x10</code>）</td>
<td>直接使用数值（如 <code>10</code>）</td>
</tr>
<tr>
<td><strong>操作数顺序</strong></td>
<td>源操作数在前，目标在后</td>
<td>目标在前，源在后</td>
</tr>
<tr>
<td><strong>内存寻址</strong></td>
<td><code>offset(base, index, scale)</code></td>
<td><code>[base + index*scale + offset]</code></td>
</tr>
<tr>
<td><strong>指令后缀</strong></td>
<td>通过后缀标明操作数大小（如 <code>l</code> 表示32位）</td>
<td>无后缀，由操作数推断</td>
</tr>
</tbody>
</table>
</div>
<h4 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h4><ul>
<li>8 个通用寄存器，其中<ul>
<li><code>EAX, EBX, ECX, EDX</code> 均为 32 位寄存器</li>
<li><code>AX, BX, CX, DX</code> 均为 16 位寄存器</li>
<li><code>AH, BH, CH, DH</code> 均为高 8 位寄存器</li>
<li><code>AL, BL, CL, DL</code> 均为低 8 位寄存器</li>
</ul>
</li>
<li>2 个专用寄存器</li>
<li>6 个段寄存器</li>
</ul>
<h4 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a>操作数寻址方式</h4><p><strong>1. 基础内存寻址模式</strong></p>
<p><strong>(1) 直接寻址（Direct Addressing）</strong> cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc              </p>
<ul>
<li><strong>语法</strong>：<code>offset</code>（AT&amp;T格式）或 <code>[offset]</code>（Intel格式）。</li>
<li><strong>用途</strong>：直接访问全局变量或静态数据。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl var(%rip), %eax  # AT&amp;T格式（RIP相对寻址，64位模式推荐）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [var]        # Intel格式（32位模式）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>(2) 寄存器间接寻址（Register Indirect Addressing）</strong></p>
<ul>
<li><strong>语法</strong>：<code>(base_register)</code> 或 <code>[base_register]</code></li>
<li><strong>用途</strong>：指针解引用。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl (%eax), %ebx     # 将EAX指向的内存值传入EBX</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, [eax]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>(3) 基址寻址（Base Addressing）</strong></p>
<ul>
<li><strong>语法</strong>：<code>offset(base_register)</code> 或 <code>[base_register + offset]</code></li>
<li><strong>用途</strong>：访问栈帧中的局部变量或结构体成员。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp), %ecx    # 从栈帧偏移8处读取数据到ECX</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, [ebp + 8]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>(4) 变址寻址（Indexed Addressing）比例寻址</strong></p>
<ul>
<li><strong>语法</strong>：<code>array(, index_register, scale)</code> 或 <code>[array + index_register*scale]</code></li>
<li><strong>用途</strong>：数组元素访问。</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl array(,%eax,4), %edx  # 数组array + EAX*4位置的值传入EDX（数组索引）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [array + eax*4]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2. 组合寻址模式</strong></p>
<p><strong>(1) 基址 + 变址（Base + Index）</strong></p>
<ul>
<li><strong>语法</strong>：<code>(base_register, index_register)</code> 或 <code>[base_register + index_register]</code></li>
<li><strong>用途</strong>：访问二维数组或动态分配的数组。</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl (%ebx, %esi), %edi  # 将EBX + ESI指向的内存值传入EDI</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edi, [ebx + esi]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>(2) 基址 + 比例变址（Base + Index*Scale）</strong></p>
<ul>
<li><strong>语法</strong>：<code>(base_register, index_register, scale)</code> 或 <code>[base_register + index_register*scale]</code></li>
<li><strong>用途</strong>：按元素大小（scale）访问数组。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl (%ebx, %esi, 4), %edi  # 将EBX + ESI*4指向的内存值传入EDI（4字节元素）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edi, [ebx + esi*4]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>(3) 基址 + 比例变址 + 偏移（Base + Index*Scale + Offset）</strong></p>
<ul>
<li><strong>语法</strong>：<code>offset(base_register, index_register, scale)</code> 或 <code>[base_register + index_register*scale + offset]</code></li>
<li><strong>用途</strong>：访问结构体数组或复杂数据结构。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl 12(%ebx, %esi, 8), %edi  # 结构体数组中第ESI个元素的偏移12处数据传入EDI</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edi, [ebx + esi*8 + 12]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3.总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寻址模式</th>
<th>AT&amp;T格式语法</th>
<th>Intel格式语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接寻址</td>
<td><code>var(%rip)</code></td>
<td><code>[rip + var]</code>（64位）或 <code>var</code></td>
</tr>
<tr>
<td>寄存器间接寻址</td>
<td><code>(%eax)</code></td>
<td><code>[eax]</code></td>
</tr>
<tr>
<td>基址寻址</td>
<td><code>8(%ebp)</code></td>
<td><code>[ebp + 8]</code></td>
</tr>
<tr>
<td>变址寻址</td>
<td><code>array(,%eax,4)</code></td>
<td><code>[array + eax*4]</code></td>
</tr>
<tr>
<td>基址+比例变址</td>
<td><code>(%ebx, %esi, 4)</code></td>
<td><code>[ebx + esi*4]</code></td>
</tr>
<tr>
<td>基址+比例变址+偏移</td>
<td><code>12(%ebx, %esi, 8)</code></td>
<td><code>[ebx + esi*8 + 12]</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="指令后缀"><a href="#指令后缀" class="headerlink" title="指令后缀"></a>指令后缀</h4><p>在 AT&amp;T 汇编格式中，<strong>指令后缀</strong>（如 <code>b</code>、<code>w</code>、<code>l</code>、<code>q</code>）用于明确操作数的大小，确保汇编器正确生成机器码。判断后缀的核心规则是：<strong>根据操作数的大小选择对应的后缀</strong>，尤其是寄存器的位数或内存操作数的显式指定。以下是详细说明：</p>
<p><strong>后缀与操作数大小的对应关系</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>后缀</th>
<th>操作数大小</th>
<th>示例寄存器/操作数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b</code></td>
<td>byte（8位）</td>
<td><code>%al</code>, <code>$0x10</code>, <code>12(%ebp)</code>（需显式指定）</td>
</tr>
<tr>
<td><code>w</code></td>
<td>word（16位）</td>
<td><code>%ax</code>, <code>%bx</code>, <code>12(%ebp)</code>（需显式指定）</td>
</tr>
<tr>
<td><code>l</code></td>
<td>long（32位）</td>
<td><code>%eax</code>, <code>%ebx</code>, <code>12(%ebp)</code>（需显式指定）</td>
</tr>
<tr>
<td><code>q</code></td>
<td>quad（64位）</td>
<td><code>%rax</code>, <code>%rbx</code>, <code>12(%ebp)</code>（需显式指定）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>立即数默认为32位</strong></p>
</blockquote>
<h4 id="判断“指针”与“临时变量"><a href="#判断“指针”与“临时变量" class="headerlink" title="判断“指针”与“临时变量"></a>判断“指针”与“临时变量</h4><p><strong>（1）<code>%edx</code>：临时变量</strong></p>
<ul>
<li><strong>特征</strong>：直接从寄存器 <code>%edx</code> 读取数据，不涉及内存地址的间接访问。</li>
<li><strong>对应C语言</strong>：<br>如果 <code>%edx</code> 存储的是某个局部变量或计算结果（如 <code>temp = a + b</code>），则对应<strong>临时变量</strong>。  </li>
</ul>
<p><strong>（2）<code>(%ecx)</code>：指针</strong></p>
<ul>
<li><strong>特征</strong>：<code>%ecx</code> 中存储的是内存地址，<code>(%ecx)</code> 表示解引用该地址（类似C语言的 <code>*ptr</code>）。  </li>
<li><strong>对应C语言</strong>：<br>如果 <code>%ecx</code> 存储的是一个指针变量（如 <code>int *ptr</code>），则 <code>(%ecx)</code> 对应<strong>指针解引用</strong>。  </li>
</ul>
<p><strong>关键结论</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作数</th>
<th>类型</th>
<th>判断依据</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%edx</code></td>
<td>临时变量</td>
<td>直接从寄存器读取数据，无间接内存访问（无括号）。</td>
</tr>
<tr>
<td><code>(%ecx)</code></td>
<td>指针</td>
<td>使用括号 <code>(%ecx)</code> 表示解引用内存地址（类似C语言的 <code>*ptr</code>）。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>常见模式对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>C语言对应操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>movl %eax, (%ebx)</code></td>
<td><code>*ptr = temp;</code></td>
<td><code>%ebx</code> 是指针（存储地址），<code>%eax</code> 是临时变量。</td>
</tr>
<tr>
<td><code>movl (%ebx), %eax</code></td>
<td><code>temp = *ptr;</code></td>
<td>从指针 <code>ptr</code> 读取值到临时变量 <code>temp</code>。</td>
</tr>
<tr>
<td><code>movl $0x1, %eax</code></td>
<td><code>temp = 1;</code></td>
<td><code>%eax</code> 是临时变量，直接赋值。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="汇编语言中M的作用"><a href="#汇编语言中M的作用" class="headerlink" title="汇编语言中M的作用"></a>汇编语言中M的作用</h4><p>在汇编语言中，<strong>M</strong> 通常表示 <strong>内存（Memory）</strong>，用于指示操作数来自内存地址。在你的问题中，<code>M[R[eax]]</code> 的含义是：</p>
<p><strong><code>M</code> 的作用</strong></p>
<ul>
<li><strong><code>M[地址]</code></strong> 表示从 <strong>内存地址为 <code>地址</code> 的位置读取数据</strong>。</li>
<li><strong><code>R[eax]</code></strong> 表示寄存器 <code>EAX</code> 的值（即 <code>EAX</code> 中存储的内容）。</li>
<li>因此，<code>M[R[eax]]</code> 的含义是：<blockquote>
<p><strong>以 <code>EAX</code> 寄存器的值作为内存地址，从该地址读取数据</strong>。</p>
</blockquote>
</li>
</ul>
<p><strong> AT&amp;T 汇编中的等价写法</strong></p>
<p>在 AT&amp;T 汇编语法中，<code>M[R[eax]]</code> 对应的写法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addl (%eax), %edx</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>含义</strong>：<ul>
<li><code>(%eax)</code>：以 <code>EAX</code> 的值为内存地址，读取该地址的内容（默认是 4 字节，即 32 位）。</li>
<li><code>addl</code>：执行 32 位加法。</li>
<li><code>%edx</code>：目标寄存器，存储结果。</li>
</ul>
</li>
</ul>
<p><strong>关键点总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R</code></td>
<td>寄存器（Register）</td>
<td><code>R[eax]</code> → <code>EAX</code> 的值</td>
</tr>
<tr>
<td><code>M</code></td>
<td>内存（Memory）</td>
<td><code>M[地址]</code> → 从地址读取数据</td>
</tr>
<tr>
<td><code>()</code></td>
<td>AT&amp;T 汇编中表示内存寻址</td>
<td><code>(%eax)</code> → 等价于 <code>M[R[eax]]</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="常见AT-amp-T格式汇编指令"><a href="#常见AT-amp-T格式汇编指令" class="headerlink" title="常见AT&amp;T格式汇编指令"></a>常见AT&amp;T格式汇编指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令类型</th>
<th>操作目的</th>
<th>影响标志位</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>addl</code></td>
<td>加法</td>
<td>OF, SF, ZF, CF</td>
<td>数值运算、地址偏移</td>
</tr>
<tr>
<td><code>subl</code></td>
<td>减法</td>
<td>OF, SF, ZF, CF</td>
<td>数值运算、条件判断</td>
</tr>
<tr>
<td><code>orl</code></td>
<td>按位或</td>
<td>OF=0, SF, ZF, CF=0</td>
<td>位掩码操作</td>
</tr>
<tr>
<td><code>testl</code></td>
<td>按位与测试</td>
<td>OF=0, SF, ZF, CF=0</td>
<td>条件判断（如检查位是否设置）</td>
</tr>
<tr>
<td><code>imull</code></td>
<td>有符号乘法</td>
<td>OF, CF</td>
<td>数值运算</td>
</tr>
<tr>
<td><code>leal</code></td>
<td>地址计算</td>
<td>无影响</td>
<td>高效数组索引计算</td>
</tr>
<tr>
<td><code>decl</code></td>
<td>递减</td>
<td>OF, SF, ZF, CF</td>
<td>循环计数、边界检查</td>
</tr>
</tbody>
</table>
</div>
<p><strong><code>sall</code>（Shift Arithmetic Left）—— 左移指令</strong></p>
<p><strong>功能</strong></p>
<ul>
<li><strong>作用</strong> ：将操作数的二进制位 <strong>向左移动</strong> 指定的位数，低位补0。</li>
<li><strong>效果</strong> ：相当于将操作数乘以 2<em>n</em> （n 为移动的位数）。</li>
</ul>
<p><strong><code>and</code>（Logical AND）—— 逻辑与指令</strong></p>
<p><strong>功能</strong></p>
<ul>
<li><strong>作用</strong> ：对两个操作数进行 <strong>按位与运算</strong> ，结果写入目标操作数。</li>
<li><strong>效果</strong> ：只有对应位都为1时，结果位才为1。</li>
</ul>
<p><code>shrl</code> 是 <strong>逻辑右移指令</strong> （Shift Right Logical），用于对操作数进行 <strong>无符号右移</strong> ，即高位补 0，低位移出。</p>
<p><code>leal</code> 是 <strong>加载有效地址（Load Effective Address）</strong> 的指令，其功能是 <strong>计算内存地址并存储到目标寄存器</strong> ，但 <strong>不会访问内存</strong> 。它常用于 <strong>地址计算</strong> 和 <strong>高效算术运算</strong> </p>
<h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><p>以下是 <strong>x86/x64 架构中常见的四个状态标志位</strong>（OF、SF、ZF、CF）的详细说明及其判断方法：</p>
<p><strong>1. 标志位概述</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>全称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CF</strong></td>
<td>Carry Flag</td>
<td><strong>无符号溢出标志</strong>：表示无符号数运算是否产生进位或借位。</td>
</tr>
<tr>
<td><strong>ZF</strong></td>
<td>Zero Flag</td>
<td><strong>零标志</strong>：表示运算结果是否为零。</td>
</tr>
<tr>
<td><strong>SF</strong></td>
<td>Sign Flag</td>
<td><strong>符号标志</strong>：表示运算结果的最高位（符号位）是否为1（负数）。</td>
</tr>
<tr>
<td><strong>OF</strong></td>
<td>Overflow Flag</td>
<td><strong>溢出标志</strong>：表示有符号数运算是否溢出（结果超出数据类型表示范围）。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2. 判断方法详解</strong></p>
<p><strong>(1) 进位标志（CF）</strong></p>
<ul>
<li><strong>用途</strong>：判断 <strong>无符号数运算</strong> 是否溢出。</li>
<li><strong>判断规则</strong>：<ul>
<li><strong>加法</strong>：若结果最高位（最高有效位）发生进位（超过数据类型的最大值），CF=1。</li>
<li><strong>减法</strong>：若结果需要借位（被减数 &lt; 减数），CF=1。</li>
</ul>
</li>
</ul>
<p><strong>(2) 零标志（ZF）</strong></p>
<ul>
<li><strong>用途</strong>：判断运算结果是否为零。</li>
<li><strong>判断规则</strong>：<ul>
<li><strong>结果为0</strong> → ZF=1</li>
<li><strong>结果非0</strong> → ZF=0</li>
</ul>
</li>
</ul>
<p><strong>(3) 符号标志（SF）</strong></p>
<ul>
<li><strong>用途</strong>：表示运算结果的符号（正/负）。</li>
<li><strong>判断规则</strong>：<ul>
<li><strong>结果最高位为1</strong>（负数）→ SF=1</li>
<li><strong>结果最高位为0</strong>（正数）→ SF=0</li>
</ul>
</li>
</ul>
<p><strong>(4) 溢出标志（OF）</strong></p>
<ul>
<li><strong>用途</strong>：判断 <strong>有符号数运算</strong> 是否溢出。</li>
<li><strong>判断规则</strong>：<ul>
<li><strong>溢出条件</strong>：两个正数相加结果为负，或两个负数相加结果为正 → OF=1。</li>
<li><strong>无溢出</strong>：其他情况 → OF=0。</li>
</ul>
</li>
</ul>
<h4 id="栈帧布局和参数偏移计算规则"><a href="#栈帧布局和参数偏移计算规则" class="headerlink" title="栈帧布局和参数偏移计算规则"></a>栈帧布局和参数偏移计算规则</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sV411b7c1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】3-3.栈与数据传送指令_哔哩哔哩_bilibili</a></p>
<p><strong>1. 参数压栈顺序</strong></p>
<p>C语言默认使用 <strong><code>cdecl</code> 调用约定</strong>，参数<strong>从右到左</strong>压入栈中。例如，函数调用 <code>operate(x, y, z, k)</code> 的压栈顺序为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push k;     <span class="comment">// 第四个参数（最右边）</span></span><br><span class="line">push z;     <span class="comment">// 第三个参数</span></span><br><span class="line">push y;     <span class="comment">// 第二个参数</span></span><br><span class="line">push x;     <span class="comment">// 第一个参数（最左边）</span></span><br><span class="line">call operate;</span><br></pre></td></tr></table></figure><br>栈中参数布局（高地址 → 低地址）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">| k  (参数4) | ← 栈顶（ESP）</span><br><span class="line">| z  (参数3) |</span><br><span class="line">| y  (参数2) |</span><br><span class="line">| x  (参数1) |</span><br><span class="line">| 返回地址   |</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 栈帧建立过程</strong></p>
<p>进入函数 <code>operate</code> 后，通过以下指令建立栈帧：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl %ebp        ; 保存旧的EBP（栈帧基址）</span><br><span class="line">movl %esp, %ebp   ; 将当前栈顶（ESP）赋值给EBP，作为新栈帧的基址</span><br></pre></td></tr></table></figure><br>此时栈帧布局如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">| k  (参数4) | ← EBP + 20</span><br><span class="line">| z  (参数3) | ← EBP + 16</span><br><span class="line">| y  (参数2) | ← EBP + 12</span><br><span class="line">| x  (参数1) | ← EBP + 8</span><br><span class="line">| 返回地址   | ← EBP + 4</span><br><span class="line">| 旧 EBP     | ← EBP</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 参数地址的计算逻辑</strong></p>
<ul>
<li><strong><code>EBP + 4</code></strong>：返回地址（由 <code>call</code> 指令自动压栈）。  </li>
<li><strong><code>EBP + 8</code></strong>：第一个参数（<code>x</code>）。  </li>
<li><strong><code>EBP + 12</code></strong>：第二个参数（<code>y</code>）。  </li>
<li><strong><code>EBP + 16</code></strong>：第三个参数（<code>z</code>）。  </li>
<li><strong><code>EBP + 20</code></strong>：第四个参数（<code>k</code>）。  </li>
</ul>
<p><strong>原因</strong>：  </p>
<ol>
<li><strong>参数顺序</strong>：参数从右到左压栈，导致第一个参数（<code>x</code>）位于栈的最低地址（<code>EBP + 8</code>），而第四个参数（<code>k</code>）位于最高地址（<code>EBP + 20</code>）。  </li>
<li><strong>偏移计算</strong>：每个参数占用4字节（32位系统中 <code>int</code> 和指针大小），因此偏移量依次递增4。  </li>
<li><strong>栈帧基址</strong>：<code>EBP</code> 指向旧的 <code>EBP</code> 值，其上方是返回地址（<code>EBP + 4</code>），再上方是参数。</li>
</ol>
<h4 id="汇编语言表示程序函数的过程调用"><a href="#汇编语言表示程序函数的过程调用" class="headerlink" title="汇编语言表示程序函数的过程调用"></a>汇编语言表示程序函数的过程调用</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Nt4y1G728/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">超硬核！408考研重点！汇编语言表示程序函数的过程调用！23王道计算机组成原理指令系统_哔哩哔哩_bilibili</a></p>
<h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>反汇编代码是将二进制机器码（如可执行文件、内存转储）转换为 <strong>人类可读的汇编指令</strong> 的结果。它是逆向工程、漏洞分析、调试等领域的核心工具。以下是详细说明：</p>
<p><strong>1. 反汇编代码的定义</strong></p>
<ul>
<li><strong>本质</strong>：将机器码（二进制/十六进制）转换为对应的汇编指令。</li>
<li><strong>作用</strong>：帮助开发者理解程序逻辑、分析恶意软件、调试崩溃原因或研究编译器优化。</li>
</ul>
<p><strong>2. 反汇编代码的典型格式</strong></p>
<p>反汇编代码通常包含以下部分：<br>| <strong>字段</strong>                  | <strong>说明</strong>                                           | <strong>示例</strong>                     |<br>| ————————————- | ————————————————————————— | —————————————— |<br>| <strong>地址（Address）</strong>       | 指令在内存中的地址（十六进制）。                   | <code>0x804838c</code>                  |<br>| <strong>机器码（Opcode）</strong>      | 对应的原始十六进制机器码（机器指令的二进制表示）。 | <code>74 08</code>                      |<br>| <strong>汇编指令（Mnemonic）</strong>  | 汇编助记符（如 <code>mov</code>, <code>jmp</code>, <code>call</code>）及操作数。    | <code>je 0x8048396</code>               |<br>| <strong>注释（Comment, 可选）</strong> | 开发者添加的注释（某些工具会自动生成符号信息）。   | <code>; if (eax == 0) goto label</code> |</p>
<p><strong>示例反汇编代码（AT&amp;T格式）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0804838c &lt;main&gt;:</span><br><span class="line">804838c:    74 08                   je     8048396 &lt;main+0xa&gt;</span><br><span class="line">804838e:    b8 00 00 00 00          mov    $0x0, %eax</span><br><span class="line">8048393:    e9 0e 00 00 00          jmp    80483a6 &lt;main+0x1a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h4><p><strong>小端方式（Little-Endian）</strong> 是一种 <strong>数据在内存中的存储顺序</strong>，其核心特点是：</p>
<blockquote>
<p><strong>数据的低位字节（LSB, Least Significant Byte）存储在内存的低地址处，高位字节（MSB, Most Significant Byte）存储在高地址处</strong>。</p>
</blockquote>
<p><strong>1. 小端 vs 大端</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>小端（Little-Endian）</strong></th>
<th><strong>大端（Big-Endian）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储顺序</strong></td>
<td>低位字节在前（低地址），高位在后</td>
<td>高位字节在前（低地址），低位在后</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>0x12345678</code> → 存储为 <code>78 56 34 12</code></td>
<td><code>0x12345678</code> → 存储为 <code>12 34 56 78</code></td>
</tr>
<tr>
<td><strong>常见平台</strong></td>
<td>x86/x64 架构（Intel/AMD 处理器）</td>
<td>ARM（部分模式）、网络协议（TCP/IP）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2. 小端方式的直观理解</strong></p>
<p><strong>示例：32位整数 <code>0x12345678</code></strong></p>
<ul>
<li><strong>内存地址分配</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址 →    0x1000    0x1001    0x1002    0x1003</span><br><span class="line">         +---------+---------+---------+---------+</span><br><span class="line">         |  0x78   |  0x56   |  0x34   |  0x12   |</span><br><span class="line">         +---------+---------+---------+---------+</span><br></pre></td></tr></table></figure></li>
<li><strong>解释</strong>：<ul>
<li>数据的最低位字节 <code>0x78</code> 存储在最低地址 <code>0x1000</code>。</li>
<li>高位字节 <code>0x12</code> 存储在最高地址 <code>0x1003</code>。</li>
</ul>
</li>
</ul>
<h4 id="转移目标地址的计算"><a href="#转移目标地址的计算" class="headerlink" title="转移目标地址的计算"></a>转移目标地址的计算</h4><p>在 IA-32（x86）架构中，<strong>转移目标地址的计算</strong>依赖于 <strong>指令的长度</strong> 和 <strong>相对偏移量（Displacement）</strong>。以下是详细分析：</p>
<p><strong>1. 转移指令的基本原理</strong></p>
<ul>
<li><strong>相对跳转（Relative Jump）</strong>：转移目标地址 = <strong>下一条指令地址</strong> + <strong>偏移量</strong>。</li>
<li><strong>偏移量</strong>：有符号的 8 位、16 位或 32 位整数，表示从 <strong>下一条指令地址</strong> 开始的偏移（正向或负向）。</li>
<li><strong>小端方式（Little-Endian）</strong>：多字节偏移量需按小端方式存储（低位字节在前）。</li>
</ul>
<p><strong>2. 示例：<code>call</code> 指令的地址计算</strong></p>
<p><strong>(1) 已知条件</strong></p>
<ul>
<li><strong>指令地址</strong>：<code>0x804838e</code>（<code>call</code> 指令的起始地址）。</li>
<li><strong>机器码</strong>：<code>E8 1E 00 00 00</code>。<ul>
<li><code>E8</code> 是 <code>call</code> 的操作码。</li>
<li><code>1E 00 00 00</code> 是偏移量（小端方式存储）。</li>
</ul>
</li>
</ul>
<p><strong>(2) 计算步骤</strong></p>
<ol>
<li><strong>确定指令长度</strong>：<ul>
<li><code>call</code> 指令占 <strong>5 字节</strong>（1 字节操作码 + 4 字节偏移量）。</li>
</ul>
</li>
<li><strong>计算下一条指令地址</strong>：<ul>
<li>下一条指令地址 = 当前指令地址 + 指令长度<br>= <code>0x804838e + 5 = 0x8048393</code>。</li>
</ul>
</li>
<li><strong>解析偏移量</strong>：<ul>
<li>偏移量字段为 <code>1E 00 00 00</code>（小端方式）→ 转换为大端顺序为 <code>0x0000001E</code>（十进制 30）。</li>
</ul>
</li>
<li><strong>计算转移目标地址</strong>：<ul>
<li>转移目标地址 = 下一条指令地址 + 偏移量<br>= <code>0x8048393 + 0x1E = 0x80483B1</code>。</li>
</ul>
</li>
</ol>
<p><strong>3. 核心公式</strong></p>
<script type="math/tex; mode=display">
\text{目标地址} = (\text{当前指令地址} + \text{指令长度}) + \text{偏移量}</script><ul>
<li><strong>当前指令地址</strong>：指令的起始地址（如 <code>0x804838e</code>）。</li>
<li><strong>指令长度</strong>：由操作码和操作数决定（如 <code>call</code> 占 5 字节）。</li>
<li><strong>偏移量</strong>：从指令的操作数中提取并转换为有符号整数。</li>
</ul>
<p><strong>9. 其他指令示例</strong></p>
<p><strong>(1) <code>je</code> 指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">804838c:    74 08                   je     0x8048396</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>当前地址</strong>：<code>0x804838c</code>。</li>
<li><strong>指令长度</strong>：2 字节。</li>
<li><strong>偏移量</strong>：<code>0x08</code>（单字节，无需反转）。</li>
<li><strong>目标地址</strong>：<code>0x804838c + 2 + 0x08 = 0x8048396</code>。</li>
</ul>
<p><strong>(2) <code>jmp</code> 指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80483a4:    E9 F6 FF FF FF          jmp    0x804839f</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>当前地址</strong>：<code>0x80483a4</code>。</li>
<li><strong>指令长度</strong>：5 字节。</li>
<li><strong>偏移量</strong>：<code>F6 FF FF FF</code>（小端）→ 补码为 <code>-10</code>（十进制）。</li>
<li><strong>目标地址</strong>：<code>0x80483a4 + 5 + (-10) = 0x804839f</code>。</li>
</ul>
<h4 id="计算下一条指令地址"><a href="#计算下一条指令地址" class="headerlink" title="计算下一条指令地址"></a><strong>计算下一条指令地址</strong></h4><p>下一条指令地址=当前指令地址+当前指令长度</p>
<h3 id="第四章-程序的链接"><a href="#第四章-程序的链接" class="headerlink" title="第四章 程序的链接"></a>第四章 程序的链接</h3><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JL411L7ku?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】7-6. 重定位_哔哩哔哩_bilibili</a></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oe411n72U/?spm_id_from=333.337.search-card.all.click">3分钟彻底理解链接器_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzxb1995/article/details/105088502">计算机系统基础摘记——程序的链接_引入链接的好处是什么-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oS4y1T7Uf?spm_id_from=333.788.player.switch&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">【CSAPP-深入理解计算机系统】7-5. 静态库的解析过程_哔哩哔哩_bilibili</a></p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>gdb调试</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sg41167B1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">一分钟学会GDB程序调试_哔哩哔哩_bilibili</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17K4y1N7Q2?spm_id_from=333.788.videopod.episodes&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">深入理解计算机系统合集（周更中）_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">计算机系统基础期末笔记汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-09 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-09T00:00:00+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-02 22:45:24" itemprop="dateModified" datetime="2025-08-02T22:45:24+08:00">2025-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/" itemprop="url" rel="index"><span itemprop="name">大二下</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机系统基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/IMG_20250706_165933.jpg" alt="IMG_20250706_165933"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/IMG_20250706_165925.jpg" alt="IMG_20250706_165925"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/IMG_20250706_165919.jpg" alt="IMG_20250706_165919"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/IMG_20250706_165914.jpg" alt="IMG_20250706_165914"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/IMG_20250706_165903.jpg" alt="IMG_20250706_165903"></p>
<p><img src="/2025/06/09/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/IMG_20250706_165909.jpg" alt="IMG_20250706_165909"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">机器学习——期末复习（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-06 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-06T00:00:00+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-22 19:53:19" itemprop="dateModified" datetime="2025-06-22T19:53:19+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/" itemprop="url" rel="index"><span itemprop="name">大二下</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h2><h3 id="方差与偏差"><a href="#方差与偏差" class="headerlink" title="方差与偏差"></a>方差与偏差</h3><p>方差（Variance）和偏差（Bias）是机器学习中衡量模型性能的两个核心概念，它们共同构成了<strong>偏差-方差权衡</strong>（Bias-Variance Tradeoff）的基础框架。以下是两者的定义与区别：</p>
<p><strong>1. 偏差（Bias）</strong></p>
<ul>
<li><strong>定义</strong>：偏差是指模型预测的期望值与真实值之间的差异。它反映了模型本身的拟合能力，即是否能够准确捕捉数据中的规律。</li>
</ul>
<p><strong>2. 方差（Variance）</strong></p>
<ul>
<li><strong>定义</strong>：方差是指模型在不同训练数据集下预测结果的波动程度。它衡量了模型对训练数据中噪声或微小变化的敏感性。</li>
</ul>
<p><strong>3. 如何降低偏差与方差</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>目标</strong></th>
<th><strong>方法</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>降低偏差</strong></td>
<td>增加模型复杂度（如更多特征、更深的神经网络）、减少正则化强度</td>
<td>使用多项式回归替代线性回归</td>
</tr>
<tr>
<td><strong>降低方差</strong></td>
<td>增加训练数据、引入正则化（L1/L2）、使用集成方法（如 Bagging、Boosting）</td>
<td>随机森林（Bagging）降低决策树的方差</td>
</tr>
</tbody>
</table>
</div>
<p><strong>4. 总结</strong></p>
<ul>
<li><strong>偏差</strong>关注模型是否能准确拟合数据（<strong>学习能力</strong>），而<strong>方差</strong>关注模型对数据波动的稳定性（<strong>泛化能力</strong>）。</li>
<li>实际应用中需通过交叉验证、正则化或集成学习等技术平衡两者的关系。</li>
</ul>
<h3 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h3><p>以下是关于监督学习与无监督学习的核心区别总结：</p>
<p><strong>1. 监督学习（Supervised Learning）</strong></p>
<p><strong>任务类型</strong>：  </p>
<ul>
<li><strong>分类（Classification）</strong>：预测离散类别标签（如垃圾邮件/非垃圾邮件）。  </li>
<li><strong>回归（Regression）</strong>：预测连续数值标签（如房价预测）。  </li>
</ul>
<p><strong>特点</strong>：  </p>
<ul>
<li>需要<strong>带标签的样本</strong>（Labeled Data），即每个训练样本都有明确的输入 $ x $ 和输出 $ y $。  </li>
<li>模型通过学习输入与标签之间的映射关系进行预测。  </li>
</ul>
<p><strong>2. 无监督学习（Unsupervised Learning）</strong></p>
<p><strong>任务类型</strong>：  </p>
<ul>
<li><strong>聚类（Clustering）</strong>：将样本划分为具有相似特征的群体（如客户分群）。  </li>
<li><strong>降维（Dimensionality Reduction）</strong>：压缩数据维度同时保留关键信息（如PCA）。  </li>
</ul>
<p><strong>特点</strong>：  </p>
<ul>
<li>仅需<strong>无标签的样本</strong>（Unlabeled Data），无需预先定义输出目标。  </li>
<li>模型自主挖掘数据内在结构或分布规律。  </li>
</ul>
<h3 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h3><h4 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h4><h5 id="贝叶斯决策论"><a href="#贝叶斯决策论" class="headerlink" title="贝叶斯决策论"></a>贝叶斯决策论</h5><p>本质思想：寻找合适的参数使得「当前的样本情况发生的概率」最大。</p>
<p>又由于假设每一个样本相互独立（概率条件理想的情况下），因此可以用连乘的形式表示上述概率，当然由于概率较小导致连乘容易出现浮点数精度损失，因此尝尝采用取对数的方式来避免「下溢」问题。也就是所谓的「对数似然估计」方法。</p>
<p>在已知样本特征 $ \mathbf{x} $ 的条件下，选择分类结果 $ c_i $，使得分类的期望损失（Risk）最小<strong>。</strong></p>
<p><strong>(1) 损失函数 $ \lambda_{ij} $</strong></p>
<ul>
<li><strong>定义</strong>：$ \lambda_{ij} $ 是将真实类别为 $ c_j $ 的样本误分类为 $ c_i $ 所产生的损失。<ul>
<li>例如：<ul>
<li>在医学诊断中，若 $ c_1 $ 表示“患病”，$ c_2 $ 表示“未患病”：<ul>
<li>$ \lambda_{21} $：将实际患病（$ c_1 $）误判为未患病（$ c_2 $）的损失（可能更高）。</li>
<li>$ \lambda_{12} $：将实际未患病（$ c_2 $）误判为患病（$ c_1 $）的损失（可能较低）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>(2) 条件风险（单个样本的期望损失）</strong></p>
<p>对于给定样本 $ \mathbf{x} $，若将其分类为 $ c_i $，则其<strong>条件风险</strong>为：</p>
<script type="math/tex; mode=display">
R(c_i | \mathbf{x}) = \sum_{j=1}^N \lambda_{ij} P(c_j | \mathbf{x})</script><ul>
<li><strong>含义</strong>：在已知 $ \mathbf{x} $ 的情况下，分类为 $ c_i $ 的平均损失。</li>
<li><strong>推导</strong>：<ul>
<li>$ P(c_j | \mathbf{x}) $：样本 $ \mathbf{x} $ 真实属于 $ c_j $ 的后验概率。</li>
<li>$ \lambda<em>{ij} $：若真实类别是 $ c_j $，但被分到 $ c_i $，则产生损失 $ \lambda</em>{ij} $。</li>
<li>因此，总期望损失是所有可能真实类别的加权和（权重为后验概率）。</li>
</ul>
</li>
</ul>
<p><strong>(3) 总体风险</strong></p>
<p>对于整个数据集，分类器 $ h(\mathbf{x}) $ 的<strong>总体风险</strong>为：</p>
<script type="math/tex; mode=display">
R(h) = \mathbb{E}_{\mathbf{x}}[R(h(\mathbf{x}) | \mathbf{x})] = \int R(h(\mathbf{x}) | \mathbf{x}) p(\mathbf{x}) d\mathbf{x}</script><ul>
<li><strong>含义</strong>：所有样本的平均条件风险。h为分类器（模型）</li>
<li><strong>目标</strong>：找到使 $ R(h) $ 最小的分类器 $ h(\mathbf{x}) $。</li>
</ul>
<h5 id="贝叶斯决策规则"><a href="#贝叶斯决策规则" class="headerlink" title="贝叶斯决策规则"></a><strong>贝叶斯决策规则</strong></h5><p>根据上述定义，贝叶斯决策论的分类规则是：</p>
<blockquote>
<p><strong>对于样本 $ \mathbf{x} $，选择使其条件风险 $ R(c_i | \mathbf{x}) $ 最小的类别 $ c_i $ 作为预测结果。</strong></p>
</blockquote>
<p>即：</p>
<script type="math/tex; mode=display">
h^*(\mathbf{x}) = \arg\min_{c_i} R(c_i | \mathbf{x}) = \arg\min_{c_i} \sum_{j=1}^N \lambda_{ij} P(c_j | \mathbf{x})</script><h5 id="特殊情况：0-1-损失函数"><a href="#特殊情况：0-1-损失函数" class="headerlink" title="特殊情况：0-1 损失函数"></a><strong>特殊情况：0-1 损失函数</strong></h5><p>当所有误分类的损失相同（即 $ \lambda<em>{ij} = 1 $ 对于 $ i \neq j $，$ \lambda</em>{ii} = 0 $）<strong>0-1 损失函数</strong>：</p>
<script type="math/tex; mode=display">
\lambda_{ij} = 
\begin{cases}
0, & \text{if } i = j \\
1, & \text{otherwise}
\end{cases}</script><p>此时条件风险简化为：</p>
<script type="math/tex; mode=display">
R(c_i | \mathbf{x}) = \sum_{j \neq i} P(c_j | \mathbf{x}) = 1 - P(c_i | \mathbf{x})</script><p>原因：概率之和为 1：$ \sum<em>{j=1}^N P(c_j | \mathbf{x}) = 1 $，因此 $ \sum</em>{j \neq i} P(c_j | \mathbf{x}) = 1 - P(c_i | \mathbf{x}) $。</p>
<p>此时，最小化风险等价于<strong>最大化后验概率</strong>，即：</p>
<script type="math/tex; mode=display">
h^*(\mathbf{x}) = \arg\max_{c_i} P(c_i | \mathbf{x})</script><p>这正是传统贝叶斯分类器的决策规则。</p>
<blockquote>
<p>即在x样本的情况下，分类正确的概率最大</p>
</blockquote>
<h4 id="后验概率与先验概率"><a href="#后验概率与先验概率" class="headerlink" title="后验概率与先验概率"></a>后验概率与先验概率</h4><h5 id="后验概率"><a href="#后验概率" class="headerlink" title="后验概率"></a>后验概率</h5><p>后验概率（Posterior Probability）是贝叶斯理论中的核心概念，指的是<strong>在观察到新证据（数据）后，对事件发生概率的修正</strong> 。<br>其本质是：</p>
<blockquote>
<p><strong>“已知结果（数据），反推原因（类别或参数）的概率”</strong> 。 </p>
</blockquote>
<p>已知结果（数据）B，反推最可能的原因A（后验概率 <em>P</em>(<em>A</em>∣<em>B</em>) ）</p>
<h5 id="先验概率（Prior-Probability）"><a href="#先验概率（Prior-Probability）" class="headerlink" title="先验概率（Prior Probability）"></a><strong>先验概率（Prior Probability）</strong></h5><p>先验概率是贝叶斯统计中的核心概念，指的是在<strong>观察到新数据之前</strong>，对某一事件或假设的概率估计。它是基于<strong>已有知识、经验或假设</strong>得出的初始概率，后续会通过新数据更新为更准确的<strong>后验概率</strong>。</p>
<p><strong>1. 核心定义</strong></p>
<ul>
<li><p><strong>数学表达</strong>：  </p>
<script type="math/tex; mode=display">
P(A)</script><ul>
<li>$ P(A) $：事件 $ A $ 的先验概率。</li>
<li>例如：$ A $ 表示“某人患有某种疾病”，则 $ P(A) $ 是该疾病的已知发病率（在未进行检测前的概率）。</li>
</ul>
</li>
<li><p><strong>与后验概率的区别</strong>：  </p>
<ul>
<li><strong>先验概率</strong>：$ P(A) $，在无新数据时的概率。  </li>
<li><strong>后验概率</strong>：$ P(A|B) $，在观察到数据 $ B $ 后更新的概率（通过贝叶斯定理计算）。</li>
</ul>
</li>
</ul>
<p><strong>2. 直观理解</strong></p>
<p><strong>(1) 类比：医学诊断</strong></p>
<ul>
<li><strong>先验概率</strong>：某种疾病的已知发病率（如 1%）。  </li>
<li><strong>新数据</strong>：患者接受检测，结果为阳性。  </li>
<li><strong>后验概率</strong>：结合发病率和检测结果，计算实际患病的概率（如 8.7%，参考贝叶斯定理的经典医学测试案例）。</li>
</ul>
<h4 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a>生成式模型和判别式模型</h4><h5 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a><strong>核心区别</strong></h5><div class="table-container">
<table>
<thead>
<tr>
<th><strong>模型类型</strong></th>
<th><strong>建模目标</strong></th>
<th><strong>数学表达</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>判别式模型</strong></td>
<td>直接建模 $ P(c</td>
<td>\mathbf{x}) $</td>
<td>$ P(c</td>
<td>\mathbf{x}) $</td>
</tr>
<tr>
<td><strong>生成式模型</strong></td>
<td>先建模联合概率 $ P(\mathbf{x}, c) $，再推导 $ P(c</td>
<td>\mathbf{x}) $</td>
<td>$ P(c</td>
<td>\mathbf{x}) = \frac{P(\mathbf{x}</td>
<td>c)P(c)}{P(\mathbf{x})} $</td>
</tr>
</tbody>
</table>
</div>
<h5 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a><strong>详细解释</strong></h5><p><strong>1. 判别式模型（Discriminative Model）</strong></p>
<ul>
<li><strong>目标</strong>：直接学习从输入 $ \mathbf{x} $ 到标签 $ c $ 的映射关系。</li>
<li><strong>数学本质</strong>：建模条件概率 $ P(c|\mathbf{x}) $，即“已知特征 $ \mathbf{x} $，预测类别 $ c $”。</li>
<li><strong>特点</strong>：<ul>
<li>不关心数据本身的分布，只关注分类边界。</li>
<li>例如：逻辑回归、支持向量机（SVM）、神经网络等。</li>
</ul>
</li>
</ul>
<p><strong>2. 生成式模型（Generative Model）</strong></p>
<ul>
<li><p><strong>目标</strong>：先学习数据的生成过程，即联合概率 $ P(\mathbf{x}, c) $，再通过贝叶斯定理推导条件概率 $ P(c|\mathbf{x}) $。</p>
</li>
<li><p><strong>数学步骤</strong>：</p>
<ol>
<li>建模 $ P(\mathbf{x}|c) $（特征在类别 $ c $ 下的分布）和 $ P(c) $（类别先验）。</li>
<li>根据贝叶斯定理计算后验概率：<script type="math/tex; mode=display">
P(c|\mathbf{x}) = \frac{P(\mathbf{x}|c)P(c)}{P(\mathbf{x})}</script></li>
<li>选择使 $ P(c|\mathbf{x}) $ 最大的类别作为预测结果。</li>
</ol>
</li>
</ul>
<h5 id="示例：二分类问题"><a href="#示例：二分类问题" class="headerlink" title="示例：二分类问题"></a><strong>示例：二分类问题</strong></h5><p>假设我们要判断一封邮件是否为垃圾邮件（$ c=spam $ 或 $ ham $）。</p>
<p><strong>判别式模型（逻辑回归）</strong></p>
<p>直接建模：</p>
<script type="math/tex; mode=display">
P(spam|\mathbf{x}) = \frac{1}{1 + e^{-(w^T \mathbf{x} + b)}}</script><p>若 $ P(spam|\mathbf{x}) &gt; 0.5 $，则判定为垃圾邮件。</p>
<p><strong>生成式模型（朴素贝叶斯）</strong></p>
<ol>
<li>建模联合概率：<script type="math/tex; mode=display">
P(\mathbf{x}, spam) = P(spam) \prod_{i} P(word_i|spam)</script><script type="math/tex; mode=display">
P(\mathbf{x}, ham) = P(ham) \prod_{i} P(word_i|ham)</script></li>
<li>计算后验概率：<script type="math/tex; mode=display">
P(spam|\mathbf{x}) = \frac{P(\mathbf{x}|spam)P(spam)}{P(\mathbf{x})}</script><script type="math/tex; mode=display">
P(ham|\mathbf{x}) = \frac{P(\mathbf{x}|ham)P(ham)}{P(\mathbf{x})}</script></li>
<li>选择概率更大的类别。</li>
</ol>
<h4 id="生成式模型的建模思路"><a href="#生成式模型的建模思路" class="headerlink" title="生成式模型的建模思路"></a>生成式模型的建模思路</h4><p>根据概率论的基本定义：</p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) = \frac{P(\mathbf{x}, c)}{P(\mathbf{x})}</script><ul>
<li><strong>含义</strong>：<ul>
<li>$ P(\mathbf{x}, c) $：联合概率，表示特征 $ \mathbf{x} $ 和类别 $ c $ 同时发生的概率。</li>
<li>$ P(\mathbf{x}) $：边缘概率（证据），表示特征 $ \mathbf{x} $ 出现的概率，用于归一化。</li>
</ul>
</li>
</ul>
<p>根据贝叶斯定理，联合概率 $ P(\mathbf{x}, c) $ 可以分解为：</p>
<script type="math/tex; mode=display">
P(\mathbf{x}, c) = P(c) \cdot P(\mathbf{x}|c)</script><p>其中：</p>
<ul>
<li>$ P(c) $：类先验概率（Prior Probability），表示类别 $ c $ 在数据中的整体占比。</li>
<li>$ P(\mathbf{x}|c) $：似然度（Likelihood），表示在类别 $ c $ 下，特征 $ \mathbf{x} $ 出现的概率。</li>
</ul>
<p>将上述分解代入条件概率公式，得到：</p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) = \frac{P(c) \cdot P(\mathbf{x}|c)}{P(\mathbf{x})}</script><p>产生问题：</p>
<p>在贝叶斯分类中，需要计算联合概率 <em>P</em>(<strong>x</strong>∣<em>c</em>) ，即在类别 <em>c</em> 下，特征向量 <strong>x</strong>=(<em>x</em>1,<em>x</em>2,…,<em>x**d</em>) 的条件概率。<br>若直接建模联合概率，需估计 <em>d</em> 个特征的所有可能组合的概率。例如：</p>
<ul>
<li>若每个特征有 <em>k</em> 个取值，类别数为 <em>K</em> ，则需要估计 <em>K</em>⋅<em>k**d</em> 个参数。</li>
<li>当特征维度 <em>d</em> 很大时（如文本分类中成千上万的词汇），参数数量呈指数级增长，导致计算不可行（<strong>维度灾难</strong> ）。</li>
</ul>
<p>举例：</p>
<ul>
<li><strong>低维空间</strong> ：假设只有 2 个特征（如“免费”和“中奖”），每个特征取值为 0 或 1，则特征空间共有 22=4 个可能的组合（即四个格子）。<ul>
<li>如果有 100 封邮件，每个格子平均有 25 封邮件（数据较密集）。</li>
</ul>
</li>
<li><strong>高维空间</strong> ：<br>当特征维度增加到 <em>d</em>=10,000 时，特征空间的组合数是 210,000 ，远大于宇宙中原子的数量（约 1080 ）。<ul>
<li>即使有 100 万封邮件，每个组合几乎都是空的（数据极度稀疏）。</li>
</ul>
</li>
</ul>
<p><strong>结果</strong> ：<br>在高维空间中，训练数据无法覆盖所有可能的特征组合，导致模型无法可靠估计联合概率 <em>P</em>(x∣c) 。</p>
<p>因此产生<strong>属性条件独立性假设</strong></p>
<h4 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h4><p>朴素贝叶斯分类器的核心思想是通过<strong>贝叶斯定理</strong>和<strong>属性条件独立性假设</strong>来简化计算，从而高效地进行分类。</p>
<h5 id="属性条件独立性假设"><a href="#属性条件独立性假设" class="headerlink" title="属性条件独立性假设"></a>属性条件独立性假设</h5><p>朴素贝叶斯的核心假设是：<strong>在已知类别 $ c $ 的条件下，所有属性（特征）之间相互独立</strong>。<br>因此，联合概率 $ P(\mathbf{x}|c) $ 可以分解为各属性独立概率的乘积：</p>
<script type="math/tex; mode=display">
P(\mathbf{x}|c) = \prod_{i=1}^d P(x_i|c)</script><p>其中 $ d $ 是特征的数量，$ x_i $ 是第 $ i $ 个特征的取值。</p>
<p>将此代入贝叶斯公式：</p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) = \frac{P(c) \cdot \prod_{i=1}^d P(x_i|c)}{P(\mathbf{x})}</script><h5 id="为何可以忽略-P-mathbf-x"><a href="#为何可以忽略-P-mathbf-x" class="headerlink" title="为何可以忽略 $ P(\mathbf{x}) $?"></a><strong>为何可以忽略 $ P(\mathbf{x}) $?</strong></h5><p>在分类任务中，我们的目标是比较不同类别 $ c $ 的后验概率 $ P(c|\mathbf{x}) $，并选择最大值。由于 $ P(\mathbf{x}) $ 对所有类别来说是相同的常量（与类别无关），因此在最大化过程中可以忽略：</p>
<script type="math/tex; mode=display">
\arg\max_{c} P(c|\mathbf{x}) = \arg\max_{c} \left[ \frac{P(c) \cdot \prod_{i=1}^d P(x_i|c)}{P(\mathbf{x})} \right] = \arg\max_{c} \left[ P(c) \cdot \prod_{i=1}^d P(x_i|c) \right]</script><p>这就是公式中 $ P(\mathbf{x}) $ 被省略的原因。</p>
<blockquote>
<p>在比较的过程中，分母相同，可以忽略</p>
</blockquote>
<h5 id="朴素贝叶斯的最终决策规则"><a href="#朴素贝叶斯的最终决策规则" class="headerlink" title="朴素贝叶斯的最终决策规则"></a><strong>朴素贝叶斯的最终决策规则</strong></h5><p>简化后的决策规则为：</p>
<script type="math/tex; mode=display">
h_{nb}(\mathbf{x}) = \arg\max_{c} \left[ P(c) \cdot \prod_{i=1}^d P(x_i|c) \right]</script><p>即：</p>
<ul>
<li>计算每个类别的先验概率 $ P(c) $。</li>
<li>计算每个特征在该类别下的条件概率 $ P(x_i|c) $。</li>
<li>将这些概率相乘，选择乘积最大的类别作为预测结果。</li>
</ul>
<h5 id="类先验概率-P-c-的估计方法"><a href="#类先验概率-P-c-的估计方法" class="headerlink" title="类先验概率 $ P(c) $ 的估计方法"></a><strong>类先验概率 $ P(c) $ 的估计方法</strong></h5><p>基于<strong>大数定律</strong></p>
<script type="math/tex; mode=display">
P(c) = \frac{|D_c|}{|D|}</script><ul>
<li><p><strong>符号含义</strong>：</p>
<ul>
<li>$ D $：训练集，包含所有样本。</li>
<li>$ D_c $：训练集中类别为 $ c $ 的样本子集。</li>
<li>$ |D_c| $：类别 $ c $ 的样本数量。</li>
<li>$ |D| $：训练集总样本数量。</li>
</ul>
</li>
<li><p><strong>直观解释</strong>：<br>类先验概率等于该类别样本数占总样本数的比例。</p>
</li>
</ul>
<h5 id="条件概率-P-x-i-c-的估计方法"><a href="#条件概率-P-x-i-c-的估计方法" class="headerlink" title="条件概率 $ P(x_i | c) $ 的估计方法"></a><strong>条件概率 $ P(x_i | c) $ 的估计方法</strong></h5><p>在生成式模型（如朴素贝叶斯分类器）中，<strong>条件概率 $ P(x_i | c) $</strong> 表示在类别 $ c $ 下，第 $ i $ 个属性取值为 $ x_i $ 的概率。根据属性类型（离散或连续），其估计方法不同：</p>
<p><strong>1. 离散属性的条件概率估计</strong></p>
<p><strong>公式</strong>：</p>
<script type="math/tex; mode=display">
P(x_i | c) = \frac{|D_{c,x_i}|}{|D_c|}</script><ul>
<li><strong>符号含义</strong>：<ul>
<li>$ D_c $：训练集中类别为 $ c $ 的样本集合。</li>
<li>$ D_{c,x_i} $：$ D_c $ 中第 $ i $ 个属性取值为 $ x_i $ 的样本子集。</li>
<li>$ |D<em>{c,x_i}| $：$ D</em>{c,x_i} $ 的样本数量。</li>
<li>$ |D_c| $：类别 $ c $ 的总样本数量。</li>
</ul>
</li>
</ul>
<p><strong>直观解释</strong>：</p>
<ul>
<li>在类别 $ c $ 的样本中，统计第 $ i $ 个属性取值为 $ x_i $ 的频率，作为 $ P(x_i | c) $ 的估计。</li>
<li><strong>示例</strong>：<br>若类别 $ c=spam $（垃圾邮件）有 200 封，其中 150 封包含“免费”一词，则：<script type="math/tex; mode=display">
P(\text{“免费”} | spam) = \frac{150}{200} = 0.75</script></li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>零概率问题</strong>：若某属性值在类别 $ c $ 中未出现，则 $ P(x_i | c) = 0 $，可能导致后续计算失效。<br><strong>解决方案</strong>：使用<strong>拉普拉斯平滑（Laplace Smoothing）</strong>，将公式改为：<script type="math/tex; mode=display">
P(x_i | c) = \frac{|D_{c,x_i}| + 1}{|D_c| + K}</script>其中 $ K $ 是该属性的取值总数。</li>
</ul>
<p><strong>2. 连续属性的条件概率估计</strong></p>
<p><strong>假设</strong>：属性服从正态分布（高斯分布）</p>
<script type="math/tex; mode=display">
p(x_i | c) = \frac{1}{\sqrt{2\pi}\sigma_{c,i}} \exp\left( -\frac{(x_i - \mu_{c,i})^2}{2\sigma_{c,i}^2} \right)</script><ul>
<li><strong>符号含义</strong>：<ul>
<li>$ \mu_{c,i} $：类别 $ c $ 在第 $ i $ 个属性上的均值。</li>
<li>$ \sigma_{c,i}^2 $：类别 $ c $ 在第 $ i $ 个属性上的方差。</li>
</ul>
</li>
</ul>
<p><strong>直观解释</strong>：</p>
<ul>
<li>假设在类别 $ c $ 下，属性 $ x<em>i $ 服从均值为 $ \mu</em>{c,i} $、方差为 $ \sigma_{c,i}^2 $ 的正态分布。</li>
<li><strong>示例</strong>：<br>若类别 $ c=spam $ 的“字数”属性均值 $ \mu<em>{spam, \text{字数}} = 500 $，方差 $ \sigma</em>{spam, \text{字数}}^2 = 100 $，则：<script type="math/tex; mode=display">
p(600 | spam) = \frac{1}{\sqrt{2\pi \cdot 100}} \exp\left( -\frac{(600 - 500)^2}{2 \cdot 100} \right) \approx 0.004</script></li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>分布假设</strong>：若实际数据不符合正态分布，需调整假设（如使用核密度估计、对数变换等）。</li>
<li><strong>参数估计</strong>：均值和方差通过训练数据计算：<script type="math/tex; mode=display">
\mu_{c,i} = \frac{1}{|D_c|} \sum_{x \in D_c} x_i, \quad \sigma_{c,i}^2 = \frac{1}{|D_c|} \sum_{x \in D_c} (x_i - \mu_{c,i})^2</script></li>
</ul>
<h4 id="半朴素贝叶斯分类器"><a href="#半朴素贝叶斯分类器" class="headerlink" title="半朴素贝叶斯分类器"></a>半朴素贝叶斯分类器</h4><p>半朴素贝叶斯分类器是对传统<strong>朴素贝叶斯</strong>的改进，它在保留计算效率的同时，<strong>适当引入部分属性间的依赖关系</strong>，从而在分类性能和计算复杂度之间取得平衡。</p>
<h5 id="独依赖估计（ODE）方法"><a href="#独依赖估计（ODE）方法" class="headerlink" title="独依赖估计（ODE）方法"></a><strong>独依赖估计（ODE）方法</strong></h5><p><strong>(1) 定义</strong></p>
<p>独依赖估计（One-Dependent Estimator, ODE）是半朴素贝叶斯的一种实现方式，其核心假设是：</p>
<blockquote>
<p><strong>每个属性 $ x_i $ 在类别 $ c $ 之外最多依赖于一个其他属性（称为父属性 $ pa_i $）</strong>。</p>
</blockquote>
<p>数学表达式为：</p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) \propto P(c) \prod_{i=1}^d P(x_i | c, pa_i)</script><p>其中：</p>
<ul>
<li>$ pa_i $：属性 $ x_i $ 的父属性（依赖的单一属性）。</li>
<li>$ P(x_i | c, pa_i) $：在类别 $ c $ 和父属性 $ pa_i $ 下，属性 $ x_i $ 的条件概率。</li>
</ul>
<p><strong>(2) 直观理解</strong></p>
<ul>
<li>每个属性 $ x_i $ 的分布不仅受类别 $ c $ 影响，还受其父属性 $ pa_i $ 的影响。</li>
<li>例如，在文本分类中，若属性 $ x_1 $ 是“免费”，$ x_2 $ 是“中奖”，可设定 $ pa_2 = x_1 $，表示“中奖”在类别和“免费”的共同作用下出现。</li>
</ul>
<h5 id="超父独依赖估计（SPODE）"><a href="#超父独依赖估计（SPODE）" class="headerlink" title="超父独依赖估计（SPODE）"></a><strong>超父独依赖估计（SPODE）</strong></h5><p>超父独依赖估计（Super Parent One-Dependent Estimator, SPODE）是<strong>半朴素贝叶斯分类器</strong>的一种扩展，其核心思想是：</p>
<blockquote>
<p><strong>所有属性都依赖于同一个“超父”属性 $ x_i $</strong>，从而在保留部分依赖关系的同时避免完全联合概率的计算。</p>
</blockquote>
<p><strong>(1) 贝叶斯定理展开</strong></p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) = \frac{P(\mathbf{x}, c)}{P(\mathbf{x})}</script><p>其中：</p>
<ul>
<li>$ P(\mathbf{x}, c) $：联合概率，表示特征 $ \mathbf{x} $ 和类别 $ c $ 同时发生的概率。</li>
<li>$ P(\mathbf{x}) $：证据（归一化因子）。</li>
</ul>
<p><strong>(2) 引入“超父”属性 $ x_i $</strong></p>
<p>假设所有属性 $ x_j (j \neq i) $ 在类别 $ c $ 下仅依赖于 $ x_i $，则：</p>
<script type="math/tex; mode=display">
P(\mathbf{x}, c) = P(c, x_i) \cdot P(x_1, \dots, x_{i-1}, x_{i+1}, \dots, x_d | c, x_i)</script><p>进一步分解为：</p>
<script type="math/tex; mode=display">
P(\mathbf{x}, c) = P(c, x_i) \cdot \prod_{j \neq i} P(x_j | c, x_i)</script><p><strong>(3) 最终形式</strong></p>
<p>由于 $ P(\mathbf{x}) $ 对所有类别相同，可忽略，最终决策规则为：</p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) \propto P(c, x_i) \cdot \prod_{j=1}^d P(x_j | c, x_i)</script><p>其中：</p>
<ul>
<li>$ P(c, x_i) $：类别 $ c $ 和属性 $ x_i $ 的联合概率。</li>
<li>$ P(x_j | c, x_i) $：在类别 $ c $ 和 $ x_i $ 的条件下，属性 $ x_j $ 的概率。</li>
</ul>
<h5 id="树增强朴素贝叶斯（TAN-Tree-Augmented-Naive-Bayes）"><a href="#树增强朴素贝叶斯（TAN-Tree-Augmented-Naive-Bayes）" class="headerlink" title="树增强朴素贝叶斯（TAN: Tree-Augmented Naive Bayes）"></a><strong>树增强朴素贝叶斯（TAN: Tree-Augmented Naive Bayes）</strong></h5><p><strong>TAN</strong>（Tree-Augmented Naive Bayes）是<strong>半朴素贝叶斯分类器</strong>的一种扩展，旨在通过引入属性间的<strong>树状依赖关系</strong>，在保留计算效率的同时，显著提升分类性能。它结合了<strong>贝叶斯网络</strong>的建模能力和<strong>生成式模型</strong>的概率推理优势。</p>
<p><strong>1. 核心思想</strong></p>
<p>TAN 的核心假设是：</p>
<blockquote>
<p><strong>所有属性（特征）在类别 $ c $ 的基础上，形成一个以属性为节点的树状依赖结构</strong>，即每个属性最多依赖一个其他属性（父属性），且整个依赖图是一棵无环的树。</p>
</blockquote>
<p><strong>数学表达</strong>：</p>
<script type="math/tex; mode=display">
P(c|\mathbf{x}) \propto P(c) \cdot \prod_{i=1}^d P(x_i | c, pa_i)</script><p>其中：</p>
<ul>
<li>$ pa_i $：属性 $ x_i $ 的父属性（依赖的单一属性）。</li>
<li>$ P(x_i | c, pa_i) $：在类别 $ c $ 和父属性 $ pa_i $ 的条件下，属性 $ x_i $ 的条件概率。</li>
</ul>
<p><strong>2. TAN 的构建步骤</strong></p>
<p>TAN 通过以下步骤构建属性间的依赖结构：</p>
<p><strong>(1) 计算互信息（Mutual Information）</strong></p>
<p>互信息衡量两个属性之间的相关性：</p>
<script type="math/tex; mode=display">
I(x_i, x_j) = \sum_{x_i, x_j} P(x_i, x_j) \log \frac{P(x_i, x_j)}{P(x_i)P(x_j)}</script><ul>
<li><strong>含义</strong>：互信息越大，两个属性之间的依赖关系越强。</li>
</ul>
<p><strong>(2) 构建带权图</strong></p>
<ul>
<li>将所有属性视为图中的节点。</li>
<li>每对属性间的边权重设为互信息 $ I(x_i, x_j) $。</li>
</ul>
<p><strong>(3) 最大带权生成树（Maximum Weight Spanning Tree, MWST）</strong></p>
<p>使用克鲁斯卡尔（Kruskal）算法或普里姆（Prim）算法，选择一棵连接所有属性节点的树，使得：</p>
<ul>
<li>树的边权重（互信息）总和最大。</li>
<li>树中无环。</li>
</ul>
<p><strong>(4) 确定依赖方向</strong></p>
<ul>
<li>随机选择一个根节点（或根据领域知识指定）。</li>
<li>从根节点出发，确定每条边的方向（父属性 → 子属性）。</li>
</ul>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250605223036362.png" alt="image-20250605223036362"></p>
<h4 id="贝叶斯网"><a href="#贝叶斯网" class="headerlink" title="贝叶斯网"></a>贝叶斯网</h4><p>待学习</p>
<h4 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h4><p>EM算法（Expectation-Maximization Algorithm）是一种<strong>迭代优化算法</strong>，用于处理<strong>含有隐变量</strong>（Hidden Variables）或<strong>缺失数据</strong>的概率模型参数估计问题。它的核心思想是通过交替执行<strong>期望（E）步</strong>和<strong>最大化（M）步</strong>，逐步逼近模型参数的最大似然估计。</p>
<h5 id="1-核心思想：解决隐变量问题"><a href="#1-核心思想：解决隐变量问题" class="headerlink" title="1. 核心思想：解决隐变量问题"></a><strong>1. 核心思想：解决隐变量问题</strong></h5><p><strong>(1) 什么是隐变量？</strong></p>
<p>隐变量（Latent Variables）是模型中<strong>不可观测但影响观测数据</strong>的变量。例如：</p>
<ul>
<li><strong>混合高斯模型（GMM）</strong>：每个样本属于哪个高斯分布是隐变量。</li>
<li><strong>聚类任务</strong>：样本所属的聚类标签是隐变量。</li>
</ul>
<p><strong>(2) 问题挑战</strong></p>
<p>当存在隐变量时，直接最大化似然函数变得困难。例如：</p>
<script type="math/tex; mode=display">
\log P(\mathbf{x}|\theta) = \log \sum_z P(\mathbf{x}, z|\theta)</script><p>其中 $ z $ 是隐变量，$ \theta $ 是模型参数。由于对数中包含求和，直接求导无法分离参数。</p>
<p><strong>(3) EM算法的解决方案</strong></p>
<p>EM算法通过以下步骤迭代求解：</p>
<ol>
<li><strong>E步（期望）</strong>：用当前参数估计隐变量的后验分布（即“责任”分配）。</li>
<li><strong>M步（最大化）</strong>：基于隐变量的后验分布，最大化期望似然函数以更新参数。</li>
</ol>
<h5 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a><strong>2. 算法流程</strong></h5><p><strong>(1) 初始化参数</strong></p>
<p>选择初始参数 $ \theta^{(0)} $，例如随机初始化或通过启发式方法设定。</p>
<p><strong>(2) E步：计算隐变量后验分布</strong></p>
<p>给定当前参数 $ \theta^{(t)} $，计算隐变量 $ z $ 的后验概率：</p>
<script type="math/tex; mode=display">
Q^{(t)}(z) = P(z|\mathbf{x}, \theta^{(t)})</script><p>这一步为每个样本分配隐变量的概率分布（如样本属于某个聚类的概率）。</p>
<p><strong>(3) M步：最大化期望似然</strong></p>
<p>基于 $ Q^{(t)}(z) $，构造期望似然函数并最大化：</p>
<script type="math/tex; mode=display">
\theta^{(t+1)} = \arg\max_{\theta} \sum_z Q^{(t)}(z) \log P(\mathbf{x}, z|\theta)</script><p>这一步更新参数 $ \theta $，使得期望似然最大。</p>
<p><strong>(4) 收敛判断</strong></p>
<p>重复E步和M步直到参数收敛（如 $ |\theta^{(t+1)} - \theta^{(t)}| &lt; \epsilon $）或达到最大迭代次数。</p>
<h5 id="3-示例：混合高斯模型（GMM）"><a href="#3-示例：混合高斯模型（GMM）" class="headerlink" title="3. 示例：混合高斯模型（GMM）"></a><strong>3. 示例：混合高斯模型（GMM）</strong></h5><p>假设数据由多个高斯分布生成，但不知道每个样本属于哪个分布。</p>
<p><strong>(1) 模型定义</strong></p>
<ul>
<li>观测变量 $ x_i \in \mathbb{R}^d $：第 $ i $ 个样本。</li>
<li>隐变量 $ z_i \in {1, …, K} $：样本 $ x_i $ 所属的高斯分布。</li>
<li>参数 $ \theta = {\mu<em>k, \Sigma_k, \pi_k}</em>{k=1}^K $：<ul>
<li>$ \mu_k $：第 $ k $ 个高斯分布的均值。</li>
<li>$ \Sigma_k $：第 $ k $ 个高斯分布的协方差矩阵。</li>
<li>$ \pi_k $：第 $ k $ 个高斯分布的权重（先验概率）。</li>
</ul>
</li>
</ul>
<p><strong>(2) E步：计算责任分配</strong></p>
<p>对于每个样本 $ x_i $ 和类别 $ k $，计算责任（responsibility）：</p>
<script type="math/tex; mode=display">
\gamma_{ik}^{(t)} = P(z_i=k|x_i, \theta^{(t)}) = \frac{\pi_k^{(t)} \mathcal{N}(x_i|\mu_k^{(t)}, \Sigma_k^{(t)})}{\sum_{j=1}^K \pi_j^{(t)} \mathcal{N}(x_i|\mu_j^{(t)}, \Sigma_j^{(t)})}</script><p>含义：在当前参数下，样本 $ x_i $ 属于类别 $ k $ 的概率。</p>
<p><strong>(3) M步：更新参数</strong></p>
<p>根据责任 $ \gamma_{ik} $ 更新参数：</p>
<ul>
<li><strong>均值更新</strong>：<script type="math/tex; mode=display">
\mu_k^{(t+1)} = \frac{\sum_{i=1}^N \gamma_{ik}^{(t)} x_i}{\sum_{i=1}^N \gamma_{ik}^{(t)}}</script></li>
<li><strong>协方差更新</strong>：<script type="math/tex; mode=display">
\Sigma_k^{(t+1)} = \frac{\sum_{i=1}^N \gamma_{ik}^{(t)} (x_i - \mu_k^{(t+1)})(x_i - \mu_k^{(t+1)})^T}{\sum_{i=1}^N \gamma_{ik}^{(t)}}</script></li>
<li><strong>权重更新</strong>：<script type="math/tex; mode=display">
\pi_k^{(t+1)} = \frac{\sum_{i=1}^N \gamma_{ik}^{(t)}}{N}</script></li>
</ul>
<p><strong>(4) 迭代终止</strong></p>
<p>当参数变化小于阈值或达到最大迭代次数时停止。</p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606143758565.png" alt="image-20250606143758565"></p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606143819352.png" alt="image-20250606143819352"></p>
<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>已知观测数据-67，-48，6，8，14，16，23，24，28，29，41，49，56，60，75，试估计两个分量的高斯混合模型的5个参数。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606150830535.png" alt="image-20250606150830535"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化观测数据</span></span><br><span class="line">data = np.array([-<span class="number">67</span>, -<span class="number">48</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">56</span>, <span class="number">60</span>,</span><br><span class="line">                 <span class="number">75</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚类</span></span><br><span class="line">gmmModel = GaussianMixture(n_components=<span class="number">2</span>)</span><br><span class="line">gmmModel.fit(data)</span><br><span class="line">labels = gmmModel.predict(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;labels =&quot;</span>, labels)</span><br><span class="line">labels = [<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(labels)):</span><br><span class="line">    <span class="keyword">if</span> labels[i] == <span class="number">0</span>:</span><br><span class="line">        plt.scatter(i, data.take(i), s=<span class="number">15</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> labels[i] == <span class="number">1</span>:</span><br><span class="line">        plt.scatter(i, data.take(i), s=<span class="number">15</span>, c=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Gaussian Mixture Model&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;means =&quot;</span>, gmmModel.means_.reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;covariances =&quot;</span>, gmmModel.covariances_.reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;weights = &quot;</span>, gmmModel.weights_.reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606150906475.png" alt="image-20250606150906475"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># means = [[ 32.98489643 -57.51107027]]</span></span><br><span class="line"><span class="comment"># covariances = [[429.45764867  90.24987882]]</span></span><br><span class="line"><span class="comment"># weights =  [[0.86682762 0.13317238]]</span></span><br></pre></td></tr></table></figure>
<h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><p>简要阐述下EM算法的原理，并给出EM算法对高斯混合模型GMM进行求解的具体过程。</p>
<h6 id="EM算法的原理"><a href="#EM算法的原理" class="headerlink" title="EM算法的原理"></a>EM算法的原理</h6><p>EM算法（期望最大化算法）是一种用于含有隐变量的概率模型参数估计的迭代优化方法。其核心思想是通过交替执行两个步骤来最大化观测数据的似然函数：</p>
<ol>
<li><strong>E步（期望步）</strong>：计算隐变量的后验期望（即责任），给定当前参数估计。</li>
<li><strong>M步（最大化步）</strong>：基于责任，最大化完全数据的期望似然函数以更新参数。</li>
</ol>
<p>EM算法通过不断优化似然函数的下界，最终收敛到局部最优解。以下具体阐述EM算法对高斯混合模型（GMM）的求解过程。</p>
<h6 id="EM算法对GMM的具体求解过程"><a href="#EM算法对GMM的具体求解过程" class="headerlink" title="EM算法对GMM的具体求解过程"></a><strong>EM算法对GMM的具体求解过程</strong></h6><p><strong>1. GMM模型定义</strong></p>
<p>GMM假设数据由 $ K $ 个高斯分布线性组合生成，其概率密度函数为：</p>
<script type="math/tex; mode=display">
p(\mathbf{x}|\theta) = \sum_{k=1}^K \alpha_k \cdot \mathcal{N}(\mathbf{x}|\mu_k, \Sigma_k)</script><p>其中：</p>
<ul>
<li>$ \alpha<em>k $：第 $ k $ 个高斯分布的权重（$ \sum</em>{k=1}^K \alpha_k = 1 $）。</li>
<li>$ \mu_k $：第 $ k $ 个高斯分布的均值向量。</li>
<li>$ \Sigma_k $：第 $ k $ 个高斯分布的协方差矩阵。</li>
<li>$ \theta = {\alpha<em>k, \mu_k, \Sigma_k}</em>{k=1}^K $：模型参数。</li>
</ul>
<p>隐变量 $ z_i \in {1,\dots,K} $ 表示样本 $ \mathbf{x}_i $ 的类别标签（未知）。</p>
<p><strong>2. EM算法步骤</strong></p>
<p><strong>(1) 初始化参数</strong></p>
<p>随机或通过K-means初始化：</p>
<ul>
<li>每个高斯分布的均值 $ \mu_k^{(0)} $、协方差 $ \Sigma_k^{(0)} $、权重 $ \alpha_k^{(0)} $。</li>
</ul>
<p><strong>(2) 迭代优化（E步与M步）</strong></p>
<p><strong>E步：计算责任（后验概率）</strong><br>对每个样本 $\mathbf{x}_i$ 和每个簇 $ k $，计算其属于第 $ k $ 个高斯分布的后验概率</p>
<script type="math/tex; mode=display">
\gamma(z_{ik}) = \frac{\alpha_k \cdot \mathcal{N}(\mathbf{x}_i | \mu_k, \Sigma_k)}{\sum_{j=1}^K \alpha_j \cdot \mathcal{N}(\mathbf{x}_i | \mu_j, \Sigma_j)}</script><p>此概率表示在当前参数下，样本 $ \mathbf{x}_i $ 属于第 $ k $ 个高斯分布的“责任”。</p>
<p><strong>M步：更新参数</strong><br>基于责任 $ \gamma(z_{ik}) $，最大化完全数据似然函数的期望，更新参数：</p>
<ul>
<li><strong>权重更新</strong>：<script type="math/tex; mode=display">
\alpha_k^{(new)} = \frac{1}{N} \sum_{i=1}^N \gamma(z_{ik})</script></li>
<li><strong>均值更新</strong>：<script type="math/tex; mode=display">
\mu_k^{(new)} = \frac{\sum_{i=1}^N \gamma(z_{ik}) \mathbf{x}_i}{\sum_{i=1}^N \gamma(z_{ik})}</script></li>
<li><strong>协方差更新</strong>：<script type="math/tex; mode=display">
\Sigma_k^{(new)} = \frac{\sum_{i=1}^N \gamma(z_{ik}) (\mathbf{x}_i - \mu_k^{(new)})(\mathbf{x}_i - \mu_k^{(new)})^\top}{\sum_{i=1}^N \gamma(z_{ik})}</script>若为单变量高斯分布，则更新方差：<script type="math/tex; mode=display">
\sigma_k^{(new)} = \frac{\sum_{i=1}^N \gamma(z_{ik}) (x_i - \mu_k^{(new)})^2}{\sum_{i=1}^N \gamma(z_{ik})}</script></li>
</ul>
<p><strong>(3) 收敛判断</strong></p>
<p>计算对数似然函数：</p>
<script type="math/tex; mode=display">
\log p(\mathbf{X}|\theta) = \sum_{i=1}^N \log \left( \sum_{k=1}^K \alpha_k \cdot \mathcal{N}(\mathbf{x}_i|\mu_k, \Sigma_k) \right)</script><p>若对数似然的变化量小于阈值或达到最大迭代次数，则停止；否则重复E步和M步。。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RT411G7jJ/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">[5分钟学算法] #06 EM算法 你到底是哪个班级的_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/396007256">《统计学习方法_第二版》学习笔记第九章 - 知乎</a></p>
<h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><h4 id="个体与集成"><a href="#个体与集成" class="headerlink" title="个体与集成"></a>个体与集成</h4><h5 id="集成学习的基本概念"><a href="#集成学习的基本概念" class="headerlink" title="集成学习的基本概念"></a><strong>集成学习的基本概念</strong></h5><p>集成学习（Ensemble Learning）通过构建并结合<strong>多个学习器（基模型）</strong>来完成学习任务，其核心思想是“<strong>优而不同</strong>”，即<strong>通过多个弱学习器的协作提升整体性能</strong>，通常能获得比单一学习器更优的泛化能力 。 </p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606154731476.png" alt="image-20250606154731476"> </p>
<p>在上图的集成模型中，若个体学习器都属于同一类别，例如都是决策树或都是神经网络，则称该集成为同质的（homogeneous）;若个体学习器包含多种类型的学习算法，例如既有决策树又有神经网络，则称该集成为异质的（heterogenous）。</p>
<blockquote>
<p><strong>同质集成</strong>：个体学习器称为“基学习器”（base learner），对应的学习算法为“基学习算法”（base learning algorithm）。 </p>
<p><strong>异质集成</strong>：个体学习器称为“组件学习器”（component learner）或直称为“个体学习器”。</p>
</blockquote>
<p>集成学习的两个重要概念：<strong>准确性</strong>和<strong>多样性</strong>（diversity）。准确性指的是个体学习器不能太差，要有一定的准确度；多样性则是个体学习器之间的输出要具有差异性。</p>
<p>通过下面的这三个例子可以很容易看出这一点，准确度较高，差异度也较高，可以较好地提升集成性能。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606155939884.png" alt="image-20250606155939884"></p>
<p><strong>集成策略</strong>：如何结合多个基模型的预测结果，例如：  </p>
<ul>
<li><strong>投票法</strong>（Voting）：多数投票（硬投票）或概率加权（软投票）。  </li>
<li><strong>加权平均法</strong>：对基模型的输出赋予不同权重 。  </li>
<li><strong>Stacking</strong>：用元模型（Meta-Model）学习基模型的输出作为新特征 。</li>
</ul>
<h5 id="基于投票法的集成个体学习器的收敛性保证："><a href="#基于投票法的集成个体学习器的收敛性保证：" class="headerlink" title="基于投票法的集成个体学习器的收敛性保证："></a><strong>基于投票法的集成个体学习器的收敛性保证</strong>：</h5><p><strong>公式解析</strong></p>
<script type="math/tex; mode=display">
P(H(\boldsymbol{x}) \neq f(\boldsymbol{x})) = \sum_{k=0}^{\lfloor T/2 \rfloor} \binom{T}{k} (1-\epsilon)^k \epsilon^{T-k} \leq \exp\left(-\frac{1}{2} T (1 - 2\epsilon)^2\right)</script><p><strong>1. 公式含义</strong></p>
<ul>
<li><strong>$H(\boldsymbol{x})$</strong>：集成学习器的最终预测结果（如多数投票结果）。</li>
<li><strong>$f(\boldsymbol{x})$</strong>：真实标记。</li>
<li><strong>$\epsilon$</strong>：单个弱学习器的错误率（即 $P(h_t(\boldsymbol{x}) \neq f(\boldsymbol{x}))$），默认小于0.5。</li>
<li><strong>$T$</strong>：基学习器的数量。</li>
<li><strong>左边</strong>：集成学习器预测错误的概率（即至少有超过 $T/2$ 个基学习器预测错误的概率）。</li>
<li><strong>右边</strong>：对左边概率的指数级上限估计。</li>
</ul>
<p><strong>2. 推导思路</strong></p>
<ul>
<li>假设每个基学习器独立且错误率为 $\epsilon$，则错误次数服从<strong>二项分布</strong> $B(T, \epsilon)$。</li>
<li>集成错误的条件是“超过半数基学习器错误”，即错误次数 $k \leq \lfloor T/2 \rfloor$。</li>
</ul>
<p><strong>两个基本结论</strong></p>
<p><strong>1. 收敛速率随个体学习器数量 $T$ 指数下降</strong></p>
<ul>
<li><strong>数学体现</strong>：错误概率的上界是 $\exp(-cT)$ 形式，其中 $c = \frac{1}{2}(1 - 2\epsilon)^2$。</li>
</ul>
<p><strong>2. $\epsilon = 0.5$ 的个体学习器对收敛没有作用</strong></p>
<ul>
<li><strong>数学原因</strong>：当 $\epsilon = 0.5$ 时，$(1 - 2\epsilon)^2 = 0$，指数项变为 0，错误概率上界为 $\exp(0) = 1$，即错误概率无法降低。</li>
</ul>
<p>根据个体学习器的<strong>生成方式</strong>，目前集成学习可分为两类，代表作如下：</p>
<ol>
<li>个体学习器直接存在强依赖关系，必须串行生成的序列化方法：<strong>Boosting</strong>；</li>
<li>个体学习器间不存在强依赖关系，可以同时生成的并行化方法：<strong>Bagging</strong> 和 <strong>随机森林 (Random Forest)</strong>。</li>
</ol>
<h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a><strong>Boosting</strong></h4><p>Boosting是一种<strong>串行</strong>的工作机制，即<strong>个体学习器的训练存在依赖关系</strong>，必须一步一步序列化进行。</p>
<p>其<strong>基本思想</strong>是：<strong>增加前一个基学习器在训练过程中预测错误样本的权重，使得后续基学习器更加关注这些打标错误的训练样本，尽可能纠正这些错误，然后基于调整后的样本分布训练下一个基学习器</strong>，如此重复，一直向下串行直至产生需要的T个基学习器，Boosting最终对这T个学习器进行加权结合，产生学习器委员会。</p>
<p>Boosting族算法最著名、使用最为广泛的就是<strong>AdaBoost</strong>，因此下面主要是对AdaBoost算法进行介绍。</p>
<p>AdaBoost使用的是<strong>指数损失函数</strong>，因此AdaBoost的权值与样本分布的更新都是围绕着最小化指数损失函数进行的。</p>
<blockquote>
<p>看到这里回想一下之前的机器学习算法，<strong>不难发现机器学习的大部分带参模型只是改变了最优化目标中的损失函数</strong>：如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是log-Loss，那就是Logistic Regression了。</p>
</blockquote>
<h5 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h5><h5 id="公式解析"><a href="#公式解析" class="headerlink" title="公式解析"></a><strong>公式解析</strong></h5><script type="math/tex; mode=display">
H(\boldsymbol{x}) = \sum_{t=1}^T \alpha_t h_t(\boldsymbol{x})</script><script type="math/tex; mode=display">
\ell_{\exp}(H | \mathcal{D}) = \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}} \left[ e^{-f(\boldsymbol{x}) H(\boldsymbol{x})} \right]</script><p><strong>1. 符号含义</strong></p>
<ul>
<li><strong>$H(\boldsymbol{x})$</strong>：最终集成模型的预测结果，是 $T$ 个基学习器 $h_t(\boldsymbol{x})$ 的加权和。</li>
<li><strong>$\alpha_t$</strong>：第 $t$ 个基学习器的权重，表示其在集成中的重要性。</li>
<li><strong>$h_t(\boldsymbol{x})$</strong>：第 $t$ 个基学习器（如决策树、感知机等）。</li>
<li><strong>$f(\boldsymbol{x})$</strong>：真实标签，通常取值为 ${-1, +1}$（二分类问题）。</li>
<li><strong>$\mathcal{D}$</strong>：训练数据分布。</li>
<li><strong>$\ell_{\exp}$</strong>：指数损失函数（Exponential Loss）。</li>
</ul>
<p><strong>2. 指数损失函数的意义</strong></p>
<p>指数损失函数的形式为：</p>
<script type="math/tex; mode=display">
\ell_{\exp}(H | \mathcal{D}) = \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}} \left[ e^{-f(\boldsymbol{x}) H(\boldsymbol{x})} \right]</script><ul>
<li><strong>直观解释</strong>：<ul>
<li>当 $H(\boldsymbol{x})$ 与 $f(\boldsymbol{x})$ 同号时（预测正确），指数项 $e^{-f(\boldsymbol{x}) H(\boldsymbol{x})}$ 接近 0，损失小。</li>
<li>当 $H(\boldsymbol{x})$ 与 $f(\boldsymbol{x})$ 异号时（预测错误），指数项趋近于正无穷，损失极大。</li>
<li>因此，该损失函数对错误样本的惩罚非常严格，迫使模型优先修正错误。</li>
</ul>
</li>
</ul>
<h5 id="AdaBoost的优化目标"><a href="#AdaBoost的优化目标" class="headerlink" title="AdaBoost的优化目标"></a><strong>AdaBoost的优化目标</strong></h5><p>AdaBoost的目标是选择基学习器 $h_t$ 和权重 $\alpha_t$，使得集成模型 $H(\boldsymbol{x})$ 能够<strong>最小化指数损失函数</strong>：</p>
<script type="math/tex; mode=display">
\min_{\alpha_1, h_1, \dots, \alpha_T, h_T} \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}} \left[ e^{-f(\boldsymbol{x}) \sum_{t=1}^T \alpha_t h_t(\boldsymbol{x})} \right]</script><p><strong>优化策略</strong></p>
<p>AdaBoost采用<strong>前向分步算法（Forward Stagewise Algorithm）</strong>，逐轮迭代优化：</p>
<ol>
<li><strong>初始化样本权重</strong>：初始时所有样本权重相等。</li>
<li><strong>训练基学习器 $h_t$</strong>：在当前样本权重分布下，训练一个弱学习器 $h_t$。</li>
<li><strong>计算权重 $\alpha_t$</strong>：根据 $h_t$ 的错误率 $\epsilon_t$ 计算其权重：<script type="math/tex; mode=display">
\alpha_t = \frac{1}{2} \ln \left( \frac{1 - \epsilon_t}{\epsilon_t} \right)</script></li>
<li><strong>更新样本权重</strong>：提高被 $h_t$ 错分类样本的权重，降低正确分类样本的权重。</li>
<li><strong>重复步骤 2-4</strong>，直到训练完成 $T$ 轮。</li>
</ol>
<h5 id="示例：二分类问题-1"><a href="#示例：二分类问题-1" class="headerlink" title="示例：二分类问题"></a><strong>示例：二分类问题</strong></h5><p>假设一个二分类任务，真实标签 $f(\boldsymbol{x}) \in {-1, +1}$，集成模型预测值 $H(\boldsymbol{x}) = \sum_{t=1}^T \alpha_t h_t(\boldsymbol{x})$：</p>
<ul>
<li>若 $H(\boldsymbol{x}) &gt; 0$，预测为 $+1$；</li>
<li>若 $H(\boldsymbol{x}) &lt; 0$，预测为 $-1$。</li>
</ul>
<p>此时，指数损失函数的值反映了模型对错误样本的惩罚程度：</p>
<ul>
<li>正确预测时，$e^{-f(\boldsymbol{x}) H(\boldsymbol{x})} \approx 0$；</li>
<li>错误预测时，$e^{-f(\boldsymbol{x}) H(\boldsymbol{x})} \gg 1$。</li>
</ul>
<h5 id="AdaBoost的算法流程"><a href="#AdaBoost的算法流程" class="headerlink" title="AdaBoost的算法流程"></a>AdaBoost的算法流程</h5><p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606172851748.png" alt="image-20250606172851748"></p>
<h5 id="重赋权法与重采样法"><a href="#重赋权法与重采样法" class="headerlink" title="重赋权法与重采样法"></a>重赋权法与重采样法</h5><p>在集成学习中，<strong>Boosting 算法的核心在于动态调整样本权重</strong> ，以逐步聚焦难分类样本。Boosting 主要通过两种方法实现样本权重的更新：<strong>重赋权法（re-weighting）</strong> 和 <strong>重采样法（re-sampling）</strong> 。</p>
<blockquote>
<p><strong>重赋权法</strong> : 对每个样本附加一个权重，这时涉及到样本属性与标签的计算，都需要乘上一个权值。 <strong>重采样法</strong> : 对于一些无法接受带权样本的及学习算法，适合用“重采样法”进行处理。方法大致过程是，根据各个样本的权重，对训练数据进行重采样，初始时样本权重一样，每个样本被采样到的概率一致，每次从N个原始的训练样本中按照权重有放回采样N个样本作为训练集，然后计算训练集错误率，然后调整权重，重复采样，集成多个基学习器。</p>
</blockquote>
<p>从偏差-方差分解来看：Boosting算法主要关注于降低偏差，每轮的迭代都关注于训练过程中预测错误的样本，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成学习器。</p>
<h5 id="拓展：Gradient-Boosting"><a href="#拓展：Gradient-Boosting" class="headerlink" title="拓展：Gradient Boosting"></a>拓展：Gradient Boosting</h5><p>任务分为分类，回归，聚类，降维等，而分类中还分为二分类和多分类</p>
<p>从AdaBoost的算法流程来看，标准的AdaBoost只适用于二分类问题。</p>
<p>通过改造AdaBoost对样本分类的限制和损失函数，可以实现多分类或回归问题，这样改造出来的算法框架成为<strong>Gradient Boosting</strong></p>
<h6 id="GBDT（Gradient-Boosting-Decision-Tree）与XGBoost"><a href="#GBDT（Gradient-Boosting-Decision-Tree）与XGBoost" class="headerlink" title="GBDT（Gradient Boosting Decision Tree）与XGBoost"></a><strong>GBDT（Gradient Boosting Decision Tree）与XGBoost</strong></h6><p><strong>1. GBDT 的核心思想</strong></p>
<p>GBDT 是基于<strong>梯度提升（Gradient Boosting）</strong>框架的集成学习方法，其特点包括：</p>
<ul>
<li><strong>基学习器</strong>：使用<strong>CART（分类与回归树）</strong>作为个体学习器。</li>
<li><strong>损失函数</strong>：<ul>
<li><strong>回归问题</strong>：平方损失（Squared Loss）：<script type="math/tex; mode=display">
\text{err}(H_t(\boldsymbol{x}), f(\boldsymbol{x})) = (H_t(\boldsymbol{x}) - f(\boldsymbol{x}))^2</script></li>
<li><strong>二分类问题</strong>：对数似然损失（Log-Likelihood Loss，类似逻辑回归）：<script type="math/tex; mode=display">
\text{err}(H_t(\boldsymbol{x}), f(\boldsymbol{x})) = \log(1 + \exp(-f(\boldsymbol{x}) H_t(\boldsymbol{x})))</script></li>
<li><strong>多分类问题</strong>：扩展为多分类对数损失。</li>
</ul>
</li>
</ul>
<p><strong>2. XGBoost 的定位</strong></p>
<p>XGBoost（eXtreme Gradient Boosting）是 GBDT 的一种<strong>高效实现和改进</strong>，类似于 LIBSVM 对 SVM 的优化关系。其核心目标是：</p>
<ul>
<li><strong>提升训练速度</strong>：通过<strong>并行计算</strong>、<strong>内存优化</strong>等工程技巧。</li>
<li><strong>增强模型性能</strong>：引入<strong>正则化项</strong>、<strong>缺失值处理</strong>、<strong>自适应学习率</strong>等改进。</li>
</ul>
<blockquote>
<p>XGBoost即eXtremeGradient Boosting的缩写，XGBoost与GBDT的关系可以类比为<br>LIBSVM和SVM的关系，即XGBoOst是GBDT的一种高效实现和改进。</p>
<p>它并非一个全新的算法框架，而是对标准 GBDT 进行了<strong>大量的工程优化和算法增强</strong>。</p>
</blockquote>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606175536310.png" alt="image-20250606175536310"></p>
<h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><p>Bagging是一种<strong>并行式</strong>的集成学习方法，即<strong>基学习器的训练之间没有前后顺序可以同时进行</strong></p>
<p>Bagging使用<strong>“有放回”采样的方式选取训练集</strong>，对于包含m个样本的训练集，进行m次有放回的随机采样操作，从而得到m个样本的采样集，这样训练集中有<strong>接近36.8%</strong>的样本没有被采到，可用作验证集来对泛化性能进行“包外估计”(out-of-bag estimate)。</p>
<p>按照相同的方式重复进行，我们就可以采集到T个包含m个样本的数据集，从而训练出<strong>T个基学习器</strong>，最终对<strong>这T个基学习器的输出进行结合</strong>。</p>
<h5 id="Bagging与Boosting的差异"><a href="#Bagging与Boosting的差异" class="headerlink" title="Bagging与Boosting的差异"></a>Bagging与Boosting的差异</h5><p>Boosting算法一大特点是串行，这样诚然可以降低模型的偏差，增强拟合能力，但是当数据过大时，一大缺点就是会降低学习效率</p>
<p>Bagging作为并行式的集成学习方法，通过综合多个基学习器的结果，可以增加学习效率</p>
<p>二者差异性：</p>
<p>1.对目标的拟合程度：Boosting对目标有更好的拟合能力（偏差小）；Bagging则偏差相对大一些</p>
<p>2.运行效率：由于并行的特点，Bagging的运行效率是大于Boosting的</p>
<p>3.泛化能力：由于Bagging每个学习器不会受其他学习器的影响，泛化能力（方差大）相对于Boosting</p>
<p>更好</p>
<h5 id="Bagging的算法流程"><a href="#Bagging的算法流程" class="headerlink" title="Bagging的算法流程"></a>Bagging的算法流程</h5><p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606182733022.png" alt="image-20250606182733022"></p>
<p>可以看出Bagging主要通过<strong>样本的扰动</strong>来增加基学习器之间的多样性，因此Bagging的基学习器应为那些对训练集十分敏感的不稳定学习算法，例如：神经网络与决策树等。</p>
<p>从偏差-方差分解来看，Bagging算法主要关注于降低方差，即通过多次重复训练提高稳定性。</p>
<p>不同于AdaBoost的是，Bagging可以十分简单地移植到多分类、回归等问题。总的说起来则是：<strong>AdaBoost关注于降低偏差，而Bagging关注于降低方差。</strong></p>
<h5 id="自助采样法（Bootstrap-Sampling）"><a href="#自助采样法（Bootstrap-Sampling）" class="headerlink" title="自助采样法（Bootstrap Sampling）"></a>自助采样法（Bootstrap Sampling）</h5><p>在机器学习中，<strong>自助采样法（Bootstrap Sampling）</strong> 是 Bagging 算法的核心技术之一。其核心思想是从原始数据集中有放回地随机抽取样本，形成新的训练子集。这一过程的一个重要数学性质是：当样本量 $n$ 趋近于无穷大时，每个样本在 Bootstrap 样本集中<strong>未被抽中</strong>的概率趋近于 $\frac{1}{e} \approx 36.6\%$。以下是详细解析：</p>
<p><strong>1. 公式推导</strong></p>
<p>假设我们从 $n$ 个样本中<strong>有放回地</strong>抽取 $n$ 次，形成一个 Bootstrap 样本集。对于任意一个特定样本（如第 $i$ 个样本），它在某次抽样中<strong>未被选中</strong>的概率为：</p>
<script type="math/tex; mode=display">
1 - \frac{1}{n}</script><p>因此，它在整个 $n$ 次抽样中<strong>从未被选中</strong>的概率为：</p>
<script type="math/tex; mode=display">
\left(1 - \frac{1}{n}\right)^n</script><p>当 $n \to \infty$ 时，该概率的极限为：</p>
<script type="math/tex; mode=display">
\lim_{n \to \infty} \left(1 - \frac{1}{n}\right)^n = \frac{1}{e} \approx 0.3679 \quad (\text{即 } 36.6\%)</script><p>在每次 Bootstrap 采样中，约有 <strong>36.6% 的样本未被选中</strong> ，这些样本称为 <strong>Out-of-Bag（OOB，包外估计）样本</strong> 。</p>
<p><strong>2. OOB 样本的应用</strong></p>
<p>在 Bagging 算法中，OOB 样本具有以下重要作用：</p>
<ol>
<li><strong>无偏验证</strong>：<br>每个基学习器的训练数据不包含其对应的 OOB 样本，因此可以用这些样本直接评估模型性能（即 OOB 误差），无需额外的交叉验证。</li>
<li><strong>特征重要性评估</strong>：<br>在随机森林中，通过比较 OOB 样本在打乱某个特征后的预测误差变化，可以衡量该特征的重要性。</li>
</ol>
<p><strong>3. 与其他采样方法的对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>采样方法</strong></th>
<th><strong>是否放回</strong></th>
<th><strong>样本覆盖范围</strong></th>
<th><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bootstrap 采样</strong></td>
<td>是</td>
<td>约 63.4% 样本被重复使用</td>
<td>Bagging、随机森林</td>
</tr>
<tr>
<td><strong>简单随机采样</strong></td>
<td>否</td>
<td>所有样本唯一出现</td>
<td>传统交叉验证</td>
</tr>
</tbody>
</table>
</div>
<h5 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h5><p>随机森林（Random Forest）是Bagging的一个拓展体，它的基学习器固定为<strong>决策树</strong>，多棵树也就组成了森林，而<strong>“随机”则在于选择划分属性的随机</strong>，随机森林在训练基学习器时，也采用有放回采样的方式添加样本扰动，同时它还引入了一种<strong>属性扰动</strong>，即在基决策树的训练过程中，在选择划分属性时，RF先从候选属性集中随机挑选出一个包含K个属性的子集，再从这个子集中选择最优划分属性 。</p>
<p>这样随机森林中基学习器的<strong>多样性不仅来自样本扰动，还来自属性扰动</strong>，从而进一步提升了基学习器之间的差异度。相比决策树的Bagging集成，随机森林的起始性能较差（由于属性扰动，基决策树的准确度有所下降），但随着基学习器数目的增多，随机森林往往会收敛到更低的泛化误差。同时不同于Bagging中决策树从所有属性集中选择最优划分属性，<strong>随机森林只在属性集的一个子集中选择划分属性，因此训练效率更高</strong>。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606184958951.png" alt="image-20250606184958951"></p>
<h4 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h4><p>在集成学习中，结合策略是将多个基学习器的输出整合为最终预测结果的关键步骤。以下是针对回归和分类问题的不同结合策略及其核心要点：</p>
<p><strong>定义</strong>：在训练好多个基学习器后，如何将其输出组合成集成模型的最终输出。</p>
<h5 id="1-平均法（回归问题）"><a href="#1-平均法（回归问题）" class="headerlink" title="1.平均法（回归问题）"></a><strong>1.平均法（回归问题）</strong></h5><ol>
<li><p><strong>简单平均法（Simple Averaging）</strong>  </p>
<ul>
<li><strong>公式</strong>：  <script type="math/tex; mode=display">
H(x) = \frac{1}{T} \sum_{i=1}^{T} h_i(x)</script></li>
<li><strong>特点</strong>：  <ul>
<li>直接对所有基学习器的预测结果取算术平均。  </li>
<li>计算简单，适合基学习器性能相近的场景。  </li>
<li>若部分基学习器表现较差，可能拖累整体性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>加权平均法（Weighted Averaging）</strong>  </p>
<ul>
<li><strong>公式</strong>：  <script type="math/tex; mode=display">
H(x) = \sum_{i=1}^{T} w_i h_i(x)</script>其中，$ w<em>i \geq 0 $ 且 $ \sum</em>{i=1}^{T} w_i = 1 $。  </li>
<li><strong>特点</strong>：  <ul>
<li>通过权重 $ w_i $ 调节各基学习器的贡献，灵活性更高。  </li>
<li>适用于基学习器性能差异较大的情况，可提升鲁棒性。  </li>
<li>权重可通过验证集性能（如RMSE、MAE）或优化算法（如梯度下降）确定。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="2-投票法（分类问题）"><a href="#2-投票法（分类问题）" class="headerlink" title="2.投票法（分类问题）"></a><strong>2.投票法（分类问题）</strong></h5><ol>
<li><p><strong>简单投票法（Majority Voting）</strong>  </p>
<ul>
<li><strong>原理</strong>：<br>每个基学习器对样本进行分类投票，最终结果由得票最多的类别决定。  </li>
<li><strong>公式</strong>（二分类示例）：  <script type="math/tex; mode=display">
H(x) = 
\begin{cases} 
1 & \text{若} \sum_{i=1}^{T} I(h_i(x) = 1) > T/2 \\
0 & \text{否则}
\end{cases}</script>其中，$ I(\cdot) $ 为指示函数。  </li>
<li><strong>特点</strong>：  <ul>
<li>简单高效，适合基学习器性能相近的场景。  </li>
<li>对异常分类器的鲁棒性较弱。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>加权投票法（Weighted Voting）</strong>  </p>
<ul>
<li><strong>原理</strong>：<br>给不同基学习器分配权重，最终结果由加权票数最高的类别决定。  </li>
<li><strong>公式</strong>（二分类示例）：  <script type="math/tex; mode=display">
H(x) = 
\begin{cases} 
1 & \text{若} \sum_{i=1}^{T} w_i I(h_i(x) = 1) > 0.5 \sum_{i=1}^{T} w_i \\
0 & \text{否则}
\end{cases}</script></li>
<li><strong>特点</strong>：  <ul>
<li>权重可根据基学习器的验证集准确率或领域知识设定。  </li>
<li>更适合处理性能差异较大的基学习器。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>绝对多数投票法（majority voting）提供了拒绝选项，这在可靠性要求很高的学习任务中是一个很好的机制。同时，对于分类任务，各个基学习器的输出值有两种类型，分别为类标记和类概率。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250606195241433.png" alt="image-20250606195241433"></p>
<p>一些在产生类别标记的同时也生成置信度的学习器，置信度可转化为类概率使用，<strong>一般基于类概率进行结合往往比基于类标记进行结合的效果更好</strong>，需要注意的是对于异质集成，其类概率不能直接进行比较，此时需要将类概率转化为类标记输出，然后再投票。</p>
<h5 id="3-学习法（Stacking）"><a href="#3-学习法（Stacking）" class="headerlink" title="3.学习法（Stacking）"></a><strong>3.学习法（Stacking）</strong></h5><p><strong>学习法</strong>是一种更高级的结合策略，其核心思想是通过训练一个<strong>次级学习器（Meta-Learner）</strong> 来动态融合多个基学习器的输出。其中，<strong>Stacking（堆叠泛化）</strong> 是学习法的典型代表，它通过将基学习器的预测结果作为新特征，进一步训练一个次级模型，最终实现更优的泛化性能。</p>
<p><strong>Stacking 的基本原理</strong></p>
<p><strong>步骤概述</strong>：  </p>
<ul>
<li><strong>训练基学习器</strong>：使用原始数据训练 $ T $ 个基学习器（如决策树、SVM、神经网络等）。  </li>
<li><strong>生成新特征</strong>：对于每个样本，将 $ T $ 个基学习器的输出（预测结果）作为该样本的新特征，形成一个 $ m \times T $ 的数据集（$ m $ 为样本数量）。  </li>
<li><strong>训练次级学习器</strong>：使用新数据集（基学习器输出 + 真实标签）训练一个次级学习器（如逻辑回归、梯度提升树等），该学习器负责融合基学习器的预测结果。  </li>
</ul>
<p><strong>Stacking 的优势</strong></p>
<ol>
<li><strong>动态权重分配</strong>：<br>次级学习器可以自动学习基学习器的权重，无需人工设定。例如，若某个基学习器表现优异，次级学习器会赋予其更高的权重。  </li>
<li><strong>异质模型融合</strong>：<br>可以混合不同类型的基学习器（如线性模型与树模型），充分利用各自的特性。  </li>
<li><strong>提升泛化能力</strong>：<br>次级学习器通过学习基学习器的输出模式，能够捕捉更复杂的决策边界。</li>
</ol>
<p><strong>Stacking 的实现细节</strong></p>
<ol>
<li><p><strong>数据划分</strong>：  </p>
<ul>
<li>通常需将原始数据分为两部分：  <ul>
<li><strong>训练集</strong>：用于训练基学习器。  </li>
<li><strong>验证集</strong>：用于生成基学习器的输出（避免过拟合）。  </li>
</ul>
</li>
<li>或采用交叉验证（如 $ k $-折）生成基学习器的预测结果，确保次级学习器的训练数据不被污染。</li>
</ul>
</li>
<li><p><strong>基学习器输出类型</strong>：  </p>
<ul>
<li><strong>分类任务</strong>：基学习器输出类概率（Soft Voting），而非类别标签（Hard Voting）。例如，逻辑回归输出 $ P(c_j | x) $，随机森林输出节点样本的类别分布。  </li>
<li><strong>回归任务</strong>：基学习器直接输出预测值（如线性回归的 $\hat{y}$）。</li>
</ul>
</li>
<li><p><strong>次级学习器选择</strong>：  </p>
<ul>
<li><strong>多响应线性回归（MLR）</strong>：适用于基学习器输出可加权平均的情况，计算简单且鲁棒。  <script type="math/tex; mode=display">
H(x) = \sum_{i=1}^{T} w_i h_i(x)</script></li>
<li><strong>复杂模型</strong>：如梯度提升树、神经网络，可捕捉基学习器输出之间的非线性关系。  </li>
</ul>
</li>
</ol>
<h4 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h4><p>在集成学习中，<strong>多样性增强（Diversity Enhancement）</strong> 是提升模型性能的关键策略。通过引入多样性，可以降低基学习器之间的相关性，从而减少误差传递和过拟合风险。以下是四种常见的多样性增强方法及其核心要点：</p>
<p><strong>1. 数据样本扰动（Data Perturbation）</strong></p>
<p><strong>原理</strong>：通过修改训练数据的分布或采样方式，使每个基学习器看到不同的数据子集。  </p>
<p><strong>实现方式</strong>：  </p>
<ul>
<li><strong>Bagging（如随机森林）</strong>：  <ul>
<li>随机有放回地采样（Bootstrap），生成多个不同的训练集。  </li>
<li>对输入扰动敏感的基学习器（如决策树、神经网络）效果显著。  </li>
</ul>
</li>
<li><strong>示例</strong>：  <ul>
<li>决策树对数据扰动敏感，Bagging 可有效提升其泛化能力。  </li>
<li>线性模型（如线性回归、SVM）对数据扰动不敏感，Bagging 效果有限。  </li>
</ul>
</li>
</ul>
<p><strong>2. 输入属性扰动（Input Attribute Perturbation）</strong></p>
<p><strong>原理</strong>：通过改变输入特征的表示或选择，增加基学习器间的差异。  </p>
<p><strong>实现方式</strong>：  </p>
<ul>
<li><strong>特征子集采样</strong>：每次随机选择部分特征进行训练（如随机森林中的列扰动）。  </li>
<li><strong>特征变换</strong>：对特征进行缩放、旋转或加噪声等操作。  </li>
<li><strong>适用场景</strong>：  <ul>
<li>数据包含大量冗余属性时，可大幅加速训练并提升多样性。  </li>
<li>对高维数据（如图像、文本）尤其有效。  </li>
</ul>
</li>
</ul>
<p><strong>3. 输出属性扰动（Output Attribute Perturbation）</strong></p>
<p><strong>原理</strong>：通过修改训练样本的标签，间接影响基学习器的学习过程。  </p>
<p><strong>实现方式</strong>：  </p>
<ul>
<li><strong>随机翻转标签</strong>：对部分样本的标记进行随机更改（需谨慎使用，避免干扰模型）。  </li>
<li><strong>Dropout（神经网络）</strong>：  <ul>
<li>在训练过程中随机“关闭”部分神经元，强制网络学习更鲁棒的特征。  </li>
<li>类似于对输出属性的随机扰动，可提升模型泛化能力。  </li>
</ul>
</li>
</ul>
<p><strong>4. 算法参数扰动（Algorithm Parameter Perturbation）</strong></p>
<p><strong>原理</strong>：通过调整基学习器的超参数，生成不同的模型行为。  </p>
<p><strong>实现方式</strong>：  </p>
<ul>
<li><strong>正则化方法</strong>：L1/L2 正则化（如 Ridge、Lasso）限制模型复杂度，降低过拟合风险。 </li>
<li><strong>随机初始化</strong>：  神经网络的随机权重初始化可能导致收敛到不同局部最优解。  </li>
</ul>
<h4 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h4><h5 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h5><p>集成学习中常见的两种方法是什么？请分别介绍它们的原理和特点。集成学习相比于单个模型有什么优势和应用场景？</p>
<p><strong>集成学习常见方法、原理、特点及优势</strong></p>
<p><strong>常见方法</strong>：Bagging 和 Boosting<br><strong>原理与特点</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>原理</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bagging</strong></td>
<td>1. <strong>自助采样</strong>：从训练集有放回抽取多个子集<br>2. <strong>并行训练</strong>基模型<br>3. <strong>聚合预测</strong>（投票/平均）</td>
<td>- 降低方差<br>- 适合高方差模型（如未剪枝决策树）<br>- 并行化，训练快<br>- 代表：随机森林</td>
</tr>
<tr>
<td><strong>Boosting</strong></td>
<td>1. <strong>顺序训练</strong>：后一个模型修正前一个模型的错误<br>2. <strong>加权困难样本</strong><br>3. <strong>加权组合</strong>模型</td>
<td>- 降低偏差<br>- 需弱学习器（如树桩）<br>- 易过拟合（需正则化）<br>- 代表：AdaBoost, GBDT, XGBoost</td>
</tr>
</tbody>
</table>
</div>
<p><strong>集成学习的优势</strong>：  </p>
<ul>
<li><strong>提升泛化能力</strong>：降低过拟合（Bagging）或欠拟合（Boosting）风险  </li>
<li><strong>增强鲁棒性</strong>：减少异常值/噪声影响（如投票机制）  </li>
<li><strong>突破性能上限</strong>：组合多个弱模型达到强模型效果  </li>
</ul>
<p><strong>应用场景</strong>：  </p>
<ul>
<li><strong>分类任务</strong>：医疗诊断（整合多模型减少误诊）  </li>
<li><strong>回归任务</strong>：房价预测（融合不同树模型提升精度）  </li>
<li><strong>不平衡数据</strong>：Boosting 加权少数类样本  </li>
<li><strong>高维数据</strong>：随机森林自动特征选择  </li>
</ul>
<h5 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h5><p>如果在完全相同的训练集上训练了五个不同的模型，并且它们都达到了95%的准确率，是否还有机会通过结合这些模型来获得更好的结果？如果可以，该怎么做？如果不行，为什么？</p>
<p><strong>模型结合提升性能的可能性与方法</strong></p>
<p><strong>是否可能提升</strong>：<strong>是</strong>，但需满足条件：<strong>模型错误不相关</strong>（即犯错样本不同）。  </p>
<p><strong>如何实现</strong>：  </p>
<ol>
<li><strong>投票法（分类）</strong>：  <ul>
<li>多数投票：5个模型对样本 (x) 的预测为 ([A, A, B, A, C]) → 最终输出 (A)  </li>
<li><strong>关键要求</strong>：模型存在<strong>多样性</strong>（如使用SVM、决策树等不同算法）  </li>
</ul>
</li>
<li><strong>加权平均（回归）</strong>：  <ul>
<li>若模型精度不同，分配权重：$ y_{\text{final}} = w_1 y_1 + w_2 y_2 + \dots + w_5 y_5$</li>
<li>权重可通过验证集性能确定  </li>
</ul>
</li>
</ol>
<p><strong>若无法提升的情况</strong>：  </p>
<ul>
<li><strong>原因</strong>：模型高度相关（如相同算法、相同特征、相同超参）  </li>
<li><strong>数学解释</strong>：误差相关性 $rho \approx 1$ 时，集成误差 $\approx$单一模型误差  </li>
</ul>
<h5 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h5><p>是否可以通过在多个服务器上并行来加速随机森林的训练？AdaBoost集成呢？为什么？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>是否支持并行</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>随机森林</strong></td>
<td>✅ <strong>是</strong></td>
<td>1. 树之间独立训练<br>2. 可分布式分配Bootstrap样本到不同服务器<br>3. 特征分裂也可并行（如选特征子集）</td>
</tr>
<tr>
<td><strong>AdaBoost</strong></td>
<td>❌ <strong>否</strong></td>
<td>1. 模型必须<strong>顺序训练</strong>：后一个模型依赖前一个模型的样本权重更新<br>2. 无法解耦迭代过程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><h4 id="聚类任务"><a href="#聚类任务" class="headerlink" title="聚类任务"></a><strong>聚类任务</strong></h4><blockquote>
<p>我们之前学习的分类/回归任务都属于 有监督学习 需要我们提供样本与标签</p>
<p>而马上要学习的聚类任务和后续学习的降维则属于 无监督学习 仅需提供样本</p>
</blockquote>
<p>聚类是一种经典的<strong>无监督学习</strong>(unsupervised learning)方法，<strong>无监督学习的目标是通过对无标记训练样本的学习，发掘和揭示数据集本身潜在的结构与规律</strong>，即不依赖于训练数据集的类标记信息。</p>
<p>聚类试图将数据集中的样本划分为若干个通常是不相交的子集,<strong>每个子集称为一个“簇”( cluster)</strong>。通过这样的划分,每簇可能对应于一些潜在的概念(类别),如“浅色瓜”“深色瓜”,“有籽瓜”“无籽瓜”,甚至“本地瓜”“外地瓜”等;需说明的是,这些概念对聚类算法而言事先是未知的,聚类过程仅能自动形成簇结构, <strong>簇所对应的概念语义需由使用者来把握和命名</strong>。</p>
<p>直观上来说，聚类是将相似的样本聚在一起，从而形成一个<strong>类簇（cluster）</strong>。涉及两个问题</p>
<ul>
<li>如何<strong>度量相似性</strong>（similarity measure），这便是<strong>距离度量</strong>(distance measure)，在生活中我们说差别小则相似，对应到多维样本，每个样本可以对应于高维空间中的一个数据点，若它们的距离相近，我们便可以称它们相似。</li>
<li>如何<strong>评价聚类结果</strong>，这便是<strong>性能度量</strong>(validity index)</li>
</ul>
<h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><h5 id="连续-离散有序"><a href="#连续-离散有序" class="headerlink" title="连续/离散有序"></a>连续/离散有序</h5><p><strong>明可夫斯基距离（Minkowski Distance）</strong></p>
<p>明可夫斯基距离是一组常用的<strong>连续型距离度量</strong>，通过调整参数 $ p $ 可以统一表示多种距离形式，是欧氏距离和曼哈顿距离的推广。</p>
<p><strong>1. 公式定义</strong></p>
<p>对于两个 $ n $ 维向量 $ \boldsymbol{x}<em>i = (x</em>{i1}, x<em>{i2}, \dots, x</em>{in}) $ 和 $ \boldsymbol{x}<em>j = (x</em>{j1}, x<em>{j2}, \dots, x</em>{jn}) $，明可夫斯基距离的计算公式为：</p>
<script type="math/tex; mode=display">
\text{dist}_{\text{mk}}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \left( \sum_{u=1}^{n} |x_{iu} - x_{ju}|^p \right)^{\frac{1}{p}}</script><p>其中，$ p \geq 1 $ 是一个可调节的参数。</p>
<p><strong>2. 特殊情况</strong></p>
<ul>
<li><p><strong>当 $ p = 2 $</strong>：退化为<strong>欧氏距离（Euclidean Distance）</strong>  </p>
<script type="math/tex; mode=display">
\text{dist}_{\text{ed}}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \sqrt{\sum_{u=1}^{n} |x_{iu} - x_{ju}|^2}</script><ul>
<li><strong>几何意义</strong>：两点之间的直线距离。  </li>
<li><strong>适用场景</strong>：大多数机器学习算法（如KNN、PCA）默认使用欧氏距离。</li>
</ul>
</li>
<li><p><strong>当 $ p = 1 $</strong>：退化为<strong>曼哈顿距离（Manhattan Distance）</strong>  </p>
<script type="math/tex; mode=display">
\text{dist}_{\text{man}}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \sum_{u=1}^{n} |x_{iu} - x_{ju}|</script><ul>
<li><strong>几何意义</strong>：沿坐标轴移动的总距离（如棋盘格路径）。  </li>
<li><strong>适用场景</strong>：高维稀疏数据（如文本特征）、计算资源受限的场景。</li>
</ul>
</li>
<li><p><strong>当 $ p \to \infty $</strong>：退化为<strong>切比雪夫距离（Chebyshev Distance）</strong>  </p>
<script type="math/tex; mode=display">
\text{dist}_{\text{che}}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \max_{u} |x_{iu} - x_{ju}|</script><ul>
<li><strong>几何意义</strong>：各维度差值的最大值。  </li>
<li><strong>适用场景</strong>：关注最坏情况下的误差（如游戏AI路径规划）。</li>
</ul>
</li>
</ul>
<p><strong>3. 参数 $ p $ 的影响</strong></p>
<ul>
<li><strong>$ p $ 越小</strong>：距离计算越关注较小的维度差异（如曼哈顿距离对单个维度的扰动更敏感）。  </li>
<li><strong>$ p $ 越大</strong>：距离计算越关注较大的维度差异（如切比雪夫距离仅关注最大差值）。  </li>
<li><strong>选择依据</strong>：  <ul>
<li>数据分布是否均匀：若某些维度差异显著，可增大 $ p $。  </li>
<li>算法需求：如KNN中，高维数据可能更适合曼哈顿距离（缓解“维度灾难”）。</li>
</ul>
</li>
</ul>
<h5 id="离散无序"><a href="#离散无序" class="headerlink" title="离散无序"></a>离散无序</h5><p>我们知道属性分为两种：<strong>连续属性</strong>(continuous attribute)和<strong>离散属性</strong>（catergorical attribute有限个取值）。对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；而对于离散值的属性，需要作下面进一步的处理：</p>
<blockquote>
<p>若属性值之间<strong>存在序关系</strong>(ordinal attribute)，则可以将其转化为连续值，例如：身高属性“高”“中等”“矮”，可转化为{1, 0.5, 0}。 </p>
<p>若属性值之间<strong>不存在序关系</strong>(non-ordinal attribute)，则通常将其转化为向量的形式，例如：性别属性“男”“女”，可转化为{（1,0）,（0,1）}。</p>
</blockquote>
<p><strong>连续属性和存在序关系的离散属性都可以直接参与计算</strong>，而不存在序关系的<strong>无序属性，我们一般采用VDM（Value Difference Metric）进行距离的计算</strong></p>
<p>VDM 是一种专门用于<strong>离散无序属性</strong>的距离度量方法，通过统计信息量化不同类别间的差异。其核心思想是：<strong>若两个类别的样本在目标变量上的分布差异越大，则它们的距离越大</strong>。</p>
<p><strong>1. 公式解析</strong></p>
<script type="math/tex; mode=display">
\text{VDM}_p(a, b) = \sum_{i=1}^{k} \left| \frac{m_{u,a,i}}{m_{u,a}} - \frac{m_{u,b,i}}{m_{u,b}} \right|^p</script><ul>
<li><strong>符号含义</strong>：  <ul>
<li>$ a, b $：两个不同的类别值（如性别“男”和“女”）。  </li>
<li>$ m_{u,a,i} $：在属性 $ u $ 的第 $ i $ 个取值下，类别 $ a $ 的样本数量。  </li>
<li>$ m_{u,a} $：类别 $ a $ 的总样本数量。  </li>
<li>$ k $：属性 $ u $ 的不同取值数目（如颜色属性有红、蓝、绿三种取值，则 $ k=3 $）。  </li>
<li>$ p $：距离幂指数（通常取 $ p=1 $ 或 $ p=2 $）。</li>
</ul>
</li>
</ul>
<p><strong>2. 核心思想</strong></p>
<ul>
<li><strong>统计分布差异</strong>：<br>对于每个属性取值 $ i $，计算类别 $ a $ 和 $ b $ 的样本比例差异：  <script type="math/tex; mode=display">
\left| \frac{m_{u,a,i}}{m_{u,a}} - \frac{m_{u,b,i}}{m_{u,b}} \right|</script>该值越大，说明两个类别在该取值上的分布差异越大。  </li>
<li><strong>加权求和</strong>：<br>将所有属性取值的差异按 $ p $ 次方加权求和，得到最终的距离。</li>
</ul>
<p><strong>3. 示例说明</strong></p>
<p>假设我们有一个“颜色”属性（红、蓝、绿），目标变量是“是否购买商品”（0/1）。统计结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>颜色</th>
<th>购买（1）</th>
<th>不购买（0）</th>
<th>总计</th>
</tr>
</thead>
<tbody>
<tr>
<td>红</td>
<td>10</td>
<td>5</td>
<td>15</td>
</tr>
<tr>
<td>蓝</td>
<td>8</td>
<td>12</td>
<td>20</td>
</tr>
<tr>
<td>绿</td>
<td>3</td>
<td>7</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>计算“红”与“蓝”之间的 VDM 距离（$ p=1 $）：</p>
<ol>
<li>计算每个颜色在购买/不购买的比例：  <ul>
<li>红：$ P(1) = 10/15 \approx 0.67 $，$ P(0) = 5/15 \approx 0.33 $  </li>
<li>蓝：$ P(1) = 8/20 = 0.4 $，$ P(0) = 12/20 = 0.6 $  </li>
</ul>
</li>
<li>计算差异并求和：  <script type="math/tex; mode=display">
\text{VDM}_1(\text{红}, \text{蓝}) = |0.67 - 0.4| + |0.33 - 0.6| = 0.27 + 0.27 = 0.54</script></li>
</ol>
<h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><p>于聚类算法不依赖于样本的真实类标，就不能像监督学习的分类那般，通过计算分对分错（即精确度或错误率）来评价学习器的好坏或作为学习过程中的优化目标。</p>
<p>直观上看,我们希望<strong>“物以类聚”</strong>,即同一簇的样本尽可能彼此相似,不同簇的样本尽可能不同换言之,聚类结果的<strong>“簇内相似度”( intra-cluster similarity)高且“簇间相似度” inter-cluster similarity)低</strong></p>
<p><strong>聚类性能度量有两类</strong></p>
<ul>
<li>“外部指标”(external index)：所谓外部指标就是已经有一个“参考模型”存在了，将当前模型与参考模型的比对结果作为指标。</li>
<li>“内部指标”( internal index)：所谓内部指标就是仅仅考虑当前模型的聚类结果。</li>
</ul>
<h5 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h5><p><strong>1.基本概念</strong></p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607110103570.png" alt="image-20250607110103570"></p>
<p>显然，$ a + b + c + d = \frac{m(m-1)}{2} $ 。</p>
<p><strong>2. 常用外部指标</strong></p>
<p><strong>（1）Jaccard系数（JC）</strong></p>
<script type="math/tex; mode=display">
\text{JC} = \frac{a}{a + b + c}</script><ul>
<li><strong>含义</strong>：衡量两个划分的重叠程度，仅考虑正确匹配（$ a $）与矛盾情况（$ b + c $）。  </li>
<li><strong>范围</strong>：$ [0, 1] $，值越大越好。  </li>
<li><strong>特点</strong>：对称性差，对噪声敏感 。</li>
</ul>
<p><strong>（2）Fowlkes-Mallows指数（FMI）</strong></p>
<script type="math/tex; mode=display">
\text{FMI} = \sqrt{\frac{a}{a + b} \cdot \frac{a}{a + c}}</script><ul>
<li><strong>含义</strong>：结合查准率（$ \frac{a}{a + c} $）和查全率（$ \frac{a}{a + b} $），反映正确匹配的综合能力。  </li>
<li><strong>范围</strong>：$ [0, 1] $，值越大越好。  </li>
<li><strong>特点</strong>：平衡性较好，适合小样本 。</li>
</ul>
<p><strong>（3）Rand指数（RI）</strong></p>
<script type="math/tex; mode=display">
\text{RI} = \frac{2(a + d)}{m(m - 1)}</script><ul>
<li><strong>含义</strong>：同时考虑正确匹配（$ a + d $）与总样本对数，适用于大规模数据。  </li>
<li><strong>范围</strong>：$ [0, 1] $，值越大越好。  </li>
<li><strong>特点</strong>：计算简单，但对噪声较鲁棒 。</li>
</ul>
<p><strong>常用指标</strong></p>
<ul>
<li><p><strong>调整兰德指数（Adjusted Rand Index, ARI）</strong>  </p>
<ul>
<li><strong>定义</strong>：衡量聚类结果与真实标签的匹配程度，调整随机聚类的影响，取值范围 [-1, 1]，值越大越好。  </li>
<li><strong>公式</strong>：  <script type="math/tex; mode=display">
\text{ARI} = \frac{\text{RI} - \mathbb{E}[\text{RI}]}{\max(\text{RI}) - \mathbb{E}[\text{RI}]}</script>其中 RI 是兰德指数（匹配样本对的比例）。</li>
</ul>
</li>
<li><p><strong>归一化互信息（Normalized Mutual Information, NMI）</strong>  </p>
<ul>
<li><strong>定义</strong>：衡量聚类结果与真实标签的信息共享程度，值越大越好。  </li>
<li><strong>公式</strong>：  <script type="math/tex; mode=display">
\text{NMI} = \frac{I(C; K)}{\sqrt{H(C) H(K)}}</script>其中 $ I(C; K) $ 是互信息，$ H(C) $ 和 $ H(K) $ 是熵。</li>
</ul>
</li>
<li><p><strong>Fowlkes-Mallows 指数（FMI）</strong>  </p>
<ul>
<li><strong>定义</strong>：基于聚类结果与真实标签的 TP、FP、TN、FN 计算，值越大越好。  </li>
<li><strong>公式</strong>：  <script type="math/tex; mode=display">
\text{FMI} = \sqrt{\frac{\text{TP}}{\text{TP} + \text{FP}} \cdot \frac{\text{TP}}{\text{TP} + \text{FN}}}</script></li>
</ul>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>在有真实标签时，能更客观地评估聚类效果。</li>
<li>适用于验证聚类结果的业务意义（如客户分群是否符合预期）。</li>
</ul>
<p><strong>局限性</strong></p>
<ul>
<li>需要真实标签，不适用于纯无监督任务。</li>
<li>对标签噪声敏感（如标签错误会误导 $ K $ 的选择）。</li>
</ul>
<p><strong>3. 应用示例</strong></p>
<p>假设一个包含4个样本的数据集，参考标签为 ${A, A, B, B}$，聚类结果为 ${C, C, D, D}$：</p>
<ul>
<li><strong>计算样本对</strong>：  <ul>
<li>$ a = 2 $（样本1-2同簇，参考与聚类均同类）。  </li>
<li>$ b = 0 $（参考同类但聚类不同类）。  </li>
<li>$ c = 0 $（参考不同类但聚类同类）。  </li>
<li>$ d = 2 $（参考不同类且聚类不同类）。  </li>
</ul>
</li>
<li><strong>指标结果</strong>：  <ul>
<li>JC = $ \frac{2}{2+0+0} = 1 $（完美匹配）。  </li>
<li>FMI = $ \sqrt{\frac{2}{2+0} \cdot \frac{2}{2+0}} = 1 $。  </li>
<li>RI = $ \frac{2(2+2)}{4 \times 3} = \frac{8}{12} \approx 0.67 $。</li>
</ul>
</li>
</ul>
<h5 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h5><p>内部指标不依赖任何外部参考模型，直接通过<strong>簇内紧凑性</strong>和<strong>簇间分离性</strong>评估聚类结果。其核心思想是：</p>
<ul>
<li><strong>簇内高内聚</strong>：同一簇的样本尽可能相似（距离小）。  </li>
<li><strong>簇间低耦合</strong>：不同簇的样本尽可能不同（距离大）。</li>
</ul>
<p><strong>1. 基本定义</strong></p>
<p>设聚类结果为 $ C = {C_1, C_2, \dots, C_k} $，定义以下四个关键距离：</p>
<p><strong>（1）簇内平均距离（avg(C)）</strong></p>
<script type="math/tex; mode=display">
\text{avg}(C) = \frac{2}{|C|(|C| - 1)} \sum_{1 \leq i < j \leq |C|} \text{dist}(\boldsymbol{x}_i, \boldsymbol{x}_j)</script><ul>
<li><strong>含义</strong>：簇内所有样本对的平均距离。  </li>
<li><strong>目标</strong>：越小越好，表示簇内样本更紧密。</li>
</ul>
<p><strong>（2）簇内最大距离（diam(C)）</strong></p>
<script type="math/tex; mode=display">
\text{diam}(C) = \max_{1 \leq i < j \leq |C|} \text{dist}(\boldsymbol{x}_i, \boldsymbol{x}_j)</script><ul>
<li><strong>含义</strong>：簇内最远的两个样本之间的距离。  </li>
<li><strong>目标</strong>：越小越好，避免簇内存在离群点。</li>
</ul>
<p><strong>（3）簇间最小距离（$ d_{\min}(C_i, C_j) $）</strong></p>
<script type="math/tex; mode=display">
d_{\min}(C_i, C_j) = \min_{\boldsymbol{x}_i \in C_i, \boldsymbol{x}_j \in C_j} \text{dist}(\boldsymbol{x}_i, \boldsymbol{x}_j)</script><ul>
<li><strong>含义</strong>：簇 $ C_i $ 和 $ C_j $ 之间最近的两个样本的距离。  </li>
<li><strong>目标</strong>：越大越好，表示簇间分离度高。</li>
</ul>
<p><strong>（4）簇中心距离（$ d_{\text{cen}}(C_i, C_j) $）</strong></p>
<script type="math/tex; mode=display">
d_{\text{cen}}(C_i, C_j) = \text{dist}(\boldsymbol{\mu}_i, \boldsymbol{\mu}_j)</script><ul>
<li><strong>含义</strong>：簇 $ C_i $ 和 $ C_j $ 的中心点（均值向量）之间的距离。  </li>
<li><strong>目标</strong>：越大越好，表示簇中心相隔较远。</li>
</ul>
<p><strong>2. 常用内部指标</strong></p>
<p><strong>1. DB指数（Davies-Bouldin Index, DBI）</strong></p>
<ul>
<li><p><strong>公式</strong>：  </p>
<script type="math/tex; mode=display">
\text{DBI} = \frac{1}{k} \sum_{i=1}^{k} \max_{j \neq i} \left( \frac{\text{avg}(C_i) + \text{avg}(C_j)}{d_{\text{cen}}(\mu_i, \mu_j)} \right)</script><ul>
<li><strong>符号含义</strong>：  <ul>
<li>$ k $：簇的数量。  </li>
<li>$ \text{avg}(C_i) $：簇 $ C_i $ 内部样本的平均距离。  </li>
<li>$ d_{\text{cen}}(\mu_i, \mu_j) $：簇 $ C_i $ 和 $ C_j $ 的中心点（均值向量）之间的距离。  </li>
</ul>
</li>
<li><strong>目标</strong>：越小越好。  </li>
<li><strong>核心思想</strong>：对于每个簇 $ C<em>i $，找到与其“最竞争”的簇 $ C_j $（即 $ \frac{\text{avg}(C_i) + \text{avg}(C_j)}{d</em>{\text{cen}}(\mu_i, \mu_j)} $ 最大的簇），并取所有簇的平均值。  </li>
</ul>
</li>
<li><p><strong>示例</strong>：<br>若簇 $ C_1 $ 和 $ C_2 $ 的平均距离分别为 2 和 3，中心距离为 5，则它们的比值为 $ \frac{2+3}{5} = 1 $。若这是 $ C_1 $ 的最大比值，则 $ C_1 $ 对 DBI 的贡献为 1。最终 DBI 是所有簇贡献的平均值。  </p>
</li>
</ul>
<p><strong>2. Dunn指数（Dunn Index, DI）</strong></p>
<ul>
<li><p><strong>公式</strong>：  </p>
<script type="math/tex; mode=display">
\text{DI} = \min_{1 \leq i \leq k} \left\{ \frac{\min_{j \neq i} d_{\min}(C_i, C_j)}{\max_{1 \leq l \leq k} \text{diam}(C_l)} \right\}</script><ul>
<li><strong>符号含义</strong>：  <ul>
<li>$ d_{\min}(C_i, C_j) $：簇 $ C_i $ 和 $ C_j $ 之间的最小距离（最近样本对的距离）。  </li>
<li>$ \text{diam}(C_l) $：簇 $ C_l $ 内的最大距离（最远样本对的距离）。  </li>
</ul>
</li>
<li><strong>目标</strong>：越大越好。  </li>
<li><strong>核心思想</strong>：  <ul>
<li>分子：所有簇对之间的最小距离中的最小值（即最“脆弱”的簇间分离度）。  </li>
<li>分母：所有簇中的最大直径（最“松散”的簇内紧凑度）。  </li>
<li>指数越大，表示簇间分离度高且簇内紧凑。  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：<br>假设簇对 $ (C_1, C_2) $ 的最小距离为 5，簇 $ C_3 $ 的最大直径为 10，则 DI 为 $ \frac{5}{10} = 0.5 $。  </p>
</li>
</ul>
<p><strong>3. 轮廓系数（Silhouette Coefficient）</strong></p>
<ul>
<li><p><strong>单一样本的轮廓系数</strong>：  </p>
<script type="math/tex; mode=display">
s = \frac{b - a}{\max(a, b)}</script><ul>
<li><strong>符号含义</strong>：  <ul>
<li>$ a $：样本到同簇其他样本的平均距离（簇内凝聚度）。  </li>
<li>$ b $：样本到最近簇中样本的平均距离（簇间分离度）。  </li>
</ul>
</li>
<li><strong>取值范围</strong>：$ [-1, 1] $，越接近 1 表示聚类效果越好。  </li>
<li><strong>核心思想</strong>：  <ul>
<li>若 $ a &lt; b $（同簇紧密，异簇疏远），则 $ s &gt; 0 $，样本分类合理。  </li>
<li>若 $ a &gt; b $（同簇松散，异簇更近），则 $ s &lt; 0 $，样本可能被错误分类。  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>整体轮廓系数</strong>：所有样本轮廓系数的平均值。  </p>
</li>
<li><p><strong>示例</strong>：<br>若某样本 $ a = 2 $，$ b = 5 $，则 $ s = \frac{5-2}{5} = 0.6 $，表明该样本分类合理。  </p>
</li>
</ul>
<p><strong>4.肘部法则（Elbow Method）</strong></p>
<p>肘部法则是一种<strong>经验性方法</strong>，常用于确定K-means等聚类算法的最优簇数（$ K $）。其核心思想是通过观察误差平方和（SSE, Sum of Squared Errors）随 $ K $ 值变化的趋势，寻找“肘部点”（即 SSE 下降速度明显减缓的拐点），从而选择最优的 $ K $ 值</p>
<ul>
<li><p><strong>SSE（误差平方和）</strong>：衡量每个样本到其所属簇中心的距离平方和，公式为：</p>
<script type="math/tex; mode=display">
\text{SSE} = \sum_{i=1}^n \|x_i - \mu_{c_i}\|^2</script><p>其中 $ x<em>i $ 是样本点，$ \mu</em>{c_i} $ 是其所属簇中心。</p>
</li>
<li><p><strong>趋势分析</strong>：</p>
<ul>
<li>当 $ K $ 增大时，SSE 会不断减小（因为簇越多，每个簇的样本越密集）。</li>
<li>但当 $ K $ 增加到某个值后，SSE 的下降速度会显著放缓，形成“肘部”形状。</li>
</ul>
</li>
<li><p><strong>肘部点的意义</strong>：<br>肘部点对应的 $ K $ 值是<strong>模型复杂度</strong>（簇数）与<strong>聚类效果</strong>（SSE）之间的平衡点。</p>
</li>
</ul>
<p><strong>指标对比与选择</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>计算方式</strong></th>
<th><strong>目标</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>局限性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>DBI</td>
<td>簇内平均距离与簇中心距离的比值</td>
<td>越小越好</td>
<td>球形簇，需指定 $ k $</td>
<td>对离群点敏感</td>
</tr>
<tr>
<td>Dunn指数</td>
<td>簇间最小距离与簇内最大直径的比值</td>
<td>越大越好</td>
<td>强调簇间分离与簇内紧凑</td>
<td>计算复杂，受离群点影响</td>
</tr>
<tr>
<td>轮廓系数</td>
<td>样本到同簇/异簇的平均距离差</td>
<td>越接近 1 越好</td>
<td>快速评估，适合 K-Means</td>
<td>对非球形簇不敏感</td>
</tr>
</tbody>
</table>
</div>
<h4 id="原型聚类与kmeans"><a href="#原型聚类与kmeans" class="headerlink" title="原型聚类与kmeans"></a>原型聚类与kmeans</h4><h5 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h5><p>原型聚类即“<strong>基于原型的聚类</strong>”（prototype-based clustering），原型表示模板的意思，就是通过参考一个模板向量或模板分布的方式来完成聚类的过程，通常情形下算法先对原型进行初始化,然后对原型进行迭代更新求解。采用不同的原型表、不同的求解方式,将产生不同的算法。</p>
<p>常见的K-Means便是基于簇中心（原型向量）来实现聚类，混合高斯聚类则是基于簇分布（概率模型）来实现聚类。</p>
<h5 id="K-Means-聚类算法详解"><a href="#K-Means-聚类算法详解" class="headerlink" title="K-Means 聚类算法详解"></a><strong>K-Means 聚类算法详解</strong></h5><p><strong>目标函数</strong>：最小化所有样本到其所属簇中心的平方距离之和：  </p>
<script type="math/tex; mode=display">
E = \sum_{i=1}^{k} \sum_{\boldsymbol{x} \in C_i} \|\boldsymbol{x} - \boldsymbol{\mu}_i\|_2^2</script><p>其中，$ \boldsymbol{\mu}<em>i = \frac{1}{|C_i|} \sum</em>{\boldsymbol{x} \in C_i} \boldsymbol{x} $ 是簇 $ C_i $ 的均值向量。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><strong>初始化簇中心</strong>：随机选择 $ k $ 个样本作为初始簇中心。  <ul>
<li><strong>改进方法</strong>：K-Means++ 算法可提升初始中心的质量。  </li>
</ul>
</li>
<li><strong>分配样本到最近簇</strong>：对每个样本 $ \boldsymbol{x} $，计算其到所有簇中心的距离，将其分配到距离最近的簇 $ C_i $。  </li>
<li><strong>更新簇中心</strong>：重新计算每个簇的均值向量 $ \boldsymbol{\mu}_i $。  </li>
<li><strong>迭代终止条件</strong>：  <ul>
<li>达到预设的最大迭代次数；  </li>
<li>簇中心不再显著变化（如变化幅度小于阈值 $ \epsilon $）；  </li>
<li>样本分配不再改变。</li>
</ul>
</li>
</ol>
<p><strong>如何选择 $ k $ 值？</strong></p>
<ul>
<li><strong>肘部法则（Elbow Method）</strong>：绘制 $ k $ 与误差 $ E $ 的关系曲线，选择误差下降显著变缓的 $ k $ 值。  </li>
<li><strong>轮廓系数（Silhouette Coefficient）</strong>：计算每个样本的轮廓系数，选择平均轮廓系数最大的 $ k $。  </li>
</ul>
<h5 id="K-Means的算法流程"><a href="#K-Means的算法流程" class="headerlink" title="K-Means的算法流程"></a>K-Means的算法流程</h5><p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607114743211.png" alt="image-20250607114743211"></p>
<h5 id="K-means"><a href="#K-means" class="headerlink" title="K-means++"></a>K-means++</h5><p>此法相对于 K-means 做出了一个小的改进。在一开始选择 k 个聚类中心时，并不是随机初始化 k 个，而是首先随机出 1 个，然后循环 k−1<em>k</em>−1 次选择剩下的 k-1 个聚类中心。选择的规则是：每次选择最不可能成为新的聚类中心的样本，或者是到所有聚类中心的最小距离最大的样本。</p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h5><p><strong>避免不良初始化</strong> ：传统K-means随机初始化可能导致中心过于集中，而K-means++通过“最大化最小距离”策略，使初始中心分布更均匀。</p>
<h5 id="Bisecting-K-means"><a href="#Bisecting-K-means" class="headerlink" title="Bisecting K-means"></a>Bisecting K-means</h5><p>此法叫做二分 K-means 算法。具体的，在一开始将所有的样本划分为一个簇，然后每次选择一个误差最大的簇进行二分裂，不断分裂直到收敛。这种方法不能使得 Loss 最小，但是可以作为 K-means 算法的一个预热，比如可以通过这种方法得到一个相对合理的簇中心，然后再利用 K-means 算法进行聚类。</p>
<h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a><strong>优势</strong></h5><p><strong>降低计算复杂度</strong> ：每次仅对一个簇进行二分，时间复杂度为 <em>O</em>(<em>k</em>⋅<em>m</em>⋅<em>n</em>) ，适合大规模数据。</p>
<p><strong>提供合理初始中心</strong> ：可作为传统K-means的预处理，减少随机初始化的影响。</p>
<h5 id="LVQ（学习向量量化）"><a href="#LVQ（学习向量量化）" class="headerlink" title="LVQ（学习向量量化）"></a><strong>LVQ（学习向量量化）</strong></h5><p><strong>核心思想</strong>：<br>LVQ 是一种<strong>有监督的原型聚类算法</strong>，结合了神经网络与向量量化技术。它通过维护一组<strong>原型向量</strong>（Prototype Vectors）来代表不同类别，并利用这些原型对数据进行分类或聚类。与 K-Means 类似，LVQ 会为每个簇分配一个原型向量，但其更新规则受类别标签的指导，因此更适用于分类任务 。</p>
<p><strong>算法特点</strong>：  </p>
<ul>
<li><strong>有监督学习</strong>：需要已知类别标签来调整原型向量，使同类样本更接近对应原型，异类样本远离原型。  </li>
<li><strong>拓扑结构建模</strong>：通过原型向量捕捉数据的局部特征，类似于自组织映射（SOM），但更具针对性。  </li>
<li><strong>硬聚类</strong>：每个样本最终被分配到最近的原型对应的类别，不提供概率输出 。</li>
</ul>
<h5 id="高斯混合聚类（Gaussian-Mixture-Model-GMM）"><a href="#高斯混合聚类（Gaussian-Mixture-Model-GMM）" class="headerlink" title="高斯混合聚类（Gaussian Mixture Model, GMM）"></a><strong>高斯混合聚类（Gaussian Mixture Model, GMM）</strong></h5><p> 一句话概述算法：高斯混合聚类算法是一种概率模型，假设数据由多个高斯分布混合而成，通过迭代优化参数以拟合数据分布，常用于无监督学习中的聚类任务。</p>
<p>算法过程：</p>
<p>初始化参数： 随机初始化每个分量的均值、协方差矩阵和混合系数。</p>
<p>E 步（Expectation）： 对每个数据点，计算它属于每个分量的后验概率，即计算每个分量的权重。</p>
<p>M 步（Maximization）： 使用E步计算得到的后验概率，更新每个分量的均值、协方差矩阵和混合系数。</p>
<p>迭代： 重复执行E步和M步，直到模型参数收敛或达到预定的迭代次数。</p>
<p>GMM的优点包括对各种形状和方向的聚类簇建模能力，以及对数据分布的灵活性。它在许多领域，如模式识别、图像处理和自然语言处理等，都有广泛的应用。<br><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250611180451162.png" alt="image-20250611180451162"></p>
<p>以下是高斯混合聚类（GMM）算法的详细步骤及EM算法中E步与M步的解释：</p>
<p><strong>算法流程解析</strong></p>
<p><strong>输入</strong>：样本集 $ D = {x_1, x_2, \dots, x_m} $，混合成分个数 $ k $。<br><strong>输出</strong>：簇划分 $ C = {C_1, C_2, \dots, C_k} $。</p>
<p><strong>步骤详解</strong></p>
<ol>
<li><p><strong>初始化模型参数</strong><br>随机初始化或通过K-means初步估计以下参数：</p>
<ul>
<li><strong>混合系数</strong> $ \alpha<em>i $（满足 $ \sum</em>{i=1}^k \alpha_i = 1 $）。</li>
<li><strong>均值向量</strong> $ \mu_i $。</li>
<li><strong>协方差矩阵</strong> $ \Sigma_i $。</li>
</ul>
</li>
<li><p><strong>迭代优化参数（EM循环）</strong><br>重复以下步骤直到收敛（如对数似然变化小于阈值）：</p>
<ul>
<li><p><strong>E步（期望步）</strong>：<br>对每个样本 $ x<em>j $，计算其由第 $ i $ 个高斯分布生成的<strong>后验概率</strong>（责任度 $ \gamma</em>{ji} $）：</p>
<script type="math/tex; mode=display">
\gamma_{ji} = p(z_j = i | x_j) = \frac{\alpha_i \mathcal{N}(x_j | \mu_i, \Sigma_i)}{\sum_{l=1}^k \alpha_l \mathcal{N}(x_j | \mu_l, \Sigma_l)}</script><p>其中 $ \mathcal{N}(x | \mu, \Sigma) $ 是高斯分布的概率密度函数。</p>
</li>
<li><p><strong>M步（最大化步）</strong>：<br>根据当前的责任度 $ \gamma_{ji} $，更新模型参数：</p>
<ol>
<li><strong>新均值向量</strong>：<script type="math/tex; mode=display">
\mu_i' = \frac{\sum_{j=1}^m \gamma_{ji} x_j}{\sum_{j=1}^m \gamma_{ji}}</script></li>
<li><strong>新协方差矩阵</strong>：<script type="math/tex; mode=display">
\Sigma_i' = \frac{\sum_{j=1}^m \gamma_{ji} (x_j - \mu_i')(x_j - \mu_i')^\top}{\sum_{j=1}^m \gamma_{ji}}</script></li>
<li><strong>新混合系数</strong>：<script type="math/tex; mode=display">
\alpha_i' = \frac{\sum_{j=1}^m \gamma_{ji}}{m}</script></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>簇划分</strong>  </p>
<ul>
<li>初始化空簇 $ C_i = \varnothing $。</li>
<li>对每个样本 $ x<em>j $，计算其属于各簇的后验概率 $ \lambda_j = \arg\max_i \gamma</em>{ji} $。</li>
<li>将 $ x<em>j $ 分配到簇 $ C</em>{\lambda_j} $ 中。</li>
</ul>
</li>
</ol>
<p><strong>E步与M步的核心作用</strong></p>
<p><strong>E步（期望步）</strong></p>
<ul>
<li><strong>目标</strong>：基于当前参数 $ (\alpha<em>i, \mu_i, \Sigma_i) $，计算每个样本 $ x_j $ 属于各高斯分布的<strong>责任度</strong> $ \gamma</em>{ji} $。</li>
<li><strong>意义</strong>：<ul>
<li>责任度反映了在当前模型下，样本 $ x_j $ 由第 $ i $ 个高斯分布生成的概率。</li>
<li><strong>软分配</strong>：允许样本部分属于多个簇，而非硬划分。</li>
</ul>
</li>
</ul>
<p><strong>M步（最大化步）</strong></p>
<ul>
<li><strong>目标</strong>：根据责任度 $ \gamma_{ji} $，重新估计模型参数 $ (\alpha_i’, \mu_i’, \Sigma_i’) $，以最大化数据的对数似然。</li>
<li><strong>关键公式</strong>：<ul>
<li><strong>均值更新</strong>：加权平均样本点，权重为责任度。</li>
<li><strong>协方差更新</strong>：加权样本点的方差，反映簇内数据分布。</li>
<li><strong>混合系数更新</strong>：各簇样本的“有效数量”占总样本的比例。</li>
</ul>
</li>
</ul>
<h4 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/smileyan9/article/details/135398479">西瓜书读书笔记整理（九） —— 第九章 聚类_西瓜书笔记第9章-CSDN博客</a></p>
<h4 id="密度聚类与DBSCAN"><a href="#密度聚类与DBSCAN" class="headerlink" title="密度聚类与DBSCAN"></a>密度聚类与DBSCAN</h4><blockquote>
<p>若样本分布为同心的两个环，kmeans则无法做到良好的聚类效果，因此引出密度聚类</p>
</blockquote>
<p>密度聚类是一种基于<strong>样本分布密集程度</strong>的无监督学习方法，其核心思想是：<strong>将高密度区域划分为同一簇，低密度区域视为噪声或边界</strong>。</p>
<p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise）是密度聚类的典型代表，通过两个关键参数 $ \epsilon $ 和 $ MinPts $ 描述样本分布的紧密性。</p>
<h5 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a><strong>1. 核心概念</strong></h5><ol>
<li><strong>$ \epsilon $-邻域</strong>  <ul>
<li>定义：与样本 $ x $ 距离不超过 $ \epsilon $ 的所有样本集合。  </li>
<li>作用：衡量样本周围的局部密度。  </li>
</ul>
</li>
<li><strong>核心对象（Core Object）</strong>  <ul>
<li>定义：若样本 $ x $ 的 $ \epsilon $-邻域内包含至少 $ MinPts $ 个样本，则 $ x $ 是核心对象。  </li>
<li>作用：作为簇的生长起点，确保簇的最小密度要求。  </li>
</ul>
</li>
<li><strong>密度直达（Directly Density-Reachable）</strong>  <ul>
<li>定义：若样本 $ x_j $ 位于核心对象 $ x_i $ 的 $ \epsilon $-邻域内，则称 $ x_i $ 可密度直达 $ x_j $。  </li>
<li>作用：建立核心对象与邻近样本的直接连接。  </li>
</ul>
</li>
<li><strong>密度可达（Density-Reachable）</strong>  <ul>
<li>定义：若存在样本序列 $ x<em>i, p_1, p_2, \dots, p_n, x_j $，其中 $ p_i $ 密度直达 $ p</em>{i+1} $，则称 $ x_i $ 可密度可达 $ x_j $。  </li>
<li>作用：通过链式传递扩展簇的范围。  </li>
</ul>
</li>
<li><strong>密度相连（Density-Connected）</strong>  <ul>
<li>定义：若样本 $ x_i $ 和 $ x_j $ 均可密度可达某个公共样本 $ x_k $，则称 $ x_i $ 和 $ x_j $ 密度相连。  </li>
<li>作用：确保簇的连通性，避免碎片化。  </li>
</ul>
</li>
</ol>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607124326529.png" alt="image-20250607124326529"></p>
<p><strong>DBSCN定义的簇</strong></p>
<ul>
<li>定义：最大密度相连的样本集合为一个簇</li>
<li>有两个性质：1.连接性：同一个簇内任意两样本，必然密度相连2.最大性：密度可达的两个样本必<br>定属于同一个簇</li>
</ul>
<h5 id="2-DBSCAN-算法流程"><a href="#2-DBSCAN-算法流程" class="headerlink" title="2. DBSCAN 算法流程"></a><strong>2. DBSCAN 算法流程</strong></h5><p>简单来理解DBSCAN：<strong>找出一个核心对象所有密度可达的样本集合形成簇</strong>。首先从数据集中任选一个核心对象A，找出所有A密度可达的样本集合，将这些样本形成一个密度相连的类簇，直到所有的核心对象都遍历完。DBSCAN算法的流程如下图所示：</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607124446432.png" alt="image-20250607124446432"></p>
<h5 id="3-参数选择与影响"><a href="#3-参数选择与影响" class="headerlink" title="3. 参数选择与影响"></a><strong>3. 参数选择与影响</strong></h5><ul>
<li><p><strong>$ \epsilon $（邻域半径）</strong>：  </p>
<ul>
<li>过小：可能导致多数样本被标记为噪声，簇数量增加。  </li>
<li>过大：可能导致不同簇合并，簇数量减少。  </li>
<li><strong>选择方法</strong>：通过<strong>K-Distance图</strong>（排序后的第 $ k $ 近邻距离）观察“拐点”。  </li>
</ul>
</li>
<li><p><strong>$ MinPts $（最小样本数）</strong>：  </p>
<ul>
<li>控制簇的最小密度阈值。  </li>
<li>通常取 $ d+1 $（$ d $ 为特征维度），避免在高维空间中误判噪声。  </li>
</ul>
</li>
</ul>
<h4 id="层次聚类与AGNES"><a href="#层次聚类与AGNES" class="headerlink" title="层次聚类与AGNES"></a>层次聚类与AGNES</h4><p>层次聚类是一种通过构建<strong>树状结构（Dendrogram）</strong>将数据划分为不同层次的聚类方法。其核心思想是：  </p>
<ul>
<li><strong>凝聚型（Agglomerative）</strong>：从每个样本作为一个独立簇开始，逐步合并最相似的簇，直到达到预设的簇数或形成一个唯一簇。  </li>
<li><strong>分裂型（Divisive）</strong>：与凝聚型相反，从整个数据集作为一个簇开始，逐步分裂为更小的簇。  </li>
</ul>
<p>本节重点介绍<strong>AGNES（Agglomerative Nesting）</strong>，一种经典的自底向上的层次聚类算法。</p>
<h5 id="1-AGNES-算法流程"><a href="#1-AGNES-算法流程" class="headerlink" title="1. AGNES 算法流程"></a><strong>1. AGNES 算法流程</strong></h5><ol>
<li><strong>初始化</strong>：每个样本作为一个独立簇。  </li>
<li><strong>迭代合并</strong>：  <ul>
<li>计算所有簇对之间的距离。  </li>
<li>合并距离最近的两个簇。  </li>
</ul>
</li>
<li><strong>终止条件</strong>：  <ul>
<li>达到预设的簇数 $ k $；  </li>
<li>所有簇之间的距离大于阈值。  </li>
</ul>
</li>
</ol>
<h5 id="2-簇间距离的定义"><a href="#2-簇间距离的定义" class="headerlink" title="2. 簇间距离的定义"></a><strong>2. 簇间距离的定义</strong></h5><p>AGNES 的关键在于如何定义<strong>簇间距离</strong>，常见的三种方法如下：</p>
<p><strong>（1）最小距离（Single Linkage）</strong></p>
<script type="math/tex; mode=display">
d_{\min}(C_i, C_j) = \min_{\boldsymbol{x} \in C_i, \boldsymbol{z} \in C_j} \text{dist}(\boldsymbol{x}, \boldsymbol{z})</script><ul>
<li><strong>含义</strong>：两个簇之间最近的两个样本的距离。  </li>
</ul>
<p><strong>（2）最大距离（Complete Linkage）</strong></p>
<script type="math/tex; mode=display">
d_{\max}(C_i, C_j) = \max_{\boldsymbol{x} \in C_i, \boldsymbol{z} \in C_j} \text{dist}(\boldsymbol{x}, \boldsymbol{z})</script><ul>
<li><strong>含义</strong>：两个簇之间最远的两个样本的距离。    </li>
</ul>
<p><strong>（3）平均距离（Average Linkage）</strong></p>
<script type="math/tex; mode=display">
d_{\text{avg}}(C_i, C_j) = \frac{1}{|C_i| |C_j|} \sum_{\boldsymbol{x} \in C_i} \sum_{\boldsymbol{z} \in C_j} \text{dist}(\boldsymbol{x}, \boldsymbol{z})</script><ul>
<li><strong>含义</strong>：两个簇所有样本对距离的平均值。  </li>
</ul>
<h5 id="层次聚类法的算法流程如下所示："><a href="#层次聚类法的算法流程如下所示：" class="headerlink" title="层次聚类法的算法流程如下所示："></a>层次聚类法的算法流程如下所示：</h5><p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607125338029.png" alt="image-20250607125338029"></p>
<h4 id="作业-2"><a href="#作业-2" class="headerlink" title="作业"></a>作业</h4><h5 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h5><p>假设任务是将下面8个点聚类成3个簇：A1(2,10), A2(2,5), A3(8,4), B1(5,8), B2(7,5), B3(6,4), C1(1,2), C3(4,9)，距离函数是欧式距离。假设初始选择A1，B1，C1分别作为每个聚类的中心，用Kmeans算法给出计算过程。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607125506436.png" alt="image-20250607125506436"></p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607125606040.png" alt="image-20250607125606040"></p>
<h5 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h5><p>Kmeans初始类簇中心如何选取？K值如何确定？请简要阐述。</p>
<p><strong>一、初始类簇中心的选取 (如何选好的起始点？)</strong></p>
<p>传统K-means随机选择初始中心点，容易导致结果不稳定（多次运行结果不同）或陷入局部最优（效果差）。改进方法主要有：</p>
<ol>
<li><strong>K-means++ (最常用且推荐)：</strong><ul>
<li><strong>核心思想：</strong> 让初始中心点彼此尽量远离。</li>
<li><strong>步骤：</strong><ol>
<li>随机选择<strong>第一个</strong>中心点。</li>
<li>计算每个数据点到<strong>当前已选中心点</strong>的最短距离（即离最近中心的距离）。</li>
<li>以<strong>与这个最短距离平方成正比</strong>的概率，随机选择下一个中心点（距离越大的点，被选中的概率越大）。</li>
<li>重复步骤2和3，直到选出K个中心点。</li>
</ol>
</li>
<li><strong>优点：</strong> 显著提高聚类质量和稳定性，计算开销增加不大。</li>
</ul>
</li>
<li><strong>多次运行+选取最优：</strong><ul>
<li>独立运行K-means算法多次（每次随机初始化）。</li>
<li>每次运行完成后，计算所有数据点与其所属簇中心的距离平方和（SSE, Sum of Squared Errors）。</li>
<li>选择SSE最小的那次运行结果作为最终结果。</li>
<li><strong>优点：</strong> 简单，增加找到更好解的机会。</li>
<li><strong>缺点：</strong> 计算开销随运行次数增加。</li>
</ul>
</li>
<li><strong>基于样本密度/距离：</strong><ul>
<li>选择数据空间中样本密度高的区域点作为中心。</li>
<li>或选择相互之间距离较远的点作为中心（类似K-means++的思想，但实现方式可能不同）。</li>
</ul>
</li>
</ol>
<p><strong>二、K值（簇数量）的确定 (如何知道分几类？)</strong></p>
<p>K值通常需要预先指定，但没有绝对正确的答案。常用方法基于评估不同K值下聚类结果的“质量”，寻找拐点或最优值：</p>
<ol>
<li><strong>肘部法则：</strong><ul>
<li><strong>核心思想：</strong> 随着K增大，簇内样本聚合更紧密，簇内平方和误差（SSE）会下降，但下降幅度会逐渐变缓。找到SSE下降速率发生显著变化的“肘点”。</li>
<li><strong>做法：</strong> 计算不同K值（如K=1, 2, 3, …, max）对应的SSE。绘制<code>K值 - SSE</code>曲线图。观察曲线，寻找SSE下降幅度突然变得平缓的那个K值（形如手臂的“肘关节”）。</li>
<li><strong>优点：</strong> 直观。</li>
<li><strong>缺点：</strong> “肘点”有时不明显或不存在，需要主观判断。</li>
</ul>
</li>
<li><strong>轮廓系数：</strong><ul>
<li><strong>核心思想：</strong> 综合衡量一个样本与其自身簇的紧密度(<code>a</code>)和与其他簇的分离度(<code>b</code>)。</li>
<li><strong>计算：</strong> 对于每个样本i：<ul>
<li><code>a(i)</code> = i 到同簇内所有其他点的平均距离（簇内不相似度）。</li>
<li><code>b(i)</code> = i 到所有<strong>其他簇</strong>中点的平均距离的最小值（最近邻簇的不相似度）。</li>
<li>样本i的轮廓系数：<code>s(i) = (b(i) - a(i)) / max(a(i), b(i))</code>。值在[-1, 1]之间。</li>
</ul>
</li>
<li><strong>整体评估：</strong> 计算所有样本轮廓系数的平均值，作为该K值下聚类的整体轮廓系数。</li>
<li><strong>选择K：</strong> 尝试不同K值，选择<strong>平均轮廓系数最大</strong>对应的K值。轮廓系数越接近1，表示聚类效果越好（簇内紧凑，簇间分离）。</li>
<li><strong>优点：</strong> 量化评估，结果在[-1, 1]之间有界。</li>
<li><strong>缺点：</strong> 计算量较大，尤其对于大数据集。</li>
</ul>
</li>
</ol>
<h4 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com.cn/developer/article/1802143">《机器学习》— 第九章 聚类-腾讯云开发者社区-腾讯云</a></p>
<h3 id="降维与度量学习"><a href="#降维与度量学习" class="headerlink" title="降维与度量学习"></a>降维与度量学习</h3><h4 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h4><p>k近邻算法简称<strong>kNN（k-Nearest Neighbor）</strong>，是一种经典的监督学习方法，是数据挖掘十大算法之一。其工作机制十分简单：给定某个测试样本，kNN基于某种<strong>距离度量</strong>在训练集中找出与其距离最近的k个带有真实标记的训练样本，然后基于这k个邻居的真实标记来进行预测，类似于集成学习中的基学习器结合策略：分类任务采用投票法，回归任务则采用平均法。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607150256290.png" alt="image-20250607150256290"></p>
<p><strong>核心思想</strong></p>
<p>1NN 分类器通过将测试样本 $ \boldsymbol{x} $ 分配到其最近邻样本 $ \boldsymbol{z} $ 的类别来完成预测。其错误概率取决于两个关键因素：</p>
<ul>
<li><strong>$ \boldsymbol{x} $ 的真实类别</strong>：$ P(c | \boldsymbol{x}) $，即给定 $ \boldsymbol{x} $ 属于类别 $ c $ 的概率。  </li>
<li><strong>$ \boldsymbol{z} $ 的类别</strong>：$ P(c | \boldsymbol{z}) $，即 $ \boldsymbol{z} $ 属于类别 $ c $ 的概率。</li>
</ul>
<p><strong>错误概率公式</strong></p>
<p>若测试样本 $ \boldsymbol{x} $ 的最近邻为 $ \boldsymbol{z} $，则 1NN 分类器出错的概率为：</p>
<script type="math/tex; mode=display">
P(\text{err}) = 1 - P(\text{correct}) = 1 - \sum_{c \in \mathcal{C}} P(c | \boldsymbol{x}) P(c | \boldsymbol{z})</script><p>其中：</p>
<ul>
<li>$ \mathcal{C} $ 是所有可能的类别集合。  </li>
<li>$ P(c | \boldsymbol{x}) $：$ \boldsymbol{x} $ 属于类别 $ c $ 的条件概率。  </li>
<li>$ P(c | \boldsymbol{z}) $：$ \boldsymbol{z} $ 属于类别 $ c $ 的条件概率。</li>
</ul>
<p>通过证明可以发现一个令人震惊的结论：<strong>最近邻分类器的错误率不超过贝叶斯最优分类器错误率的两倍</strong>。 </p>
<p>对于距离度量，<strong>不同的度量方法得到的k个近邻不尽相同，从而对最终的投票结果产生了影响</strong>，因此选择一个合适的距离度量方法也十分重要。</p>
<p>在上一篇聚类算法中，在度量样本相似性时介绍了常用的几种距离计算方法，包括<strong>闵可夫斯基距离，曼哈顿距离，VDM</strong>等。在实际应用中，<strong>kNN的距离度量函数一般根据样本的特性来选择合适的距离度量，同时应对数据进行去量纲/归一化处理来消除大量纲属性的强权政治影响</strong>。 </p>
<h4 id="低维嵌入"><a href="#低维嵌入" class="headerlink" title="低维嵌入"></a>低维嵌入</h4><p><strong>使用knn的前提是样本空间的密度要一定大，但是这个条件在现实中很难满足，因此引出降维操作</strong></p>
<blockquote>
<p>kNN的重要假设: 任意测试样本  附近任意小的  距离范围内总能找到一个训练样本，即训练样本的采样密度足够大，或称为 <strong>“密采样”( dense sample)</strong> 。然而，这个假设在现实任务中通常很难满足</p>
</blockquote>
<p>样本的<strong>特征数</strong>也称为<strong>维数</strong>（dimensionality），当维数非常大时，也就是通常所说的“<strong>维数灾难</strong>”(curse of dimensionality)，具体表现在：在高维情形下，<strong>数据样本变得十分稀疏</strong>，因为此时要满足训练样本为“<strong>密采样</strong>”的总体样本数目是一个触不可及的天文数字。<strong>训练样本的稀疏使得其代表总体分布的能力大大减弱，从而消减了学习器的泛化能力</strong>；同时当维数很高时，<strong>计算距离也变得十分复杂</strong>，甚至连计算内积都不再容易</p>
<p>缓解维数灾难的一个重要途径就是<strong>降维（dimension reduction），即通过某种数学变换将原始高维空间转变到一个低维的子空间</strong>。在这个子空间中，样本的密度将大幅提高，同时距离计算也变得容易。这</p>
<p>时也许会有疑问，降维之后不是会丢失原始数据的一部分信息吗？</p>
<p>实际上，在很多实际问题中，虽然训练数据是高维的，但是与学习任务相关也许仅仅是其中的一个低维子空间，也称为一个<strong>低维嵌入</strong>，例如：数据属性中存在噪声属性、相似属性或冗余属性等，<strong>对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果</strong>。</p>
<h4 id="MDS算法"><a href="#MDS算法" class="headerlink" title="MDS算法"></a><strong>MDS算法</strong></h4><p>MDS（Multidimensional Scaling，多维尺度分析）是一种经典的<strong>降维技术</strong>，其核心目标是将高维数据映射到低维空间（如二维或三维），同时<strong>尽可能保留原始数据中样本点之间的距离关系</strong>。以下是其核心原理与应用要点：</p>
<p><strong>1. 核心思想</strong></p>
<ul>
<li><strong>输入</strong>：一个样本点之间的距离矩阵 $ D $（如欧氏距离、余弦距离等）。  </li>
<li><strong>输出</strong>：低维空间中样本点的坐标矩阵 $ Z $，使得低维空间中的距离与原始距离尽可能一致 。  </li>
<li><strong>关键假设</strong>：高维数据的内在结构可通过样本间的距离关系描述，降维后需最小化这种关系的失真。</li>
</ul>
<p><strong>2. 算法步骤</strong></p>
<p>MDS 的核心是通过<strong>矩阵分解</strong>从距离矩阵推导低维坐标：</p>
<ol>
<li><p><strong>构建距离矩阵 $ D $</strong>：<br>对于 $ r $ 个样本，计算两两之间的距离，形成 $ r \times r $ 的矩阵 $ D $，其中 $ D_{ij} $ 表示样本 $ i $ 和 $ j $ 的距离 。</p>
</li>
<li><p><strong>双中心化（Double Centering）</strong>：<br>构造矩阵 $ B = -\frac{1}{2} H D^{(2)} H $，其中 $ D^{(2)} $ 是距离的平方矩阵，$ H = I - \frac{1}{r} \mathbf{1} \mathbf{1}^\top $ 是中心化矩阵 。</p>
</li>
<li><p><strong>特征值分解</strong>：<br>对 $ B $ 进行特征值分解，得到 $ B = V \Lambda V^\top $，其中 $ \Lambda $ 是按降序排列的特征值对角矩阵，$ V $ 是对应的特征向量矩阵 。</p>
</li>
<li><p><strong>构造低维坐标</strong>：<br>选择前 $ d’ $ 个最大特征值（$ d’ $ 为目标维度）和对应的特征向量，计算低维坐标矩阵：  </p>
<script type="math/tex; mode=display">
Z = \Lambda^{1/2} V^\top</script><p>其中 $ \Lambda^{1/2} $ 是特征值矩阵的平方根 。</p>
</li>
</ol>
<p><strong>3. 关键特性</strong></p>
<ul>
<li><strong>保留距离关系</strong>：MDS 直接优化低维空间中的距离与原始距离的一致性，适用于需精确保留样本相似性的场景（如生物信息学中的基因关系分析）。  </li>
<li><strong>非线性适应性</strong>：与 PCA 不同，MDS 不要求数据线性分布，更适合处理非线性结构（如环形、流形数据）。  </li>
<li><strong>灵活性</strong>：支持任意距离度量（如自定义的相似性指标），而 PCA 仅适用于欧氏距离 。</li>
</ul>
<h4 id="线性降维方法"><a href="#线性降维方法" class="headerlink" title="线性降维方法"></a><strong>线性降维方法</strong></h4><p>线性降维通过<strong>线性变换</strong>将高维数据 $ \mathbf{X} \in \mathbb{R}^{d \times m} $ 投影到低维空间 $ \mathbf{Z} \in \mathbb{R}^{d’ \times m} $（$ d’ \leq d $），保留数据的主要信息。其数学表达为：</p>
<script type="math/tex; mode=display">
\mathbf{Z} = \mathbf{W}^\top \mathbf{X}</script><ul>
<li><strong>变换矩阵 $ \mathbf{W} \in \mathbb{R}^{d \times d’} $</strong>：<br>每一列是正交的基向量，构成低维子空间的坐标系。  </li>
<li><p><strong>目标</strong>：选择 $ \mathbf{W} $ 使得低维表示 $ \mathbf{Z} $ 最大化保留原始数据的信息（如方差、距离等）。</p>
</li>
<li><p><strong>MDS</strong>：<br>直接以<strong>保留高维空间中样本点之间的距离关系</strong>为目标。降维后的低维空间需尽可能保持原始样本两两之间的距离（如欧氏距离、自定义相似性距离）。  </p>
<ul>
<li><strong>示例</strong>：在基因数据分析中，MDS可确保基因表达相似的样本在低维空间中仍紧密分布。  </li>
</ul>
</li>
<li><p><strong>其他线性方法（如PCA、LDA）</strong>：  </p>
<ul>
<li><strong>PCA</strong>：最大化数据在低维空间的方差，强调保留全局结构而非具体距离。  </li>
<li><strong>LDA</strong>：在监督学习中最大化类间分离度，忽略类内距离。  </li>
</ul>
</li>
</ul>
<h4 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h4><p>不同于MDS采用距离保持的方法，主成分分析（Principal Component Analysis ,PCA）是一种经典的<strong>无监督降维算法</strong> ，其核心目标是通过线性变换将高维数据映射到低维空间，同时保留数据的<strong>最大方差信息</strong> （即信息损失最小）</p>
<p>直接通过一个<strong>线性变换</strong>，将原始空间中的样本<strong>投影</strong>到新的低维空间中。</p>
<p>简单来理解这一过程便是：<strong>PCA采用一组新的基（向量）来表示样本点，其中每一个基向量都是原始空间基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的。</strong></p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607155733314.png" alt="image-20250607155733314"></p>
<p>假设使用d’个新基向量来表示原来样本，实质上是将样本投影到一个由d’个基向量确定的一个<strong>超平面</strong>上（<strong>即舍弃了一些维度</strong>），要用一个超平面对空间中所有高维样本进行恰当的表达，最理想的情形是：<strong>若这些样本点都能在超平面上表出且这些表出在超平面上都能够很好地分散开来</strong>。但是一般使用较原空间低一些维度的超平面来做到这两点十分不容易，因此我们退一步海阔天空，要求这个超平面应具有如下两个性质：</p>
<blockquote>
<p><strong>最近重构性</strong>：样本点到超平面的距离足够近，即尽可能在超平面附近；</p>
<p><strong>最大可分性</strong>：样本点在超平面上的投影尽可能地分散开来，即投影后的坐标具有区分性。</p>
</blockquote>
<p>这里十分神奇的是：<strong>最近重构性与最大可分性虽然从不同的出发点来定义优化问题中的目标函数，但最终这两种特性得到了完全相同的优化问题</strong>：</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607165159235.png" alt="image-20250607165159235"></p>
<h5 id="协方差矩阵与优化求解"><a href="#协方差矩阵与优化求解" class="headerlink" title="协方差矩阵与优化求解"></a><strong>协方差矩阵与优化求解</strong></h5><p>若数据已<strong>中心化</strong>（均值为零），则 $ \mathbf{X} \mathbf{X}^\top $ 是<strong>样本协方差矩阵</strong>的 $ m $ 倍。此时，PCA的优化问题转化为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \underset{\mathbf{W}}{\text{maximize}}
& & \text{tr}\left( \mathbf{W}^\top \mathbf{X} \mathbf{X}^\top \mathbf{W} \right) \\
& \text{subject to}
& & \mathbf{W}^\top \mathbf{W} = \mathbf{I}
\end{aligned}</script><p>通过拉格朗日乘数法，该问题的解为 $ \mathbf{X} \mathbf{X}^\top $ 的前 $ d’ $ 个最大特征值对应的特征向量</p>
<h5 id="PCA的数学推导"><a href="#PCA的数学推导" class="headerlink" title="PCA的数学推导"></a><strong>PCA的数学推导</strong></h5><ul>
<li><p><strong>优化目标</strong>：  </p>
<script type="math/tex; mode=display">
\max_{\mathbf{W}} \quad \text{tr}\left( \mathbf{W}^\top \mathbf{X} \mathbf{X}^\top \mathbf{W} \right) \quad \text{s.t.} \quad \mathbf{W}^\top \mathbf{W} = \mathbf{I}</script><p>其中，$ \mathbf{X} \in \mathbb{R}^{d \times m} $ 是中心化后的数据矩阵（均值为零）。</p>
</li>
<li><p><strong>拉格朗日乘数法</strong>：<br>引入拉格朗日乘子 $ \Lambda $，构造拉格朗日函数：</p>
<script type="math/tex; mode=display">
\mathcal{L}(\mathbf{W}, \Lambda) = \text{tr}\left( \mathbf{W}^\top \mathbf{X} \mathbf{X}^\top \mathbf{W} \right) - \text{tr}\left( \Lambda (\mathbf{W}^\top \mathbf{W} - \mathbf{I}) \right)</script><p>对 $ \mathbf{W} $ 求导并令导数为零，得到：</p>
<script type="math/tex; mode=display">
\mathbf{X} \mathbf{X}^\top \mathbf{W} = \Lambda \mathbf{W}</script><p>即 $ \mathbf{X} \mathbf{X}^\top $ 的特征向量 $ \mathbf{w}_i $ 满足：</p>
<script type="math/tex; mode=display">
\mathbf{X} \mathbf{X}^\top \mathbf{w}_i = \lambda_i \mathbf{w}_i</script></li>
</ul>
<h5 id="PCA特征向量选择"><a href="#PCA特征向量选择" class="headerlink" title="PCA特征向量选择"></a>PCA特征向量选择</h5><p><strong>1. 核心问题</strong></p>
<p>在PCA中，我们希望找到一个 $ d’ \times d $ 的变换矩阵 $ \mathbf{W} $，其列向量是协方差矩阵 $ \mathbf{X} \mathbf{X}^\top $ 的特征向量，且满足正交约束 $ \mathbf{W}^\top \mathbf{W} = \mathbf{I} $。关键问题是：<strong>如何从 $ d $ 个特征向量中选择 $ d’ $ 个最优的？</strong></p>
<p><strong>2. 数学推导</strong></p>
<ol>
<li><p><strong>特征值分解</strong>：<br>协方差矩阵 $ \mathbf{X} \mathbf{X}^\top \in \mathbb{R}^{d \times d} $ 可分解为：</p>
<script type="math/tex; mode=display">
\mathbf{X} \mathbf{X}^\top \mathbf{W} = \mathbf{W} \boldsymbol{\Lambda}</script><p>其中，$ \boldsymbol{\Lambda} = \text{diag}(\lambda_1, \lambda_2, \dots, \lambda_d) $ 是特征值对角矩阵，$ \mathbf{W} $ 是特征向量矩阵。</p>
</li>
<li><p><strong>优化目标转化</strong>：<br>PCA的目标是最大化 $ \text{tr}(\mathbf{W}^\top \mathbf{X} \mathbf{X}^\top \mathbf{W}) $。利用特征值分解，可得：</p>
<script type="math/tex; mode=display">
\mathbf{W}^\top \mathbf{X} \mathbf{X}^\top \mathbf{W} = \mathbf{W}^\top (\mathbf{W} \boldsymbol{\Lambda}) = \boldsymbol{\Lambda}</script><p>因此，优化目标变为：</p>
<script type="math/tex; mode=display">
\max_{\mathbf{W}} \quad \text{tr}(\boldsymbol{\Lambda}) = \sum_{i=1}^{d'} \lambda_i</script><p>即选择 $ d’ $ 个最大的特征值 $ \lambda_i $ 对应的特征向量组成 $ \mathbf{W} $。</p>
</li>
</ol>
<p><strong>3. 特征向量选择策略</strong></p>
<ul>
<li><strong>按特征值排序</strong>：<br>特征值 $ \lambda_i $ 表示数据沿特征向量 $ \mathbf{w}_i $ 方向的方差。选择前 $ d’ $ 个最大特征值对应的特征向量，可保留最多信息。  </li>
<li><strong>正交性保证</strong>：<br>特征向量矩阵 $ \mathbf{W} $ 的列自动满足 $ \mathbf{W}^\top \mathbf{W} = \mathbf{I} $，无需额外正交化。</li>
</ul>
<h5 id="PCA算法的整个流程如下图所示："><a href="#PCA算法的整个流程如下图所示：" class="headerlink" title="PCA算法的整个流程如下图所示："></a>PCA算法的整个流程如下图所示：</h5><p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607170020467.png" alt="image-20250607170020467"></p>
<h4 id="核化线性降维"><a href="#核化线性降维" class="headerlink" title="核化线性降维"></a><strong>核化线性降维</strong></h4><p>待学习</p>
<h4 id="流形学习"><a href="#流形学习" class="headerlink" title="流形学习"></a>流形学习</h4><p><strong>流形学习（manifold learning）</strong>是一种借助拓扑流形概念的降维方法，流形是指在<strong>局部与欧式空间同胚的空间</strong>，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种 <strong>“邻域保持”</strong> 的思想。其中 <strong>等度量映射（Isomap）试图在降维前后保持邻域内样本之间的距离，而局部线性嵌入（LLE）则是保持邻域内样本之间的线性关系</strong> 。</p>
<h5 id="等度量映射Isomap"><a href="#等度量映射Isomap" class="headerlink" title="等度量映射Isomap"></a>等度量映射Isomap</h5><p>等度量映射的基本出发点是：高维空间中的直线距离具有误导性，因为有时高维空间中的直线距离在低维空间中是不可达的。<strong>因此利用流形在局部上与欧式空间同胚的性质，可以使用近邻距离来逼近测地线距离</strong>，即对于一个样本点，它与近邻内的样本点之间是可达的，且距离使用欧式距离计算，这样整个样本空间就形成了一张近邻图，高维空间中两个样本之间的距离就转为最短路径问题。可采用著名的<strong>Dijkstra算法</strong>或<strong>Floyd算法</strong>计算最短距离，得到高维空间中任意两点之间的距离后便可以使用 MDS 算法来其计算低维空间中的坐标。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607171119645.png" alt="image-20250607171119645"></p>
<p>Isomap算法流程如下图：</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607171258284.png" alt="image-20250607171258284"></p>
<p>对于近邻图的构建，常用的有两种方法：<strong>一种是指定近邻点个数</strong>，像kNN一样选取k个最近的邻居；<strong>另一种是指定邻域半径</strong>，距离小于该阈值的被认为是它的近邻点。但两种方法均会出现下面的问题：</p>
<blockquote>
<p>若<strong>邻域范围指定过大，则会造成“短路问题”</strong>，即本身距离很远却成了近邻，将距离近的那些样本扼杀在摇篮。</p>
<p>若<strong>邻域范围指定过小，则会造成“断路问题”</strong>，即有些样本点无法可达了，整个世界村被划分为互不可达的小部落。</p>
</blockquote>
<h5 id="局部线性嵌入"><a href="#局部线性嵌入" class="headerlink" title="局部线性嵌入"></a>局部线性嵌入</h5><p>待学习</p>
<h4 id="度量学习"><a href="#度量学习" class="headerlink" title="度量学习"></a>度量学习</h4><p><strong>1. 核心思想</strong></p>
<p>度量学习（Metric Learning）的核心目标是<strong>学习一个合理的距离度量</strong>，使得相似样本距离更近，不相似样本距离更远。传统欧式距离（Euclidean Distance）虽然简单，但其固定权重无法反映不同特征的实际重要性。因此，我们引入<strong>加权欧式距离</strong>，通过可调节的参数（权重）优化距离计算。</p>
<p><strong>2. 欧式距离与加权欧式距离</strong></p>
<ul>
<li><p><strong>标准欧式距离</strong>：  </p>
<script type="math/tex; mode=display">
\text{dist}_{\text{ed}}^2(\boldsymbol{x}_i, \boldsymbol{x}_j) = \|\boldsymbol{x}_i - \boldsymbol{x}_j\|_2^2 = \sum_{k=1}^d (\boldsymbol{x}_{i,k} - \boldsymbol{x}_{j,k})^2</script><p>每个特征维度对距离的贡献相同，未考虑特征的重要性差异。</p>
</li>
<li><p><strong>加权欧式距离</strong>：  </p>
<script type="math/tex; mode=display">
\text{dist}_{\text{wed}}^2(\boldsymbol{x}_i, \boldsymbol{x}_j) = (\boldsymbol{x}_i - \boldsymbol{x}_j)^\top \mathbf{W} (\boldsymbol{x}_i - \boldsymbol{x}_j)</script><p>其中，$ \mathbf{W} = \text{diag}(\boldsymbol{w}) $ 是对角权重矩阵，$ w_k \geq 0 $ 表示第 $ k $ 个特征的权重。<br>展开后为：</p>
<script type="math/tex; mode=display">
\text{dist}_{\text{wed}}^2(\boldsymbol{x}_i, \boldsymbol{x}_j) = \sum_{k=1}^d w_k (\boldsymbol{x}_{i,k} - \boldsymbol{x}_{j,k})^2</script></li>
</ul>
<p><strong>3. 权重的作用</strong></p>
<ul>
<li><strong>特征重要性调节</strong>：  <ul>
<li>高权重 $ w_k $：强调第 $ k $ 维特征对距离的影响（如图像的颜色通道比位置更重要）。  </li>
<li>低权重 $ w_k $：弱化噪声或冗余特征的影响。  </li>
</ul>
</li>
<li><strong>几何意义</strong>：<br>加权欧式距离相当于在各特征维度上进行缩放，将数据映射到一个新的空间，使得关键特征的差异更显著。</li>
</ul>
<p><strong>4. 度量学习的目标</strong></p>
<p>通过学习最优权重 $ \boldsymbol{w} $，使以下目标成立：</p>
<ul>
<li><strong>相似样本</strong>：加权距离小（$ \text{dist}_{\text{wed}}^2(\boldsymbol{x}_i, \boldsymbol{x}_j) \to 0 $）。  </li>
<li><strong>不相似样本</strong>：加权距离大（$ \text{dist}_{\text{wed}}^2(\boldsymbol{x}_i, \boldsymbol{x}_j) \to \infty $）。  </li>
</ul>
<p>典型优化问题形式：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol{w}} \quad \sum_{(\boldsymbol{x}_i, \boldsymbol{x}_j) \in S} \text{dist}_{\text{wed}}^2(\boldsymbol{x}_i, \boldsymbol{x}_j) + \lambda \|\boldsymbol{w}\|_2^2</script><p>其中，$ S $ 是相似样本对集合，$ \lambda $ 是正则化项防止过拟合。</p>
<blockquote>
<p>总结来说，</p>
<ul>
<li><strong>降维是将原高维空间嵌入到一个合适的低维子空间中，接着在低维空间中进行学习任务</strong></li>
<li><strong>度量学习则是试图去学习出一个 *距离度量* 来等效降维的效果</strong></li>
</ul>
</blockquote>
<h5 id="LMNN（Large-Margin-Nearest-Neighbors）详解"><a href="#LMNN（Large-Margin-Nearest-Neighbors）详解" class="headerlink" title="LMNN（Large Margin Nearest Neighbors）详解"></a><strong>LMNN（Large Margin Nearest Neighbors）详解</strong></h5><p><strong>1. 核心思想</strong></p>
<p>LMNN 是一种<strong>监督度量学习方法</strong>，其目标是通过学习一个线性变换矩阵 $ \mathbf{M} $，使<strong>同类样本在变换后的空间中更紧密</strong>，<strong>不同类样本被推开</strong>，从而提升KNN等基于距离的算法性能。其核心是引入<strong>最大边距（Large Margin）</strong>的概念，类似于SVM的分类边界。</p>
<p><strong>2. 损失函数</strong></p>
<p>LMNN 的优化目标由两部分组成：</p>
<ul>
<li><p><strong>Pull Loss（拉力损失）</strong>：<br>使同类样本对的距离尽可能小，公式为：</p>
<script type="math/tex; mode=display">
\varepsilon_{\text{pull}}(\mathbf{L}) = \sum_{j \sim i} \|\mathbf{L}(\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j)\|^2</script><p>其中，$ j \sim i $ 表示与样本 $ i $ 同类的最近邻样本。</p>
</li>
<li><p><strong>Push Loss（推力损失）</strong>：<br>使不同类样本对的距离至少保持一个固定边距 $ \xi_{ijl} $，公式为：</p>
<script type="math/tex; mode=display">
\varepsilon_{\text{push}}(\mathbf{L}) = \sum_{i,j,l} (1 - y_{il}) \left[1 + \|\mathbf{L}(\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j)\|^2 - \|\mathbf{L}(\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_l)\|^2\right]_+</script><p>其中，$ y<em>{il} = 1 $ 表示样本 $ i $ 和 $ l $ 属于同一类，否则为0；$ [\cdot]</em>+ $ 表示取正值部分。</p>
</li>
<li><p><strong>总损失函数</strong>：  </p>
<script type="math/tex; mode=display">
\varepsilon(\mathbf{L}) = (1 - \mu) \varepsilon_{\text{pull}}(\mathbf{L}) + \mu \varepsilon_{\text{push}}(\mathbf{L})</script><p>参数 $ \mu \in [0, 1] $ 控制两类损失的权重。</p>
</li>
</ul>
<p><strong>3. 优化问题</strong></p>
<p>LMNN 的目标是最小化总损失函数，同时满足以下约束：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \min_{\mathbf{M}, \boldsymbol{\xi}} \quad (1 - \mu) \sum_{i,j \sim i} (\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j)^\top \mathbf{M} (\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j) + \mu \sum_{i,j \sim i,l} (1 - y_{il}) \xi_{ijl} \\
& \text{s.t.} \quad (\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_l)^\top \mathbf{M} (\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_l) - (\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j)^\top \mathbf{M} (\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j) \geq 1 - \xi_{ijl}, \\
& \quad \quad \quad \xi_{ijl} \geq 0, \quad \mathbf{M} \succeq 0.
\end{aligned}</script><ul>
<li><strong>约束（1）</strong>：确保不同类样本对的距离比同类样本对大至少 $ 1 - \xi_{ijl} $。  </li>
<li><strong>约束（2）</strong>：松弛变量 $ \xi_{ijl} \geq 0 $ 允许部分样本对违反约束。  </li>
<li><strong>约束（3）</strong>：$ \mathbf{M} $ 必须是半正定矩阵，保证距离的非负性和三角不等式。</li>
</ul>
<h4 id="作业-3"><a href="#作业-3" class="headerlink" title="作业"></a>作业</h4><h5 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h5><p>数据降维有哪些常用的方法？阐述主成分分析（PCA）算法的计算流程，并讨论PCA 降维之后的维度如何确定？</p>
<p><strong>（1）常用数据降维方法</strong></p>
<ol>
<li><strong>主成分分析（PCA）</strong>：通过线性变换保留最大方差方向，适用于去噪和压缩数据 。  </li>
<li><strong>线性判别分析（LDA）</strong>：在监督学习中最大化类间分离度，适用于分类任务 。  </li>
</ol>
<p><strong>（2）主成分分析（PCA）的计算流程</strong></p>
<ol>
<li><strong>数据标准化</strong>：对原始数据去均值、方差归一化，消除量纲影响 。  </li>
<li><strong>计算协方差矩阵</strong>：  <script type="math/tex; mode=display">
\mathbf{\Sigma} = \frac{1}{m} \mathbf{X} \mathbf{X}^\top</script>其中 $ \mathbf{X} $ 是中心化后的数据矩阵 。  </li>
<li><strong>特征值分解</strong>：对协方差矩阵进行特征值分解，得到特征值 $ \lambda_i $ 和单位正交特征向量 $ \mathbf{w}_i $ 。  </li>
<li><strong>选择主成分</strong>：按特征值大小排序，选择前 $ d’ $ 个最大特征值对应的特征向量构成变换矩阵 $ \mathbf{W} = [\mathbf{w}<em>1, \mathbf{w}_2, \dots, \mathbf{w}</em>{d’}] $。  </li>
<li><strong>降维投影</strong>：计算低维表示 $ \mathbf{Z} = \mathbf{W}^\top \mathbf{X} $，其中 $ \mathbf{Z} \in \mathbb{R}^{d’ \times m} $ 。</li>
</ol>
<p><strong>（3）PCA降维后维度的确定</strong></p>
<ul>
<li><strong>累积方差贡献率</strong>：选择前 $ d’ $ 个主成分，使累计方差占比达到阈值（如95%）。  </li>
<li><strong>肘部法则（Elbow Method）</strong>：绘制特征值随维度变化的曲线，选择“拐点”作为 $ d’ $。  </li>
</ul>
<h5 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h5><p>度量学习的目标是什么？LMNN算法中三元组损失是什么？如何计算？</p>
<p><strong>（1）度量学习的目标</strong></p>
<p>度量学习旨在学习一个合理的距离度量，使得：</p>
<ul>
<li><strong>相似样本</strong>：距离尽可能小（如同类样本）。  </li>
<li><strong>不相似样本</strong>：距离尽可能大（如异类样本）。<br>典型应用包括推荐系统（优化用户-商品相似性）、图像检索（提升匹配精度）和生物识别（增强类间可分性）。</li>
</ul>
<p><strong>（2）LMNN中的三元组损失</strong></p>
<p>LMNN（Large Margin Nearest Neighbor）是一种监督度量学习方法，其核心思想是通过优化距离度量来提升KNN的分类性能。虽然LMNN本身主要使用对比损失（Contrastive Loss），但三元组损失（Triplet Loss）是深度度量学习中常见的损失函数，其计算方式如下：<strong>三元组损失的定义</strong></p>
<p>三元组损失基于锚点（Anchor）、正例（Positive）和负例（Negative）三个样本，目标是使锚点与正例的距离小于锚点与负例的距离，公式为：</p>
<script type="math/tex; mode=display">
\mathcal{L} = \sum_{i,j,l} \max\left(0, \|\mathbf{z}_i - \mathbf{z}_j\|^2 - \|\mathbf{z}_i - \mathbf{z}_l\|^2 + m\right)</script><ul>
<li>$ \mathbf{z}_i $：锚点样本的嵌入表示。  </li>
<li>$ \mathbf{z}_j $：与锚点同类的正例样本。  </li>
<li>$ \mathbf{z}_l $：与锚点不同类的负例样本。  </li>
<li>$ m $：预设的边界值（Margin），控制正负样本距离的最小差距 。</li>
</ul>
<p><strong>LMNN的损失函数</strong></p>
<p>LMNN 的损失函数包含两部分：</p>
<ol>
<li><strong>拉力损失（Pull Loss）</strong>：最小化同类样本对的距离：  <script type="math/tex; mode=display">
\varepsilon_{\text{pull}} = \sum_{i,j \sim i} \|\mathbf{L}(\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j)\|^2</script></li>
<li><strong>推力损失（Push Loss）</strong>：最大化异类样本对的距离：  <script type="math/tex; mode=display">
\varepsilon_{\text{push}} = \sum_{i,j \sim i,l} (1 - y_{il}) \left[1 + \|\mathbf{L}(\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_j)\|^2 - \|\mathbf{L}(\bar{\boldsymbol{x}}_i - \bar{\boldsymbol{x}}_l)\|^2\right]_+</script>其中 $ \mathbf{L} $ 是线性变换矩阵，$ y<em>{il} $ 表示样本对是否同类，$ [\cdot]</em>+ $ 表示取正值部分 。</li>
</ol>
<p><strong>优化目标</strong></p>
<p>LMNN 的总损失为拉力和推力损失的加权和：</p>
<script type="math/tex; mode=display">
\varepsilon(\mathbf{L}) = (1 - \mu) \varepsilon_{\text{pull}} + \mu \varepsilon_{\text{push}}</script><p>参数 $ \mu \in [0, 1] $ 平衡两类损失的权重，最终通过优化 $ \mathbf{L} $ 得到最优距离度量 。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607175825520.png" alt="image-20250607175825520"></p>
<h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>监督学习解决现实问题有哪些难点?<br>1.标记数据获取成本高：在许多领域如医疗，获取标记数据是昂贵且耗时的。<br>2.未标记数据大量存在且易得：相对而言，未标记数据大量存在且容易获取。<br>3.提升模型的泛化能力：通过利用未标记数据，可以增强模型的泛化能力。<br>举例：在医疗领域，获取医生标记的诊断数据非常昂贵，但有大量未标记的病人记录。<br>半监督学习可以帮助利用这些未标记数据，提高疾病预测模型的准确性。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607181345721.png" alt="image-20250607181345721">半监督学习结合了有监督学习和无监督学习，半监督学习使用<strong>少量的标记数据</strong>和<strong>大量的未标记数据</strong>来训练模型，主要目标是提升模型在未标记数据上的表现。</p>
<h5 id="基于生成模型的方法"><a href="#基于生成模型的方法" class="headerlink" title="基于生成模型的方法"></a>基于生成模型的方法</h5><p>假设所有数据（无论是否有标记）都是由一个<strong>潜在的模型</strong>“生成”的。那么无标记的数据可以帮助更准确的估计潜在模型的参数。<br>比如右图中可以看到数据可以由两个高斯分布近似，则无监督的数据可以被用来更好得做高斯分布的参数估计</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607183201926.png" alt="image-20250607183201926"></p>
<h5 id="半监督SVM"><a href="#半监督SVM" class="headerlink" title="半监督SVM"></a><strong>半监督SVM</strong></h5><p>监督学习中的SVM试图找到一个划分超平面，使得两侧支持向量之间的间隔最大，即 <strong>最大划分间隔</strong> 思想。对于半监督SVM (Semi-Supervised Support Vector Machine, S3VM) 则考虑超平面在能将两类标记样本分隔的同时，<strong>穿过数据低密度的区域</strong>。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607183349866.png" alt="image-20250607183349866"></p>
<h6 id="TSVM-Transductive-Support-Vector-Machine"><a href="#TSVM-Transductive-Support-Vector-Machine" class="headerlink" title="TSVM(Transductive Support Vector Machine)"></a>TSVM(Transductive Support Vector Machine)</h6><p><strong>1. 核心思想</strong></p>
<p>TSVM 是一种<strong>半监督学习方法</strong>，通过结合有标记数据 $ D_l $ 和未标记数据 $ D_u $，利用伪标签（Pseudo-labels）和迭代优化策略，最大化分类超平面的间隔。其损失函数需同时考虑：</p>
<ul>
<li><strong>有标记样本</strong>：最小化分类错误（Hinge Loss）。  </li>
<li><strong>未标记样本</strong>：通过伪标签引入约束，逐步调整超平面。</li>
</ul>
<p><strong>2. 损失函数推导</strong></p>
<p>TSVM 的目标是找到一个超平面 $ \boldsymbol{w}^\top \boldsymbol{x} + b = 0 $，使得：</p>
<ol>
<li><strong>有标记样本</strong>的分类误差最小。  </li>
<li><strong>未标记样本</strong>的伪标签与超平面预测结果一致。  </li>
</ol>
<p><strong>标准SVM的损失函数</strong>为：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol{w}, b, \xi} \quad \frac{1}{2} \|\boldsymbol{w}\|^2 + C \sum_{i=1}^l \xi_i</script><p>其中，$ \xi_i $ 是松弛变量，表示样本 $ (\boldsymbol{x}_i, y_i) $ 的分类误差。</p>
<p><strong>TSVM的扩展</strong>：<br>引入未标记样本 $ D_u $ 的伪标签 $ \hat{y}_j $（$ j = l+1, \dots, l+u $），并赋予其较小的惩罚系数 $ C_u $（初始阶段 $ C_u \ll C_l $）：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol{w}, b, \xi} \quad \frac{1}{2} \|\boldsymbol{w}\|^2 + C_l \sum_{i=1}^l \xi_i + C_u \sum_{j=l+1}^{l+u} \xi_j</script><p>其中：</p>
<ul>
<li>$ C_l $：有标记样本的惩罚系数。  </li>
<li>$ C_u $：未标记样本的惩罚系数，初始值很小，逐步增大以增强伪标签的影响。</li>
</ul>
<p><strong>3. 迭代优化流程</strong></p>
<ol>
<li><p><strong>初始化</strong>：  </p>
<ul>
<li>用有标记数据 $ D_l $ 训练初始 SVM，得到 $ \boldsymbol{w}_0, b_0 $。  </li>
<li>对未标记数据 $ D_u $ 预测伪标签 $ \hat{y}_j = \text{sign}(\boldsymbol{w}_0^\top \boldsymbol{x}_j + b_0) $。  </li>
</ul>
</li>
<li><p><strong>伪标签调整</strong>：  </p>
<ul>
<li>若存在冲突（如 $ \hat{y}_i \hat{y}_j &lt; 0 $ 且 $ \xi_i + \xi_j &gt; 2 $），翻转其中一个伪标签（如 $ \hat{y}_i \leftarrow -\hat{y}_i $）。  </li>
<li>重新求解优化问题，更新 $ \boldsymbol{w}, b $。  </li>
</ul>
</li>
<li><p><strong>参数调整</strong>：  </p>
<ul>
<li>逐步增大 $ C_u $（如 $ C_u \leftarrow \min{2C_u, C_l} $），增强未标记样本的影响。  </li>
</ul>
</li>
</ol>
<p><strong>4. 关键数学细节</strong></p>
<ul>
<li><p><strong>Hinge Loss</strong>：<br>对每个样本 $ (\boldsymbol{x}_i, y_i) $，损失为：</p>
<script type="math/tex; mode=display">
\xi_i = \max\left(0, 1 - y_i (\boldsymbol{w}^\top \boldsymbol{x}_i + b)\right)</script><p>未标记样本的伪标签 $ \hat{y}_j $ 同样代入此公式，但惩罚系数为 $ C_u $。  </p>
</li>
<li><p><strong>正则化项</strong>：<br>$ \frac{1}{2} |\boldsymbol{w}|^2 $ 确保超平面的泛化能力，防止过拟合。  </p>
</li>
<li><p><strong>伪标签翻转条件</strong>：<br>当两个未标记样本 $ i, j $ 满足：</p>
<script type="math/tex; mode=display">
\hat{y}_i \hat{y}_j < 0 \quad \text{且} \quad \xi_i > 0, \xi_j > 0, \quad \xi_i + \xi_j > 2</script><p>表示它们被错误分类且距离超平面较近，需翻转其中一个标签以减少冲突。</p>
</li>
</ul>
<h5 id="图半监督学习"><a href="#图半监督学习" class="headerlink" title="图半监督学习"></a><strong>图半监督学习</strong></h5><p>给定一个数据集，我们可将其映射为一个图，数据集中每个样本对应于图结点，若两个样本之间的相似度很高(或相关性很强)，则对应的结点之间存在一条边，边的“强度”(strength) 正比于样本之间的相似度(或相关性)。</p>
<p>可将有标记样本所对应的结点想象为染过色，标记样本所对应的结点尚未染色。半监督学习就对应于“颜色”在图上扩散或传播的过程。由于个图对应了一个矩阵，我们就能基于矩阵运算来进行半监督学习算法的推导与分析。</p>
<p><img src="/2025/06/06/college/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/image-20250607184534217.png" alt="image-20250607184534217"></p>
<p><strong>图半监督学习中的能量函数推导详解</strong></p>
<p><strong>1. 图结构与亲和矩阵</strong></p>
<p>给定有标记数据集 $ D<em>l = {(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), \dots, (\boldsymbol{x}_l, y_l)} $ 和未标记数据集 $ D_u = {\boldsymbol{x}</em>{l+1}, \boldsymbol{x}<em>{l+2}, \dots, \boldsymbol{x}</em>{l+u}} $，构建图 $ G = (V, E) $：</p>
<ul>
<li><strong>结点集</strong>：$ V = {\boldsymbol{x}<em>1, \dots, \boldsymbol{x}_l, \boldsymbol{x}</em>{l+1}, \dots, \boldsymbol{x}_{l+u}} $，包含所有样本。  </li>
<li><strong>边集</strong>：通过亲和矩阵 $ \mathbf{W} $ 表示，元素定义为：<script type="math/tex; mode=display">
(\mathbf{W})_{ij} = 
\begin{cases}
\exp\left(-\frac{\|\boldsymbol{x}_i - \boldsymbol{x}_j\|^2}{2\sigma^2}\right), & i \neq j \\
0, & \text{otherwise}
\end{cases}</script>其中，$ \sigma $ 是高斯核的带宽参数，控制邻接关系的敏感性。</li>
</ul>
<p><strong>2. 能量函数的定义与推导</strong></p>
<p>假设分类模型的输出标记为 $ f(\boldsymbol{x}_i) $（取值为类别标签，如 $ \pm 1 $），定义能量函数 $ E(f) $ 为：</p>
<script type="math/tex; mode=display">
E(f) = \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} (f(\boldsymbol{x}_i) - f(\boldsymbol{x}_j))^2</script><p>其中 $ m = l + u $ 是总样本数。</p>
<p><strong>3. 能量函数的展开与简化</strong></p>
<ol>
<li><strong>展开平方项</strong><script type="math/tex; mode=display">
E(f) = \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} \left[ f^2(\boldsymbol{x}_i) - 2 f(\boldsymbol{x}_i) f(\boldsymbol{x}_j) + f^2(\boldsymbol{x}_j) \right]</script></li>
<li><strong>利用对称性简化</strong><br>由于 $ \mathbf{W} $ 是对称矩阵（$(\mathbf{W})<em>{ij} = (\mathbf{W})</em>{ji}$），可交换求和顺序：<script type="math/tex; mode=display">
\sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} f^2(\boldsymbol{x}_j) = \sum_{j=1}^m \sum_{i=1}^m (\mathbf{W})_{ji} f^2(\boldsymbol{x}_j) = \sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} f^2(\boldsymbol{x}_i)</script>因此，能量函数变为<script type="math/tex; mode=display">
E(f) = \frac{1}{2} \left( 2 \sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} f^2(\boldsymbol{x}_i) - 2 \sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} f(\boldsymbol{x}_i) f(\boldsymbol{x}_j) \right)</script></li>
<li><strong>引入度矩阵</strong><br>定义度矩阵 $ \mathbf{D} $ 为对角矩阵，其对角线元素为：<script type="math/tex; mode=display">
d_i = \sum_{j=1}^m (\mathbf{W})_{ij}</script>最终能量函数可表示为：<script type="math/tex; mode=display">
E(f) = \sum_{i=1}^m d_i f^2(\boldsymbol{x}_i) - \sum_{i=1}^m \sum_{j=1}^m (\mathbf{W})_{ij} f(\boldsymbol{x}_i) f(\boldsymbol{x}_j) = \boldsymbol{f}^\top (\mathbf{D} - \mathbf{W}) \boldsymbol{f}</script>其中，$ \boldsymbol{f} = [f(\boldsymbol{x}_1), f(\boldsymbol{x}_2), \dots, f(\boldsymbol{x}_m)]^\top $。</li>
</ol>
<p><strong>图半监督学习方法推导详解</strong></p>
<p><strong>1. 分块矩阵表示</strong></p>
<p>将亲和矩阵 $ \mathbf{W} $ 和度矩阵 $ \mathbf{D} $ 按有标记数据（前 $ l $ 行列）和未标记数据（后 $ u $ 行列）分块：</p>
<script type="math/tex; mode=display">
\mathbf{W} = 
\begin{bmatrix}
\mathbf{W}_{ll} & \mathbf{W}_{lu} \\
\mathbf{W}_{ul} & \mathbf{W}_{uu}
\end{bmatrix}, \quad
\mathbf{D} = 
\begin{bmatrix}
\mathbf{D}_{ll} & \mathbf{0}_{lu} \\
\mathbf{0}_{ul} & \mathbf{D}_{uu}
\end{bmatrix}</script><p>其中：</p>
<ul>
<li>$ \mathbf{W}_{ll} $：有标记数据间的亲和度。  </li>
<li>$ \mathbf{W}_{lu} $：有标记与未标记数据间的亲和度。  </li>
<li>$ \mathbf{W}_{uu} $：未标记数据间的亲和度。  </li>
<li>$ \mathbf{D}<em>{ll}, \mathbf{D}</em>{uu} $：对应子图的度矩阵。</li>
</ul>
<p><strong>2. 能量函数的分块展开</strong></p>
<p>能量函数 $ E(f) = \boldsymbol{f}^\top (\mathbf{D} - \mathbf{W}) \boldsymbol{f} $ 可展开为</p>
<p>展开后得到：</p>
<script type="math/tex; mode=display">
E(f) = \boldsymbol{f}_l^\top (\mathbf{D}_{ll} - \mathbf{W}_{ll}) \boldsymbol{f}_l - 2 \boldsymbol{f}_u^\top \mathbf{W}_{ul} \boldsymbol{f}_l + \boldsymbol{f}_u^\top (\mathbf{D}_{uu} - \mathbf{W}_{uu}) \boldsymbol{f}_u</script><p><strong>3. 对未标记数据 $ \boldsymbol{f}_u $ 求偏微分</strong></p>
<p>目标是最小化 $ E(f) $，对 $ \boldsymbol{f}_u $ 求偏导并令其为零：</p>
<script type="math/tex; mode=display">
\frac{\partial E(f)}{\partial \boldsymbol{f}_u} = -2 \mathbf{W}_{ul} \boldsymbol{f}_l + 2 (\mathbf{D}_{uu} - \mathbf{W}_{uu}) \boldsymbol{f}_u = 0</script><p>解得：</p>
<script type="math/tex; mode=display">
\boldsymbol{f}_u = (\mathbf{D}_{uu} - \mathbf{W}_{uu})^{-1} \mathbf{W}_{ul} \boldsymbol{f}_l</script><h4 id="协同训练"><a href="#协同训练" class="headerlink" title="协同训练"></a>协同训练</h4><p>协同训练（Co-training）是一种经典的<strong>半监督学习方法</strong>，由Blum和Mitchell于1998年首次提出，主要用于处理<strong>多视图数据</strong>（Multi-view Data）。其核心思想是通过多个分类器的协作，利用少量标记数据和大量未标记数据提升模型性能。以下是详细解析：</p>
<p><strong>1. 核心思想与假设</strong></p>
<p><strong>（1）多视图数据</strong></p>
<ul>
<li><strong>定义</strong>：每个样本可被划分为多个<strong>充分冗余且条件独立</strong>的视图（View）。  <ul>
<li><strong>充分冗余</strong>：每个视图本身包含足够信息，可独立完成学习任务。  </li>
<li><strong>条件独立性</strong>：在给定类别标签的条件下，不同视图的特征相互独立。<br>例如，网页数据可划分为“文本内容”和“超链接结构”两个视图，它们共同描述网页内容。</li>
</ul>
</li>
</ul>
<p><strong>（2）协作机制</strong></p>
<ul>
<li><strong>双分类器设计</strong>：使用两个分类器 $ h_1 $ 和 $ h_2 $，分别基于视图 $ V_1 $ 和 $ V_2 $ 进行训练。  </li>
<li><strong>伪标签生成</strong>：分类器 $ h_1 $ 对未标记数据的高置信度预测结果会被 $ h_2 $ 使用，反之亦然，形成迭代优化。  </li>
<li><strong>目标</strong>：通过分类器间的互补性，逐步扩展标记数据集，提升模型泛化能力。</li>
</ul>
<p><strong>2. 算法流程</strong></p>
<ol>
<li><strong>初始化阶段</strong>：  <ul>
<li>使用少量标记数据 $ D_l $，分别训练分类器 $ h_1 $（基于视图 $ V_1 $）和 $ h_2 $（基于视图 $ V_2 $）。  </li>
</ul>
</li>
<li><strong>伪标签生成</strong>：  <ul>
<li>对未标记数据 $ D_u $，$ h_1 $ 预测视图 $ V_1 $ 的伪标签，$ h_2 $ 预测视图 $ V_2 $ 的伪标签。  </li>
<li>选择置信度高于阈值的样本加入训练集（如 $ h_1 $ 的预测结果用于更新 $ h_2 $ 的训练数据，反之亦然）。  </li>
</ul>
</li>
<li><strong>迭代优化</strong>：  <ul>
<li>重复伪标签生成和模型训练，直到未标记数据耗尽或模型收敛。</li>
</ul>
</li>
</ol>
<p><strong>3. 核心优势</strong></p>
<ul>
<li><strong>减少对标注数据的依赖</strong>：仅需少量标记数据即可训练高性能模型，尤其适合标注成本高的场景（如医疗影像分析）。  </li>
<li><strong>提升模型鲁棒性</strong>：分类器间的协作可纠正彼此的错误，降低单一模型过拟合风险。  </li>
<li><strong>多视图互补性</strong>：不同视图的信息融合能捕捉更全面的特征（如图像的RGB通道与纹理特征）。</li>
</ul>
<h4 id="作业-4"><a href="#作业-4" class="headerlink" title="作业"></a>作业</h4><h5 id="1-4"><a href="#1-4" class="headerlink" title="1"></a>1</h5><p>什么是半监督学习？请简要描述其基本思想。半监督学习相比于监督学习和无监督学习有什么优势和应用场景？</p>
<p><strong>（1）定义与基本思想</strong>  </p>
<p>半监督学习（Semi-Supervised Learning）是结合<strong>监督学习</strong>（利用标记数据）和<strong>无监督学习</strong>（利用未标记数据）的机器学习方法，其核心思想是通过少量标记数据与大量未标记数据的联合训练，提升模型的泛化能力和鲁棒性。  </p>
<ul>
<li><strong>监督学习</strong>：依赖大量人工标注数据（如分类、回归）。  </li>
<li><strong>无监督学习</strong>：仅利用数据分布规律（如聚类、降维）。  </li>
<li><strong>半监督学习</strong>：在标记数据稀缺时，通过未标记数据挖掘潜在结构，降低标注成本 。</li>
</ul>
<p><strong>（2）优势</strong>  </p>
<ul>
<li><strong>减少标注依赖</strong>：仅需少量标记数据即可训练高性能模型，适用于标注成本高的场景（如医疗影像分析）。  </li>
<li><strong>提升模型性能</strong>：利用未标记数据增强数据多样性，缓解过拟合风险。  </li>
<li><strong>平衡效率与精度</strong>：在资源有限时，兼顾监督学习的准确性与无监督学习的高效性 。</li>
</ul>
<p><strong>（3）应用场景</strong>  </p>
<ul>
<li><strong>医学诊断</strong>：利用少量标注的病理图像和大量未标注数据训练疾病预测模型。  </li>
<li><strong>推荐系统</strong>：结合用户行为（有标记）与商品属性（未标记）优化排序模型。  </li>
<li><strong>自然语言处理</strong>：通过预训练模型（如GPT）的“预训练+微调”框架，减少人工标注需求 。</li>
</ul>
<h5 id="2-4"><a href="#2-4" class="headerlink" title="2"></a>2</h5><p>协同训练算法的作用是什么？请简述算法主要流程和所需条件。</p>
<p><strong>（1）作用与核心思想</strong>  </p>
<p>协同训练是一种典型的半监督学习方法，适用于<strong>多视图数据</strong>（Multi-view Data）。其核心思想是通过多个分类器的协作，利用未标记数据扩展训练集，最终提升模型性能。  </p>
<ul>
<li><strong>多视图条件</strong>：  <ul>
<li><strong>充分冗余</strong>：每个视图本身包含足够信息，可独立完成任务。  </li>
<li><strong>条件独立性</strong>：在给定类别标签的条件下，不同视图的特征相互独立 。</li>
</ul>
</li>
</ul>
<p><strong>（2）算法流程</strong>  </p>
<ol>
<li><strong>初始化阶段</strong>：  <ul>
<li>使用少量标记数据 $ D_l $，分别训练两个分类器 $ h_1 $（基于视图 $ V_1 $）和 $ h_2 $（基于视图 $ V_2 $）。  </li>
</ul>
</li>
<li><strong>伪标签生成</strong>：  <ul>
<li>对未标记数据 $ D_u $，$ h_1 $ 预测 $ V_2 $ 的伪标签，$ h_2 $ 预测 $ V_1 $ 的伪标签。  </li>
<li>选择置信度高于阈值的样本加入训练集（如 $ h_1 $ 的预测结果用于更新 $ h_2 $ 的训练数据，反之亦然）。  </li>
</ul>
</li>
<li><strong>迭代优化</strong>：  <ul>
<li>重复伪标签生成和模型训练，直到未标记数据耗尽或模型收敛 。</li>
</ul>
</li>
</ol>
<p><strong>（3）所需条件</strong>  </p>
<ul>
<li><strong>多视图划分</strong>：数据需满足“充分冗余”和“条件独立性”（如图像的RGB通道与纹理特征）。  </li>
<li><strong>分类器多样性</strong>：选择差异较大的分类器（如SVM + 决策树），增强互补性。  </li>
<li><strong>伪标签可靠性</strong>：初始模型需有一定性能，避免错误伪标签污染训练集 。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/01/%E5%AD%A6%E4%B9%A0/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/01/%E5%AD%A6%E4%B9%A0/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">weatherweb开发学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-01T00:00:00+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-12 18:48:30" itemprop="dateModified" datetime="2025-06-12T18:48:30+08:00">2025-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" itemprop="url" rel="index"><span itemprop="name">weatherweb开发日志</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h3><p>智能天气提醒助手</p>
<p>描述：开发一款web应用，实时获取天气数据并支持个性化提醒（如雨天带伞）。</p>
<p>要求：</p>
<p>调用天气API获取实时数据（如OpenWeatherMap，每天1000次免费调用）</p>
<p>使用前端三件套设计交互界面，展示当前及未来天气信息，空气质量、体感温度、日出日落、月相等信息；</p>
<p>使用fastapi做后端</p>
<p>支持地点设置和天气提醒条件配置，在预设的提醒条件下提醒用户，并且将用户偏好保存至本地文件。</p>
<p>多城市切换、历史天气查询、全球地图展示等额外功能（可选*）。</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>fastapi，前端三件套(fetchapi)，apifox</p>
<h3 id="fetchapi"><a href="#fetchapi" class="headerlink" title="fetchapi"></a>fetchapi</h3><p><strong>Fetch API</strong> 是现代浏览器提供的标准网络请求接口，允许开发者通过 JavaScript 发起异步 HTTP 请求（如 GET、POST、PUT、DELETE 等），并处理响应数据（如 JSON、文本、图片等）。它是传统 <code>XMLHttpRequest</code>（AJAX）的替代方案，语法更简洁，且支持 Promise 异步编程。</p>
<p><strong>简单来说，就是用作给后端发送请求，实现前后端分离</strong></p>
<p><img src="/2025/06/01/%E5%AD%A6%E4%B9%A0/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20250609163335375.png" alt="image-20250609163335375"></p>
<h4 id="用法学习"><a href="#用法学习" class="headerlink" title="用法学习"></a>用法学习</h4><p>在使用 <code>fetch</code> 发起 HTTP 请求时，<code>method</code>、<code>headers</code> 和 <code>body</code> 是配置请求的核心参数，它们共同决定了请求的行为和数据格式。以下是每个参数的具体作用及示例：</p>
<h5 id="1-method-39-POST-39"><a href="#1-method-39-POST-39" class="headerlink" title="1. method: &#39;POST&#39;"></a><strong>1. <code>method: &#39;POST&#39;</code></strong></h5><p><strong>作用</strong></p>
<p>指定 HTTP 请求的方法（动词），<code>POST</code> 表示向服务器提交数据（如创建资源）。</p>
<ul>
<li><strong>常见方法</strong>：<ul>
<li><code>GET</code>：获取数据（默认方法，无需显式声明）。</li>
<li><code>POST</code>：提交数据（如新增记录）。</li>
<li><code>PUT</code>：更新数据。</li>
<li><code>DELETE</code>：删除数据。</li>
</ul>
</li>
<li><strong>与后端交互</strong>：FastAPI 的路由通过 <code>@app.post()</code>、<code>@app.get()</code> 等装饰器匹配请求方法。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/submit&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 告诉服务器这是一个提交请求</span></span><br><span class="line">  <span class="comment">// ...其他配置</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="2-headers-请求头"><a href="#2-headers-请求头" class="headerlink" title="2. headers 请求头"></a><strong>2. <code>headers</code> 请求头</strong></h5><p><strong>作用</strong></p>
<p>定义请求的元信息，用于告知服务器如何处理请求和数据格式。</p>
<ul>
<li><strong>关键字段</strong>：<ul>
<li><strong><code>Content-Type</code></strong>：指定请求体（<code>body</code>）的数据格式。<ul>
<li><code>application/json</code>：表示发送 JSON 数据。</li>
<li><code>application/x-www-form-urlencoded</code>：表示表单数据（键值对）。</li>
<li><code>multipart/form-data</code>：用于上传文件。</li>
</ul>
</li>
<li><strong><code>Authorization</code></strong>：携带身份凭证（如 Token）。</li>
<li><strong><code>Accept</code></strong>：声明客户端期望的响应格式（如 JSON、XML）。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">headers</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>, <span class="comment">// 告诉服务器请求体是 JSON</span></span><br><span class="line">  <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your_token_here&#x27;</span> <span class="comment">// 身份验证（可选）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-body-JSON-stringify-item"><a href="#3-body-JSON-stringify-item" class="headerlink" title="3. body: JSON.stringify(item)"></a><strong>3. <code>body: JSON.stringify(item)</code></strong></h5><p><strong>作用</strong></p>
<p>定义请求体（即发送给服务器的数据），需根据 <code>Content-Type</code> 的类型进行格式化。</p>
<ul>
<li><strong><code>JSON.stringify(item)</code></strong>：将 JavaScript 对象转换为 JSON 字符串。<ul>
<li>因为 HTTP 协议只能传输文本，不能直接传输对象。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>若未设置 <code>Content-Type: application/json</code>，服务器可能无法正确解析数据。</li>
<li>若使用 <code>FormData</code> 上传文件，需使用 <code>multipart/form-data</code> 格式。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> item = &#123; <span class="attr">name</span>: <span class="string">&quot;Apple&quot;</span>, <span class="attr">price</span>: <span class="number">1.99</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item) <span class="comment">// 转换为 &#x27;&#123;&quot;name&quot;:&quot;Apple&quot;,&quot;price&quot;:1.99&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="完整示例：向-FastAPI-提交数据"><a href="#完整示例：向-FastAPI-提交数据" class="headerlink" title="完整示例：向 FastAPI 提交数据"></a><strong>完整示例：向 FastAPI 提交数据</strong></h5><p><strong>FastAPI 后端定义</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: Item</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Item created&quot;</span>, <span class="string">&quot;item&quot;</span>: item&#125;</span><br></pre></td></tr></table></figure>
<p><strong>前端调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> item = &#123; <span class="attr">name</span>: <span class="string">&quot;Banana&quot;</span>, <span class="attr">price</span>: <span class="number">0.99</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://localhost:8000/items/&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> <span class="comment">// 必须与数据格式匹配</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item) <span class="comment">// 将对象转为 JSON 字符串</span></span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>必填性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>method</code></td>
<td>定义请求类型（如 <code>POST</code>）</td>
<td>必填（非 <code>GET</code> 时）</td>
</tr>
<tr>
<td><code>headers</code></td>
<td>声明数据格式、身份凭证等</td>
<td>必填（尤其 <code>Content-Type</code>）</td>
</tr>
<tr>
<td><code>body</code></td>
<td>发送的数据（需格式化为字符串）</td>
<td>必填（<code>POST</code>/<code>PUT</code> 时）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>关键点</strong>：  </p>
<ul>
<li><code>POST</code> 请求必须设置 <code>headers[&#39;Content-Type&#39;]</code> 和 <code>body</code>。</li>
<li><code>JSON.stringify()</code> 是发送 JSON 数据的关键步骤。</li>
<li>FastAPI 会根据 <code>Content-Type</code> 自动解析请求体并进行数据校验（通过 Pydantic 模型）。</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><h4 id="CORS-是什么？"><a href="#CORS-是什么？" class="headerlink" title="CORS 是什么？"></a><strong>CORS 是什么？</strong></h4><p><strong>CORS（Cross-Origin Resource Sharing）</strong> 是一种浏览器安全机制，用于解决 <strong>跨域请求</strong> 的问题。它允许服务器明确授权某些跨域请求，从而在保障安全的前提下，实现前后端分离架构中的跨域通信。</p>
<h4 id="为什么需要-CORS？"><a href="#为什么需要-CORS？" class="headerlink" title="为什么需要 CORS？"></a><strong>为什么需要 CORS？</strong></h4><p><strong>1. 同源策略（Same-Origin Policy）</strong></p>
<p>浏览器默认遵循 <strong>同源策略</strong>，即网页只能请求与自身 <strong>同源（相同域名、协议、端口）</strong> 的资源。<br><strong>例如</strong>：</p>
<ul>
<li>前端地址：<code>http://localhost:3000</code></li>
<li>后端地址：<code>http://localhost:8000</code><br>此时，前端向后端发起的请求会被浏览器 <strong>拦截</strong>，因为端口不同（3000 vs 8000）。</li>
</ul>
<p><strong>2. 跨域场景</strong></p>
<p>跨域是前后端分离架构中的常见问题，例如：</p>
<ul>
<li>前端部署在 <code>https://example.com</code>，后端 API 在 <code>https://api.example.com</code>。</li>
<li>前端本地开发（<code>localhost:3000</code>）调用后端服务（<code>localhost:8000</code>）。</li>
</ul>
<p><strong>3. CORS 的作用</strong></p>
<p>CORS 通过 <strong>服务器响应头</strong> 告诉浏览器：“这个跨域请求是安全的，允许它通过”。<br>浏览器根据这些响应头决定是否放行请求。</p>
<h4 id="如何配置-CORS？"><a href="#如何配置-CORS？" class="headerlink" title="如何配置 CORS？"></a><strong>如何配置 CORS？</strong></h4><p>以 <strong>FastAPI</strong> 为例，配置允许跨域请求的步骤如下：</p>
<p><strong>启用 CORS 中间件</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.middleware.cors <span class="keyword">import</span> CORSMiddleware</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 CORS</span></span><br><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    allow_origins=[<span class="string">&quot;http://localhost:3000&quot;</span>],  <span class="comment"># 允许的源</span></span><br><span class="line">    allow_credentials=<span class="literal">True</span>,                    <span class="comment"># 允许携带凭证</span></span><br><span class="line">    allow_methods=[<span class="string">&quot;*&quot;</span>],                       <span class="comment"># 允许所有方法（GET、POST 等）</span></span><br><span class="line">    allow_headers=[<span class="string">&quot;*&quot;</span>],                       <span class="comment"># 允许所有头信息</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="CORS-的实际应用场景"><a href="#CORS-的实际应用场景" class="headerlink" title="CORS 的实际应用场景"></a><strong>CORS 的实际应用场景</strong></h4><p><strong>1. 前后端分离开发</strong></p>
<ul>
<li>前端（React/Vue）运行在 <code>localhost:3000</code>，后端（FastAPI）运行在 <code>localhost:8000</code>。</li>
<li>配置 <code>allow_origins=[&quot;http://localhost:3000&quot;]</code> 允许跨域通信。</li>
</ul>
<p><strong>2. 第三方 API 调用</strong></p>
<ul>
<li>前端直接调用第三方服务（如天气 API），需服务器启用 CORS。</li>
<li>示例：<code>Access-Control-Allow-Origin: *</code> 表示允许所有来源。</li>
</ul>
<p><strong>3. 需要凭证的场景</strong></p>
<ul>
<li>前端需携带 Cookie 或 Token 访问后端接口：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    allow_origins=[<span class="string">&quot;http://localhost:3000&quot;</span>],</span><br><span class="line">    allow_credentials=<span class="literal">True</span>,  <span class="comment"># 允许携带凭证</span></span><br><span class="line">    allow_methods=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">    allow_headers=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th>概念</th>
<th>作用</th>
<th>配置示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>同源策略</strong></td>
<td>浏览器安全机制，阻止跨域请求</td>
<td>默认启用</td>
</tr>
<tr>
<td><strong>CORS</strong></td>
<td>服务器通过响应头授权跨域请求</td>
<td><code>Access-Control-Allow-Origin</code></td>
</tr>
<tr>
<td><strong>预检请求</strong></td>
<td>OPTIONS 请求，验证复杂跨域请求的合法性</td>
<td>自动触发</td>
</tr>
<tr>
<td><strong>FastAPI 配置</strong></td>
<td>使用 <code>CORSMiddleware</code> 中间件</td>
<td><code>app.add_middleware(...)</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>最佳实践</strong>：</p>
<ol>
<li><strong>开发阶段</strong>：允许所有来源（<code>allow_origins=[&quot;*&quot;]</code>），方便调试。</li>
<li><strong>生产环境</strong>：严格限制允许的源、方法、头信息，避免安全风险。</li>
<li><strong>携带凭证</strong>：启用 <code>allow_credentials=True</code> 并明确指定允许的源（避免使用 <code>*</code>）。</li>
</ol>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="Nginx-是什么？"><a href="#Nginx-是什么？" class="headerlink" title="Nginx 是什么？"></a><strong>Nginx 是什么？</strong></h4><p><strong>Nginx</strong>（发音为 “engine-x”）是一个高性能的开源 <strong>Web 服务器、反向代理服务器、负载均衡器和 HTTP 缓存</strong>，广泛用于现代 Web 架构中。它以轻量级、低资源消耗和高并发处理能力著称，常用于优化网站性能、管理流量和提升安全性。</p>
<h4 id="Nginx-的核心功能"><a href="#Nginx-的核心功能" class="headerlink" title="Nginx 的核心功能"></a><strong>Nginx 的核心功能</strong></h4><p><strong>1. Web 服务器</strong></p>
<ul>
<li><strong>静态资源托管</strong>：直接提供 HTML、CSS、JS、图片等静态文件服务。</li>
<li><strong>动态请求转发</strong>：将动态请求（如 API）转发给后端应用（如 FastAPI、Django、Node.js）。</li>
</ul>
<p><strong>2. 反向代理</strong></p>
<ul>
<li><strong>作用</strong>：接收客户端请求，转发给后端服务器（如 FastAPI），隐藏真实服务器地址。</li>
<li><strong>优势</strong>：提高安全性、支持负载均衡、缓存和 SSL 终端。</li>
</ul>
<p><strong>3. 负载均衡</strong></p>
<ul>
<li><strong>作用</strong>：将请求分发到多个后端服务器（如多个 FastAPI 实例），避免单点故障。</li>
<li><strong>算法</strong>：轮询（Round Robin）、最少连接（Least Connections）、IP 哈希（IP Hash）等。</li>
</ul>
<p><strong>4. SSL/TLS 终端</strong></p>
<ul>
<li><strong>作用</strong>：处理 HTTPS 加密和解密，减轻后端服务器的压力。</li>
<li><strong>配置</strong>：绑定证书和私钥，强制 HTTPS。</li>
</ul>
<p><strong>5. 缓存</strong></p>
<ul>
<li><strong>作用</strong>：缓存静态资源（如图片、CSS）或动态内容（如 API 响应），减少后端负载。</li>
</ul>
<p><strong>6. 高可用性和容错</strong></p>
<ul>
<li><strong>健康检查</strong>：自动检测后端服务器状态，故障时切换备用节点。</li>
</ul>
<h4 id="Nginx-的典型应用场景"><a href="#Nginx-的典型应用场景" class="headerlink" title="Nginx 的典型应用场景"></a><strong>Nginx 的典型应用场景</strong></h4><p><strong>1. 反向代理 FastAPI 服务</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/sites-available/fastapi.conf</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;  <span class="comment"># FastAPI 服务地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：将 <code>example.com</code> 的请求转发给运行在 <code>127.0.0.1:8000</code> 的 FastAPI 服务。</li>
</ul>
<p><strong>2. 静态文件托管</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /static/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /var/www/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：直接提供 <code>/var/www/static/</code> 目录下的静态文件（如图片、CSS）。</li>
</ul>
<h4 id="Nginx-与-FastAPI-的协作流程"><a href="#Nginx-与-FastAPI-的协作流程" class="headerlink" title="Nginx 与 FastAPI 的协作流程"></a><strong>Nginx 与 FastAPI 的协作流程</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; Nginx（反向代理） -&gt; FastAPI（处理业务逻辑） -&gt; 数据库/其他服务</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>静态资源</strong>：由 Nginx 直接返回（如 HTML、CSS、JS）。</li>
<li><strong>API 请求</strong>：Nginx 转发给 FastAPI，FastAPI 处理后返回 JSON 数据。</li>
<li><strong>HTTPS</strong>：Nginx 处理加密和解密，FastAPI 无需关心 SSL。</li>
</ol>
<p><strong>最佳实践</strong>：</p>
<ol>
<li><strong>开发阶段</strong>：直接运行 FastAPI（<code>uvicorn main:app --reload</code>）。</li>
<li><strong>生产环境</strong>：Nginx + FastAPI（Gunicorn/Uvicorn） + 数据库。</li>
<li><strong>性能优化</strong>：启用 Gzip 压缩、HTTP/2、缓存静态资源。</li>
</ol>
<p>通过 Nginx 的反向代理和负载均衡，可以显著提升 FastAPI 应用的性能、安全性和可扩展性。</p>
<h3 id="反向代理是什么？"><a href="#反向代理是什么？" class="headerlink" title="反向代理是什么？"></a>反向代理是什么？</h3><p><strong>反向代理（Reverse Proxy）</strong> 是一种服务器角色，它位于客户端与服务器之间，接收客户端的请求后，将请求转发给后端服务器（如 FastAPI、Django、Node.js 等），并将后端服务器的响应返回给客户端。<strong>它的核心作用是隐藏后端服务器的真实地址，优化请求处理流程，并增强安全性</strong>。</p>
<p>反向代理是现代 Web 架构中不可或缺的组件，尤其在前后端分离、微服务、高并发场景下作用显著。通过 Nginx 等工具实现反向代理，可以：</p>
<ul>
<li>提升安全性（隐藏后端、过滤攻击）。</li>
<li>优化性能（负载均衡、缓存静态资源）。</li>
<li>简化运维（集中管理 SSL、日志）。</li>
</ul>
<p>对于 FastAPI 项目，推荐在生产环境中使用 Nginx 作为反向代理，以充分发挥其高性能和灵活性优势。</p>
<h3 id="二级域名是什么？"><a href="#二级域名是什么？" class="headerlink" title="二级域名是什么？"></a>二级域名是什么？</h3><p><strong>二级域名（Second-Level Domain, SLD）</strong> 是域名系统（DNS）中的一个层级，通常位于顶级域名（TLD）之下，主域名（一级域名）之上。它是域名结构中的关键部分，用于标识网站或服务的主体。</p>
<p><strong>域名层级结构</strong></p>
<p>域名由多个层级组成，从右向左层级递增，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mail.example.com</span><br><span class="line">|     |        |</span><br><span class="line">|     |        └── 顶级域名（TLD）：com/net/org</span><br><span class="line">|     └────────── 二级域名（SLD）：example</span><br><span class="line">└──────────────── 子域名（Subdomain）：mail</span><br></pre></td></tr></table></figure>
<p><strong>1. 顶级域名（TLD）</strong></p>
<ul>
<li><strong>定义</strong>：域名的最后一部分，表示域名的类别或国家/地区。</li>
<li><strong>示例</strong>：<code>.com</code>（商业）、<code>.org</code>（非营利组织）、<code>.net</code>（网络服务）、<code>.cn</code>（中国）、<code>.jp</code>（日本）。</li>
</ul>
<p><strong>2. 二级域名（SLD）</strong></p>
<ul>
<li><strong>定义</strong>：位于 TLD 之下的域名部分，是域名的主体，通常由用户注册并拥有。</li>
<li><strong>示例</strong>：在 <code>example.com</code> 中，<code>example</code> 是二级域名。</li>
</ul>
<p><strong>3. 子域名（Subdomain）</strong></p>
<ul>
<li><strong>定义</strong>：在二级域名前添加的前缀，用于进一步细分网站或服务。</li>
<li><strong>示例</strong>：在 <code>mail.example.com</code> 中，<code>mail</code> 是子域名。</li>
</ul>
<p><strong>二级域名的常见用途</strong></p>
<ol>
<li><strong>品牌标识</strong>：<br>二级域名是品牌的核心标识，如 <code>google.com</code>、<code>apple.com</code>。</li>
<li><strong>服务划分</strong>：<br>通过子域名区分不同服务，例如：<ul>
<li><code>mail.google.com</code>：邮件服务</li>
<li><code>drive.google.com</code>：云存储服务</li>
<li><code>maps.google.com</code>：地图服务</li>
</ul>
</li>
<li><strong>多语言或地区支持</strong>：<br>通过二级域名提供本地化内容，例如：<ul>
<li><code>fr.wikipedia.org</code>（法语版）</li>
<li><code>zh.wikipedia.org</code>（中文版）</li>
</ul>
</li>
</ol>
<h3 id="DOM元素"><a href="#DOM元素" class="headerlink" title="DOM元素"></a>DOM元素</h3><p><strong>DOM（Document Object Model，文档对象模型）</strong> 是浏览器将 HTML 或 XML 文档解析为树状结构的编程接口。<strong>DOM 元素</strong> 是构成这棵树的节点（如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;button&gt;</code> 等），它们不仅是页面内容的载体，更是实现动态交互的核心工具。</p>
<h3 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h3><h4 id="api"><a href="#api" class="headerlink" title="api"></a>api</h4><p>获取api<a target="_blank" rel="noopener" href="https://home.openweathermap.org/api_keys">https://home.openweathermap.org/api_keys</a></p>
<p>api文档<a target="_blank" rel="noopener" href="https://openweathermap.org/api">Weather API - OpenWeatherMap</a></p>
<h4 id="版本1-0"><a href="#版本1-0" class="headerlink" title="版本1.0"></a>版本1.0</h4><p><img src="/2025/06/01/%E5%AD%A6%E4%B9%A0/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20250602191448931.png" alt="image-20250602191448931"></p>
<p>完成基本天气功能的开发</p>
<h4 id="版本2-0"><a href="#版本2-0" class="headerlink" title="版本2.0"></a>版本2.0</h4><p><img src="/2025/06/01/%E5%AD%A6%E4%B9%A0/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/weatherweb%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20250604095743649.png" alt="image-20250604095743649"></p>
<p>完成ai建议功能</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/21/diary/%E8%84%9A%E8%B8%8F%E5%AE%9E%E5%9C%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/21/diary/%E8%84%9A%E8%B8%8F%E5%AE%9E%E5%9C%B0/" class="post-title-link" itemprop="url">脚踏实地</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-21 00:00:00 / 修改时间：20:23:38" itemprop="dateCreated datePublished" datetime="2025-05-21T00:00:00+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="脚踏实地"><a href="#脚踏实地" class="headerlink" title="脚踏实地"></a>脚踏实地</h3><p>没有一夜暴富的美梦，天下掉馅饼的事情只有可能是诱惑，在得到某些好处前先想一想你配不配。</p>
<p>杜绝心浮气躁，用双手制造财富。.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/14/%E5%AD%A6%E4%B9%A0/kaggle/titanic/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%AC%AC%E4%B8%80%E8%8A%82%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E5%8F%8A%E5%88%9D%E6%AD%A5%E8%A7%82%E5%AF%9F-%E8%AF%BE%E7%A8%8B-checkpoint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/14/%E5%AD%A6%E4%B9%A0/kaggle/titanic/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%AC%AC%E4%B8%80%E8%8A%82%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E5%8F%8A%E5%88%9D%E6%AD%A5%E8%A7%82%E5%AF%9F-%E8%AF%BE%E7%A8%8B-checkpoint/" class="post-title-link" itemprop="url">数据分析——第一章：第一节数据载入及初步观察</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-14 00:00:00 / 修改时间：16:56:27" itemprop="dateCreated datePublished" datetime="2025-05-14T00:00:00+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kaggle/" itemprop="url" rel="index"><span itemprop="name">kaggle</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kaggle/titanic/" itemprop="url" rel="index"><span itemprop="name">titanic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>复习</strong>:这门课程得主要目的是通过真实的数据，以实战的方式了解数据分析的流程和熟悉数据分析python的基本操作。知道了课程的目的之后，我们接下来我们要正式的开始数据分析的实战教学，完成kaggle上<a target="_blank" rel="noopener" href="https://www.kaggle.com/c/titanic/overview">泰坦尼克的任务</a>，实战数据分析全流程。<br>这里有两份资料：<br>教材《Python for Data Analysis》和 baidu.com &amp;<br>google.com（善用搜索引擎）</p>
<h2 id="1-第一章：数据载入及初步观察"><a href="#1-第一章：数据载入及初步观察" class="headerlink" title="1 第一章：数据载入及初步观察"></a>1 第一章：数据载入及初步观察</h2><h3 id="1-1-载入数据"><a href="#1-1-载入数据" class="headerlink" title="1.1 载入数据"></a>1.1 载入数据</h3><p>数据集下载 <a target="_blank" rel="noopener" href="https://www.kaggle.com/c/titanic/overview">https://www.kaggle.com/c/titanic/overview</a></p>
<h4 id="1-1-1-任务一：导入numpy和pandas"><a href="#1-1-1-任务一：导入numpy和pandas" class="headerlink" title="1.1.1 任务一：导入numpy和pandas"></a>1.1.1 任务一：导入numpy和pandas</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>【提示】如果加载失败，学会如何在你的python环境下安装numpy和pandas这两个库</p>
<h4 id="1-1-2-任务二：载入数据"><a href="#1-1-2-任务二：载入数据" class="headerlink" title="1.1.2 任务二：载入数据"></a>1.1.2 任务二：载入数据</h4><p>(1) 使用相对路径载入数据<br>(2) 使用绝对路径载入数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br><span class="line">test=pd.read_csv(<span class="string">&#x27;./titanic/test.csv&#x27;</span>)</span><br><span class="line">train=pd.read_csv(<span class="string">&#x27;./titanic/train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">abs_path_test=os.path.abspath(<span class="string">&#x27;./titanic/test.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(abs_path_test)</span><br><span class="line">test=pd.read_csv(abs_path_test)</span><br><span class="line">abs_path_train=os.path.abspath(<span class="string">&#x27;./titanic/train.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(abs_path_train)</span><br><span class="line">train=pd.read_csv(abs_path_train)</span><br><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<pre><code>/workspace/WuTeachingAI/hands-on-data-analysis/myself/titanic/test.csv
/workspace/WuTeachingAI/hands-on-data-analysis/myself/titanic/train.csv
</code></pre><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>C123</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
  </tbody>
</table>


<p>【提示】相对路径载入报错时，尝试使用os.getcwd()查看当前工作目录。<br>【思考】知道数据加载的方法后，试试pd.read_csv()和pd.read_table()的不同，如果想让他们效果一样，需要怎么做？了解一下’.tsv’和’.csv’的不同，如何加载这两个数据集？<br>【总结】加载的数据是所有工作的第一步，我们的工作会接触到不同的数据格式（eg:.csv;.tsv;.xlsx）,但是加载的方法和思路都是一样的，在以后工作和做项目的过程中，遇到之前没有碰到的问题，要多多查资料吗，使用googel，了解业务逻辑，明白输入和输出是什么。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pd.read_csv() 和 pd.read_table() 本质上非常相似，主要区别在于默认的分隔符参数。</span></span><br><span class="line"><span class="comment"># 通过显式设置 `sep` 参数，可以让它们处理各种以不同字符分隔的文本文件。</span></span><br><span class="line"><span class="comment"># &#x27;.csv&#x27; 文件用逗号分隔，&#x27;.tsv&#x27; 文件用制表符分隔。选择合适的pandas读取函数或正确设置`sep`参数即可加载。</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-3-任务三：每1000行为一个数据模块，逐块读取"><a href="#1-1-3-任务三：每1000行为一个数据模块，逐块读取" class="headerlink" title="1.1.3 任务三：每1000行为一个数据模块，逐块读取"></a>1.1.3 任务三：每1000行为一个数据模块，逐块读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">chunker=pd.read_csv(<span class="string">&#x27;./titanic/train.csv&#x27;</span>,chunksize=<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunker:</span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure>
<pre><code>     PassengerId  Survived  Pclass  \
0              1         0       3   
1              2         1       1   
2              3         1       3   
3              4         1       1   
4              5         0       3   
..           ...       ...     ...   
886          887         0       2   
887          888         1       1   
888          889         0       3   
889          890         1       1   
890          891         0       3   

                                                  Name     Sex   Age  SibSp  \
0                              Braund, Mr. Owen Harris    male  22.0      1   
1    Cumings, Mrs. John Bradley (Florence Briggs Th...  female  38.0      1   
2                               Heikkinen, Miss. Laina  female  26.0      0   
3         Futrelle, Mrs. Jacques Heath (Lily May Peel)  female  35.0      1   
4                             Allen, Mr. William Henry    male  35.0      0   
..                                                 ...     ...   ...    ...   
886                              Montvila, Rev. Juozas    male  27.0      0   
887                       Graham, Miss. Margaret Edith  female  19.0      0   
888           Johnston, Miss. Catherine Helen &quot;Carrie&quot;  female   NaN      1   
889                              Behr, Mr. Karl Howell    male  26.0      0   
890                                Dooley, Mr. Patrick    male  32.0      0   

     Parch            Ticket     Fare Cabin Embarked  
0        0         A/5 21171   7.2500   NaN        S  
1        0          PC 17599  71.2833   C85        C  
2        0  STON/O2. 3101282   7.9250   NaN        S  
3        0            113803  53.1000  C123        S  
4        0            373450   8.0500   NaN        S  
..     ...               ...      ...   ...      ...  
886      0            211536  13.0000   NaN        S  
887      0            112053  30.0000   B42        S  
888      2        W./C. 6607  23.4500   NaN        S  
889      0            111369  30.0000  C148        C  
890      0            370376   7.7500   NaN        Q  

[891 rows x 12 columns]
</code></pre><p>【思考】什么是逐块读取？为什么要逐块读取呢？</p>
<p>【提示】大家可以chunker(数据块)是什么类型？用<code>for</code>循环打印出来出处具体的样子是什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **什么是逐块读取？**</span></span><br><span class="line"><span class="comment"># 逐块读取（Chunking）是指在读取大型数据集时，不一次性将整个文件加载到内存中，而是将文件分成若干个小的数据块（chunks），每次只加载和处理一个数据块。</span></span><br><span class="line"><span class="comment"># 在pandas中，可以通过在 `pd.read_csv()` 或类似的读取函数中设置 `chunksize` 参数来实现逐块读取。`chunksize` 定义了每个数据块包含的行数。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># **为什么要逐块读取呢？**</span></span><br><span class="line"><span class="comment"># 1.  **处理内存不足的大文件**：</span></span><br><span class="line"><span class="comment">#     *   当数据集非常大，其大小超过了计算机可用内存时，一次性加载整个文件会导致内存溢出错误（MemoryError）。逐块读取允许我们分批处理数据，每次只在内存中保留一小部分数据，从而有效避免内存问题。</span></span><br><span class="line"><span class="comment"># 2.  **提高处理效率（特定场景下）**：</span></span><br><span class="line"><span class="comment">#     *   对于某些类型的操作，例如对数据进行迭代处理、过滤或聚合，如果不需要同时访问所有数据，逐块处理可以使得程序更快地开始处理数据，而不是等待整个大文件加载完毕。</span></span><br><span class="line"><span class="comment">#     *   可以边读取边处理，实现流式数据处理的效果。</span></span><br><span class="line"><span class="comment"># 3.  **数据清洗和预处理**：</span></span><br><span class="line"><span class="comment">#     *   在对大型原始数据进行初步的清洗、转换或特征工程时，可以逐块进行，将处理后的数据块追加到新的存储中，或者在每个块上计算统计量并逐步累积。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-任务四：将表头改成中文，索引改为乘客ID-对于某些英文资料，我们可以通过翻译来更直观的熟悉我们的数据"><a href="#1-1-4-任务四：将表头改成中文，索引改为乘客ID-对于某些英文资料，我们可以通过翻译来更直观的熟悉我们的数据" class="headerlink" title="1.1.4 任务四：将表头改成中文，索引改为乘客ID [对于某些英文资料，我们可以通过翻译来更直观的熟悉我们的数据]"></a>1.1.4 任务四：将表头改成中文，索引改为乘客ID [对于某些英文资料，我们可以通过翻译来更直观的熟悉我们的数据]</h4><p>PassengerId =&gt; 乘客ID<br>Survived    =&gt; 是否幸存<br>Pclass      =&gt; 乘客等级(1/2/3等舱位)<br>Name        =&gt; 乘客姓名<br>Sex         =&gt; 性别<br>Age         =&gt; 年龄<br>SibSp       =&gt; 堂兄弟/妹个数<br>Parch       =&gt; 父母与小孩个数<br>Ticket      =&gt; 船票信息<br>Fare        =&gt; 票价<br>Cabin       =&gt; 客舱<br>Embarked    =&gt; 登船港口             </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line"><span class="comment">#将&quot;乘客ID&quot;列作为行索引</span></span><br><span class="line">df=pd.read_csv(<span class="string">&#x27;./titanic/train.csv&#x27;</span>,names=[<span class="string">&#x27;乘客ID&#x27;</span>,<span class="string">&#x27;是否幸存&#x27;</span>,<span class="string">&#x27;仓位等级&#x27;</span>,<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;性别&#x27;</span>,<span class="string">&#x27;年龄&#x27;</span>,<span class="string">&#x27;兄弟姐妹个数&#x27;</span>,<span class="string">&#x27;父母子女个数&#x27;</span>,<span class="string">&#x27;船票信息&#x27;</span>,<span class="string">&#x27;票价&#x27;</span>,<span class="string">&#x27;客舱&#x27;</span>,<span class="string">&#x27;登船港口&#x27;</span>],index_col=<span class="string">&#x27;乘客ID&#x27;</span>,header=<span class="number">0</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>是否幸存</th>
      <th>仓位等级</th>
      <th>姓名</th>
      <th>性别</th>
      <th>年龄</th>
      <th>兄弟姐妹个数</th>
      <th>父母子女个数</th>
      <th>船票信息</th>
      <th>票价</th>
      <th>客舱</th>
      <th>登船港口</th>
    </tr>
    <tr>
      <th>乘客ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>C123</td>
      <td>S</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
  </tbody>
</table>
【思考】所谓将表头改为中文其中一个思路是：将英文列名表头替换成中文。还有其他的方法吗？

### 1.2 初步观察
导入数据后，你可能要对数据的整体结构和样例进行概览，比如说，数据大小、有多少列，各列都是什么格式的，是否包含null等

#### 1.2.1 任务一：查看数据的基本信息


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">df.info()</span><br><span class="line">df.describe()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    <class 'pandas.core.frame.dataframe'>
    Index: 891 entries, 1 to 891
    Data columns (total 11 columns):
     #   Column  Non-Null Count  Dtype  
    ---  ------  --------------  -----  
     0   是否幸存    891 non-null    int64  
     1   仓位等级    891 non-null    int64  
     2   姓名      891 non-null    object 
     3   性别      891 non-null    object 
     4   年龄      714 non-null    float64
     5   兄弟姐妹个数  891 non-null    int64  
     6   父母子女个数  891 non-null    int64  
     7   船票信息    891 non-null    object 
     8   票价      891 non-null    float64
     9   客舱      204 non-null    object 
     10  登船港口    889 non-null    object 
    dtypes: float64(2), int64(4), object(5)
    memory usage: 83.5+ KB



<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>是否幸存</th>
      <th>仓位等级</th>
      <th>年龄</th>
      <th>兄弟姐妹个数</th>
      <th>父母子女个数</th>
      <th>票价</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>714.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.383838</td>
      <td>2.308642</td>
      <td>29.699118</td>
      <td>0.523008</td>
      <td>0.381594</td>
      <td>32.204208</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.486592</td>
      <td>0.836071</td>
      <td>14.526497</td>
      <td>1.102743</td>
      <td>0.806057</td>
      <td>49.693429</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>0.420000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.000000</td>
      <td>2.000000</td>
      <td>20.125000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>7.910400</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.000000</td>
      <td>3.000000</td>
      <td>28.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>14.454200</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>38.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>31.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>80.000000</td>
      <td>8.000000</td>
      <td>6.000000</td>
      <td>512.329200</td>
    </tr>
  </tbody>
</table>


<p>【提示】有多个函数可以这样做，你可以做一下总结</p>
<h4 id="1-2-2-任务二：观察表格前10行的数据和后15行的数据"><a href="#1-2-2-任务二：观察表格前10行的数据和后15行的数据" class="headerlink" title="1.2.2 任务二：观察表格前10行的数据和后15行的数据"></a>1.2.2 任务二：观察表格前10行的数据和后15行的数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">df.head(<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>是否幸存</th>
      <th>仓位等级</th>
      <th>姓名</th>
      <th>性别</th>
      <th>年龄</th>
      <th>兄弟姐妹个数</th>
      <th>父母子女个数</th>
      <th>船票信息</th>
      <th>票价</th>
      <th>客舱</th>
      <th>登船港口</th>
    </tr>
    <tr>
      <th>乘客ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>C123</td>
      <td>S</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0</td>
      <td>3</td>
      <td>Moran, Mr. James</td>
      <td>male</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>330877</td>
      <td>8.4583</td>
      <td>NaN</td>
      <td>Q</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0</td>
      <td>1</td>
      <td>McCarthy, Mr. Timothy J</td>
      <td>male</td>
      <td>54.0</td>
      <td>0</td>
      <td>0</td>
      <td>17463</td>
      <td>51.8625</td>
      <td>E46</td>
      <td>S</td>
    </tr>
    <tr>
      <th>8</th>
      <td>0</td>
      <td>3</td>
      <td>Palsson, Master. Gosta Leonard</td>
      <td>male</td>
      <td>2.0</td>
      <td>3</td>
      <td>1</td>
      <td>349909</td>
      <td>21.0750</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>9</th>
      <td>1</td>
      <td>3</td>
      <td>Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)</td>
      <td>female</td>
      <td>27.0</td>
      <td>0</td>
      <td>2</td>
      <td>347742</td>
      <td>11.1333</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>10</th>
      <td>1</td>
      <td>2</td>
      <td>Nasser, Mrs. Nicholas (Adele Achem)</td>
      <td>female</td>
      <td>14.0</td>
      <td>1</td>
      <td>0</td>
      <td>237736</td>
      <td>30.0708</td>
      <td>NaN</td>
      <td>C</td>
    </tr>
    <tr>
      <th>11</th>
      <td>1</td>
      <td>3</td>
      <td>Sandstrom, Miss. Marguerite Rut</td>
      <td>female</td>
      <td>4.0</td>
      <td>1</td>
      <td>1</td>
      <td>PP 9549</td>
      <td>16.7000</td>
      <td>G6</td>
      <td>S</td>
    </tr>
    <tr>
      <th>12</th>
      <td>1</td>
      <td>1</td>
      <td>Bonnell, Miss. Elizabeth</td>
      <td>female</td>
      <td>58.0</td>
      <td>0</td>
      <td>0</td>
      <td>113783</td>
      <td>26.5500</td>
      <td>C103</td>
      <td>S</td>
    </tr>
    <tr>
      <th>13</th>
      <td>0</td>
      <td>3</td>
      <td>Saundercock, Mr. William Henry</td>
      <td>male</td>
      <td>20.0</td>
      <td>0</td>
      <td>0</td>
      <td>A/5. 2151</td>
      <td>8.0500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>14</th>
      <td>0</td>
      <td>3</td>
      <td>Andersson, Mr. Anders Johan</td>
      <td>male</td>
      <td>39.0</td>
      <td>1</td>
      <td>5</td>
      <td>347082</td>
      <td>31.2750</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>15</th>
      <td>0</td>
      <td>3</td>
      <td>Vestrom, Miss. Hulda Amanda Adolfina</td>
      <td>female</td>
      <td>14.0</td>
      <td>0</td>
      <td>0</td>
      <td>350406</td>
      <td>7.8542</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
  </tbody>
</table>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">df.tail()</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-任务三：判断数据是否为空，为空的地方返回True，其余地方返回False"><a href="#1-2-4-任务三：判断数据是否为空，为空的地方返回True，其余地方返回False" class="headerlink" title="1.2.4 任务三：判断数据是否为空，为空的地方返回True，其余地方返回False"></a>1.2.4 任务三：判断数据是否为空，为空的地方返回True，其余地方返回False</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">df.isnull().head()</span><br></pre></td></tr></table></figure>
<p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>是否幸存</th>
      <th>仓位等级</th>
      <th>姓名</th>
      <th>性别</th>
      <th>年龄</th>
      <th>兄弟姐妹个数</th>
      <th>父母子女个数</th>
      <th>船票信息</th>
      <th>票价</th>
      <th>客舱</th>
      <th>登船港口</th>
    </tr>
    <tr>
      <th>乘客ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>5</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
    </tr>
  </tbody>
</table><br>【总结】上面的操作都是数据分析中对于数据本身的观察</p>
<p>【思考】对于一个数据，还可以从哪些方面来观察？找找答案，这个将对下面的数据分析有很大的帮助</p>
<h3 id="1-3-保存数据"><a href="#1-3-保存数据" class="headerlink" title="1.3 保存数据"></a>1.3 保存数据</h3><h4 id="1-3-1-任务一：将你加载并做出改变的数据，在工作目录下保存为一个新文件train-chinese-csv"><a href="#1-3-1-任务一：将你加载并做出改变的数据，在工作目录下保存为一个新文件train-chinese-csv" class="headerlink" title="1.3.1 任务一：将你加载并做出改变的数据，在工作目录下保存为一个新文件train_chinese.csv"></a>1.3.1 任务一：将你加载并做出改变的数据，在工作目录下保存为一个新文件train_chinese.csv</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line"><span class="comment"># 注意：不同的操作系统保存下来可能会有乱码。大家可以加入`encoding=&#x27;GBK&#x27; 或者 ’encoding = ’utf-8‘‘`</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;./titanic/train_chinese.csv&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>【总结】数据的加载以及入门，接下来就要接触数据本身的运算，我们将主要掌握numpy和pandas在工作和项目场景的运用。</p>
</class>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/" class="post-title-link" itemprop="url">python web——fastapi</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-14T00:00:00+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-14 09:12:41" itemprop="dateModified" datetime="2025-07-14T09:12:41+08:00">2025-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/" itemprop="url" rel="index"><span itemprop="name">python-web</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/fastapi/" itemprop="url" rel="index"><span itemprop="name">fastapi</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 并基于标准的 Python 类型提示。</p>
<p>关键特性:</p>
<ul>
<li><strong>快速</strong>：可与 <strong>NodeJS</strong> 和 <strong>Go</strong> 并肩的极高性能（归功于 Starlette 和 Pydantic）。<a target="_blank" rel="noopener" href="https://fastapi.tiangolo.com/zh/#_11">最快的 Python web 框架之一</a>。</li>
<li><strong>高效编码</strong>：提高功能开发速度约 200％ 至 300％。*</li>
<li><strong>更少 bug</strong>：减少约 40％ 的人为（开发者）导致错误。*</li>
<li><strong>智能</strong>：极佳的编辑器支持。处处皆可自动补全，减少调试时间。</li>
<li><strong>简单</strong>：设计的易于使用和学习，阅读文档的时间更短。</li>
<li><strong>简短</strong>：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。</li>
<li><strong>健壮</strong>：生产可用级别的代码。还有自动生成的交互式文档。</li>
<li><strong>标准化</strong>：基于（并完全兼容）API 的相关开放标准：<a target="_blank" rel="noopener" href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> (以前被称为 Swagger) 和 <a target="_blank" rel="noopener" href="https://json-schema.org/">JSON Schema</a>。</li>
</ul>
<h3 id="两个核心组件：Starlette-和-Pydantic"><a href="#两个核心组件：Starlette-和-Pydantic" class="headerlink" title="两个核心组件：Starlette 和 Pydantic"></a>两个核心组件：Starlette 和 Pydantic</h3><p>Starlette 负责web部分</p>
<p>Starlette 是 FastAPI 的底层 ASGI（异步服务器网关接口）框架，为 FastAPI 提供了异步编程能力和高性能的网络通信支持。</p>
<p>ASGI（<strong>Asynchronous Server Gateway Interface</strong> ）是一种用于连接 Python Web 服务器和应用程序框架的<strong>异步接口标准</strong> ，旨在支持现代 Web 协议（如 WebSocket、HTTP/2）和异步编程模型</p>
<p>Pydantic负责</p>
<p>Pydantic 负责 FastAPI 的数据验证、序列化和自动文档生成</p>
<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p><strong>HTTP协议</strong> 是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于万维网（WWW: World Wide Web）服务器与本地浏览器之间传输超文本的传送协议。HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/1.png" alt="1"></p>
<h4 id="二、http协议特性"><a href="#二、http协议特性" class="headerlink" title="二、http协议特性"></a>二、http协议特性</h4><p>（1）基于 TCP/IP 协议</p>
<p>http 协议是基于 <strong>TCP/IP 协议</strong>之上的应用层协议。</p>
<p>（2）基于请求 - 响应模式</p>
<p>HTTP 协议规定，请求从客户端发出，最后服务器端响应应该请求并返回。换句话说，肯定是先<strong>从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应</strong>。</p>
<p>（3）无状态保存</p>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。</p>
<p>使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并<strong>不保留之前一切的请求或响应报文的信息</strong>。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。</p>
<p>（4）短连接</p>
<p>HTTP 1.0 默认使用的是短连接。浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。 </p>
<p>HTTP 1.1 起，默认使用长连接。要使用长连接，客户端和服务器的 HTTP 首部的 Connection 都要设置为 keep - alive，才能支持长连接。 </p>
<p>HTTP 长连接，指的是复用 TCP 连接。多个 HTTP 请求可以复用同一个 TCP 连接，这就节省了 TCP 连接建立和断开的消耗。</p>
<h4 id="三、http请求协议与响应协议"><a href="#三、http请求协议与响应协议" class="headerlink" title="三、http请求协议与响应协议"></a>三、http请求协议与响应协议</h4><p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/2.png" alt="2"></p>
<blockquote>
<p>Socket（套接字）是计算机网络中用于实现进程间双向通信的端点抽象，它为应用层进程通过网络协议交换数据提供了统一的接口。具体来说，Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，本质上是一组封装了复杂网络协议的接口，简化了开发者对底层通信细节的操作。</p>
<p>从功能上看，Socket 可以看作是网络通信的“电话插座”：两个设备（如客户端与服务器）通过 Socket 建立连接后，即可像电话通话一样进行数据交换，而端口号则类似于插座上的插孔，用于标识具体的通信进程，且不能被其他进程占用。此外，Socket 包含网络通信必需的五种核心信息，例如使用的协议（TCP/UDP）、本地与远程地址、端口等，构成了网络通信的基本操作单元。</p>
<p>总结而言，Socket 既是通信端点的逻辑概念，也是实现网络应用层交互的关键工具，其设计目标是屏蔽底层协议的复杂性，提供统一的编程接口。</p>
</blockquote>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/3.png" alt="3"></p>
<blockquote>
<p>GET ：请求参数通过 URL 的查询字符串（Query String）传递，数据暴露在地址栏中，例如：<a href="https://example.com">https://example.com</a> ?name=value</p>
<p>POST ：请求参数存储在请求体（Body）中传输，相对更安全，且支持传输非字符串数据（如文件、二进制等）</p>
<p>一个完整的URL包括：协议、ip、端口、路径、参数</p>
<p>例如：<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=yuan">https://www.baidu.com/s?wd=yuan</a> 其中https是协议，www.baidu.com 是IP，端口默认80，/s是路径，参数是wd=yuan</p>
<p>请求方式：get与post请求</p>
<ul>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456。POST方法是把提交的数据放在HTTP包的请求体中。</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制</li>
</ul>
<p>响应状态码：状态码的职责是当客户端向服务器端发送请求时，返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了问题。状态码如200 OK，以3位数字和原因组成。</p>
</blockquote>
<p>测试http协议格式：请求与响应</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#web应用程序：遵循http协议</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock=socket.socket()</span><br><span class="line">sock.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    conn 表示新建立的套接字对象，用于在服务器和客户端之间进行数据传输。</span></span><br><span class="line"><span class="string">    addr 是一个元组，它包含了连接进来的客户端的 IP 地址和端口号。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    conn, addr = sock.accept()<span class="comment">#阻塞等待客户端连接</span></span><br><span class="line">    data=conn.recv(<span class="number">1024</span>)<span class="comment">#请求报文</span></span><br><span class="line">    <span class="comment"># data 是一个字节串，包含了客户端发送的请求信息。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;客户端发送的请求信息：\n&quot;</span>,data)</span><br><span class="line">    conn.send(<span class="string">b&quot;HTTP/1.1 200 ok\r\nserver:zxj\r\n\r\nhello world&quot;</span>)<span class="comment">#响应首行+响应头+响应体</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<p>测试post请求：urlencoded格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 socket 连接</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 POST 请求报文</span></span><br><span class="line">path = <span class="string">&quot;/&quot;</span>  <span class="comment"># 目标路径</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,  <span class="comment"># 数据格式</span></span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="built_in">len</span>(<span class="string">&quot;username=admin&amp;password=123456&quot;</span>)  <span class="comment"># 数据长度</span></span><br><span class="line">&#125;</span><br><span class="line">body = <span class="string">&quot;username=admin&amp;password=123456&quot;</span>  <span class="comment"># 请求体（表单数据）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接请求报文</span></span><br><span class="line">request = <span class="string">f&quot;POST <span class="subst">&#123;path&#125;</span> HTTP/1.1\r\n&quot;</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> headers.items():</span><br><span class="line">    request += <span class="string">f&quot;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;v&#125;</span>\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;\r\n&quot;</span>  <span class="comment"># 空行分隔头部与主体</span></span><br><span class="line">request += body</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">client.send(request.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收响应</span></span><br><span class="line">response = client.recv(<span class="number">4096</span>)</span><br><span class="line"><span class="built_in">print</span>(response.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>
<p>测试post请求：json格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义请求地址</span></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1:8080&quot;</span></span><br><span class="line"><span class="comment"># 定义 JSON 数据（字典格式）</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 POST 请求</span></span><br><span class="line">response = requests.post(</span><br><span class="line">    url, </span><br><span class="line">    json=data  <span class="comment"># 使用 json 参数自动序列化字典并设置 Content-Type: application/json</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出响应结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;状态码:&quot;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;响应内容:&quot;</span>, response.text)  <span class="comment"># 使用 text 获取原始响应文本</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">客户端发送的请求信息：</span></span><br><span class="line"><span class="string"> b&#x27;POST / HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nUser-Agent: python-requests/2.32.2\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 43\r\nContent-Type: application/json\r\n\r\n&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 <code>json=data</code> 参数，<code>requests</code> 会自动将字典转换为 JSON 字符串，并设置请求头 <code>Content-Type: application/json</code>，无需手动调用 <code>json.dumps()</code> 或配置 headers </p>
<p>SSL 验证是指通过 SSL 证书验证网站身份并确保通信安全的过程。其核心目标是确认服务器的真实性、防止身份伪造，并建立加密连接以保护数据传输的安全性</p>
<p>HTTPS（HyperText Transfer Protocol Secure）是以安全为目标的 HTTP 通道，通过在 HTTP 基础上加入加密和身份认证机制，确保数据传输的隐私性、完整性和服务器身份的真实性</p>
<p>https=http+ssl</p>
<p>通过 <code>Content-Type</code>，服务器可识别请求体（Body）的格式（如 JSON、表单数据），客户端可解析响应数据的类型（如 HTML、图片）</p>
<p>例如：conn.send(b”HTTP/1.1 200 ok\r\nserver:zxj\r\n<strong>content-type:text/html</strong>\r\n\r\n</p><h1>hello world&lt;\h1&gt;”)<p></p>
<p>再例如：‘HTTP/1.1 200 ok\r\nserver:zxj\r\n<strong>content-type:application/json</strong>\r\n\r\n{“user_id”:zxj}’</p>
</h1></blockquote>
<h5 id="api接口"><a href="#api接口" class="headerlink" title="api接口"></a>api接口</h5><p>在开发web应用中，有两种应用模式：</p>
<p>1.前后端不分离：客户端看到的内容和所有页面效果都是有服务端提供出来的</p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/4.png" alt="4"></p>
<p>2.前后端分离：把前端的页面效果（html，css，js分离到另一个服务端，python服务端只需要返回数据即可）</p>
<p>前端形成一个独立的网站，服务端构成一个独立的网站</p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/5.png" alt="5"></p>
<p><strong>应用程序编程接口（Application Programming Interface，API接口）</strong>，就是应用程序对外提供了一个操作数据的入口，这个入口可以是一个函数或类方法，也可以是一个url地址或者一个网络地址。当客户端调用这个入口，应用程序则会执行对应代码操作，给客户端完成相对应的功能。</p>
<p>当然，api接口在工作中是比较常见的开发内容，有时候，我们会调用其他人编写的api接口，有时候，我们也需要提供api接口给其他人操作。由此就会带来一个问题，api接口往往都是一个函数、类方法、或者url或其他网络地址，不断是哪一种，当api接口编写过程中，我们都要考虑一个问题就是这个接口应该怎么编写？接口怎么写的更加容易维护和清晰，这就需要大家在调用或者编写api接口的时候要有一个明确的编写规范！！！</p>
<p>为了在团队内部形成共识，防止个人习惯差异引起的混乱，我们都需要找到一种大家都觉得很好的接口实现规范，而且这种规范能够让后端写的接口，用途一目了然，减少客户端和服务端双方之间的合作成本。</p>
<p>目前市面上大部分公司开发人员使用的接口实现规范主要有：restful、RPC。</p>
<p>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。它首次出现在2000年Roy Fielding的博士论文中。</p>
<p>RESTful是一种专门为Web开发而定义API接口的设计风格，尤其适用于前后端分离的应用模式中。</p>
<p><strong>关键：面向资源开发</strong></p>
<p>这种风格的理念认为后端开发任务就是提供数据的，对外提供的是数据资源的访问接口，所以在定义接口时，客户端访问的URL路径就表示这种要操作的数据资源。</p>
<p>而<strong>对于数据资源分别使用POST、DELETE、GET、UPDATE等请求动作来表达对数据的增删查改</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>请求方法</th>
<th>请求地址</th>
<th>后端操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/student/</td>
<td>增加学生</td>
</tr>
<tr>
<td>GET</td>
<td>/student/</td>
<td>获取所有学生</td>
</tr>
<tr>
<td>GET</td>
<td>/student/1</td>
<td>获取id为1的学生</td>
</tr>
<tr>
<td>PUT</td>
<td>/student/1</td>
<td>修改id为1的学生</td>
</tr>
<tr>
<td>DELETE</td>
<td>/student/1</td>
<td>删除id为1的学生</td>
</tr>
</tbody>
</table>
</div>
<p>restful规范是一种通用的规范，不限制语言和开发框架的使用。事实上，我们可以使用任何一门语言，任何一个框架都可以实现符合restful规范的API接口。</p>
<h3 id="fastapi快速开始"><a href="#fastapi快速开始" class="headerlink" title="fastapi快速开始"></a>fastapi快速开始</h3><h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><p>安装：<code>pip install fastapi</code></p>
<p>还需要一个ASGI服务器，生产环境使用Uvicorn：<code>pip install uvicorn</code></p>
<blockquote>
<p>ASGI（<strong>Asynchronous Server Gateway Interface</strong> ）是一种<strong>异步服务器网关接口</strong> ，为 Python Web 应用提供了标准接口，使其能够处理现代网络协议（如 WebSocket、HTTP/2 等）的异步请求。与传统的 WSGI 不同，ASGI 支持异步编程模型，允许单个请求处理多个事件（如长连接、双向通信），从而提升高并发场景下的性能</p>
<p>Uvicorn 是一个基于 ASGI 的高性能异步 Web 服务器，专为 Python 异步框架设计。</p>
<p>web应用程序=web框架+自己写的业务逻辑代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI<span class="comment">#fastapi类</span></span><br><span class="line"></span><br><span class="line">app= FastAPI()<span class="comment">#创建一个fastapi实例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user_id&quot;</span>:<span class="number">1001</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/shop&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">shop</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;shop_id&quot;</span>:<span class="number">1002</span>&#125;</span><br></pre></td></tr></table></figure>
<p>启动：<code>uvicorn &quot;04 fastapi_begin:app&quot; --reload</code></p>
<p>也可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(app=<span class="string">&quot;04 fastapi_begin:app&quot;</span>,port=<span class="number">8080</span>,reload=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>接口文档</p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/6.png" alt="6"></p>
<blockquote>
<p>修饰器（Decorator）是 Python 中一种动态修改函数或类行为的高级功能，本质上是一个函数或类，它<strong>接受目标函数或类作为参数，并返回包装后的新函数或类对象</strong>，从而在<strong>不修改原始代码</strong> 的前提下为对象添加额外功能</p>
</blockquote>
<h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><h4 id="路径操作修饰器"><a href="#路径操作修饰器" class="headerlink" title="路径操作修饰器"></a>路径操作修饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get()</span></span><br><span class="line"><span class="meta">@app.post()</span></span><br><span class="line"><span class="meta">@app.put()</span></span><br><span class="line"><span class="meta">@app.patch()</span></span><br><span class="line"><span class="meta">@app.delete()</span></span><br><span class="line"><span class="meta">@app.options()</span></span><br><span class="line"><span class="meta">@app.head()</span></span><br><span class="line"><span class="meta">@app.trace()</span></span><br></pre></td></tr></table></figure>
<p>路径操作修饰器参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tags为接口添加标签，用于在自动生成的文档</span></span><br><span class="line"><span class="string">summary为接口添加描述</span></span><br><span class="line"><span class="string">description为接口添加详细描述</span></span><br><span class="line"><span class="string">response_description为接口返回值描述</span></span><br><span class="line"><span class="string">deprecated为过时的接口</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/post&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="meta">        tags=[<span class="string">&quot;这是post方法&quot;</span>],</span></span></span><br><span class="line"><span class="params"><span class="meta">        summary=<span class="string">&quot;这是post方法的描述&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        description=<span class="string">&quot;这是post方法的详细描述&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        response_description=<span class="string">&quot;这是post方法的返回值描述&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        deprecated=<span class="literal">True</span>, <span class="comment"># 过时的接口</span></span></span></span><br><span class="line"><span class="params"><span class="meta">        </span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br></pre></td></tr></table></figure>
<h4 id="include-router"><a href="#include-router" class="headerlink" title="include_router"></a>include_router</h4><p>文件路径如下</p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/7.png" alt="7"></p>
<p>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> apps.app01.shop <span class="keyword">import</span> shop</span><br><span class="line"><span class="keyword">from</span> apps.app02.user <span class="keyword">import</span> user</span><br><span class="line"></span><br><span class="line">app= FastAPI()</span><br><span class="line"></span><br><span class="line">app.include_router(shop,</span><br><span class="line">                 prefix=<span class="string">&quot;/shop&quot;</span>, <span class="comment"># 路由前缀</span></span><br><span class="line">                 tags=[<span class="string">&quot;购物中心接口&quot;</span>], <span class="comment"># 标签</span></span><br><span class="line">                 responses=&#123;<span class="number">200</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;成功&quot;</span>&#125;&#125; <span class="comment"># 响应描述</span></span><br><span class="line">                 )</span><br><span class="line">app.include_router(user,</span><br><span class="line">                 prefix=<span class="string">&quot;/user&quot;</span>, <span class="comment"># 路由前缀</span></span><br><span class="line">                 tags=[<span class="string">&quot;用户接口&quot;</span>], <span class="comment"># 标签</span></span><br><span class="line">                 responses=&#123;<span class="number">200</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;成功&quot;</span>&#125;&#125; <span class="comment"># 响应描述</span></span><br><span class="line">                 )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(<span class="string">&quot;main:app&quot;</span>, port=<span class="number">8080</span>,  reload=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>shop.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line">shop=APIRouter()</span><br><span class="line"></span><br><span class="line"><span class="meta">@shop.get(<span class="params"><span class="string">&quot;/food&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shop_food</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;food&quot;</span>:<span class="string">&quot;shop food&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@shop.get(<span class="params"><span class="string">&quot;/drink&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shop_drink</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;drink&quot;</span>:<span class="string">&quot;shop drink&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>user.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line">user=APIRouter()</span><br><span class="line"></span><br><span class="line"><span class="meta">@user.post(<span class="params"><span class="string">&quot;/login&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_login</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>:<span class="string">&quot;user login&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@user.post(<span class="params"><span class="string">&quot;/register&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_register</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>:<span class="string">&quot;user register&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>include_router</code> 是 FastAPI 框架中用于整合路由的核心方法，其作用是将通过 <code>APIRouter</code> 定义的路由模块添加到主应用程序实例中，使这些路由在应用中生效。</p>
</blockquote>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/8.png" alt="8"></p>
<h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><h4 id="4-1-路径参数"><a href="#4-1-路径参数" class="headerlink" title="4.1 路径参数"></a>4.1 路径参数</h4><h5 id="（1）基本用法"><a href="#（1）基本用法" class="headerlink" title="（1）基本用法"></a>（1）基本用法</h5><p>以使用与 Python 格式化字符串相同的语法来声明路径”参数”或”变量”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(user_id, <span class="built_in">type</span>(user_id))</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user_id&quot;</span>: user_id&#125;</span><br></pre></td></tr></table></figure>
<p>路径参数 <code>user_id</code> 的值将作为参数 <code>user_id</code> 传递给你的函数。</p>
<h5 id="（2）有类型的路径参数"><a href="#（2）有类型的路径参数" class="headerlink" title="（2）有类型的路径参数"></a>（2）有类型的路径参数</h5><p>你可以使用标准的 Python 类型标注为函数中的路径参数声明类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">user_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(user_id, <span class="built_in">type</span>(user_id))</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user_id&quot;</span>: user_id&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>user_id</code> 被声明为 int 类型。</p>
<blockquote>
<p>这将为你的函数提供编辑器支持，包括错误检查、代码补全等等。</p>
</blockquote>
<h5 id="（3）注意顺序"><a href="#（3）注意顺序" class="headerlink" title="（3）注意顺序"></a>（3）注意顺序</h5><p>在创建路径操作时，你会发现有些情况下路径是固定的。</p>
<p>比如 <code>/users/me</code>，我们假设它用来获取关于当前用户的数据。</p>
<p>然后，你还可以使用路径 <code>/user/&#123;username&#125;</code> 来通过用户名获取关于特定用户的数据。</p>
<p>由于路径操作是<strong>按顺序依次运行</strong>的，你需要确保路径 /<code>user/me</code> 声明在路径 <code>/user/&#123;username&#125;</code> 之前。</p>
<p>如下</p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250516193934740.png" alt="image-20250516193934740"></p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250516201128482.png" alt="image-20250516201128482"></p>
<blockquote>
<p>路由（Routing）是指在网络中<strong>选择数据传输路径</strong>的过程，其核心目标是将数据从源点高效、可靠地传输到目的地</p>
<p>cURL 是一个开源的命令行工具和跨平台的库（libcurl），用于基于 URL 语法在网络协议下进行数据传输。它支持多种协议（如 HTTP、HTTPS、FTP、SMTP 等），能够实现文件上传、下载以及与 Web 服务器的交互，常被开发者用于 API 测试、数据传输等场景</p>
</blockquote>
<h4 id="4-2-查询参数（请求参数）"><a href="#4-2-查询参数（请求参数）" class="headerlink" title="4.2 查询参数（请求参数）"></a>4.2 查询参数（请求参数）</h4><p>路径函数中声明<strong>不属于路径参数的其他函数参数</strong>时，它们将被<strong>自动解释为查询字符串参数</strong>，就是 <code>url？</code>之后用 <code>&amp;</code> 分割的 <code>key-value 键值对</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app02.get(<span class="params"><span class="string">&quot;/jobs&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_jobs</span>(<span class="params">kind1: <span class="built_in">str</span>, kind2: <span class="built_in">str</span>, kind3: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment">#基于查询参数的值来执行不同的操作</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;kind1&quot;</span>: kind1,</span><br><span class="line">        <span class="string">&quot;kind2&quot;</span>: kind2,</span><br><span class="line">        <span class="string">&quot;kind3&quot;</span>: kind3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250516201707589.png" alt="image-20250516201707589"></p>
<p>增加路径参数：kind1为路径参数</p>
<p>增加默认参数值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app02.get(<span class="params"><span class="string">&quot;/jobs/&#123;kind1&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_jobs</span>(<span class="params">kind1: <span class="built_in">str</span>, kind2: <span class="built_in">str</span>=<span class="string">&quot;None&quot;</span>, kind3: <span class="built_in">str</span>=<span class="string">&quot;None&quot;</span></span>):<span class="comment">#增加默认值，可选填</span></span><br><span class="line">    <span class="comment">#基于查询参数的值来执行不同的操作</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;kind1&quot;</span>: kind1,</span><br><span class="line">        <span class="string">&quot;kind2&quot;</span>: kind2,</span><br><span class="line">        <span class="string">&quot;kind3&quot;</span>: kind3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Request URL：</p>
<p><code>http://127.0.0.1:8080/app02/jobs/11?kind2=22&amp;kind3=33</code></p>
<p>自python3.5开始，PEP484为python引入了类型注解(type hints)，typing的主要作用有：</p>
<blockquote>
<p>1.类型检查，防止运行时出现参数、返回值类型不符。</p>
<p>2.作为开发文档附加说明，方便使用者调用时传入和返回参数类型。</p>
<p>3.模块加入不会影响程序的运行不会报正式的错误，pycharm支持typing检查错误时会出现黄色警告。</p>
</blockquote>
<p><code>type hints</code>主要是要指示函数的输入和输出的数据类型，数据类型在typing包中，基本类型有<code>str list dict</code>等等，</p>
<blockquote>
<p>Type Hints 是 Python 3.5 引入的功能，通过类型注解增强代码的可读性和可维护性。它允许开发者为变量、函数参数、返回值等指定预期的数据类型，从而帮助静态类型检查工具（如 <code>mypy</code>）捕获潜在错误，并提升 IDE 的智能提示能力。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>此处 <code>name: str</code> 表示参数需为字符串类型，<code>-&gt; str</code> 表示返回值类型为字符串 。</p>
</blockquote>
<p><code>Union</code>是当有多种可能的数据类型时使用，比如函数有可能根据不同情况有时返回str或返回list，那么就可以写成<code>Union[list, str]</code></p>
<blockquote>
<p>从 Python 3.10 起，<code>Union[X, Y]</code> 可简写为 <code>X | Y</code>。例如 <code>int | str</code> 等价于 <code>Union[int, str]</code> 。</p>
<p>再例如：<code>kind2:str|None=None</code></p>
</blockquote>
<p><code>Optional</code>是Union的一个简化，当数据类型中有可能是None时，比如有可能是str也有可能是None，则Optional[str]，相当于Union[str, None]</p>
<h4 id="4-3-请求体数据"><a href="#4-3-请求体数据" class="headerlink" title="4.3 请求体数据"></a>4.3 请求体数据</h4><p>当你需要将数据从客户端（例如浏览器）发送给 API 时，你将其作为「请求体」发送。请求体是客户端发送给 API 的数据。响应体是 API 发送给客户端的数据。</p>
<p>FastAPI 基于 <code>Pydantic</code> ，<code>Pydantic</code> 主要用来做类型强制检查（校验数据）。不符合类型要求就会抛出异常。</p>
<p>对于 API 服务，支持类型检查非常有用，会让服务更加健壮，也会加快开发速度，因为开发者再也不用自己写一行一行的做类型检查。</p>
<p>安装上手 <code>pip install pydantic</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel,Field,field_validator</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>,<span class="type">Optional</span></span><br><span class="line"></span><br><span class="line">app03 = APIRouter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    province: <span class="built_in">str</span></span><br><span class="line">    city: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="comment">#正则表达式</span></span><br><span class="line">    <span class="comment">#username:str=Field(pattern=&quot;^[a-zA-Z0-9]&#123;3,10&#125;$&quot;,title=&quot;用户名&quot;,description=&quot;用户名长度在3-10之间，且只能包含字母和数字&quot;)</span></span><br><span class="line">    <span class="comment">#name: str|None = None</span></span><br><span class="line">    name:<span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span>=Field(default=<span class="number">0</span>,gt=<span class="number">0</span>,lt=<span class="number">100</span>)</span><br><span class="line">    birth:<span class="type">Union</span>[date,<span class="literal">None</span>] = <span class="literal">None</span></span><br><span class="line">    friends:<span class="built_in">list</span>[<span class="built_in">int</span>]=[]</span><br><span class="line">    description:<span class="type">Optional</span>[<span class="built_in">str</span>]=<span class="literal">None</span></span><br><span class="line">    <span class="comment">#嵌套</span></span><br><span class="line">    addr:Address|<span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    field_validator 的第一个参数必须是 cls，因为它是类方法 （classmethod），用于在验证字段时访问模型类的上下文。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">    @field_validator(<span class="params"><span class="string">&quot;name&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name_must_alpha</span>(<span class="params">cls,value</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        value.isalpha() 会检查字符串是否只由字母组成，如果是则返回 True，否则返回 False。</span></span><br><span class="line"><span class="string">        如果返回 False，assert 触发，会抛出 AssertionError，并显示错误信息 &quot;name must be alpha&quot;。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> value.isalpha(), <span class="string">&quot;name must be alpha&quot;</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    data:<span class="built_in">list</span>[User]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app03.post(<span class="params"><span class="string">&quot;/user&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">user</span>(<span class="params">user:User</span>):</span><br><span class="line">    <span class="built_in">print</span>(user,<span class="built_in">type</span>(user))</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"><span class="meta">@app03.post(<span class="params"><span class="string">&quot;/data&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">data:Data</span>):</span><br><span class="line">    <span class="built_in">print</span>(data,<span class="built_in">type</span>(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>BaseModel</code>专门用于数据验证、数据转换和序列化。在定义数据结构时继承自 BaseModel，可以：</p>
<ul>
<li><strong>自动校验数据类型</strong>：根据类中字段的类型注解，自动校验输入数据是否符合预期类型。</li>
<li><strong>数据转换</strong>：可以自动将输入数据（例如 JSON 字符串）转换成相应的 Python 数据类型。</li>
<li><strong>序列化输出</strong>：支持将模型实例转换成 JSON、字典等格式，便于响应输出。</li>
</ul>
<p>在 Pydantic 中，<code>Field</code> 用于为模型字段提供额外的信息，比如设置默认值、描述信息、约束条件（例如长度、范围等）或别名。这可以帮助自动生成 OpenAPI 文档、增强验证或对字段进行更细粒度的控制。</p>
<p><code>field_validator</code> 是 Pydantic v2 中用于替代旧版 <code>@validator</code> 的新装饰器，专门用于为模型字段添加自定义验证逻辑。它通过更清晰的命名和更灵活的模式（如 <code>mode=&quot;before&quot;</code> 或 <code>mode=&quot;after&quot;</code>）提升代码可读性和验证逻辑的控制能力</p>
<p><code>field_validator</code>和<code>model_validator</code>区别</p>
<p><strong><code>field_validator</code></strong>专门针对<strong>单个字段</strong> 进行验证，适用于需要校验特定字段的规则（如长度、格式、类型约束）。例如验证用户名长度</p>
<p><strong><code>model_validator</code></strong>作用于<strong>整个模型实例</strong> ，适用于需要跨字段验证或全局逻辑的场景。例如检查两次密码是否一致</p>
</blockquote>
<h4 id="4-4-form表单数据"><a href="#4-4-form表单数据" class="headerlink" title="4.4 form表单数据"></a>4.4 form表单数据</h4><p>在 <code>OAuth2</code> 规范的一种使用方式（密码流）中，需要将用户名、密码作为表单字段发送，而不是 JSON。</p>
<p>FastAPI 可以使用 <strong>Form 组件</strong>来接收表单数据，需要先使用 <code>pip install python-multipart</code> 命令进行安装。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app04.post(<span class="params"><span class="string">&quot;/register&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">username:<span class="built_in">str</span>=Form(<span class="params"></span>),password:<span class="built_in">str</span>=Form(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;username: <span class="subst">&#123;username&#125;</span>, password: <span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: password</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>发送post请求：form表单数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标 URL</span></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1:8080/app04/register&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表单数据（键值对）</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;test_user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;secure_password_123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 POST 请求</span></span><br><span class="line">response = requests.post(</span><br><span class="line">    url, </span><br><span class="line">    data=data</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 requests.post() 的 data 参数传递表单数据，该参数接受字典或字符串格式的数据。requests 会自动将其编码为 application/x-www-form-urlencoded 格式</p>
</blockquote>
<h4 id="4-5-文件上传"><a href="#4-5-文件上传" class="headerlink" title="4.5 文件上传"></a>4.5 文件上传</h4><p>导入必要库</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> File,UploadFile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">app05 = APIRouter()</span><br></pre></td></tr></table></figure>
<p>通过字节上传</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app05.post(<span class="params"><span class="string">&quot;/file&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">file</span>(<span class="params">file: <span class="built_in">bytes</span> = File(<span class="params">...</span>)</span>):</span><br><span class="line">    <span class="comment">#适合小文件上传</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;file&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: <span class="built_in">len</span>(file)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>多文件上传</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app05.post(<span class="params"><span class="string">&quot;/files&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">files</span>(<span class="params">files: <span class="built_in">list</span>[<span class="built_in">bytes</span>] = File(<span class="params">...</span>)</span>):</span><br><span class="line">    <span class="comment">#多文件上传</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(file))</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;files&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: <span class="built_in">len</span>(files)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>UploadFile上传，绝对路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app05.post(<span class="params"><span class="string">&quot;/uploadfile&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">upload_file</span>(<span class="params">file: UploadFile= File(<span class="params">...</span>)</span>):</span><br><span class="line">    <span class="comment">#适合大文件上传</span></span><br><span class="line">    <span class="comment"># 获取当前文件的绝对路径</span></span><br><span class="line">    base_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    <span class="built_in">print</span>(base_dir)</span><br><span class="line">    img_dir = os.path.join(base_dir, <span class="string">&quot;../imgs&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(img_dir)</span><br><span class="line">    <span class="comment"># 创建目录</span></span><br><span class="line">    path = os.path.join(img_dir, file.filename)</span><br><span class="line">    <span class="comment">#path=os.path.join(&quot;../imgs&quot;,file.filename)</span></span><br><span class="line">    <span class="built_in">print</span>(path)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件名:&quot;</span>, file.filename)</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> file.file:</span><br><span class="line">            f.write(chunk)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;filename&quot;</span>: file.filename</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>UploadFile是 FastAPI 提供的一个类，用于处理文件上传。与直接将文件内容读取为字节流（例如 bytes相比，UploadFile有以下优点：</p>
<ul>
<li><strong>内存优化</strong>：它采用了文件对象的方式处理上传文件，不必将整个文件内容一次性加载到内存中，适合处理大文件。</li>
<li><strong>异步支持</strong>：支持异步操作，可以用异步方式读取文件内容，提高性能。</li>
<li><strong>文件元数据</strong>：提供文件名、内容类型等元数据信息，通过属性 <code>filename</code>、<code>content_type</code> 获取。</li>
<li><strong>文件接口</strong>：通过 file 属性获取一个类文件对象，可以像操作普通文件一样读取或保存上传的文件。</li>
</ul>
</blockquote>
<h4 id="4-6-Request对象"><a href="#4-6-Request对象" class="headerlink" title="4.6 Request对象"></a>4.6 Request对象</h4><p>有些情况下我们希望能直接访问 Request 对象。例如我们在路径操作函数中想获取客户端的 IP 地址，需要在函数中声明 Request 类型的参数，FastAPI 就会自动传递 Request 对象给这个参数，我们就可以获取到 Request 对象及其属性信息，例如 header、url、cookie、session 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app06.post(<span class="params"><span class="string">&quot;/items&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">items</span>(<span class="params">request: Request</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;url:&quot;</span>, request.url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;客户端ip:&quot;</span>, request.client.host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求头:&quot;</span>, request.headers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;客户端宿主&quot;</span>,request.headers.get(<span class="string">&quot;user-agent&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cookie:&quot;</span>, request.cookies)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: request.url,</span><br><span class="line">        <span class="string">&quot;client_ip&quot;</span>: request.client.host,</span><br><span class="line">        <span class="string">&quot;headers&quot;</span>: request.headers,</span><br><span class="line">        <span class="string">&quot;user_agent&quot;</span>: request.headers.get(<span class="string">&quot;user-agent&quot;</span>),</span><br><span class="line">        <span class="string">&quot;cookies&quot;</span>: request.cookies</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7请求静态文件"><a href="#4-7请求静态文件" class="headerlink" title="4.7请求静态文件"></a>4.7请求静态文件</h4><p>在 Web 开发中，需要请求很多静态资源文件（不是由服务器生成的文件），如 css/js 和图片文件等。</p>
<p>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi.staticfiles <span class="keyword">import</span> StaticFiles</span><br><span class="line">app.mount(<span class="string">&quot;/static&quot;</span>, StaticFiles(directory=<span class="string">&quot;statics&quot;</span>))<span class="comment">#静态文件目录</span></span><br></pre></td></tr></table></figure>
<p><img src="./../../../../images/fastapi/image-20250517143857442.png" alt="image-20250517143857442"></p>
<p><img src="./../../../../images/fastapi/image-20250517143914772.png" alt="image-20250517143914772"></p>
<blockquote>
<p><strong>静态网站</strong></p>
<p>完全由静态文件（HTML、CSS、JavaScript）组成，内容固定不变，所有页面在开发时已预生成，无需动态计算或数据库支持</p>
<p><strong>动态网站</strong></p>
<p>内容根据用户请求实时生成，通常依赖数据库和服务器端编程（如PHP、Python、Node.js），能提供个性化和交互功能</p>
<p><code>StaticFiles</code>是 FastAPI（实际来自 Starlette）提供的一个类，用于挂载和服务静态文件目录。<br>它的作用是让你可以通过 HTTP 路径直接访问服务器上的静态资源（如图片、CSS、JS 文件等）。</p>
<p><code>mount()</code>方法用于将一个完整的应用或静态文件目录挂载到主 FastAPI 应用的某个路径下。这样，访问指定路径时，请求会被转发到挂载的应用或目录。</p>
</blockquote>
<h4 id="4-8-响应模型相关参数"><a href="#4-8-响应模型相关参数" class="headerlink" title="4.8 响应模型相关参数"></a>4.8 响应模型相关参数</h4><h5 id="response-model"><a href="#response-model" class="headerlink" title="response_model"></a>response_model</h5><p><code>response_model</code>是 FastAPI 路由装饰器（如 <code>@app.post</code>、<code>@app.get</code> 等）中的一个参数，用于指定接口响应的数据模型。它的作用是：</p>
<ul>
<li><strong>自动校验和序列化</strong>：FastAPI 会根据你指定的 Pydantic 模型自动校验、过滤和格式化返回的数据。</li>
<li><strong>自动生成文档</strong>：接口文档会自动显示响应的数据结构。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserIn</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="built_in">str</span>|<span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserOut</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="built_in">str</span>|<span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app07.post(<span class="params"><span class="string">&quot;/user02&quot;</span>,response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_user</span>(<span class="params">user: UserIn</span>):</span><br><span class="line">    <span class="comment"># 这里可以进行一些处理，比如将用户信息存储到数据库中</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<ul>
<li>注册功能</li>
<li>输入账号、密码、昵称、邮箱，注册成功后返回个人信息</li>
</ul>
<h5 id="response-model-exclude-unset-True"><a href="#response-model-exclude-unset-True" class="headerlink" title="response_model_exclude_unset=True"></a>response_model_exclude_unset=True</h5><p>通过上面的例子，我们学到了如何用 response_model 控制响应体结构，但是，如果它们实际上没有存储，则可能要从结果中忽略它们。例如，如果 model 在 NoSQL 数据库中具有很多可选属性，但是不想发送很长的 JSON 响应，其中包含默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name:<span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span>|<span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax:<span class="built_in">float</span>=<span class="number">10.5</span></span><br><span class="line">    tags: <span class="built_in">list</span>[<span class="built_in">str</span>]|<span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟数据库</span></span><br><span class="line">items=&#123;</span><br><span class="line">    <span class="string">&quot;item01&quot;</span>:Item(name=<span class="string">&quot;item01&quot;</span>,price=<span class="number">10.5</span>),</span><br><span class="line">    <span class="string">&quot;item02&quot;</span>:Item(name=<span class="string">&quot;item02&quot;</span>,description=<span class="string">&quot;item02&quot;</span>,price=<span class="number">20.5</span>,tax=<span class="number">20.5</span>,tags=[<span class="string">&quot;tag1&quot;</span>,<span class="string">&quot;tag2&quot;</span>]),</span><br><span class="line">    <span class="string">&quot;item03&quot;</span>:Item(name=<span class="string">&quot;item03&quot;</span>,description=<span class="string">&quot;item03&quot;</span>,price=<span class="number">30.5</span>,tax=<span class="number">30.5</span>,tags=[<span class="string">&quot;tag1&quot;</span>,<span class="string">&quot;tag2&quot;</span>]),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app07.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>,response_model=Item,response_model_exclude_unset=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br></pre></td></tr></table></figure>
<p>设置后返回为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">item01</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item01&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">10.5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你设置 <code>response_model_exclude_unset=True</code> 时，返回的响应数据只包含<strong>被显式设置过的字段</strong>，没有被赋值的（即使用默认值且未传递的）字段不会出现在响应中。</p>
</blockquote>
<h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h5><p><strong>response_model_exclude_defaults </strong>作用：排除所有值为默认值的字段。</p>
<p><strong>response_model_exclude_none</strong> 作用：排除所有值为 <code>None</code> 的字段。</p>
<p><strong>response_model_include</strong> 作用：只返回指定字段</p>
<p><strong>response_model_exclude</strong> 作用：排除指定字段，不在响应中返回。</p>
<h3 id="jinja2模板"><a href="#jinja2模板" class="headerlink" title="jinja2模板"></a>jinja2模板</h3><p>要了解 jinja2，那么需要先理解模板的概念。模板在 Python 的 web 开发中广泛使用，它能够有效的将业务逻辑和页面逻辑分开，使代码可读性增强、并且更加容易理解和维护。</p>
<p>模板简单来说就是一个其中包涵占位变量表示动态的部分的文件，模板文件在经过动态赋值后，返回给用户。</p>
<p>jinja2 是 Flask 作者开发的一个模板系统，起初是仿 django 模板的一个模板引擎，为 Flask 提供模板支持，由于其灵活，快速和安全等优点被广泛使用。</p>
<p>在 jinja2 中，存在三种语法：</p>
<blockquote>
<ol>
<li>变量取值 <code>&#123;&#123; &#125;&#125;</code></li>
<li>控制结构 <code>&#123;% %&#125;</code></li>
</ol>
<p>应用于前后端不分离，模板html+数据库，返回动态网站</p>
</blockquote>
<h4 id="5-1-变量"><a href="#5-1-变量" class="headerlink" title="5.1 变量"></a>5.1 变量</h4><p>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi.templating <span class="keyword">import</span> Jinja2Templates</span><br><span class="line"></span><br><span class="line">templates=Jinja2Templates(directory=<span class="string">&quot;templates&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request: Request</span>):</span><br><span class="line">    <span class="comment">#数据库</span></span><br><span class="line">    name=<span class="string">&quot;World&quot;</span></span><br><span class="line">    books=[<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>]</span><br><span class="line">    user=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> templates.TemplateResponse(</span><br><span class="line">        <span class="string">&quot;index.html&quot;</span>,<span class="comment">#模板文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: request,<span class="comment"># FastAPI需要一个request对象</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">            <span class="string">&quot;books&quot;</span>: books,</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: user</span><br><span class="line">        &#125;<span class="comment">#context上下文对象</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Your favorite books are:&lt;/p&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;% <span class="keyword">for</span> book <span class="keyword">in</span> books %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; book &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;p&gt;姓名：&#123;&#123; user.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：&#123;&#123; user.age &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250517200643492.png" alt="image-20250517200643492"></p>
<h4 id="5-2-过滤器"><a href="#5-2-过滤器" class="headerlink" title="5.2 过滤器"></a>5.2 过滤器</h4><p>变量可以通过“过滤器”进行修改，过滤器可以理解为是 jinja2 里面的内置函数和字符串处理函数。常用的过滤器有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>过滤器名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>capitalize</td>
<td>把值的首字母转换成大写，其他字母转换为小写</td>
</tr>
<tr>
<td>lower</td>
<td>把值转换成小写形式</td>
</tr>
<tr>
<td>title</td>
<td>把值中每个单词的首字母都转换成大写</td>
</tr>
<tr>
<td>trim</td>
<td>把值的首尾空格去掉</td>
</tr>
<tr>
<td>striptags</td>
<td>渲染之前把值中所有的 HTML 标签都删掉</td>
</tr>
<tr>
<td>join</td>
<td>拼接多个值为字符串</td>
</tr>
<tr>
<td>round</td>
<td>默认对数字进行四舍五入，也可以用参数进行控制</td>
</tr>
<tr>
<td>safe</td>
<td>渲染时值不转义</td>
</tr>
</tbody>
</table>
</div>
<p>那么如何使用这些过滤器呢？只需要在变量后面使用管道 (|) 分割，多个过滤器可以链式调用，前一个过滤器的输出会作为后一个过滤器的输入。</p>
<p>例如：<code>&lt;h1&gt;Hello, &#123;&#123; name|upper &#125;&#125;!&lt;/h1&gt;</code>   <code>&lt;li&gt;&#123;&#123; book|title &#125;&#125;&lt;/li&gt;</code></p>
<h4 id="5-3-控制结构"><a href="#5-3-控制结构" class="headerlink" title="5.3 控制结构"></a>5.3 控制结构</h4><p>jinja2中的if语句类似与Python的if语句，它也具有单分支，多分支等多种结构，不同的是，条件语句不需要使用冒号结尾，而结束控制语句，需要使用endif关键字</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;影视区&lt;/p&gt;</span><br><span class="line"><span class="punctuation">&#123;</span>% if age &gt;= <span class="number">18</span> %<span class="punctuation">&#125;</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;成人影片&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;成人游戏&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="punctuation">&#123;</span>% else %<span class="punctuation">&#125;</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;儿童影片&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;儿童游戏&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="punctuation">&#123;</span>% endif %<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>jinja2中的for循环用于迭代Python的数据类型，包括列表、元组和字典。在jinja2中不存在while循环。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>% for book in books %<span class="punctuation">&#125;</span></span><br><span class="line">&lt;li&gt;<span class="punctuation">&#123;</span><span class="punctuation">&#123;</span> book|title <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>&lt;/li&gt;</span><br><span class="line"><span class="punctuation">&#123;</span>% endfor %<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="ORM操作"><a href="#ORM操作" class="headerlink" title="ORM操作"></a>ORM操作</h3><p>在大型的 Web 开发中，我们肯定会用到数据库操作，那么 FastAPI 也支持数据库的开发，你可以用 PostgreSQL、MySQL、SQLite、Oracle 等。本文用 SQLite 为例。我们看下在 FastAPI 是如何操作设计数据库的。</p>
<p>FastAPI 是一个很优秀的框架，但是缺少一个合适的 ORM，官方代码里面使用的是 SQLAlchemy，Tortoise ORM 是受 Django 启发的易于使用的异步 ORM（对象关系映射器）。</p>
<p>Tortoise ORM 目前支持以下数据库：</p>
<ul>
<li>PostgreSQL &gt;= 9.4（使用 asyncpg）</li>
<li>SQLite（使用 aiosqlite）</li>
<li>MySQL/MariaDB（使用 aiomysql 或使用 asyncmy）</li>
</ul>
<p>安装：<code>pip install tortoise-orm</code></p>
<h4 id="6-1-创建模型"><a href="#6-1-创建模型" class="headerlink" title="6.1 创建模型"></a>6.1 创建模型</h4><p><strong>1. 一对一关系（One-to-One）</strong></p>
<ul>
<li><strong>定义</strong> ：一张表中的一条记录仅关联另一张表中的一条记录。</li>
<li><strong>示例</strong> ：用户表（User）与身份证信息表（IDCard），一个用户仅对应一张身份证信息。</li>
</ul>
<p><strong>2. 一对多关系（One-to-Many）</strong></p>
<ul>
<li><strong>定义</strong> ：一张表中的一条记录关联另一张表中的多条记录。</li>
<li><strong>示例</strong> ：班级表（Class）与学生表（Student），一个班级包含多个学生，但每个学生只能属于一个班级。</li>
</ul>
<p><strong>3. 多对多关系（Many-to-Many）</strong></p>
<ul>
<li><strong>定义</strong> ：两张表中的记录可以互相关联多条记录，通常通过中间表实现。</li>
<li><strong>示例</strong> ：学生表（Student）与课程表（Course），一个学生可选修多门课程，一门课程也可被多个学生选修。</li>
</ul>
<p><strong>4. 自引用关系（Self-Referencing）</strong></p>
<ul>
<li><strong>定义</strong> ：表内的记录通过字段关联自身，形成层级或树状结构。</li>
<li><strong>示例</strong> ：员工表（Employee），每个员工可能有直属上级（另一个员工）。</li>
</ul>
<p><strong>5. 继承关系（Inheritance）</strong></p>
<ul>
<li><strong>定义</strong> ：基于面向对象的继承概念，子表继承父表的字段和约束。</li>
<li><strong>示例</strong> ：用户表（User）作为基表，管理员表（Admin）和普通用户表（RegularUser）继承其字段（如用户名、密码）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tortoise.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tortoise <span class="keyword">import</span> fields</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Model 是所有数据模型的基类，通过继承 Model 可定义数据库表的结构。每个 Model 子类对应一张数据库表，其类属性定义了表的字段（列）及其约束。</span></span><br><span class="line"><span class="string">fields 提供了多种字段类型，用于定义数据库表的列及其约束。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="built_in">id</span> = fields.IntField(pk=<span class="literal">True</span>)<span class="comment">#该字段会被指定为模型的主键</span></span><br><span class="line">    name = fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">    pwd = fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;密码&quot;</span>)</span><br><span class="line">    sno = fields.IntField(description=<span class="string">&quot;学号&quot;</span>)</span><br><span class="line">    <span class="comment">#一对多关系</span></span><br><span class="line">    Class_id = fields.ForeignKeyField(</span><br><span class="line">        <span class="string">&quot;models.Class&quot;</span>,<span class="comment">#关联的模型类</span></span><br><span class="line">        related_name=<span class="string">&quot;students&quot;</span>,<span class="comment">#反向查询时的名称</span></span><br><span class="line">        on_delete=fields.CASCADE,<span class="comment">#级联删除</span></span><br><span class="line">        description=<span class="string">&quot;班级&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#多对多关系</span></span><br><span class="line">    Course_id = fields.ManyToManyField(</span><br><span class="line">        <span class="string">&quot;models.Course&quot;</span>,<span class="comment">#关联的模型类</span></span><br><span class="line">        related_name=<span class="string">&quot;students&quot;</span>,<span class="comment">#反向查询时的名称</span></span><br><span class="line">        description=<span class="string">&quot;课程&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="built_in">id</span> = fields.IntField(pk=<span class="literal">True</span>)</span><br><span class="line">    name = fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;课程名称&quot;</span>)</span><br><span class="line">    teacher = fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;授课老师&quot;</span>)</span><br><span class="line">    <span class="comment">#一对多关系</span></span><br><span class="line">    teacher_id = fields.ForeignKeyField(</span><br><span class="line">        <span class="string">&quot;models.Teacher&quot;</span>,<span class="comment">#关联的模型类</span></span><br><span class="line">        related_name=<span class="string">&quot;courses&quot;</span>,<span class="comment">#反向查询时的名称</span></span><br><span class="line">        on_delete=fields.CASCADE,<span class="comment">#级联删除</span></span><br><span class="line">        description=<span class="string">&quot;老师&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="built_in">id</span> = fields.IntField(pk=<span class="literal">True</span>)</span><br><span class="line">    name= fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;班级名称&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="built_in">id</span> =fields.IntField(pk=<span class="literal">True</span>)</span><br><span class="line">    name = fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;老师姓名&quot;</span>)</span><br><span class="line">    pwd = fields.CharField(max_length=<span class="number">50</span>,description=<span class="string">&quot;密码&quot;</span>)</span><br><span class="line">    sno = fields.IntField(description=<span class="string">&quot;工号&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ORM（Object Relational Mapping，对象关系映射）是一种程序设计技术，主要用于实现<strong>面向对象编程语言</strong> 与<strong>关系型数据库</strong> 之间的数据转换。其核心思想是通过对象模型与数据库表结构的映射，将数据库操作转化为面向对象的操作，从而简化开发流程并提升代码的可维护性</p>
<p>Tortoise ORM 是一款专为 Python 异步环境设计的轻量级对象关系映射（ORM）框架，其设计灵感来源于 Django ORM，但专注于异步编程场景，适用于 FastAPI、Sanic 等基于 <code>asyncio</code> 的现代 Web 框架。</p>
<p>关系型数据库与非关系型数据库</p>
<p><strong>关系型数据库</strong><br>以表格形式存储数据，数据按行和列组织，列代表属性（字段），行代表记录。例如，用户表可能包含 <code>id</code>、<code>name</code>、<code>email</code> 等列，每行对应一个用户记录。这种结构化设计支持严格的模式约束（Schema）17。</p>
<p><strong>典型代表</strong> ：MySQL、Oracle、PostgreSQL。</p>
<p><strong>非关系型数据库（NoSQL）</strong><br>采用非结构化或半结构化存储，常见的类型包括：</p>
<ul>
<li><p><strong>文档型</strong> （如 MongoDB）：以 JSON 或 BSON 格式存储数据。</p>
</li>
<li><p><strong>键值型</strong> （如 Redis）：通过键直接访问值。</p>
</li>
<li><p><strong>列存储</strong> （如 Cassandra）：按列而非行组织数据。</p>
</li>
<li><p><strong>图数据库</strong> </p>
<p>（如 Neo4j）：以节点和边表示数据关系</p>
</li>
</ul>
</blockquote>
<h4 id="6-2-aerich迁移工具"><a href="#6-2-aerich迁移工具" class="headerlink" title="6.2 aerich迁移工具"></a>6.2 aerich迁移工具</h4><p><strong>docker 安装 mysql</strong>：</p>
<p>拉取 MySQL 镜像：<code>docker pull mysql</code></p>
<p>运行 MySQL 容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name fastapi -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p表示端口映射<br>—restart=always表示容器退出时总是重启<br>—name表示容器命名<br>—privileged=true表示赋予容器权限修改宿主文件权利<br>-v /home/mysql/log:/var/log/mysql表示容器日志挂载到宿主机<br>-v /home/mysql/data:/var/lib/mysql表示容器存储文件挂载到宿主机<br>-v /home/mysql/conf/my.cnf:/etc/mysql/my.cnf表示容器配置文件挂载到宿主机<br>-e MYSQL_ROOT_PASSWORD=a12bCd3_W45pUq6表示设置mysql的root用户密码,建议用强密码<br>-d表示后台运行</p>
</blockquote>
<p>启动这个 MySQL 容器：<code>docker start fastapi</code></p>
<p>进入 MySQL 容器：<code>docker exec -it fastapi bash</code></p>
<blockquote>
<p>这条命令的作用是：</p>
<ul>
<li><code>docker exec</code>：在已运行的 Docker 容器中执行命令。</li>
<li><code>-it</code>：<code>-i</code> 表示交互式操作，<code>-t</code> 分配一个伪终端（让你像在终端一样操作）。</li>
<li><code>fastapi</code>：这是你要进入的容器名称（你的 MySQL 容器名）。</li>
<li><code>bash</code>：在容器内启动 bash shell。</li>
</ul>
<p>这条命令会让你进入名为 <code>fastapi</code> 的容器，并获得一个 bash 命令行界面，就像登录到一台 Linux 服务器一样，可以在里面执行各种命令（比如登录 MySQL、查看日志等）。</p>
</blockquote>
<p>登录 MySQL：<code>mysql -u root -p</code></p>
<p>从主机直接连接：<code>mysql -h 127.0.0.1 -P 3306 -u root -p</code></p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">TORTOISE_ORM = &#123;</span><br><span class="line">    &quot;connections&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &#123;</span><br><span class="line">            &quot;engine&quot;:&#x27;tortoise.backends.mysql&#x27;,#选择数据库引擎，mysql</span><br><span class="line">            &quot;credentials&quot;: &#123;</span><br><span class="line">                &quot;host&quot;: &quot;localhost&quot;,#数据库地址</span><br><span class="line">                &quot;port&quot;: 3306,#数据库端口</span><br><span class="line">                &quot;user&quot;: &quot;root&quot;,#数据库用户名</span><br><span class="line">                &quot;password&quot;: &quot;root&quot;,#数据库密码</span><br><span class="line">                &quot;database&quot;: &quot;fastapi_db&quot;,#数据库名称</span><br><span class="line">                &#x27;charset&#x27;: &quot;utf8mb4&quot;,#数据库编码</span><br><span class="line">                &#x27;echo&#x27;: True,#是否打印sql语句</span><br><span class="line">                &#x27;minsize&#x27;: 1,#连接池最小连接数</span><br><span class="line">                &#x27;maxsize&#x27;: 5#连接池最大连接数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;apps&quot;: &#123;</span><br><span class="line">        &quot;models&quot;: &#123;</span><br><span class="line">            #db.models是我们自己定义的模型类,models在db文件夹下</span><br><span class="line">            &quot;models&quot;: [&quot;db.models&quot;,&quot;aerich.models&quot;],</span><br><span class="line">            &quot;default_connection&quot;: &quot;default&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;use_tz&#x27;: False,#是否使用时区</span><br><span class="line">    &#x27;timezone&#x27;: &#x27;Asia/Shanghai&#x27;,#时区</span><br><span class="line">    &quot;generate_schemas&quot;: True,</span><br><span class="line">    &quot;add_exception_handlers&quot;: True</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="1-初始化配置，只需要使用一次"><a href="#1-初始化配置，只需要使用一次" class="headerlink" title="1.初始化配置，只需要使用一次"></a>1.初始化配置，只需要使用一次</h5><p>aerich 是一种 ORM 迁移工具，需要结合 tortoise 异步 orm 框架使用。安装 aerich</p>
<p><code>pip install aerich</code></p>
<p><code>aerich init -t settings.TORTOISE_ORM  # TORTOISE_ORM 配置的位置</code></p>
<blockquote>
<p>初始化完会在当前目录生成一个文件：pyproject.toml 和一个文件夹：migrations</p>
<ul>
<li>pyproject.toml：保存配置文件路径，低版本可能是 aerich.ini</li>
<li>migrations：存放迁移文件</li>
</ul>
</blockquote>
<h5 id="2-初始化数据库，一般情况下只用一次"><a href="#2-初始化数据库，一般情况下只用一次" class="headerlink" title="2.初始化数据库，一般情况下只用一次"></a>2.初始化数据库，一般情况下只用一次</h5><p><code>aerich init-db</code></p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250521105044582.png" alt="image-20250521105044582"></p>
<h5 id="3-更新模型并进行迁移"><a href="#3-更新模型并进行迁移" class="headerlink" title="3.更新模型并进行迁移"></a>3.更新模型并进行迁移</h5><p>修改model类，重新生成迁移文件</p>
<p><code>aerich migrate</code></p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250521111024194.png" alt="image-20250521111024194"></p>
<h5 id="4-重新执行迁移，写入数据库"><a href="#4-重新执行迁移，写入数据库" class="headerlink" title="4.重新执行迁移，写入数据库"></a>4.重新执行迁移，写入数据库</h5><p><code>aerich upgrade</code></p>
<p><img src="/2025/05/14/%E5%AD%A6%E4%B9%A0/python-web/fastapi/fastapi/image-20250521111131931.png" alt="image-20250521111131931"></p>
<h5 id="5-回到上一个版本"><a href="#5-回到上一个版本" class="headerlink" title="5.回到上一个版本"></a>5.回到上一个版本</h5><p><code>aerich downgrade</code></p>
<h5 id="6-查看历史迁移记录"><a href="#6-查看历史迁移记录" class="headerlink" title="6.查看历史迁移记录"></a>6.查看历史迁移记录</h5><p><code>aerich history</code></p>
<blockquote>
<p><code>register_tortoise</code> 是 Tortoise ORM 提供的一个工具函数，用于在 <strong>FastAPI</strong> 等异步框架中快速集成和管理 Tortoise ORM 的生命周期（如启动时初始化数据库连接，关闭时释放资源）。其核心作用是简化 Tortoise ORM 的配置和自动化管理，开发者只需一行代码即可完成复杂的初始化流程</p>
</blockquote>
<h4 id="6-3-ORM查询操作"><a href="#6-3-ORM查询操作" class="headerlink" title="6.3 ORM查询操作"></a>6.3 ORM查询操作</h4><p>api.stud</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"><span class="comment">#导入数据库</span></span><br><span class="line"><span class="keyword">from</span> db.models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">student_api=APIRouter()</span><br><span class="line"></span><br><span class="line"><span class="meta">@student_api.get(<span class="params"><span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_students</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    #查询所有学生信息</span></span><br><span class="line"><span class="string">    students= await Student.all()#获取所有学生信息</span></span><br><span class="line"><span class="string">    for student in students:</span></span><br><span class="line"><span class="string">        print(student.id,student.name)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #过滤查询filter</span></span><br><span class="line"><span class="string">    students= await Student.filter(name__contains=&quot;张&quot;).all()</span></span><br><span class="line"><span class="string">    for student in students:</span></span><br><span class="line"><span class="string">        print(student.id,student.name)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #get学生信息</span></span><br><span class="line"><span class="string">    stu = await Student.get(id=1)</span></span><br><span class="line"><span class="string">    print(stu.id,stu.name)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #模糊查询</span></span><br><span class="line"><span class="string">    #最大值</span></span><br><span class="line"><span class="string">    stu =await Student.filter(sno__gt=1000).all()</span></span><br><span class="line"><span class="string">    #最小值</span></span><br><span class="line"><span class="string">    #stu = await Student.filter(sno__lt=1000).all()</span></span><br><span class="line"><span class="string">    #范围查询</span></span><br><span class="line"><span class="string">    #stu = await Student.filter(sno__range=(1000,2000)).all()</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #values查询</span></span><br><span class="line"><span class="string">    stu = await Student.all().values(&quot;sno&quot;,&quot;name&quot;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="string">&quot;操作&quot;</span>:<span class="string">&quot;获取所有学生信息&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@student_api.post(<span class="params"><span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_student</span>():</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="string">&quot;操作&quot;</span>:<span class="string">&quot;创建学生信息&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@student_api.get(<span class="params"><span class="string">&quot;/&#123;student_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_student</span>(<span class="params">student_id:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="string">&quot;操作&quot;</span>:<span class="string">f&quot;获取学生信息，ID：<span class="subst">&#123;student_id&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@student_api.put(<span class="params"><span class="string">&quot;/&#123;student_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">update_student</span>(<span class="params">student_id:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="string">&quot;操作&quot;</span>:<span class="string">f&quot;更新学生信息，ID：<span class="subst">&#123;student_id&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 FastAPI 和 Tortoise ORM 中，<code>async</code> 和 <code>await</code> 用于<strong>异步编程</strong>，主要原因如下：</p>
<ol>
<li><strong>异步 I/O 操作</strong><br>数据库查询（如 Student.all()）是耗时的 I/O 操作。使用 <code>async</code>/<code>await</code> 可以在等待数据库响应时，不阻塞主线程，提高应用的并发性能。</li>
<li><strong>FastAPI 支持异步路由</strong><br>FastAPI 支持异步（<code>async def</code>）的路由函数，这样可以充分利用 Python 的异步特性，提升 Web 服务的吞吐量。</li>
<li><strong>Tortoise ORM 的方法是异步的</strong><br>Tortoise ORM 的数据库操作方法（如 <code>.all()</code>、<code>.create()</code> 等）本身就是异步方法，必须用 <code>await</code> 调用，并且所在函数必须用 <code>async def</code> 声明。</li>
</ol>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="端口查询"><a href="#端口查询" class="headerlink" title="端口查询"></a>端口查询</h4><p>查看所有端口占用情况：<code>netstat -ano</code></p>
<p>查询特定端口是否被占用：<code>netstat -ano | findstr 8080</code></p>
<p>使用 <code>taskkill</code> 命令强制结束进程：<code>taskkill /PID 进程ID /F</code></p>
<p>通过 PID 查找进程：<code>tasklist | findstr PID</code></p>
<h4 id="获取绝对路径"><a href="#获取绝对路径" class="headerlink" title="获取绝对路径"></a>获取绝对路径</h4><p>获取当前文件的绝对路径：<code>base_dir = os.path.dirname(os.path.abspath(__file__))</code></p>
<p>拼接路径：<code>img_dir = os.path.join(base_dir, &quot;../imgs&quot;)</code></p>
<h4 id="mysql部分指令"><a href="#mysql部分指令" class="headerlink" title="mysql部分指令"></a>mysql部分指令</h4><p><strong>查看数据库列表</strong>：<code>SHOW DATABASES;</code></p>
<p><strong>选择数据库</strong>：<code>USE 数据库名;</code></p>
<p><strong>删除数据库</strong>：<code>DROP DATABASE 数据库名;</code></p>
<p><strong>创建数据库</strong>：<code>CREATE DATABASE 数据库名;</code></p>
<p><strong>登录 MySQL</strong>：<code>mysql -u root -p</code></p>
<p><strong>退出</strong>：<code>exit</code></p>
<h4 id="docker部分指令"><a href="#docker部分指令" class="headerlink" title="docker部分指令"></a>docker部分指令</h4><p><strong>linux安装docker</strong>：<code>sudo apt-get update &amp;&amp; sudo apt-get install docker.io</code></p>
<p><strong>查看 Docker 版本信息</strong>：<code>docker version</code></p>
<p><strong>查看镜像</strong>：<code>docker images</code></p>
<p><strong>查看所有的容器</strong>：<code>docker ps -a</code> </p>
<blockquote>
<p><code>systemctl</code> 是 <strong>systemd</strong> 系统和服务管理器的核心工具，用于管理系统和服务的状态及配置。</p>
</blockquote>
<p><code>mysql-client</code> 是 MySQL 数据库的命令行客户端工具。它允许你通过命令行连接和操作 MySQL 数据库服务器，比如执行 SQL 查询、管理数据库和用户等。</p>
<p>常用命令格式如下：<code>mysql -h 主机地址 -P 端口号 -u 用户名 -p</code></p>
<p>你可以在终端输入以下命令来检查是否已安装 <code>mysql-client</code>：<code>mysql --version</code></p>
<p>可以使用以下命令安装：<code>sudo apt-get update  sudo apt-get install mysql-client</code></p>
<blockquote>
<p><code>sudo apt-get update</code> 这个命令的作用是<strong>更新本地软件包列表</strong>。</p>
</blockquote>
<p><strong>停止并删除容器</strong>：<code>docker stop fastapi  docker rm fastapi</code></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>fastapi一个项目<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TSVPzkE7Y?spm_id_from=333.788.videopod.episodes&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">FastAPI进阶_哔哩哔哩_bilibili</a></p>
<p>教程<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ya4y1D7et/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">fastapi框架快速学习_哔哩哔哩_bilibili</a></p>
<p>fastapi相关知识的补充<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zJ7mzdEc8?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">Python 异步编程 - 搞明白 async, await (继续解释 yield)_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
