<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zxj Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang XiJun">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="zxj Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="zxj">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang XiJun</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-17 09:01:15" itemprop="dateModified" datetime="2025-11-17T09:01:15+08:00">2025-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="操作系统概论">操作系统概论</h2>
<h3 id="操作系统的主要特征">操作系统的主要特征</h3>
<h4 id="并发性-concurrency"><strong>并发性 (Concurrency)</strong></h4>
<p>🔍 核心定义</p>
<blockquote>
<p><strong>并发性</strong>是指两个或两个以上的事件或活动在<strong>同一时间间隔内</strong>发生。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：“同一时间间隔” ≠
“同一时刻”。它强调的是“看起来同时”，而不是“真正同时”。</li>
</ul>
<p>📌 操作系统中的体现</p>
<ol type="1">
<li><strong>多个 I/O 设备同时工作</strong>：
<ul>
<li>你的键盘在输入，打印机在打印，网卡在收发数据。这些设备都在“同时”工作。</li>
</ul></li>
<li><strong>I/O 和 CPU 计算同时进行</strong>：
<ul>
<li>当 CPU 在计算时，I/O 设备可能在后台传输数据。CPU 不需要等待 I/O
完成，可以去处理其他任务。</li>
</ul></li>
<li><strong>内存中多个程序交替执行</strong>：
<ul>
<li>这是最核心的体现。操作系统通过<strong>时间片轮转</strong>（Time-Slicing）等调度算法，让多个程序“轮流”使用
CPU，从而实现“宏观上的并发”。</li>
</ul></li>
</ol>
<p>🖼️ 并发 vs 并行</p>
<p>这是你 PPT 中提出的关键问题！</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 44%">
<col style="width: 44%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">并发 (Concurrency)</th>
<th style="text-align: left;">并行 (Parallelism)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>定义</strong></td>
<td style="text-align: left;">多个任务在<strong>同一时间间隔内</strong>交替执行。</td>
<td style="text-align: left;">多个任务在<strong>同一时刻</strong>真正同时执行。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>物理基础</strong></td>
<td style="text-align: left;">单 CPU 系统即可实现。</td>
<td style="text-align: left;">需要多核 CPU 或多处理器系统。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>效果</strong></td>
<td style="text-align: left;">“看起来”同时进行。</td>
<td style="text-align: left;">“真正”同时进行。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>类比</strong></td>
<td style="text-align: left;">一个人在厨房里，一会儿切菜，一会儿炒菜，一会儿洗碗。</td>
<td style="text-align: left;">三个人在厨房里，一个人切菜，一个人炒菜，一个人洗碗。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>✅
<strong>一句话总结</strong>：<strong>并行是并发的一种特例</strong>。并发是“逻辑上的同时”，并行是“物理上的同时”。</p>
</blockquote>
<h4 id="共享性-sharing"><strong>共享性 (Sharing)</strong></h4>
<p>🔍 核心定义</p>
<blockquote>
<p><strong>共享性</strong>指操作系统中的资源（包括硬件资源和软件资源）可被<strong>多个并发执行的进程共同使用</strong>，而不是被一个进程所独占。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：共享不等于“无限制访问”，它必须在<strong>操作系统管理下</strong>进行，以保证安全和有序。</li>
</ul>
<p>📌 资源共享的方式</p>
<p>1️⃣ 透明资源共享 / 同时共享方式</p>
<ul>
<li><strong>含义</strong>：允许多个进程在<strong>同一时间段内</strong>对资源进行访问，好像每个进程都独占资源一样。</li>
<li><strong>特点</strong>：
<ul>
<li>访问的次序对结果无影响。</li>
<li>通常用于<strong>可重入</strong>或<strong>只读</strong>的资源。</li>
</ul></li>
<li><strong>例子</strong>：
<ul>
<li><strong>CPU</strong>：通过时间片轮转，让多个进程“同时”使用
CPU。</li>
<li><strong>主存
(RAM)</strong>：多个进程的代码和数据可以同时存在于内存中。</li>
<li><strong>磁盘</strong>：多个进程可以同时读取磁盘上的不同文件。</li>
<li><strong>打印机</strong>：虽然物理上一次只能打印一个任务，但操作系统可以通过“打印队列”实现逻辑上的“同时共享”。</li>
</ul></li>
</ul>
<p>2️⃣ 独占资源共享 / 互斥共享方式</p>
<ul>
<li><strong>含义</strong>：在<strong>同一时间段内</strong>只允许<strong>一个进程</strong>访问资源。</li>
<li><strong>特点</strong>：
<ul>
<li>这类资源称为<strong>临界资源 (Critical Resource)</strong>。</li>
<li>必须通过<strong>互斥机制</strong>（如锁、信号量）来保护。</li>
</ul></li>
<li><strong>例子</strong>：
<ul>
<li><strong>磁带机</strong>：一次只能由一个进程控制。</li>
<li><strong>扫描仪</strong>：一次只能扫描一份文档。</li>
<li><strong>数据库中的某一行记录</strong>：如果两个事务同时修改同一行，会导致数据不一致。</li>
</ul></li>
</ul>
<p>🛠️ 操作系统如何管理共享？</p>
<ul>
<li><strong>提供显式资源共享机制</strong>：如 <code>fork()</code>,
<code>semaphore</code>, <code>mutex</code>, <code>lock</code>
等系统调用。</li>
<li><strong>将互斥访问下放给用户决策</strong>：程序员需要自己负责加锁和解锁，操作系统提供工具。</li>
</ul>
<h4 id="异步性-asynchrony">异步性 (Asynchrony)</h4>
<p>🔍 核心定义</p>
<blockquote>
<p><strong>异步性</strong>指在多道程序环境中，由于资源有限而进程众多，多数情况下，进程的执行不是一气呵成，而是“走走停停”。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：进程的执行是不可预测的，它的推进速度取决于系统调度、I/O
等待、中断等多种因素。</li>
</ul>
<p>📌 异步性的表现</p>
<ol type="1">
<li><strong>作业到达系统的时间和类型不确定</strong>：
<ul>
<li>用户随时可能启动一个新程序。</li>
</ul></li>
<li><strong>操作员发出命令或操作的时间和类型不确定</strong>：
<ul>
<li>用户可能随时按下键盘或点击鼠标。</li>
</ul></li>
<li><strong>程序运行发生错误或异常的类型和时刻不确定</strong>：
<ul>
<li>程序可能因为除零、内存溢出等原因崩溃。</li>
</ul></li>
<li><strong>中断事件发生的时刻不确定</strong>：
<ul>
<li>时钟中断、I/O 中断、硬件故障中断等都是随机发生的。</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[并发性] --&gt; B[多个任务同时执行]</span><br><span class="line">    C[共享性] --&gt; D[资源被多个任务共同使用]</span><br><span class="line">    E[异步性] --&gt; F[任务执行“走走停停”]</span><br><span class="line"></span><br><span class="line">    B &amp; D &amp; F --&gt; G[现代操作系统的核心特征]</span><br><span class="line">    G --&gt; H[实现多任务、多用户环境]</span><br></pre></td></tr></table></figure>
<h3 id="多道程序设计">多道程序设计</h3>
<h4 id="核心思想">核心思想</h4>
<blockquote>
<p><strong>多道程序设计</strong>是指允许多个程序<strong>同时</strong>驻留在内存中，并由操作系统<strong>统一管理和调度</strong>，使它们<strong>交替</strong>（并发）地使用
CPU 和其他系统资源。</p>
</blockquote>
<ul>
<li><strong>核心目的</strong>：<strong>掩盖 I/O 等待时间，提高 CPU
和系统资源的利用率</strong>。</li>
<li><strong>终极目标</strong>：让昂贵的 CPU
<strong>永远不要闲着</strong>！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 单道程序 vs 多道程序</span><br><span class="line">    dateFormat  HH:mm:ss</span><br><span class="line">    axisFormat  %Ss</span><br><span class="line"></span><br><span class="line">    section 单道程序</span><br><span class="line">    作业A-CPU     :crit, a1, 00:00:00, 2s</span><br><span class="line">    作业A-I/O     :active, a2, after a1, 8s</span><br><span class="line">    作业A-CPU     :crit, a3, after a2, 2s</span><br><span class="line">    作业A-I/O     :active, a4, after a3, 8s</span><br><span class="line"></span><br><span class="line">    section 多道程序</span><br><span class="line">    作业A-CPU     :crit, b1, 00:00:00, 2s</span><br><span class="line">    作业B-CPU     :crit, b2, after b1, 2s</span><br><span class="line">    作业C-CPU     :crit, b3, after b2, 2s</span><br><span class="line">    作业A-I/O     :active, b4, after b1, 8s</span><br><span class="line">    作业B-I/O     :active, b5, after b2, 8s</span><br><span class="line">    作业C-I/O     :active, b6, after b3, 8s</span><br></pre></td></tr></table></figure>
<p><strong>对比</strong>：在多道程序中，当作业 A 在等待 I/O 时，CPU
立刻去执行作业 B 和 C。CPU 几乎没有空闲时间，利用率接近 100%！</p>
<h4 id="cpu利用率">cpu利用率</h4>
<p><code>CPU利用率 = 1 - p^n</code></p>
<p>🔍 假设条件</p>
<ol type="1">
<li><strong>系统中有 <code>n</code> 个程序</strong> 同时在内存中。</li>
<li><strong>每个程序平均有 <code>p</code> 的概率在等待 I/O
操作</strong>。
<ul>
<li>例如，<code>p = 0.8</code> 表示一个程序有 80%
的时间在等磁盘读写、键盘输入等，只有 20% 的时间在真正使用 CPU。</li>
</ul></li>
<li><strong>各个程序的等待操作是相互独立的</strong>。
<ul>
<li>这是一个关键假设，意味着一个程序是否在等 I/O，不影响其他程序。</li>
</ul></li>
</ol>
<p>💡 公式推导</p>
<ul>
<li><strong>CPU 空闲的概率</strong>：当且仅当<strong>所有 <code>n</code>
个程序都在等待 I/O</strong> 时，CPU 才会空闲。</li>
<li>因为每个程序等待 I/O 的概率是
<code>p</code>，且它们相互独立，所以<strong>所有 <code>n</code>
个程序都等待 I/O 的概率是 <code>p^n</code></strong>。</li>
<li><strong>因此，CPU 空闲的概率 = <code>p^n</code></strong>。</li>
<li><strong>CPU 利用率 = 1 - CPU 空闲的概率 =
<code>1 - p^n</code></strong>。</li>
</ul>
<p>若进程平均花费 80% 的时间等待 I/O，则为了使得 CPU 利用率不低于
80%，应至少有多少道程序在主存中运行？</p>
<h3 id="计算过程">计算过程</h3>
<p>根据公式：</p>
<p>CPU利用率 = 1 - p^n ≥ 0.8</p>
<p>移项得：</p>
<p>p^n ≤ 0.2</p>
<p>代入 <code>p = 0.8</code>：</p>
<p>0.8^n ≤ 0.2</p>
<p>两边取对数（以 10 为底或自然对数均可）：</p>
<p>n * log(0.8) ≤ log(0.2)</p>
<p>注意：<code>log(0.8)</code>
是负数，所以在除的时候要<strong>反转不等号方向</strong>：</p>
<p>n ≥ log(0.2) / log(0.8)</p>
<p>计算数值：</p>
<ul>
<li><code>log(0.2) ≈ -0.69897</code></li>
<li><code>log(0.8) ≈ -0.09691</code></li>
<li><code>n ≥ (-0.69897) / (-0.09691) ≈ 7.21</code></li>
</ul>
<p>因为 <code>n</code> 必须是整数，且要满足
<code>n ≥ 7.21</code>，所以：</p>
<blockquote>
<p><strong><code>n = 8</code></strong></p>
</blockquote>
<p>✅ 最终答案</p>
<p><strong>为了使得 CPU 利用率不低于 80%，应至少有 8
道程序在主存中运行。</strong></p>
<h4 id="是不是同时运行的程序越多越好">是不是同时运行的程序越多越好？</h4>
<p><strong>不是！同时运行的程序（道数）并不是越多越好。存在一个最优的“道数”，超过这个值，系统的整体效率反而会下降。</strong></p>
<p>当道数 <code>n</code>
超过某个临界值后，系统性能会急剧下降。主要原因有：</p>
<p>1️⃣ <strong>上下文切换开销 (Context Switching Overhead)</strong></p>
<p><strong>什么是上下文切换？</strong></p>
<ul>
<li>当操作系统从一个进程切换到另一个进程时，它需要保存当前进程的状态（寄存器、内存映射、程序计数器等），并加载下一个进程的状态。</li>
</ul>
<p>2️⃣ <strong>内存压力 (Memory Pressure)</strong></p>
<ul>
<li><strong>每个进程都需要内存</strong>：代码段、数据段、堆、栈、页表等。</li>
</ul>
<p>3️⃣ <strong>资源竞争加剧 (Resource Contention)</strong></p>
<ul>
<li><strong>锁竞争</strong>：多个进程同时访问共享资源（如数据库连接池、文件锁），需要排队等待，增加了延迟。</li>
<li><strong>缓存失效</strong>：多个进程的指令和数据交替进入 CPU
缓存，导致缓存命中率降低，CPU 需要更频繁地从内存读取数据。</li>
</ul>
<h3 id="处理器状态">处理器状态</h3>
<h4 id="为什么需要两种处理器状态">为什么需要两种处理器状态？</h4>
<p>现代计算机是一个多用户、多任务的环境。如果所有程序都能随意执行任何指令，那么一个不小心的
bug 或一个恶意程序就可能：</p>
<ul>
<li>格式化硬盘。</li>
<li>修改系统时间。</li>
<li>访问其他用户的隐私数据。</li>
<li>导致系统崩溃。</li>
</ul>
<p>为了避免这种情况，CPU 被设计成有两种工作模式：</p>
<ol type="1">
<li><strong>用户态 (User
Mode)</strong>：普通程序运行的状态，只能执行“安全”的指令。</li>
<li><strong>核心态 (Kernel Mode / Supervisor
Mode)</strong>：操作系统内核运行的状态，可以执行所有指令，包括“危险”的特权指令。</li>
</ol>
<h4 id="程序状态字-psw">程序状态字 (PSW)</h4>
<p><strong>Program Status Word (PSW)</strong>
是一个非常重要的寄存器。</p>
<ul>
<li><strong>定义</strong>：PSW 是 CPU
内部的一个特殊寄存器，用于存储当前处理器的各种状态信息。</li>
<li><strong>关键作用</strong>：PSW
中有一个<strong>标志位</strong>（通常是最高位或某一位），用来标识当前
CPU 处于<strong>用户态还是核心态</strong>。
<ul>
<li><code>PSW[bit] = 0</code> → 用户态</li>
<li><code>PSW[bit] = 1</code> → 核心态</li>
</ul></li>
</ul>
<blockquote>
<p>✅ <strong>这就是 CPU
判断当前是否可以执行特权指令的依据！</strong></p>
</blockquote>
<p>当 CPU 执行一条指令时，它会检查 PSW 中的这个标志位：</p>
<ul>
<li>如果是<strong>用户态</strong>，并且指令是<strong>特权指令</strong>，则触发一个<strong>异常
(Exception)</strong>，操作系统会介入处理（通常是终止该程序）。</li>
<li>如果是<strong>核心态</strong>，则允许执行。</li>
</ul>
<h4 id="cpu-如何判断当前是否可以执行特权指令">CPU
如何判断当前是否可以执行特权指令？</h4>
<p><strong>答案</strong>：CPU 通过检查 <strong>程序状态字 (PSW)</strong>
中的一个特定标志位来判断。</p>
<ul>
<li>如果该标志位表示当前处于<strong>用户态</strong>，并且遇到的是<strong>特权指令</strong>，则
CPU
会触发一个<strong>异常</strong>（通常是“非法指令”或“特权指令违规”），并将控制权交给操作系统内核。</li>
<li>操作系统内核会根据情况决定是终止该程序，还是进行其他处理。</li>
</ul>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116191358137.png" alt="image-20251116191358137">
<figcaption aria-hidden="true">image-20251116191358137</figcaption>
</figure>
<h2 id="进程控制和管理">进程控制和管理</h2>
<h3 id="进程定义与属性">进程定义与属性</h3>
<p>进程（Process）是<strong>程序在计算机上的一次执行</strong>实例，是<strong>操作系统进行资源分配、调度和保护的基本单位</strong>。</p>
<h4 id="为什么要引入进程">为什么要引入“进程”？</h4>
<p>1️⃣ <strong>刻画系统的动态性（Dynamic Nature）</strong></p>
<ul>
<li><strong>问题</strong>：程序是静态的代码，无法描述“执行中”的状态。</li>
<li><strong>解决方案</strong>：进程是一个<strong>动态实体</strong>，它有生命周期（创建
→ 运行 → 阻塞 → 终止）。</li>
<li><strong>意义</strong>：操作系统可以精确跟踪每个任务的当前状态，做出调度决策。</li>
</ul>
<p>2️⃣ <strong>发挥系统的并发性（Concurrency）</strong></p>
<ul>
<li><strong>问题</strong>：CPU 和 I/O 设备速度不匹配。程序在等待
I/O（如读文件、网络请求）时，CPU 就空闲了。</li>
<li><strong>解决方案</strong>：通过<strong>进程切换</strong>，让 CPU
在等待期间去执行其他任务。</li>
<li><strong>意义</strong>：提高了 CPU 利用率和系统吞吐量。</li>
</ul>
<p>3️⃣ <strong>解决资源共享与隔离的矛盾</strong></p>
<ul>
<li><strong>问题</strong>：多个程序可能需要共享资源（如文件、打印机），但又不能互相干扰。</li>
<li><strong>解决方案</strong>：
<ul>
<li><strong>共享性</strong>：进程可以通过合法机制（如共享内存、消息队列）共享资源。</li>
<li><strong>独立性/保护性</strong>：每个进程拥有独立的地址空间，操作系统通过内存管理单元（MMU）确保
A 进程不能访问 B 进程的内存。</li>
</ul></li>
<li><strong>意义</strong>：既实现了协作，又保证了安全和稳定。</li>
</ul>
<h4 id="进程的五大核心属性">进程的五大核心属性</h4>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 45%">
<col style="width: 43%">
</colgroup>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 动态性</strong></td>
<td>进程是动态的，有生命周期（创建 → 运行 → 阻塞 → 终止）。</td>
<td><code>uvicorn</code> 启动时创建进程，<code>Ctrl+C</code>
终止时销毁进程。</td>
</tr>
<tr>
<td><strong>2. 并发性</strong></td>
<td>多个进程可以“同时”运行（宏观并发，微观交替）。</td>
<td>一台服务器同时处理成百上千个用户的 HTTP 请求。</td>
</tr>
<tr>
<td><strong>3. 独立性</strong></td>
<td>每个进程有独立的地址空间和资源，互不干扰。</td>
<td>一个 Python 进程崩溃，不会导致另一个 Python 进程退出。</td>
</tr>
<tr>
<td><strong>4. 制约性</strong></td>
<td>进程间可能存在同步或互斥关系（如竞争资源、等待结果）。</td>
<td>多个进程写同一个日志文件，需要用文件锁避免内容错乱。</td>
</tr>
<tr>
<td><strong>5. 共享性</strong></td>
<td>进程可以通过操作系统提供的机制共享资源（如内存、文件）。</td>
<td>多个 FastAPI worker 进程共享一个 Redis 缓存连接池。</td>
</tr>
</tbody>
</table>
<h3 id="进程状态转换">进程状态转换</h3>
<h4 id="五态模型">五态模型</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204410504.png" alt="image-20251115204410504">
<figcaption aria-hidden="true">image-20251115204410504</figcaption>
</figure>
<h4 id="七态模型">七态模型</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204451732.png" alt="image-20251115204451732">
<figcaption aria-hidden="true">image-20251115204451732</figcaption>
</figure>
<p>七态模型在五态模型的基础上，<strong>显式增加了“挂起（Suspend）”的概念</strong></p>
<blockquote>
<p>挂起 = 进程被换出到外存（Swap）</p>
<ul>
<li><strong>目的</strong>：当系统内存紧张时，操作系统会将一些<strong>暂时不活跃</strong>的进程（比如长时间阻塞的进程）从内存移到硬盘上的“交换区（Swap
Space）”，以腾出内存给更紧急的任务。</li>
</ul>
</blockquote>
<p><strong>挂起就绪态 (Ready/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程具备运行条件（即它已经准备好执行），但目前在外存中。只有当它被换入内存后，才能被调度器选中运行。</strong></p>
</blockquote>
<p><strong>挂起等待态 (Blocked/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程正在等待某一个事件发生（如 I/O
完成、用户输入、网络响应），并且目前在外存中。</strong></p>
</blockquote>
<h3 id="进程描述和组成">进程描述和组成</h3>
<h4 id="进程映像">进程映像</h4>
<p><strong>进程映像（Process
Image）是指进程在内存中的完整内容，包括代码、数据、堆、栈以及内核数据结构（如
PCB）等所有组成部分的集合。</strong></p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210257885.png" alt="image-20251115210257885">
<figcaption aria-hidden="true">image-20251115210257885</figcaption>
</figure>
<h4 id="进程上下文">进程上下文</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210715693.png" alt="image-20251115210715693">
<figcaption aria-hidden="true">image-20251115210715693</figcaption>
</figure>
<blockquote>
<p>寄存器上下文 (Register Context)<strong>存储在 PCB 中</strong>
<strong>包含：通用寄存器、程序计数器、栈指针、程序状态字</strong></p>
<p>这是进程“灵魂”的一部分——CPU 执行时最直接依赖的状态。</p>
</blockquote>
<h4 id="pcbprocess-control-block进程控制块"><strong>PCB（Process Control
Block，进程控制块）</strong></h4>
<p><strong>PCB
是操作系统为每个进程创建的一个数据结构，用来记录和刻画该进程的所有状态和相关信息。</strong></p>
<p>1️⃣ <strong>进程标识信息 (Identification Information)</strong></p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PID (Process ID)</strong></td>
<td>进程的唯一数字标识，如 <code>12345</code>。</td>
</tr>
<tr>
<td><strong>PPID (Parent PID)</strong></td>
<td>父进程的 PID，用于构建进程树。</td>
</tr>
<tr>
<td><strong>UID/GID (User/Group ID)</strong></td>
<td>进程所属用户的 ID 和组 ID，用于权限控制。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🌰 <strong>你的例子</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前进程 PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;父进程 PID: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure> 这些值就是从 PCB
中读取的！</p>
</blockquote>
<p>2️⃣ <strong>处理器状态信息 (Processor State Information)</strong> ——
<strong>这就是“寄存器上下文”</strong></p>
<p>这是 PCB 最关键的部分，用于<strong>上下文切换</strong>。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>程序计数器 (PC)</strong></td>
<td>下一条要执行的指令地址。</td>
</tr>
<tr>
<td><strong>通用寄存器 (AX, BX, CX…)</strong></td>
<td>存放临时计算结果、变量地址等。</td>
</tr>
<tr>
<td><strong>程序状态字 (PSW)</strong></td>
<td>包含标志位（零标志 Z、进位标志 C、溢出标志 O
等）、中断允许位、特权级别。</td>
</tr>
<tr>
<td><strong>栈指针 (SP)</strong></td>
<td>指向当前函数调用栈的顶部。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚡ <strong>关键点</strong>：每次进程切换时，操作系统都会将当前 CPU
寄存器的值“倾倒”进 PCB，再从新进程的 PCB
“倒回”寄存器。这就是“上下文切换”的核心开销。</p>
</blockquote>
<p>3️⃣ <strong>进程调度信息 (Scheduling Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程状态</strong></td>
<td>就绪、运行、阻塞、挂起等。</td>
</tr>
<tr>
<td><strong>进程优先级</strong></td>
<td>决定调度顺序。</td>
</tr>
<tr>
<td><strong>时间片剩余量</strong></td>
<td>用于时间片轮转调度。</td>
</tr>
<tr>
<td><strong>等待事件</strong></td>
<td>如等待键盘输入、网络数据包到达等。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🌰 <strong>你的例子</strong>： 在 FastAPI 中，当一个请求在
<code>await httpx.get(...)</code>
时，其对应协程/线程的状态会被标记为“阻塞”，并被放入等待队列。这就是 PCB
中“进程状态”字段的作用。</p>
</blockquote>
<p>4️⃣ <strong>内存管理信息 (Memory Management Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>页表基址 / 段表指针</strong></td>
<td>用于虚拟内存到物理内存的地址转换。</td>
</tr>
<tr>
<td><strong>内存分配情况</strong></td>
<td>代码段、数据段、堆、栈的起始地址和大小。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>💡
<strong>关键点</strong>：确保进程访问的是自己的内存空间，实现“内存保护”。</p>
</blockquote>
<p>5️⃣ <strong>I/O 状态信息 (I/O Status Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>打开的文件列表</strong></td>
<td>文件描述符（fd）、文件指针、访问模式等。</td>
</tr>
<tr>
<td><strong>分配的 I/O 设备</strong></td>
<td>如打印机、网卡等。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🌰 <strong>你的例子</strong>： 当你在 Python 中
<code>f = open("log.txt", "a")</code> 时，操作系统会在 PCB
的“打开文件列表”中添加一条记录，记录这个文件句柄 <code>f</code> 对应的
fd。</p>
</blockquote>
<p>6️⃣ <strong>记账信息 (Accounting Information)</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU 使用时间</strong></td>
<td>进程已使用的 CPU 时间总和。</td>
</tr>
<tr>
<td><strong>累计运行时间</strong></td>
<td>从创建到现在的总时间。</td>
</tr>
<tr>
<td><strong>最大内存使用量</strong></td>
<td>历史峰值。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📊 <strong>用途</strong>：用于性能监控、计费、调试等。</p>
</blockquote>
<h3 id="进程队列">进程队列</h3>
<h4 id="链接方式">链接方式</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212223846.png" alt="image-20251115212223846">
<figcaption aria-hidden="true">image-20251115212223846</figcaption>
</figure>
<h4 id="索引方式">索引方式</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212241091.png" alt="image-20251115212241091">
<figcaption aria-hidden="true">image-20251115212241091</figcaption>
</figure>
<h3 id="进程切换和处理器状态转换">进程切换和处理器状态转换</h3>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212521578.png" alt="image-20251115212521578">
<figcaption aria-hidden="true">image-20251115212521578</figcaption>
</figure>
<h4 id="模式切换-vs.-进程切换">模式切换 vs. 进程切换</h4>
<ol type="1">
<li>模式切换 (Mode Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：CPU 在“用户态（User Mode）”和“核心态（Kernel
Mode）”之间的切换。
<strong>触发方式</strong>：由<strong>中断（Interrupt）或系统调用（System
Call）</strong> 引起。
<strong>目的</strong>：让操作系统获得控制权，执行特权指令（如访问硬件、修改内存映射）。</p>
</blockquote>
<ol start="2" type="1">
<li>进程切换 (Process Switch / Context Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：操作系统暂停当前正在运行的进程，保存其状态，并加载另一个进程的状态，使其开始运行。
<strong>触发方式</strong>：通常发生在<strong>核心态</strong>下，由中断或系统调用引发。
<strong>目的</strong>：实现多任务并发，公平分配 CPU 时间。</p>
</blockquote>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115215300054.png" alt="image-20251115215300054">
<figcaption aria-hidden="true">image-20251115215300054</figcaption>
</figure>
<h4 id="当进程开始运行时操作系统如何重新获得控制">当进程开始运行时，操作系统如何重新获得控制？</h4>
<p>果进程一直在运行，操作系统就永远没机会调度其他进程了，系统就会卡死。</p>
<p><strong>答案：中断 (Interrupt) 是关键！</strong></p>
<ul>
<li><strong>什么是中断？</strong>
中断就像一个“<strong>紧急电话</strong>”，它能打断 CPU
当前正在执行的程序，强制 CPU
去处理一个更高优先级的事情——通常是操作系统内核。
<ul>
<li><strong>硬件中断</strong>：由外部设备触发，比如键盘敲击、鼠标移动、网络数据包到达、定时器到期。</li>
<li><strong>软件中断/异常</strong>：由程序自身触发，比如除零错误、访问非法内存地址、或者程序主动发起的<strong>系统调用</strong>（如
<code>open()</code>, <code>read()</code>）。</li>
</ul></li>
</ul>
<h4 id="进程需要保存哪些状态">进程需要保存哪些状态？</h4>
<p>当操作系统获得控制权后，它必须把当前正在运行的进程（比如进程0）的“工作状态”完整地记录下来，以便将来能恢复执行。这个过程叫做“<strong>保存现场
(Save Context)</strong>”。</p>
<p><strong>需要保存哪些状态？</strong></p>
<p>这些状态主要存储在一个叫做 <strong>PCB (Process Control Block,
进程控制块)</strong> 的数据结构里。PCB 就像是进程的“<strong>身份证 +
工作日志 + 资源清单</strong>”。</p>
<h4 id="如何选择下一个待执行的进程线程">如何选择下一个待执行的进程/线程？</h4>
<p>当操作系统保存完当前进程的状态后，它需要决定“<strong>接下来该让谁干活</strong>”。这个决策过程叫做“<strong>进程调度
(Process Scheduling)</strong>”。</p>
<p><strong>如何选择？</strong></p>
<p>这取决于操作系统的<strong>调度算法 (Scheduling
Algorithm)</strong>。</p>
<h3 id="线程">线程</h3>
<h4 id="为什么需要线程-引入线程的动机">为什么需要线程？——
引入线程的动机</h4>
<p>❓ 问题：进程模型有什么不足？</p>
<ol type="1">
<li><strong>切换开销大</strong>：进程切换需要保存/恢复整个内存空间（代码、数据、堆、栈）和
PCB，开销大。</li>
<li><strong>通信困难</strong>：进程间通信（IPC）需要管道、消息队列、共享内存等复杂机制，效率低。</li>
<li><strong>不适合细粒度并发</strong>：比如一个 Web
服务器，每个请求都创建一个进程，成本太高。</li>
</ol>
<p>✅ 解决方案：引入线程！</p>
<blockquote>
<p><strong>线程是进程内的一个执行单元，是 CPU
调度和分派的基本单位。</strong></p>
</blockquote>
<ul>
<li><strong>同一个进程内的所有线程</strong>：
<ul>
<li><strong>共享</strong>：代码段、数据段、堆、打开的文件等<strong>进程资源</strong>。</li>
<li><strong>私有</strong>：各自的<strong>栈</strong>和<strong>寄存器上下文</strong>。</li>
</ul></li>
</ul>
<blockquote>
<p>💡
<strong>核心价值</strong>：<strong>实现进程内部的并发，降低切换和通信开销</strong>。</p>
</blockquote>
<h4 id="什么是线程-核心定义">什么是线程？—— 核心定义</h4>
<blockquote>
<p><strong>线程（Thread）是进程中一个可并发执行的控制流，它拥有自己独立的栈和寄存器状态，但与其他线程共享进程的地址空间和资源。</strong></p>
</blockquote>
<h4 id="线程如何工作-线程的生命周期与切换">线程如何工作？——
线程的生命周期与切换</h4>
<ol type="1">
<li><strong>线程的生命周期状态</strong></li>
</ol>
<p>和进程类似，线程也有状态：<strong>新建 → 就绪 → 运行 → 阻塞 →
终止</strong>。</p>
<ol start="2" type="1">
<li><strong>线程切换（Thread Switching）</strong></li>
</ol>
<ul>
<li><strong>开销远小于进程切换</strong>！因为不需要切换地址空间（页表），只需要保存/恢复<strong>寄存器上下文和栈指针</strong>。</li>
<li>切换由<strong>线程调度器</strong>（在 OS
内核或用户态库中）管理。</li>
</ul>
<ol start="3" type="1">
<li><strong>线程的实现方式</strong></li>
</ol>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 45%">
<col style="width: 24%">
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用户级线程 (User-Level Threads)</strong></td>
<td>由用户态线程库（如 Java Green Threads）管理，内核 unaware</td>
<td>Python 的 <code>greenlet</code>（非标准）</td>
</tr>
<tr>
<td><strong>内核级线程 (Kernel-Level Threads)</strong></td>
<td>由操作系统内核直接管理，每个线程对应一个内核调度实体</td>
<td>Python 的 <code>threading</code> 模块</td>
</tr>
<tr>
<td><strong>混合模式</strong></td>
<td>用户级线程映射到少量内核线程</td>
<td>Go 的 Goroutine</td>
</tr>
</tbody>
</table>
<blockquote>
<p>💡 <strong>Python 的 <code>threading</code>
是内核级线程</strong>，但受 GIL 限制，无法真正并行执行 Python
字节码。</p>
</blockquote>
<h2 id="处理器调度">处理器调度</h2>
<h3 id="调度层次">调度层次</h3>
<p>1️⃣ 高级调度（High-Level Scheduling）—— 作业调度 / 长程调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪些“作业”被允许进入系统参与 CPU 竞争。
<strong>对象</strong>：作业（Job）→
通常是一个完整的程序或任务（如编译一个文件、运行一个脚本）。
<strong>发生频率</strong>：<strong>低</strong>（几分钟到几小时一次）。
<strong>执行者</strong>：操作系统内核。</p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选作业进内存</strong>：从后备队列中选择作业，将其加载到内存，创建进程。</li>
<li><strong>控制多道程序的道数</strong>：决定同时在内存中运行多少个作业（即并发度）。太多会耗尽内存，太少会浪费
CPU。</li>
</ul>
<p>2️⃣ 中级调度（Medium-Level Scheduling）—— 平衡调度 / 内存调度</p>
<blockquote>
<p><strong>目标</strong>：根据内存状态，决定哪些进程可以在内存中运行，哪些需要换出到外存。
<strong>对象</strong>：进程（Process）。
<strong>发生频率</strong>：<strong>中等</strong>（几秒到几分钟一次）。
<strong>执行者</strong>：操作系统内核。</p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程进出内存</strong>：当内存紧张时，将一些不活跃的进程（如长时间阻塞的进程）换出到
Swap 分区；当内存空闲时，再换回。</li>
<li><strong>平衡系统负载</strong>：防止内存溢出，提高系统吞吐量。</li>
</ul>
<p>3️⃣ 低级调度（Low-Level Scheduling）—— 进程调度 / CPU 调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪个就绪队列中的进程/线程获得 CPU 执行权。
<strong>对象</strong>：进程或线程（内核级线程）。
<strong>发生频率</strong>：<strong>高</strong>（毫秒级，每几十到几百毫秒一次）。
<strong>执行者</strong>：操作系统内核 →
<strong>这是操作系统最核心的部分</strong>！</p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程分配
CPU</strong>：从就绪队列中选出下一个要运行的进程/线程。</li>
<li><strong>执行上下文切换</strong>：保存当前进程上下文，恢复新进程上下文。</li>
<li><strong>实现公平与效率</strong>：通过调度算法（如
RR、优先级、MLFQ）保证所有进程都能得到 CPU 时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[高级调度] --&gt;|选作业进内存| B[中级调度]</span><br><span class="line">    B --&gt;|选进程进出内存| C[低级调度]</span><br><span class="line">    C --&gt;|选进程分配 CPU| D[CPU 执行]</span><br><span class="line"></span><br><span class="line">    style A fill:#f9d5e5,stroke:#333</span><br><span class="line">    style B fill:#e3eaa7,stroke:#333</span><br><span class="line">    style C fill:#b2d3c2,stroke:#333</span><br></pre></td></tr></table></figure>
<h3 id="调度算法评价指标">调度算法评价指标</h3>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116131448708.png" alt="image-20251116131448708">
<figcaption aria-hidden="true">image-20251116131448708</figcaption>
</figure>
<h3 id="七种调度策略">七种调度策略</h3>
<h4 id="先来先服务-first-come-first-serverd-fcfs">先来先服务 (First Come
First Serverd, FCFS)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132753390.png" alt="image-20251116132753390">
<figcaption aria-hidden="true">image-20251116132753390</figcaption>
</figure>
<h4 id="短作业优先-shortest-job-first-sjf">短作业优先 (Shortest Job
First, SJF)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132925377.png" alt="image-20251116132925377">
<figcaption aria-hidden="true">image-20251116132925377</figcaption>
</figure>
<h4 id="最短剩余时间优先-shortest-remaining-time-first-srtf">最短剩余时间优先
(Shortest Remaining Time First, SRTF)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133352988.png" alt="image-20251116133352988">
<figcaption aria-hidden="true">image-20251116133352988</figcaption>
</figure>
<h4 id="最高响应比优先-highest-response-ratio-first-hrrf">最高响应比优先
(Highest Response Ratio First, HRRF)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133432719.png" alt="image-20251116133432719">
<figcaption aria-hidden="true">image-20251116133432719</figcaption>
</figure>
<h4 id="优先级调度-priority-scheduling">优先级调度 (Priority
Scheduling)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141512909.png" alt="image-20251116141512909">
<figcaption aria-hidden="true">image-20251116141512909</figcaption>
</figure>
<h4 id="轮转调度-round-robin-scheduling-rr">轮转调度 (Round Robin
Scheduling, RR)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141611150.png" alt="image-20251116141611150">
<figcaption aria-hidden="true">image-20251116141611150</figcaption>
</figure>
<h4 id="多级反馈队列调度-multi-level-feedback-queue-mlfq">多级反馈队列调度
(Multi-Level Feedback Queue, MLFQ)</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116144745818.png" alt="image-20251116144745818">
<figcaption aria-hidden="true">image-20251116144745818</figcaption>
</figure>
<h2 id="并发互斥与同步">并发：互斥与同步</h2>
<h3 id="进程交互"><strong>进程交互</strong></h3>
<h4 id="为什么需要进程交互">为什么需要“进程交互”？</h4>
<p>在单进程时代，程序是“独占”的——它不需要考虑别人。但在现代操作系统中：</p>
<ul>
<li>多个进程/线程同时运行。</li>
<li>它们可能共享资源（如内存、文件、数据库连接）。</li>
<li>它们可能需要协同完成一个复杂任务（如一个 Web
请求涉及多个微服务）。</li>
</ul>
<p>这就产生了两个根本性问题：</p>
<ol type="1">
<li><strong>竞争（Competition）</strong>：多个进程争抢同一个资源，导致结果不可预测。</li>
<li><strong>协作（Cooperation）</strong>：多个进程需要按特定顺序执行，才能完成共同目标。</li>
</ol>
<blockquote>
<p>✅ <strong>进程交互就是解决这两个问题的机制</strong>。</p>
</blockquote>
<h4 id="竞争关系进程互斥">竞争关系（进程互斥）</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程互斥是指若干进程因相互争夺独占型资源而产生的竞争制约关系。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“相互争夺”</strong>：多个进程都想使用同一个资源。</li>
<li><strong>“独占型资源”</strong>：一次只能被一个进程使用的资源，如打印机、临界区代码、全局变量、数据库连接等。</li>
<li><strong>“竞争制约关系”</strong>：一个进程的执行会制约另一个进程的执行。</li>
</ul>
<p>🧱 两个核心控制问题：</p>
<ol type="1">
<li><strong>死锁问题（Deadlock）</strong>
<ul>
<li><strong>定义</strong>：多个进程互相等待对方释放资源，导致所有进程都无法继续执行。</li>
<li><strong>经典例子</strong>：“哲学家就餐问题”——五个哲学家围坐圆桌，每人左右各有一根筷子。他们必须拿到两根筷子才能吃饭。如果每个人都拿起左边的筷子，然后等待右边的筷子，就会陷入死锁。</li>
<li><strong>四个必要条件</strong>：
<ul>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul></li>
</ul></li>
<li><strong>饥饿问题（Starvation）</strong>
<ul>
<li><strong>定义</strong>：某个进程因为优先级低或资源分配策略不当，长时间得不到所需资源，导致无法执行。</li>
<li><strong>例子</strong>：在一个高优先级任务永远不结束的系统中，低优先级任务可能永远得不到
CPU。</li>
</ul></li>
</ol>
<h4 id="协作关系进程同步">协作关系（进程同步）</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程同步是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“完成共同任务”</strong>：多个进程/线程需要合作才能达成目标。</li>
<li><strong>“协调活动”</strong>：它们需要按特定顺序执行。</li>
<li><strong>“排定执行先后次序”</strong>：比如 A 必须在 B 之前执行。</li>
<li><strong>“等待、传递信号或消息”</strong>：通过同步机制（如信号量、条件变量、管道）实现通信和协调。</li>
</ul>
<p>🧱 核心思想：</p>
<ul>
<li><strong>“生产者-消费者”模型</strong>：生产者生成数据，消费者消费数据，它们必须同步。</li>
<li><strong>“读者-写者”模型</strong>：读者可以同时读，但写者必须独占。</li>
<li><strong>“屏障（Barrier）”</strong>：所有进程到达某个点后才能继续执行。</li>
</ul>
<h3 id="临界区管理">临界区管理</h3>
<h4 id="什么是临界区">什么是“临界区”？</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>并发进程中，与共享变量有关的程序段叫做“临界区”（Critical
Section）。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“并发进程”</strong>：多个进程/线程同时运行。</li>
<li><strong>“共享变量”</strong>：多个进程都能访问和修改的变量（如全局变量、数据库连接、文件句柄）。</li>
<li><strong>“程序段”</strong>：一段代码，比如 <code>counter += 1</code>
这样的操作。</li>
</ul>
<blockquote>
<p>💡 <strong>简单说</strong>：<strong>临界区 =
操作共享资源的那一小段代码。</strong></p>
</blockquote>
<p>🎯 为什么重要？</p>
<p>因为这段代码如果被多个进程同时执行，会导致<strong>竞态条件（Race
Condition）</strong>，产生不可预测的结果。</p>
<h4 id="如何避免错误-互斥访问临界区">如何避免错误？——
互斥访问临界区</h4>
<blockquote>
<p><strong>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误。</strong></p>
</blockquote>
<p>这就是“<strong>进程互斥</strong>”的核心思想。</p>
<h4 id="临界区调度的三个原则经典">临界区调度的三个原则（经典！）</h4>
<p>这是解决临界区问题的黄金法则，任何同步机制都必须满足这三个条件：</p>
<p>✅ 原则 1：一次至多一个进程能够进入临界区内执行</p>
<blockquote>
<p><strong>互斥性（Mutual Exclusion）</strong></p>
</blockquote>
<ul>
<li>这是最基本的要求。任何时候，最多只能有一个进程在临界区内。</li>
<li>如果 A 在临界区，B 就不能进入，必须等待。</li>
</ul>
<p>✅ 原则 2：如果已有进程在临界区，其他试图进入的进程应等待</p>
<blockquote>
<p><strong>忙则等待（Progress）</strong></p>
</blockquote>
<ul>
<li>如果临界区空闲，想进入的进程可以立即进入。</li>
<li>如果临界区被占用，其他进程必须等待，不能“自旋”浪费
CPU（虽然有些实现会自旋，但理想情况下应该阻塞等待）。</li>
</ul>
<p>✅ 原则
3：进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</p>
<blockquote>
<p><strong>有限等待（Bounded Waiting）</strong></p>
</blockquote>
<ul>
<li>防止“饥饿”。不能让某个进程永远等下去。</li>
<li>例如，使用队列来管理等待的进程，确保每个进程最终都能获得进入临界区的机会。</li>
</ul>
<h3 id="实现临界区管理的软件方法一peterson方法">实现临界区管理的软件方法一Peterson方法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int turn;           // turn 表示轮到谁进入</span><br><span class="line">boolean flag[2];   // flag[i] 表示进程 i 想进入临界区</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">flag[0] = flag[1] = false;</span><br><span class="line"></span><br><span class="line">Process P0() &#123;</span><br><span class="line">    flag[0] = true;</span><br><span class="line">    turn = 1;       // 谦让给 P1</span><br><span class="line">    while (flag[1] &amp;&amp; turn == 1); // 等待 P1 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process P1() &#123;</span><br><span class="line">    flag[1] = true;</span><br><span class="line">    turn = 0;       // 谦让给 P0</span><br><span class="line">    while (flag[0] &amp;&amp; turn == 0); // 等待 P0 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[1] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 1. 互斥性 (Mutual Exclusion)</p>
<blockquote>
<p><strong>定义</strong>：一次至多一个进程能进入临界区。</p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 和 P1 同时进入临界区。</li>
<li>那么 <code>flag[0] = true</code> 且
<code>flag[1] = true</code>。</li>
<li>根据算法，P0 在进入前设置了 <code>turn = 1</code>，P1 设置了
<code>turn = 0</code>。</li>
<li>由于 <code>turn</code> 只能取值 0 或 1，不可能同时为 0 和 1。</li>
<li>所以，当 P0 检查 <code>while (flag[1] &amp;&amp; turn == 1)</code>
时，如果 <code>turn == 0</code>，它就会阻塞。</li>
<li>同理，P1 也会被阻塞。</li>
<li><strong>结论</strong>：不可能同时进入。</li>
</ul>
<p>✅ 2. 空闲让进 (Progress)</p>
<blockquote>
<p><strong>定义</strong>：如果临界区空闲，且有进程想进入，则该进程应该能进入。</p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>如果 P1 不想进入临界区，则 <code>flag[1] = false</code>。</li>
<li>此时，无论 <code>turn</code> 是多少，P0 的
<code>while (flag[1] &amp;&amp; turn == 1)</code> 条件都会失败（因为
<code>flag[1]</code> 是 <code>false</code>），所以 P0
可以立即进入临界区。</li>
</ul>
<p>✅ 3. 有限等待 (Bounded Waiting)</p>
<blockquote>
<p><strong>定义</strong>：一个进程最多等待另一个进程执行完临界区一次，就能获得进入的机会。</p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 被阻塞，说明 <code>turn = 1</code> 且
<code>flag[1] = true</code>，即 P1 在临界区。</li>
<li>当 P1 执行完临界区后，它会设置 <code>flag[1] = false</code>。</li>
<li>此时，如果 P0 还想进入，它的 <code>while</code>
条件会失败，从而进入临界区。</li>
<li>如果 P1 在 <code>flag[1] = false</code> 后又想进入，则它会设置
<code>flag[1] = true</code> 和 <code>turn = 0</code>。</li>
<li>此时，P0 会被阻塞，但 P1 执行完后，P0 就能进入。</li>
<li><strong>结论</strong>：P0 最多等待 P1
执行一次临界区，就能进入。</li>
</ul>
<h3 id="信号量与pv操作">信号量与PV操作</h3>
<h4 id="信号量semaphore">信号量（Semaphore）</h4>
<p>✅ 核心定义：</p>
<blockquote>
<p><strong>信号量是一种软件资源，用于表示物理资源的实体，是一个与队列有关的整型变量。</strong></p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“表示物理资源”</strong>：比如打印机、数据库连接池、线程池中的可用线程数。</li>
<li><strong>“整型变量”</strong>：信号量的值代表当前<strong>可用资源的数量</strong>。</li>
<li><strong>“与队列有关”</strong>：当资源不足时，等待的进程会被放入一个<strong>等待队列</strong>。</li>
</ul>
<h4 id="pv-操作信号量的原子操作">P/V 操作：信号量的“原子操作”</h4>
<p>✅ 定义：</p>
<blockquote>
<p><strong>P (Proberen, 尝试) 和 V (Verhogen, 增加)
是对信号量进行操作的原语。</strong></p>
</blockquote>
<ul>
<li><strong>P 操作</strong>：尝试获取资源。如果资源可用（信号量 &gt;
0），则减 1；否则，进程进入等待队列。</li>
<li><strong>V
操作</strong>：释放资源。增加信号量值，并唤醒一个等待的进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// P 操作 (Wait)</span><br><span class="line">void P(semaphore s) &#123;</span><br><span class="line">    s.value = s.value - 1;</span><br><span class="line">    if (s.value &lt; 0) &#123;</span><br><span class="line">        // 资源不足，将当前进程加入等待队列并阻塞</span><br><span class="line">        block(current_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// V 操作 (Signal)</span><br><span class="line">void V(semaphore s) &#123;</span><br><span class="line">    s.value = s.value + 1;</span><br><span class="line">    if (s.value &lt;= 0) &#123;</span><br><span class="line">        // 有进程在等待，唤醒一个</span><br><span class="line">        wakeup(one_waiting_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ <strong>关键点</strong>：P/V 操作必须是<strong>原子操作（Atomic
Operation）</strong>，即在执行过程中不能被中断。否则会导致竞态条件。</p>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<h4 id="哲学家进餐问题核心描述">哲学家进餐问题：核心描述</h4>
<p>✅ 问题设定：</p>
<ul>
<li>有 <strong>5 位哲学家</strong> 围坐在一张圆桌旁。</li>
<li>每位哲学家面前有一盘<strong>意大利面</strong>。</li>
<li>桌子上有 <strong>5 把叉子</strong>，每两位哲学家之间放一把。</li>
<li>哲学家的生活只有两件事：
<ul>
<li><strong>思考（Think）</strong>：什么都不做。</li>
<li><strong>吃饭（Eat）</strong>：必须同时拿到<strong>左右两边的叉子</strong>才能吃。</li>
</ul></li>
<li>吃完后，会放下叉子，继续思考。</li>
</ul>
<blockquote>
<p>💡
<strong>目标</strong>：设计一个算法，让所有哲学家都能吃饱，且不会发生死锁或饥饿。</p>
</blockquote>
<h4 id="为什么会出现死锁">为什么会出现死锁？</h4>
<p>📌 死锁的四个必要条件：</p>
<ol type="1">
<li><strong>互斥条件</strong>：叉子一次只能被一个人使用。</li>
<li><strong>请求与保持条件</strong>：哲学家拿起一把叉子后，会继续等待另一把。</li>
<li><strong>不剥夺条件</strong>：不能强行从哲学家手中拿走叉子。</li>
<li><strong>环路等待条件</strong>：每位哲学家都在等右边的人放下叉子，形成一个循环等待链。</li>
</ol>
<h4 id="解决方案打破死锁的四个条件之一">解决方案：打破死锁的四个条件之一</h4>
<p>要避免死锁，只需破坏其中一个必要条件即可。以下是几种经典的解决方案：</p>
<p>✅ 解决方案 1：限制同时就餐的哲学家数量（破坏“环路等待”）</p>
<blockquote>
<p><strong>最多允许 4 位哲学家同时吃面。</strong></p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>如果只有 4 个人尝试拿叉子，那么至少有一把叉子是空闲的。</li>
<li>这样，总会有一个人能拿到两把叉子并吃完，从而释放资源。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 5 把叉子（信号量）</span><br><span class="line">forks = [threading.Semaphore(1) for _ in range(5)]</span><br><span class="line"># 限制同时就餐人数为 4</span><br><span class="line">dining_room = threading.Semaphore(4)</span><br><span class="line"></span><br><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        dining_room.acquire()  # 进入餐厅（最多 4 人）</span><br><span class="line">        </span><br><span class="line">        forks[i].acquire()       # 拿起左边叉子</span><br><span class="line">        forks[(i + 1) % 5].acquire()  # 拿起右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()       # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()  # 放下右边叉子</span><br><span class="line">        </span><br><span class="line">        dining_room.release()    # 离开餐厅</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">def eat(i):</span><br><span class="line">    print(f&quot;Philosopher &#123;i&#125; is eating...&quot;)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line"># 创建 5 个哲学家线程</span><br><span class="line">threads = []</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=philosopher, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 2：奇偶号哲学家取叉子顺序不同（破坏“环路等待”）</p>
<blockquote>
<p><strong>奇数号哲学家先取左边叉子，再取右边；偶数号哲学家先取右边叉子，再取左边。</strong></p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>这样就不会形成环路等待。</li>
<li>例如，哲学家 0（偶数）先拿右边叉子（叉子 1），哲学家
1（奇数）先拿左边叉子（叉子 1）→
他们争抢同一把叉子，但最终只会有一个成功，另一个等待，从而打破环路。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        </span><br><span class="line">        if i % 2 == 0:  # 偶数号哲学家</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 先拿右边叉子</span><br><span class="line">            forks[i].acquire()             # 再拿左边叉子</span><br><span class="line">        else:  # 奇数号哲学家</span><br><span class="line">            forks[i].acquire()             # 先拿左边叉子</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 再拿右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()                 # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()      # 放下右边叉子</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 3：拿起两把叉子才开始吃（破坏“请求与保持”）</p>
<blockquote>
<p><strong>每位哲学家必须同时拿到两把叉子才能开始吃，否则一把也不拿。</strong></p>
</blockquote>
<p>1️⃣ 全局变量定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"></span><br><span class="line">semaphore s[<span class="number">5</span>];     <span class="comment">// 用于阻塞哲学家的信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥锁，保护 state 和 s</span></span><br><span class="line"><span class="type">int</span> state[<span class="number">5</span>];      <span class="comment">// 哲学家的状态</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>s[i]</code> 初始值为 0，因为一开始没有人需要等待。</li>
<li><code>state[i]</code> 初始化为 <code>THINKING</code>。</li>
</ul>
<p>2️⃣ <code>take_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">take_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = HUNGRY;  <span class="comment">// 哲学家 i 变成饥饿状态</span></span><br><span class="line">    test(i);            <span class="comment">// 尝试让 i 吃饭</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">    P(s[i]);            <span class="comment">// 如果 test(i) 没有让 i 吃上饭，这里会阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = HUNGRY</code></strong>:
告诉“管家”，我饿了。</li>
<li><strong><code>test(i)</code></strong>: “管家”检查我是否能吃。
<ul>
<li>如果能吃，<code>test(i)</code> 会执行
<code>V(s[i])</code>，唤醒我。</li>
<li>如果不能吃，<code>test(i)</code> 不做任何事。</li>
</ul></li>
<li><strong><code>P(s[i])</code></strong>:
如果我没被唤醒，我就在这里阻塞，等待邻居放叉子。</li>
</ul>
<blockquote>
<p>✅
<strong>这个函数是“非阻塞”的</strong>：它只负责声明“我饿了”，然后立即返回。真正的等待发生在
<code>P(s[i])</code>。</p>
</blockquote>
<p>3️⃣ <code>put_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = THINKING; <span class="comment">// 哲学家 i 变成思考状态</span></span><br><span class="line">    test((i + <span class="number">1</span>) % <span class="number">5</span>);  <span class="comment">// 检查右边邻居</span></span><br><span class="line">    test((i + <span class="number">4</span>) % <span class="number">5</span>);  <span class="comment">// 检查左边邻居（(i+4)%5 == (i-1)%5）</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = THINKING</code></strong>:
我吃饱了，不再占用叉子。</li>
<li><strong><code>test((i+1)%5)</code> 和
<code>test((i+4)%5)</code></strong>:
告诉“管家”，我的邻居们可能现在可以吃饭了。
<ul>
<li>例如，哲学家 0 放下叉子后，哲学家 1 和 4
可能现在能拿到两把叉子了。</li>
<li>“管家”会检查他们是否处于 <code>HUNGRY</code>
状态，并且邻居都不在吃，如果是，就唤醒他们。</li>
</ul></li>
</ul>
<p>4️⃣ <code>test(int i)</code> 函数 —— 核心逻辑！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;  <span class="comment">// 可以吃了！</span></span><br><span class="line">        V(s[i]);            <span class="comment">// 唤醒哲学家 i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong>检查三个条件</strong>：
<ol type="1">
<li><code>state[i] == HUNGRY</code>: 我确实想吃饭。</li>
<li><code>state[(i+1)%5] != EATING</code>: 我右边的邻居没在吃。</li>
<li><code>state[(i+4)%5] != EATING</code>: 我左边的邻居没在吃。</li>
</ol></li>
<li><strong>如果都满足</strong>：说明我现在可以拿到两把叉子！
<ul>
<li>设置 <code>state[i] = EATING</code>。</li>
<li>执行 <code>V(s[i])</code>，唤醒我自己（因为我在
<code>take_fork</code> 中 <code>P(s[i])</code> 阻塞了）。</li>
</ul></li>
</ul>
<blockquote>
<p>✅ <strong>这个函数是“原子”的</strong>：因为它在 <code>mutex</code>
保护下执行，不会被其他哲学家打断。</p>
</blockquote>
<h3 id="生产者消费者问题">生产者消费者问题</h3>
<p><code>mutex</code> 的作用就是：</p>
<blockquote>
<p><strong>保护对共享变量（或临界区）的访问</strong>，
<strong>只在真正操作这些共享资源的前后“加锁”和“解锁”</strong>。</p>
</blockquote>
<p>（防死锁铁律）：</p>
<blockquote>
<p><strong>永远不要在持有互斥锁（mutex）的情况下，调用可能阻塞的操作（如
P(empty)、P(full)、sleep、wait 等）。</strong></p>
</blockquote>
<h3 id="什么是生产者-消费者问题">什么是生产者-消费者问题？</h3>
<p>这是一个经典的<strong>多线程同步问题</strong>，用于模拟现实中的“生产”与“消费”场景：</p>
<ul>
<li><strong>生产者 (Producer)</strong>：负责制造数据或产品。</li>
<li><strong>消费者
(Consumer)</strong>：负责处理或消费这些数据/产品。</li>
<li><strong>缓冲区
(Buffer)</strong>：一个有限大小的共享空间，用来暂存生产者的产品，供消费者取用。</li>
</ul>
<p>📌 核心挑战</p>
<ol type="1">
<li><strong>互斥 (Mutual
Exclusion)</strong>：多个生产者/消费者不能同时操作缓冲区的同一个位置，否则数据会错乱。</li>
<li><strong>同步 (Synchronization)</strong>：
<ul>
<li>生产者不能在缓冲区满时继续生产（要等待）。</li>
<li>消费者不能在缓冲区空时继续消费（要等待）。</li>
</ul></li>
</ol>
<h4 id="代码">代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">item B[n];</span><br><span class="line">Semaphore empty;  /*可用的空缓冲区个数*/</span><br><span class="line">Semaphore full;   /*可用的产品数*/</span><br><span class="line">Semaphore mutex;  /*互斥信号量*/</span><br><span class="line">empty = n; full = 0; mutex = 1;</span><br><span class="line">int in = 0; out = 0;  /*in为放入缓冲区指针, out为取出缓冲区指针*/</span><br><span class="line"></span><br><span class="line">Process producer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        item product = produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        B[in] = product;</span><br><span class="line">        in = (in+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process consumer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Item product = B[out];</span><br><span class="line">        out = (out+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        consume(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题如果将p操作的顺序交换会出现什么情况">问题：如果将P操作的顺序交换，会出现什么情况？</h4>
<p><strong>生产者霸占着 <code>mutex</code> 锁，等待
<code>empty</code>，消费者等待 <code>mutex</code>
锁，导致死锁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Producer as 生产者 P1</span><br><span class="line">    participant Consumer as 消费者 C1</span><br><span class="line">    participant Mutex as 互斥锁 (mutex)</span><br><span class="line">    participant Empty as 空闲缓冲区 (empty)</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 初始状态: empty=0 (缓冲区满), mutex=1</span><br><span class="line"></span><br><span class="line">    Producer-&gt;&gt;Mutex: P(mutex) // 成功获取锁，mutex=0</span><br><span class="line">    Producer-&gt;&gt;Empty: P(empty) // empty=0，阻塞！等待空位...</span><br><span class="line">    Note over Producer: 生产者 P1 霸占 mutex 锁，等待 empty</span><br><span class="line"></span><br><span class="line">    Consumer-&gt;&gt;Full: P(full) // full=1，成功，full=0</span><br><span class="line">    Consumer-&gt;&gt;Mutex: P(mutex) // mutex=0，阻塞！等待锁...</span><br><span class="line">    Note over Consumer: 消费者 C1 等待 mutex 锁</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 💥 死锁！</span><br><span class="line">    Note right of Producer: 我要等 empty (需 C1 消费)</span><br><span class="line">    Note left of Consumer: 我要等 mutex (需 P1 释放)</span><br></pre></td></tr></table></figure>
<h4 id="问题当前生产者消费者共用一个互斥锁会造成竞争">问题：当前生产者消费者共用一个互斥锁会造成竞争</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore pmutex, cmutex; // 两个独立的互斥锁</span><br><span class="line">...</span><br><span class="line">P(pmutex); // 生产者只锁自己的写入区域</span><br><span class="line">P(cmutex); // 消费者只锁自己的读取区域</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>生产者之间</strong>：仍然需要 <code>pmutex</code>
来互斥，因为多个生产者可能同时想写入 <code>in</code>
指针指向的位置。</li>
<li><strong>消费者之间</strong>：仍然需要 <code>cmutex</code>
来互斥，因为多个消费者可能同时想读取 <code>out</code>
指针指向的位置。</li>
<li><strong>生产者 vs 消费者</strong>：<strong>它们可以并行！</strong>
只要生产者在写一个位置，消费者在读另一个位置，两者互不干扰，完全可以同时进行。</li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="死锁产生">死锁产生</h3>
<h4 id="什么是死锁">什么是死锁</h4>
<p>在多进程/多线程系统中，<strong>死锁</strong>是指两个或多个进程因竞争资源而造成的一种互相等待的现象，若无外力作用，它们都将无法向前推进。</p>
<blockquote>
<p><strong>简单说：A 等 B，B 等 C，C 又等
A，大家谁也不让步，结果全都卡住。</strong></p>
</blockquote>
<h4 id="死锁的4个必要条件">死锁的4个必要条件</h4>
<p>只要系统发生死锁，以下4个条件<strong>必然同时成立</strong>。缺一不可！</p>
<p>1️⃣ 互斥访问 (Mutual Exclusion)</p>
<ul>
<li><strong>定义</strong>：系统中存在临界资源，进程应互斥地使用这些资源。</li>
<li><strong>通俗解释</strong>：资源一次只能被一个进程使用。比如，打印机、文件、数据库连接、内存中的某个变量等。</li>
<li><strong>为什么是必要条件</strong>？如果资源可以被多个进程同时共享（如只读文件），那就不存在竞争，也就不会死锁。</li>
</ul>
<p>2️⃣ 占有和等待 (Hold and Wait)</p>
<ul>
<li><strong>定义</strong>：进程在请求资源得不到满足而等待时，不释放已占有的资源。</li>
<li><strong>通俗解释</strong>：一个进程已经拿着一些资源，但它还需要其他资源才能完成工作，于是它一边等着新资源，一边还紧紧攥着自己手里的旧资源，不肯放手。</li>
<li><strong>为什么是必要条件</strong>？如果一个进程在等待新资源时能主动释放旧资源，那么它就不会阻塞别人，死锁也就不会形成。</li>
</ul>
<p>3️⃣ 不剥夺 (No Preemption)</p>
<ul>
<li><strong>定义</strong>：已被占用的资源只能由属主进程自愿释放，而不允许被其他进程剥夺。</li>
<li><strong>通俗解释</strong>：资源一旦被某个进程拿走，除非它自己愿意还回来，否则谁也不能强行抢走。这保证了进程的“自主性”，但也为死锁埋下了隐患。</li>
<li><strong>为什么是必要条件</strong>？如果系统能强行剥夺资源（比如操作系统强制回收），那么就可以打破死锁链。</li>
</ul>
<p>4️⃣ 循环等待 (Circular Wait)</p>
<ul>
<li><strong>定义</strong>：存在循环等待链，每个进程在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li>
<li><strong>通俗解释</strong>：这是一个闭环。A 等 B 的资源，B 等 C
的资源，C 又等 A 的资源，形成了一个“等待环”。</li>
<li><strong>为什么是必要条件</strong>？如果没有循环，等待链最终会指向一个“不等待”的进程，这个进程完成后会释放资源，从而解开整个等待链。</li>
</ul>
<h3 id="死锁防止">死锁防止</h3>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116173459401.png" alt="image-20251116173459401">
<figcaption aria-hidden="true">image-20251116173459401</figcaption>
</figure>
<h3 id="死锁避免">死锁避免</h3>
<h4 id="银行家算法">银行家算法</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116181426684.png" alt="image-20251116181426684">
<figcaption aria-hidden="true">image-20251116181426684</figcaption>
</figure>
<h3 id="死锁检测和解除">死锁检测和解除</h3>
<h4 id="资源分配图">资源分配图</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182605135.png" alt="image-20251116182605135">
<figcaption aria-hidden="true">image-20251116182605135</figcaption>
</figure>
<ul>
<li><strong>阻塞节点 (Blocked
Node)</strong>：一个进程，它<strong>正在请求一个或多个资源，但这些资源当前都被其他进程占用，且没有空闲实例可用</strong>。它必须等待。</li>
<li><strong>非阻塞节点 (Non-blocked
Node)</strong>：一个进程，它<strong>要么没有请求任何资源，要么它请求的资源当前有空闲实例可以立即满足</strong>。它可以继续执行。</li>
</ul>
<h4 id="如何通过资源分配图判断死锁">如何通过资源分配图判断死锁？</h4>
<p>✅ 死锁的充分条件（当资源类型只有一个实例时）</p>
<blockquote>
<p><strong>如果资源分配图中存在一个环，则系统一定发生死锁。</strong></p>
</blockquote>
<ul>
<li><strong>原因</strong>：在一个环中，每个进程都在等待下一个进程所持有的资源，而下一个进程又在等待再下一个……形成一个无限等待的闭环。</li>
</ul>
<p>⚠️ 当资源类型有多个实例时</p>
<blockquote>
<p><strong>环的存在是死锁的必要条件，但不是充分条件。</strong></p>
</blockquote>
<ul>
<li><strong>原因</strong>：即使图中有环，但如果环中的某个资源类型有多个实例，那么可能还有空闲实例可以满足某个进程的需求，从而打破死锁。</li>
</ul>
<h4 id="资源分配图的简化">资源分配图的简化</h4>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182901353.png" alt="image-20251116182901353">
<figcaption aria-hidden="true">image-20251116182901353</figcaption>
</figure>
<h4 id="死锁检测算法">死锁检测算法</h4>
<p>与银行家算法的安全性检测类似</p>
<figure>
<img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116184516361.png" alt="image-20251116184516361">
<figcaption aria-hidden="true">image-20251116184516361</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2025/">操作系统原理 (2025
春季学期)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XZAbeqEyt/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">01
- AI 时代的操作系统课2025
南京大学操作系统原理]_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/" class="post-title-link" itemprop="url">milvus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-20 19:28:13" itemprop="dateModified" datetime="2025-09-20T19:28:13+08:00">2025-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/" itemprop="url" rel="index"><span itemprop="name">python-web</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/milvus/" itemprop="url" rel="index"><span itemprop="name">milvus</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="为什么使用milvus">为什么使用milvus</h3>
<p>非结构化数据（如文本、图像和音频）格式各异，蕴含丰富的潜在语义，因此分析起来极具挑战性。为了处理这种复杂性，Embeddings
被用来将非结构化数据转换成能够捕捉其基本特征的数字向量。然后将这些向量存储在向量数据库中，从而实现快速、可扩展的搜索和分析。</p>
<p>Milvus
提供强大的数据建模功能，使您能够将非结构化或多模式数据组织成结构化的
Collections。它支持多种数据类型，适用于不同的属性模型，包括常见的数字和字符类型、各种向量类型、数组、集合和
JSON，为您节省了维护多个数据库系统的精力。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908091053654.png" alt="image-20250908091053654">
<figcaption aria-hidden="true">image-20250908091053654</figcaption>
</figure>
<h3 id="部署windows">部署（windows）</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/install_standalone-windows.md">在
Docker（Linux）中运行 Milvus | Milvus 文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Download the configuration file and rename it as docker-compose.yml</span><br><span class="line">C:\&gt;Invoke-WebRequest https://github.com/milvus-io/milvus/releases/download/v2.6.0/milvus-standalone-docker-compose.yml -OutFile docker-compose.yml</span><br><span class="line"></span><br><span class="line"># Start Milvus</span><br><span class="line">C:\&gt;docker compose up -d</span><br></pre></td></tr></table></figure>
<p>注意设置环境变量DOCKER_VOLUME_DIRECTORY来决定卷映射的路径</p>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 31%">
<col style="width: 14%">
<col style="width: 46%">
</colgroup>
<thead>
<tr>
<th>容器</th>
<th>镜像</th>
<th>在 Milvus 中的角色</th>
<th>一句话说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd</td>
<td>quay.io/coreos/etcd:v3.5.18</td>
<td>元数据与协调中心</td>
<td>负责“记帐”——存索引结构、集合信息、节点心跳等，相当于 Milvus
的“大脑备忘录”。</td>
</tr>
<tr>
<td>minio</td>
<td>minio/minio:RELEASE.2024-12-18T13-15-44Z</td>
<td>对象存储</td>
<td>负责“存文件”——把向量索引文件、大字段、日志快照等落地成对象，相当于
Milvus 的“硬盘”。</td>
</tr>
<tr>
<td>standalone</td>
<td>milvusdb/milvus:v2.6.0</td>
<td>计算节点（单机版）</td>
<td>负责“干活”——接受 SDK 请求、做向量检索、构建索引，相当于 Milvus
的“工人”。</td>
</tr>
</tbody>
</table>
<h3 id="安装">安装</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pymilvus</span><br></pre></td></tr></table></figure>
<h3 id="基本概念">基本概念</h3>
<h4 id="数据库">数据库</h4>
<p>在 Milvus
中，数据库是组织和管理数据的逻辑单元。为了提高数据安全性并实现多租户，你可以创建多个数据库，为不同的应用程序或租户从逻辑上隔离数据。例如，创建一个数据库用于存储用户
A 的数据，另一个数据库用于存储用户 B 的数据。</p>
<h4 id="collections">collections</h4>
<p>在 Milvus 上，您可以创建多个 Collections
来管理数据，并将数据作为实体插入到 Collections 中。Collections
和实体<strong>类似于关系数据库中的表和记录</strong>。</p>
<p>Collection
是一个二维表，具有固定的列和变化的行。每列代表一个字段，每行代表一个实体。</p>
<p>下图显示了一个有 8 列和 6 个实体的 Collection。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908094418551.png" alt="image-20250908094418551">
<figcaption aria-hidden="true">image-20250908094418551</figcaption>
</figure>
<h4 id="schema">schema</h4>
<p>Schema 定义了 Collections 的数据结构。在创建一个 Collection
之前，你需要设计出它的 Schema。</p>
<p>设计良好的 Schema
至关重要，因为它抽象了数据模型，并决定能否通过搜索实现业务目标。此外，由于插入
Collections 的每一行数据都必须遵循
Schema，因此有助于保持数据的一致性和长期质量。从技术角度看，定义明确的
Schema
会带来组织良好的列数据存储和更简洁的索引结构，从而提升搜索性能。</p>
<p>一个 Collection Schema
有一个主键、最多四个向量字段和几个标量字段。下图说明了如何将文章映射到模式字段列表。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908094645183.png" alt="image-20250908094645183">
<figcaption aria-hidden="true">image-20250908094645183</figcaption>
</figure>
<h3 id="与langchain集成">与langchain集成</h3>
<p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/vectorstores/milvus/#query-directly">Milvus
| 🦜️🔗 LangChain</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/integrate_with_langchain.md">使用
Milvus 和 LangChain 的检索增强生成（RAG） | Milvus 文档</a></p>
<p>本人实现的用于分块后存储入milvus的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">class MilvusStorage:</span><br><span class="line">    &quot;&quot;&quot;Milvus向量存储管理类</span><br><span class="line">    </span><br><span class="line">    负责将分块后的文档内容存储到Milvus向量数据库中，</span><br><span class="line">    支持向量检索和BM25全文检索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    def __init__(self, </span><br><span class="line">                 embedding_function: Embeddings,</span><br><span class="line">                 uri: Optional[str] = None, </span><br><span class="line">                 db_name: Optional[str] = None,</span><br><span class="line">                 token: Optional[str] = None,</span><br><span class="line">                 collection_name: Optional[str] = None):</span><br><span class="line">        &quot;&quot;&quot;初始化Milvus存储客户端</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            embedding_function: LangChain embedding模型实例（必需）</span><br><span class="line">            uri: Milvus服务地址，默认从环境变量MILVUS_URI获取</span><br><span class="line">            db_name: 数据库名称，默认从环境变量MILVUS_DB_NAME获取</span><br><span class="line">            token: 认证令牌，默认从环境变量MILVUS_TOKEN获取（可选）</span><br><span class="line">            collection_name: 集合名称，默认从环境变量MILVUS_COLLECTION_NAME获取</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 验证必需参数</span><br><span class="line">        if not embedding_function:</span><br><span class="line">            raise ValueError(&quot;embedding_function是必需参数，必须提供LangChain Embeddings实例&quot;)</span><br><span class="line">        </span><br><span class="line">        # 从环境变量读取配置，如果参数没有提供的话</span><br><span class="line">        self.uri = uri or os.getenv(&#x27;MILVUS_URI&#x27;, &#x27;http://localhost:19530&#x27;)</span><br><span class="line">        self.db_name = db_name or os.getenv(&#x27;MILVUS_DB_NAME&#x27;, &#x27;rag&#x27;)</span><br><span class="line">        self.token = token or os.getenv(&#x27;MILVUS_TOKEN&#x27;) or None</span><br><span class="line">        self.collection_name = collection_name or os.getenv(&#x27;MILVUS_COLLECTION_NAME&#x27;, &#x27;chunks&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 设置embedding函数</span><br><span class="line">        self.embedding_function = embedding_function</span><br><span class="line">        </span><br><span class="line">        # 初始化LangChain Milvus向量存储</span><br><span class="line">        self.vector_store = Milvus(</span><br><span class="line">            embedding_function=self.embedding_function,</span><br><span class="line">            connection_args=&#123;</span><br><span class="line">                &quot;uri&quot;: self.uri,</span><br><span class="line">                &quot;db_name&quot;: self.db_name,</span><br><span class="line">                &quot;token&quot;: self.token</span><br><span class="line">            &#125; if self.token else &#123;</span><br><span class="line">                &quot;uri&quot;: self.uri,</span><br><span class="line">                &quot;db_name&quot;: self.db_name</span><br><span class="line">            &#125;,</span><br><span class="line">            collection_name=self.collection_name,</span><br><span class="line">            index_params=&#123;&quot;index_type&quot;: &quot;HNSW&quot;, &quot;metric_type&quot;: &quot;COSINE&quot;, &quot;params&quot;: &#123;&quot;M&quot;: 16, &quot;efConstruction&quot;: 200&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    def store_chunks(self, chunk_result: ChunkResult) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;存储分块结果到Milvus</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_result: 分块结果对象</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 插入结果，包含插入状态和记录数</span><br><span class="line">            </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当向量存储未初始化时</span><br><span class="line">            Exception: Milvus操作异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not self.vector_store:</span><br><span class="line">            raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">        </span><br><span class="line">        if not chunk_result.chunks:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;, </span><br><span class="line">                &quot;inserted_count&quot;: 0,</span><br><span class="line">                &quot;message&quot;: &quot;无数据需要插入&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            # 转换为LangChain Document格式</span><br><span class="line">            documents = self._convert_chunks_to_langchain_docs(chunk_result)</span><br><span class="line">            </span><br><span class="line">            # 为每个文档生成UUID作为主键</span><br><span class="line">            from uuid import uuid4</span><br><span class="line">            uuids = [str(uuid4()) for _ in range(len(documents))]</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus添加文档，指定IDs</span><br><span class="line">            ids = self.vector_store.add_documents(documents=documents, ids=uuids)</span><br><span class="line">            </span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;inserted_count&quot;: len(documents),</span><br><span class="line">                &quot;document_ids&quot;: ids,</span><br><span class="line">                &quot;document_name&quot;: chunk_result.document_name,</span><br><span class="line">                &quot;strategy&quot;: chunk_result.strategy.value,</span><br><span class="line">                &quot;collection_name&quot;: self.collection_name</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            raise Exception(f&quot;Milvus插入失败: &#123;str(e)&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def _convert_chunks_to_langchain_docs(self, chunk_result: ChunkResult) -&gt; List[Document]:</span><br><span class="line">        &quot;&quot;&quot;为现有Documents添加存储所需的元数据</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_result: 分块结果，chunks已经是Document列表</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            List[Document]: 添加了元数据的Document列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        documents = []</span><br><span class="line">        </span><br><span class="line">        for idx, chunk in enumerate(chunk_result.chunks):</span><br><span class="line">            # 创建符合Milvus集合schema的元数据</span><br><span class="line">            # 注意：page_content会自动映射到text_content字段</span><br><span class="line">            updated_metadata = &#123;</span><br><span class="line">                **chunk.metadata,  # 保留原有元数据</span><br><span class="line">                &quot;document_name&quot;: chunk_result.document_name,</span><br><span class="line">                &quot;chunk_index&quot;: idx,</span><br><span class="line">                &quot;chunk_size&quot;: len(chunk.page_content)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            # 创建新Document以避免修改原始数据</span><br><span class="line">            # LangChain会自动将page_content映射到Milvus的text_content字段</span><br><span class="line">            # embedding字段会由embedding_function自动生成</span><br><span class="line">            doc = Document(</span><br><span class="line">                page_content=chunk.page_content,</span><br><span class="line">                metadata=updated_metadata</span><br><span class="line">            )</span><br><span class="line">            documents.append(doc)</span><br><span class="line">        </span><br><span class="line">        return documents</span><br><span class="line">    </span><br><span class="line">    def store_chunks_batch(self, chunk_results: List[ChunkResult]) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;批量存储多个分块结果到Milvus</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_results: 分块结果列表</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 批量插入结果</span><br><span class="line">            </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当向量存储未初始化时</span><br><span class="line">            Exception: Milvus操作异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not self.vector_store:</span><br><span class="line">            raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">        </span><br><span class="line">        if not chunk_results:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;没有分块结果需要存储&quot;,</span><br><span class="line">                &quot;total_chunks&quot;: 0,</span><br><span class="line">                &quot;document_count&quot;: 0</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            # 收集所有文档</span><br><span class="line">            all_documents = []</span><br><span class="line">            total_chunks = 0</span><br><span class="line">            </span><br><span class="line">            for chunk_result in chunk_results:</span><br><span class="line">                if chunk_result.chunks:</span><br><span class="line">                    documents = self._convert_chunks_to_langchain_docs(chunk_result)</span><br><span class="line">                    all_documents.extend(documents)</span><br><span class="line">                    total_chunks += len(documents)</span><br><span class="line">            </span><br><span class="line">            if not all_documents:</span><br><span class="line">                return &#123;</span><br><span class="line">                    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                    &quot;message&quot;: &quot;没有文档需要存储&quot;,</span><br><span class="line">                    &quot;total_chunks&quot;: 0,</span><br><span class="line">                    &quot;document_count&quot;: len(chunk_results)</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            # 为所有文档生成UUID作为主键</span><br><span class="line">            from uuid import uuid4</span><br><span class="line">            uuids = [str(uuid4()) for _ in range(len(all_documents))]</span><br><span class="line">            </span><br><span class="line">            # 批量添加所有文档，指定IDs</span><br><span class="line">            ids = self.vector_store.add_documents(documents=all_documents, ids=uuids)</span><br><span class="line">            </span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;message&quot;: f&quot;成功存储 &#123;len(chunk_results)&#125; 个文档的 &#123;total_chunks&#125; 个分块&quot;,</span><br><span class="line">                &quot;total_chunks&quot;: total_chunks,</span><br><span class="line">                &quot;document_count&quot;: len(chunk_results),</span><br><span class="line">                &quot;ids&quot;: ids,</span><br><span class="line">                &quot;collection_name&quot;: self.collection_name</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            raise Exception(f&quot;Milvus批量插入失败: &#123;str(e)&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def delete_document(self, </span><br><span class="line">                       document_name: str, </span><br><span class="line">                       collection_name: Optional[str] = None) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;删除指定文档的所有chunks</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            document_name: 文档名称</span><br><span class="line">            collection_name: collection名称</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 删除结果</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        target_collection = collection_name or self.collection_name</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not self.vector_store:</span><br><span class="line">                raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus删除功能</span><br><span class="line">            # 注意：LangChain Milvus可能不支持按元数据过滤删除，这里提供基本实现</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;,</span><br><span class="line">                &quot;document_name&quot;: document_name,</span><br><span class="line">                &quot;error&quot;: &quot;LangChain Milvus不支持按文档名删除，请使用其他方式&quot;,</span><br><span class="line">                &quot;collection_name&quot;: target_collection</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;, </span><br><span class="line">                &quot;document_name&quot;: document_name,</span><br><span class="line">                &quot;error&quot;: str(e)</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    def get_document_stats(self, </span><br><span class="line">                          document_name: Optional[str] = None,</span><br><span class="line">                          collection_name: Optional[str] = None) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;获取文档统计信息</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            document_name: 文档名称，None则统计所有文档</span><br><span class="line">            collection_name: collection名称</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 统计信息</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        target_collection = collection_name or self.collection_name</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not self.vector_store:</span><br><span class="line">                raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus获取基本信息</span><br><span class="line">            # 注意：LangChain Milvus没有直接的统计方法，这里提供基本信息</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;collection_name&quot;: target_collection,</span><br><span class="line">                &quot;vector_store_type&quot;: &quot;LangChain Milvus&quot;,</span><br><span class="line">                &quot;embedding_function&quot;: str(type(self.embedding_function).__name__),</span><br><span class="line">                &quot;connection_uri&quot;: self.uri,</span><br><span class="line">                &quot;database_name&quot;: self.db_name,</span><br><span class="line">                &quot;message&quot;: &quot;详细统计信息需要通过其他方式获取&quot;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        except Exception as e:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;,</span><br><span class="line">                &quot;error&quot;: str(e)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本ann搜索">基本ANN搜索</h3>
<p>近似近邻（ANN）搜索以记录向量嵌入排序顺序的索引文件为基础，根据接收到的搜索请求中携带的查询向量查找向量嵌入子集，将查询向量与子群中的向量进行比较，并返回最相似的结果。</p>
<p>ANN 和 k-Nearest Neighbors (kNN) 搜索是向量相似性搜索的常用方法。在
kNN
搜索中，必须将向量空间中的所有向量与搜索请求中携带的查询向量进行比较，然后找出最相似的向量，这既耗时又耗费资源。</p>
<p>与 kNN 搜索不同，ANN
搜索算法要求提供一个<strong>索引</strong>文件，记录向量 Embeddings
的排序顺序。当收到搜索请求时，可以使用索引文件作为参考，快速找到可能包含与查询向量最相似的向量嵌入的子组。然后，你可以使用指定的<strong>度量类型</strong>来测量查询向量与子组中的向量之间的相似度，根据与查询向量的相似度对组成员进行排序，并找出<strong>前
K 个</strong>组成员。</p>
<p>ANN
搜索依赖于预建索引，搜索吞吐量、内存使用量和搜索正确性可能会因选择的索引类型而不同。您需要在搜索性能和正确性之间取得平衡。</p>
<h3 id="混合检索">混合检索</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multi-vector-search.md">多向量混合搜索 |
Milvus 文档</a></p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092720695.png" alt="image-20250908092720695">
<figcaption aria-hidden="true">image-20250908092720695</figcaption>
</figure>
<p>让我们考虑一个真实世界的使用案例，其中每个产品都包含文字描述和图片。根据可用数据，我们可以进行三种类型的搜索：</p>
<ul>
<li><strong>语义文本搜索：</strong>这涉及使用密集向量查询产品的文本描述。可以使用<a target="_blank" rel="noopener" href="https://zilliz.com/learn/explore-colbert-token-level-embedding-and-ranking-model-for-similarity-search?_gl=1*d243m9*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#A-Quick-Recap-of-BERT">BERT</a>和<a target="_blank" rel="noopener" href="https://zilliz.com/learn/NLP-essentials-understanding-transformers-in-AI?_gl=1*d243m9*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">Transformers</a>等模型或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/guide-to-using-openai-text-embedding-models?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">OpenAI</a>
等服务生成文本嵌入。</li>
<li><strong>全文搜索</strong>：在这里，我们使用稀疏向量的关键词匹配来查询产品的文本描述。<a target="_blank" rel="noopener" href="https://zilliz.com/learn/mastering-bm25-a-deep-dive-into-the-algorithm-and-application-in-milvus?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">BM25</a>等算法或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings?_gl=1*1cde1oq*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#BGE-M3">BGE-M3</a>或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings?_gl=1*ov2die*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#SPLADE">SPLADE</a>等稀疏嵌入模型可用于此目的。</li>
<li><strong>多模态图像搜索：</strong>这种方法使用带有密集向量的文本查询对图像进行查询。可以使用<a target="_blank" rel="noopener" href="https://zilliz.com/learn/exploring-openai-clip-the-future-of-multimodal-ai-learning?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879&amp;_gl=1*90lcis*_gcl_au*MTI2OTI1Njc4OS4xNzU3MTYxMTEz*_ga*NTMyMTM0NTIwLjE3NTcxNjExMTM.*_ga_KKMVYG8YF2*czE3NTcyOTM4NzUkbzUkZzEkdDE3NTcyOTQ4MTMkajYwJGwwJGgw">CLIP</a>
等模型生成图像嵌入。</li>
</ul>
<p>混合检索的构建流程：</p>
<ol type="1">
<li><p>创建具有多个向量场的 Collections</p>
<ul>
<li>定义 Collections Schema</li>
<li>配置索引参数</li>
<li>创建 Collections</li>
</ul></li>
<li><p>插入数据‘</p></li>
<li><p>执行混合搜索</p>
<ul>
<li><p>创建多个 AnnSearchRequest 实例</p>
<p>混合搜索是通过在<code>hybrid_search()</code>
函数中创建多个<code>AnnSearchRequest</code>
来实现的，其中每个<code>AnnSearchRequest</code> 代表一个特定向量场的基本
ANN
搜索请求。因此，在进行混合搜索之前，有必要为每个向量场创建一个<code>AnnSearchRequest</code>
。</p></li>
<li><p>配置 Rerankers 策略</p></li>
</ul></li>
</ol>
<h3 id="rerankers-策略">Rerankers 策略</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/rrf-ranker.md">RRF 排序器 | Milvus
文档</a></p>
<p>要对 ANN
搜索结果集进行合并和重新排序，选择适当的重新排序策略至关重要。Milvus
提供两种重排策略：</p>
<ul>
<li><strong>加权排名</strong>：如果结果需要强调某个向量场，请使用该策略。WeightedRanker
可以为某些向量场赋予更大的权重，使其更加突出。</li>
<li><strong>RRFRanker（互易排名融合排名器）</strong>：在不需要特别强调的情况下选择此策略。RRFRanker
能有效平衡每个向量场的重要性。</li>
</ul>
<h4 id="加权排名">加权排名</h4>
<p>加权排名器通过为每个搜索路径分配不同的重要性权重，智能地组合来自多个搜索路径的结果并确定其优先级。与技艺高超的厨师平衡多种配料以制作完美菜肴的方式类似，加权排名器也会平衡不同的搜索结果，以提供最相关的综合结果。这种方法非常适合在多个向量场或模式中进行搜索，其中某些场对最终排名的贡献应比其他场更大。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092538807.png" alt="image-20250908092538807">
<figcaption aria-hidden="true">image-20250908092538807</figcaption>
</figure>
<h4 id="rrfranker">RRFRanker</h4>
<p>互惠排名融合（RRF）排名器是 Milvus
混合搜索的一种重新排名策略，它根据多个向量搜索路径的排名位置而不是原始相似度得分来平衡搜索结果。就像体育比赛考虑的是球员的排名而不是个人统计数据一样，RRF
Ranker
根据每个项目在不同搜索路径中的排名高低来组合搜索结果，从而创建一个公平、均衡的最终排名。</p>
<p>RRF Ranker
专门设计用于<strong>混合搜索场景</strong>，在这种场景中，您需要平衡来自多个向量搜索路径的结果，而无需分配明确的重要性权重。</p>
<figure>
<img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092346065.png" alt="image-20250908092346065">
<figcaption aria-hidden="true">image-20250908092346065</figcaption>
</figure>
<h3 id="多租户">多租户</h3>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multi_tenancy.md#Partition-key-based-multi-tenancy">实施多租户
| Milvus 文档</a></p>
<p>Milvus
支持四个级别的多租户：<strong>数据库</strong>、<strong>Collection</strong>、<strong>Partition</strong>
和<strong>Partition Key</strong>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%">
<col style="width: 28%">
<col style="width: 28%">
<col style="width: 14%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th>** 数据库级**</th>
<th><strong>Collections 级</strong></th>
<th><strong>分区级</strong></th>
<th><strong>分区 Key 级</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据隔离</strong></td>
<td>物理</td>
<td>物理</td>
<td>物理</td>
<td>物理 + 逻辑</td>
</tr>
<tr>
<td><strong>最大租户数</strong></td>
<td>默认为 64 个。您可以通过修改 Milvus.yaml
配置文件中的<code>maxDatabaseNum</code> 参数来增加租户数。</td>
<td>默认为 65,536。可以通过修改 Milvus.yaml
配置文件中的<code>maxCollectionNum</code> 参数来增加。</td>
<td>每个 Collection 最多 1,024 个。</td>
<td>百万</td>
</tr>
<tr>
<td><strong>数据 Schema 灵活性</strong></td>
<td>高</td>
<td>中</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><strong>RBAC 支持</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>搜索性能</strong></td>
<td>强</td>
<td>强</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td><strong>跨租户搜索支持</strong></td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>是</td>
</tr>
<tr>
<td><strong>支持有效处理冷热数据</strong></td>
<td>是</td>
<td>是</td>
<td>支持</td>
<td>否 目前不支持 Partition Key 级策略。</td>
</tr>
</tbody>
</table>
<h3 id="比较有意思的教程">比较有意思的教程</h3>
<p>多模态rag<a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multimodal_rag_with_milvus.md">用 Milvus
制作多模态 RAG | Milvus 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/text_image_search.md">使用 Milvus
进行文本到图像搜索 | Milvus 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/image_similarity_search.md">使用
Milvus 搜索图像 | Milvus 文档</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/05/%E5%AE%9E%E4%B9%A0/Tosea.ai/api%E8%B0%83%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/05/%E5%AE%9E%E4%B9%A0/Tosea.ai/api%E8%B0%83%E6%9F%A5/" class="post-title-link" itemprop="url">api调查</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-05T00:00:00+08:00">2025-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-06 22:53:32" itemprop="dateModified" datetime="2025-09-06T22:53:32+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/Tosea-ai/" itemprop="url" rel="index"><span itemprop="name">Tosea.ai</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="convertapi">convertapi</h3>
<p><a target="_blank" rel="noopener" href="https://www.convertapi.com/">ConvertAPI: Powerful File
Conversion API for Developers &amp; Businesses</a></p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 15%">
<col style="width: 16%">
<col style="width: 27%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr>
<th>档次</th>
<th>官方名称</th>
<th>月费 (CNY)</th>
<th>每月包含转换次数</th>
<th>单文件上限</th>
<th>并发任务数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Developer</td>
<td>¥249</td>
<td>1,000 次</td>
<td>200 MB</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Startup</td>
<td>¥677</td>
<td>5,000 次</td>
<td>300 MB</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>Growth</td>
<td>¥1,247</td>
<td>15,000 次</td>
<td>500 MB</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>Business</td>
<td>¥2,495</td>
<td>50,000 次</td>
<td>1 GB</td>
<td>无限制</td>
</tr>
</tbody>
</table>
<h3 id="cloudconvert">CloudConvert</h3>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 22%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>模式</th>
<th>价格</th>
<th>包含内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一次性购买积分</strong></td>
<td><strong>$9 美元</strong> 起</td>
<td>500 个转换积分</td>
</tr>
<tr>
<td><strong>月度订阅</strong></td>
<td><strong>$9 美元/月</strong></td>
<td>每月 1000 个转换积分，未用完可滚存</td>
</tr>
</tbody>
</table>
<p>每天免费 10 次转换</p>
<p>pdf转ppt，一次要花费4积分，平均下来一份需要0.47元，付费情况下可以做到
5个并发任务</p>
<p><a target="_blank" rel="noopener" href="https://cloudconvert.com/pricing">定价 |云转换</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudconvert.com/pdf-to-pptx">PDF to PowerPoint |
CloudConvert</a></p>
<h3 id="groupdocs.conversionaspose.pdf-cloud">GroupDocs.Conversion/Aspose.PDF
Cloud</h3>
<p>每个月1000次以内的api调用是30美金，平均下来是一份0.21元，但是如果超过1000次每个月，就要0.09美金一次转换</p>
<p>付费默认5并发</p>
<p>https://products.groupdocs.cloud/conversion/python/pdf-to-ppt/</p>
<p><a target="_blank" rel="noopener" href="https://dashboard.groupdocs.cloud/#/">Dashboard</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.aspose.cloud/#/">Dashboard</a></p>
<p><a target="_blank" rel="noopener" href="https://purchase.groupdocs.cloud/pricing/">Pricing Guide -
Purchase - groupdocs.cloud</a></p>
<h3 id="adobe-pdf">Adobe PDF</h3>
<p>每个月五百次的免费转换</p>
<p><a target="_blank" rel="noopener" href="https://developer.adobe.com/document-services/pricing/main/">Adobe
PDF Services API Pricing | PDF Embed API Pricing | Adobe Acrobat
Services Pricing - Adobe Developers</a></p>
<h3 id="度慧科技">度慧科技</h3>
<p>这个很便宜，我在腾讯云上看，300r可以买五千次，500r可以买5万次转换。阿里云，100r可以买3000次，有效期一个月</p>
<p>并发数为200</p>
<p><a target="_blank" rel="noopener" href="https://try.dhconvert.com/">度慧文档转换</a></p>
<p>[<a target="_blank" rel="noopener" href="https://market.cloud.tencent.com/products/24078?keyword=度慧">度慧]PDF转Word,PPT,Excel,TXT,OFD（OCR高级版）-腾讯云市场</a></p>
<p><a target="_blank" rel="noopener" href="https://market.aliyun.com/detail/cmapi00044824#sku=yuncode3882400007">【度慧文档转换】PDF转Word/PPT/Excel/TXT/OFD
- 支持扫描版OCR【最新版】_数据API_OCR_API-_云市场-阿里云</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepagent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepagent/" class="post-title-link" itemprop="url">deepagents实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-28T00:00:00+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-20 08:50:19" itemprop="dateModified" datetime="2025-10-20T08:50:19+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hjeMzVEUu?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">LangChain
Deep Agents - 构建你自己的深度研究智能体_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.langchain.com/deep-agents/">《深度智能体》 —
Deep Agents</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepresearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepresearch/" class="post-title-link" itemprop="url">deepresearch实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-28 00:00:00 / 修改时间：15:24:12" itemprop="dateCreated datePublished" datetime="2025-08-28T00:00:00+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="理解deepresearch">理解deepresearch</h3>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aXg5zzExm?buvid=XX7932A7E9DD8A1DA92D4974AB535749A9B44&amp;from_spmid=tm.recommend.0.0&amp;is_story_h5=false&amp;mid=25yhOI1fPeVYa5V16BFcAw%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=aec53502-2411-4bc1-8ccf-ce85bd6efc1e&amp;share_source=QQ&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1753142992&amp;unique_k=tZcFKrS&amp;up_id=28357052&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">🦜🕸️
Open Deep Research V2：新架构！上下文工程最新实践
📋_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://academy.langchain.com/courses/take/deep-research-with-langgraph/lessons/67513388-course-overview">Project:
Deep Research with LangGraph - LangChain Academy</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/langchain-ai/open_deep_research">langchain-ai/open_deep_research
— langchain-ai/open_deep_research</a></p>
<p>官方博文<a target="_blank" rel="noopener" href="https://blog.langchain.com/open-deep-research/">开启深度研究 —
Open Deep Research</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/25/%E5%AE%9E%E4%B9%A0/Tosea.ai/aippt%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/25/%E5%AE%9E%E4%B9%A0/Tosea.ai/aippt%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">aippt技术调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-25T00:00:00+08:00">2025-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 19:00:20" itemprop="dateModified" datetime="2025-08-28T19:00:20+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/Tosea-ai/" itemprop="url" rel="index"><span itemprop="name">Tosea.ai</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="技术路线">技术路线</h3>
<p><strong>方案 A：html → PDF →
pptx</strong>（我尝试下来不大可行，无法再进行编辑了）</p>
<p><strong>方案 B：html → PPTXGenJS</strong></p>
<p><strong>方案 C：html → python-pptx</strong> (主流)</p>
<p><strong>方案 D：markdown → Slidev</strong></p>
<p>我尝试了当前市面的ppt生成产品，在网页里面展示还会有良好的动画效果，但是一旦导出成pptx，都是会变成静态页面，没有动画</p>
<p>reveal.js可以利用页面生成丰富的ppt动画效果；Slidev可以将markdown语法转化成ppt，可以导出为pdf或pptx，需要注意的是，PPTX
文件中的所有幻灯片都会被导出为图片。</p>
<p>PPTXGenJS和python-pptx的原理基本一致，区别一个是使用js一个是python，使用方法都是通过解析HTML标签内容，定义一个ppt实例，将html的内容一点点加入这个示例中，最后导出pptx。这样都仅能实现最基本的ppt演示，不会有复杂的结构，而且经常会出现一个问题——某个标签内文字太多往往会超出ppt演示范围</p>
<p>直接让AI来生成非常自由的PPT，最终的效果一般来说都比较烂，大部分都是预定义一个html模板，然后让AI来自动的选择模板往里面填充内容</p>
<h3 id="相关工具">相关工具</h3>
<p><a target="_blank" rel="noopener" href="https://cn.sli.dev/guide/">Slidev</a>
是一个为开发者设计的基于 Web 的幻灯片制作工具。它帮助您以 Markdown
的形式专注于编写幻灯片的内容，并制作出具有交互式演示功能的、高度可自定义的幻灯片。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hakimel/reveal.js">reveal.js</a>
是一个开源的 <strong>HTML 演示框架</strong>，用 JavaScript
写成。只要你会写 HTML/CSS/JS，就可以像做网页一样做出
<strong>酷炫、响应式、支持键盘/鼠标/触控交互</strong> 的幻灯片。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gitbrent/PptxGenJS">PptxGenJS</a>
允许您使用 JavaScript 生成专业的 PowerPoint 演示文稿——直接从
Node、React、Vite、Electron，甚至浏览器中生成。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/scanny/python-pptx">python-pptx</a>
是一个用于创建、读取和更新 PowerPoint (.pptx)文件的 Python
库。典型的使用场景是从动态内容（如数据库查询、分析输出或 JSON 负载）生成
PowerPoint 演示文稿，可能是在响应 HTTP 请求时生成 PPTX 文件并下载。</p>
<blockquote>
<p>python-pptx使用方式：根据标签解析html文件，如h1，div等，然后一点点添加到定义的页中</p>
</blockquote>
<h3 id="市面同类产品">市面同类产品</h3>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.genspark.ai/agents?type=slides_agent">Genspark</a>
<ul>
<li>Genspark 是 <strong>MainFunc</strong> 公司（由前小度 CEO
景鲲和前小度 CTO 朱凯华联合创立）推出的 <strong>AI Agent
搜索引擎</strong>（或称“AI 原生搜索引擎”）。</li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://www.tiangong.cn/?from=ai-tab.cn">skywork</a>
<ul>
<li>Skywork 是昆仑万维（Kunlun Inc.）旗下 <strong>SkyWork AI</strong>
推出的一系列 <strong>开源大模型</strong> 与 <strong>AI
技术品牌</strong>。</li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://manus.im/app">manus</a></li>
<li><a target="_blank" rel="noopener" href="https://gamma.app/">Gamma</a> 是一个 <strong>“AI
驱动的在线内容工作站”</strong>：输入一句话、一段大纲或任何资料，它就能在
<strong>1-3 分钟内</strong> 帮你生成
<strong>高颜值、品牌化、可互动</strong> 的演示文稿、网站、社媒图文或
PDF，并可一键导出为 <strong>PPT / Google Slides / PDF /
网站链接</strong>。</li>
</ol>
<p>manus是每页ppt都是一个html文件，我猜测应该是使用像python-pptx的库生成</p>
<h3 id="ppt-mcp">ppt-mcp</h3>
<p>可以参考其中的工具实现，这两个我看下来都是使用python-pptx包</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GongRzhe/Office-PowerPoint-MCP-Server">GongRzhe/Office-PowerPoint-MCP-Server:
A MCP (Model Context Protocol) server for PowerPoint manipulation using
python-pptx. This server provides tools for creating, editing, and
manipulating PowerPoint presentations through the MCP protocol.</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ltc6539/mcp-ppt">ltc6539/mcp-ppt: A mcp
server supporting you to generate powerpoint using LLM and natural
language automatically.</a></p>
<h3 id="架构思考">架构思考</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">    subgraph &quot;Plan-and-Execute阶段&quot;</span><br><span class="line">        A[&quot;用户输入&quot;] --&gt; B[&quot;Planner Agent&quot;]</span><br><span class="line">        B --&gt; C[&quot;Agent Executor&quot;]</span><br><span class="line">        C --&gt; D[&quot;Replanner&quot;]</span><br><span class="line">        D --&gt;|&quot;需要更多信息&quot;| C</span><br><span class="line">        D --&gt;|&quot;信息充足&quot;| E[&quot;输出结构化信息&quot;]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;内容生成阶段&quot;</span><br><span class="line">        E --&gt; F[&quot;大纲设计节点&quot;]</span><br><span class="line">        F --&gt; G[&quot;页面内容生成节点&quot;]</span><br><span class="line">        G --&gt; H[&quot;HTML代码生成节点&quot;]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;文件转换阶段&quot;</span><br><span class="line">        H --&gt; I[&quot;html演示生成&quot;]</span><br><span class="line">        I --&gt; J[&quot;转换pptx节点&quot;]</span><br><span class="line">        J --&gt; K[&quot;输出PPTX文件&quot;]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<h3 id="利用apryse将pdf转成pptx">利用APRYSE将pdf转成pptx</h3>
<p>Apryse（曾用名 PDFTron）是一家加拿大公司推出的商用 SDK 家族，专注
“任何格式进、任何格式出” 的文档处理。</p>
<p>获取apikey<a target="_blank" rel="noopener" href="https://docs.apryse.com/core/guides/get-started/trial-key">Free
trial key for Apryse SDK | Apryse documentation</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.apryse.com/core/guides/get-started/python3">Python
3.X PDF Library for Windows, Linux and Mac | Apryse
documentation</a></p>
<p><strong>安装 Apryse SDK 的“结构化输出模块”（Structured Output
Module）</strong>。该模块是一个可选的扩展包，PDF → PPTX、PDF → Word
等高级转换功能都依赖它。<a target="_blank" rel="noopener" href="https://docs.apryse.com/core/guides/info/modules">库插件：OCR、CAD
转 PDF - 适用于服务器/桌面 SDK | Apryse 文档 — Library Add-ons: OCR, CAD
to PDF - for Server/Desktop SDK | Apryse documentation</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from apryse_sdk import PDFNet, PDFDoc, Convert, StructuredOutputModule</span><br><span class="line"></span><br><span class="line"># 1. 初始化（许可证）</span><br><span class="line">PDFNet.Initialize(&quot;demo:1756369085114:&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 告诉 SDK 模块放在哪里</span><br><span class="line">PDFNet.AddResourceSearchPath(r&quot;F:\project python\test\StructuredOutputWindows\Lib\Windows&quot;)</span><br><span class="line"></span><br><span class="line"># 3. 可选：确认模块已就位</span><br><span class="line">if not StructuredOutputModule.IsModuleAvailable():</span><br><span class="line">    raise RuntimeError(&quot;StructuredOutput module not found!&quot;)</span><br><span class="line"></span><br><span class="line"># 4. 正常调用</span><br><span class="line">doc = PDFDoc(&quot;input.pdf&quot;)</span><br><span class="line">Convert.ToPowerPoint(doc, &quot;output.pptx&quot;)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.convertapi.com/a">Overview</a></p>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zftnz6Ewx/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">动手实现一个做PPT的MCP服务器_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/" class="post-title-link" itemprop="url">agentic-rag实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-19T00:00:00+08:00">2025-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-08 10:05:23" itemprop="dateModified" datetime="2025-09-08T10:05:23+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/rag/" itemprop="url" rel="index"><span itemprop="name">rag</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言">前言</h3>
<p><strong>这个agentic
rag主要是作用于检索部分，由是否需要调用检索工具判定是否进入检索阶段，当检索到相关的文章，则进行回答，否则对问题进行改写，再次检索</strong></p>
<p>代码见<a target="_blank" rel="noopener" href="https://github.com/zxj-2023/learn-rag-langchain/tree/main/agentic-rag">learn-rag-langchain/agentic-rag
at main · zxj-2023/learn-rag-langchain</a></p>
<p>在这个教程中，我们将构建一个检索代理。当您希望 LLM
决定是否从向量存储中检索上下文或直接响应用户时，检索代理非常有用。</p>
<p>完成教程后，我们将完成以下工作：</p>
<ol type="1">
<li>获取并预处理用于检索的文档。</li>
<li>为这些文档建立语义索引，并为代理创建一个检索工具。</li>
<li>构建一个能够决定何时使用检索工具的代理式 RAG 系统。</li>
</ol>
<figure>
<img src="/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/image-20250819165309335.png" alt="image-20250819165309335">
<figcaption aria-hidden="true">image-20250819165309335</figcaption>
</figure>
<h3 id="预处理文档">1. 预处理文档</h3>
<p>获取用于我们 RAG 系统的文档。我们将使用 Lilian Weng
优秀博客中最新的三页。我们将从使用 <code>WebBaseLoader</code>
工具获取页面内容开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from langchain_community.document_loaders import WebBaseLoader</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    &quot;https://lilianweng.github.io/posts/2024-11-28-reward-hacking/&quot;,</span><br><span class="line">    &quot;https://lilianweng.github.io/posts/2024-07-07-hallucination/&quot;,</span><br><span class="line">    &quot;https://lilianweng.github.io/posts/2024-04-12-diffusion-video/&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">docs = [WebBaseLoader(url).load() for url in urls]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs[0][0].page_content.strip()[:1000]</span><br></pre></td></tr></table></figure>
<p>将获取的文档分割成更小的块，以便索引到我们的向量存储中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from langchain_text_splitters import RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">docs_list = [item for sublist in docs for item in sublist]</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(</span><br><span class="line">    chunk_size=100, chunk_overlap=50</span><br><span class="line">)</span><br><span class="line">doc_splits = text_splitter.split_documents(docs_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc_splits[0].page_content.strip()</span><br></pre></td></tr></table></figure>
<h3 id="创建检索工具">2. 创建检索工具</h3>
<p>现在我们已经有了分割的文档，我们可以将它们索引到一个向量存储中，我们将使用这个向量存储进行语义搜索。</p>
<p>使用内存向量存储和 OpenAI 嵌入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from langchain_chroma import Chroma  # 导入 Chroma</span><br><span class="line">from langchain_openai import OpenAIEmbeddings</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 确保安装了 langchain-chroma</span><br><span class="line"># pip install langchain-chroma</span><br><span class="line"></span><br><span class="line">embedding = OpenAIEmbeddings(</span><br><span class="line">    api_key=&quot;sk-&quot;, </span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;,</span><br><span class="line">    model=&quot;text-embedding-v4&quot;,</span><br><span class="line">    check_embedding_ctx_length=False,</span><br><span class="line">    dimensions=1536,</span><br><span class="line">    chunk_size=5  # 设置较小的批次大小</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 使用 Chroma 替代 InMemoryVectorStore</span><br><span class="line">vectorstore = Chroma.from_documents(</span><br><span class="line">    documents=doc_splits, </span><br><span class="line">    embedding=embedding,</span><br><span class="line">    persist_directory=&quot;./chroma_db&quot;  # 指定持久化目录</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重新加载已存在的 Chroma 数据库</span><br><span class="line">vectorstore = Chroma(</span><br><span class="line">    persist_directory=&quot;./chroma_db&quot;,</span><br><span class="line">    embedding_function=embedding</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">retriever = vectorstore.as_retriever()</span><br></pre></td></tr></table></figure>
<p>使用 LangChain 的预构建 <code>create_retriever_tool</code>
创建检索工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langchain.tools.retriever import create_retriever_tool</span><br><span class="line"></span><br><span class="line">retriever_tool = create_retriever_tool(</span><br><span class="line">    retriever,                    # 【输入】一个已经配置好的检索器（例如：向量数据库的检索器）</span><br><span class="line">    &quot;retrieve_blog_posts&quot;,        # 【工具名称】这个工具的唯一标识名（供模型内部调用）</span><br><span class="line">    &quot;Search and return information about Lilian Weng blog posts.&quot;  # 【工具描述】模型看到的说明，用于决定是否调用它</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retriever_tool.invoke(&#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="生成查询">3. 生成查询</h3>
<p>现在我们将开始构建我们智能体 RAG 图中的组件（节点和边）。</p>
<p>构建一个 <code>generate_query_or_respond</code> 节点。它将调用 LLM
来根据当前图状态（消息列表）生成响应。根据输入消息，它将决定使用检索工具进行检索，或直接响应用户。请注意，我们通过
<code>.bind_tools</code> 向聊天模型提供了先前创建的
<code>retriever_tool</code> 访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langchain_community.chat_models import ChatTongyi</span><br><span class="line">llm = ChatTongyi(</span><br><span class="line">    model=&quot;qwen3-235b-a22b&quot;,</span><br><span class="line">    api_key=&quot;sk-&quot;,</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;,</span><br><span class="line">    model_kwargs=&#123;&quot;enable_thinking&quot;: False&#125;   # 关键在这里</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import MessagesState</span><br><span class="line"></span><br><span class="line">def generate_query_or_respond(state: MessagesState):</span><br><span class="line">    &quot;&quot;&quot;调用模型，根据当前状态生成响应。根据问题，模型将决定是使用检索工具进行检索，还是直接回复用户。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    response = (</span><br><span class="line">        llm</span><br><span class="line">        .bind_tools([retriever_tool]).invoke(state[&quot;messages&quot;])</span><br><span class="line">    )</span><br><span class="line">    return &#123;&quot;messages&quot;: [response]&#125;</span><br></pre></td></tr></table></figure>
<p>提出一个需要语义搜索的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">generate_query_or_respond(input)[&quot;messages&quot;][-1].pretty_print()</span><br></pre></td></tr></table></figure>
<h3 id="评定文件">4.评定文件</h3>
<p>添加一个条件边 — <code>grade_documents</code> —
来判断检索到的文档是否与问题相关。</p>
<p>我们将使用一个具有结构化输出模式 <code>GradeDocuments</code>
的模型来对文档进行评分。 <code>grade_documents</code>
函数将根据评分决策（ <code>generate_answer</code> 或
<code>rewrite_question</code> ）返回要前往的节点的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pydantic import BaseModel, Field</span><br><span class="line">from typing import Literal</span><br><span class="line"></span><br><span class="line"># 定义评分提示模板</span><br><span class="line">GRADE_PROMPT = (</span><br><span class="line">    &quot;你是一个评分员，负责评估检索到的文档与用户问题的相关性。\n &quot;</span><br><span class="line">    &quot;以下是检索到的文档内容：\n\n &#123;context&#125; \n\n&quot;</span><br><span class="line">    &quot;以下是用户的问题：&#123;question&#125; \n&quot;</span><br><span class="line">    &quot;如果文档包含与用户问题相关的关键词或语义含义，则将其评为相关。\n&quot;</span><br><span class="line">    &quot;请给出一个二元评分：&#x27;yes&#x27;（是）表示相关，&#x27;no&#x27;（否）表示不相关。&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 定义用于评估文档相关性的 Pydantic 模型</span><br><span class="line">class GradeDocuments(BaseModel):</span><br><span class="line">    &quot;&quot;&quot;使用二元评分对文档进行相关性评估。&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    binary_score: str = Field(</span><br><span class="line">        description=&quot;相关性评分：&#x27;yes&#x27; 表示相关，&#x27;no&#x27; 表示不相关&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"># 初始化用于评分的聊天模型</span><br><span class="line">grader_model = llm</span><br><span class="line"></span><br><span class="line">def grade_documents(</span><br><span class="line">    state: MessagesState,</span><br><span class="line">) -&gt; Literal[&quot;generate_answer&quot;, &quot;rewrite_question&quot;]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    判断检索到的文档是否与用户问题相关。</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        state: 包含消息历史的状态对象，其中第一条消息是用户问题，</span><br><span class="line">               最后一条消息是检索到的文档内容。</span><br><span class="line">    </span><br><span class="line">    返回:</span><br><span class="line">        如果文档相关，返回 &quot;generate_answer&quot;；</span><br><span class="line">        如果不相关，返回 &quot;rewrite_question&quot;，表示需要重写问题并重新检索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    question = state[&quot;messages&quot;][0].content  # 获取用户问题</span><br><span class="line">    context = state[&quot;messages&quot;][-1].content  # 获取检索到的文档内容</span><br><span class="line"></span><br><span class="line">    # 将问题和文档内容填入提示模板</span><br><span class="line">    prompt = GRADE_PROMPT.format(question=question, context=context)</span><br><span class="line">    </span><br><span class="line">    # 调用模型，并以结构化输出（Pydantic 模型）的形式获取评分结果</span><br><span class="line">    response = (</span><br><span class="line">        grader_model</span><br><span class="line">        .with_structured_output(GradeDocuments)</span><br><span class="line">        .invoke([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;])</span><br><span class="line">    )</span><br><span class="line">    #print(response)</span><br><span class="line">    score = response.binary_score  # 获取二元评分结果</span><br><span class="line"> </span><br><span class="line">    # 根据评分决定下一步操作</span><br><span class="line">    if score == &quot;yes&quot;:</span><br><span class="line">        return &quot;generate_answer&quot;  # 文档相关，生成答案</span><br><span class="line">    else:</span><br><span class="line">        return &quot;rewrite_question&quot;  # 文档不相关，重写问题后重新检索</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from langchain_core.messages import convert_to_messages</span><br><span class="line"></span><br><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: convert_to_messages(#将一系列消息转换为 BaseMessage 类型的消息列表。</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;&quot;,</span><br><span class="line">                &quot;tool_calls&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;retrieve_blog_posts&quot;,</span><br><span class="line">                        &quot;args&quot;: &#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;&quot;role&quot;: &quot;tool&quot;, &quot;content&quot;: &quot;meow&quot;, &quot;tool_call_id&quot;: &quot;1&quot;&#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">grade_documents(input)</span><br></pre></td></tr></table></figure>
<h3 id="重写问题">5. 重写问题</h3>
<p>构建 <code>rewrite_question</code> 节点。</p>
<p>检索工具可能会返回潜在的不相关文档，这表明需要改进原始用户问题。为此，我们将调用
<code>rewrite_question</code> 节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">REWRITE_PROMPT = (</span><br><span class="line">    &quot;Look at the input and try to reason about the underlying semantic intent / meaning.\n&quot;</span><br><span class="line">    &quot;Here is the initial question:&quot;</span><br><span class="line">    &quot;\n ------- \n&quot;</span><br><span class="line">    &quot;&#123;question&#125;&quot;</span><br><span class="line">    &quot;\n ------- \n&quot;</span><br><span class="line">    &quot;Formulate an improved question:&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def rewrite_question(state: MessagesState):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    重写用户最初的提问，以更好地表达其语义意图。</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        state: 包含消息历史的状态对象，其中第一条消息是用户原始问题。</span><br><span class="line">    </span><br><span class="line">    返回:</span><br><span class="line">        一个字典，包含一条新的用户消息，内容为改写后的问题。</span><br><span class="line">        该消息将用于后续的检索步骤，以提高检索结果的相关性。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    messages = state[&quot;messages&quot;]</span><br><span class="line">    question = messages[0].content  # 获取用户最初的提问</span><br><span class="line">    prompt = REWRITE_PROMPT.format(question=question)  # 将问题填入提示模板</span><br><span class="line">    response = llm.invoke([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;])  # 调用模型生成改写后的问题</span><br><span class="line">    </span><br><span class="line">    # 返回新的消息结构，内容为改写后的问题</span><br><span class="line">    return &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: response.content&#125;]&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: convert_to_messages(</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;&quot;,</span><br><span class="line">                &quot;tool_calls&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;retrieve_blog_posts&quot;,</span><br><span class="line">                        &quot;args&quot;: &#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;&quot;role&quot;: &quot;tool&quot;, &quot;content&quot;: &quot;meow&quot;, &quot;tool_call_id&quot;: &quot;1&quot;&#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = rewrite_question(input)</span><br><span class="line">print(response[&quot;messages&quot;][-1][&quot;content&quot;])</span><br></pre></td></tr></table></figure>
<h3 id="生成答案">6. 生成答案</h3>
<p>构建 <code>generate_answer</code>
节点：如果我们通过了评分器的检查，我们可以根据原始问题和检索到的上下文生成最终答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GENERATE_PROMPT = (</span><br><span class="line">    &quot;You are an assistant for question-answering tasks. &quot;</span><br><span class="line">    &quot;Use the following pieces of retrieved context to answer the question. &quot;</span><br><span class="line">    &quot;If you don&#x27;t know the answer, just say that you don&#x27;t know. &quot;</span><br><span class="line">    &quot;Use three sentences maximum and keep the answer concise.\n&quot;</span><br><span class="line">    &quot;Question: &#123;question&#125; \n&quot;</span><br><span class="line">    &quot;Context: &#123;context&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_answer(state: MessagesState):</span><br><span class="line">    &quot;&quot;&quot;Generate an answer.&quot;&quot;&quot;</span><br><span class="line">    question = state[&quot;messages&quot;][0].content</span><br><span class="line">    context = state[&quot;messages&quot;][-1].content</span><br><span class="line">    prompt = GENERATE_PROMPT.format(question=question, context=context)</span><br><span class="line">    response = llm.invoke([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;])</span><br><span class="line">    return &#123;&quot;messages&quot;: [response]&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: convert_to_messages(</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;&quot;,</span><br><span class="line">                &quot;tool_calls&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;retrieve_blog_posts&quot;,</span><br><span class="line">                        &quot;args&quot;: &#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;tool&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;reward hacking can be categorized into two types: environment or goal misspecification, and reward tampering&quot;,</span><br><span class="line">                &quot;tool_call_id&quot;: &quot;1&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = generate_answer(input)</span><br><span class="line">response[&quot;messages&quot;][-1].pretty_print()</span><br></pre></td></tr></table></figure>
<h3 id="组装图表">7. 组装图表</h3>
<p>以 <code>generate_query_or_respond</code> 开头，并确定是否需要调用
<code>retriever_tool</code></p>
<p>使用 <code>tools_condition</code> 跳转到下一步：</p>
<ul>
<li>如果 <code>generate_query_or_respond</code> 返回
<code>tool_calls</code> ，调用 <code>retriever_tool</code>
获取上下文</li>
<li>否则，直接回复用户</li>
</ul>
<p>对检索到的文档内容按与问题的相关性（ <code>grade_documents</code>
）进行评分，并路由到下一步：</p>
<ul>
<li>如果不相关，使用 <code>rewrite_question</code>
重写问题，然后再次调用 <code>generate_query_or_respond</code></li>
<li>如果相关，请继续到 <code>generate_answer</code>
并使用检索到的文档上下文生成最终响应 <code>ToolMessage</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import StateGraph, START, END</span><br><span class="line">from langgraph.prebuilt import ToolNode</span><br><span class="line">from langgraph.prebuilt import tools_condition</span><br><span class="line"></span><br><span class="line"># 创建一个基于状态图（StateGraph）的流程，用于管理对话或任务的执行流程</span><br><span class="line">workflow = StateGraph(MessagesState)</span><br><span class="line"></span><br><span class="line"># 定义流程中将循环执行的各个节点</span><br><span class="line">workflow.add_node(generate_query_or_respond)          # 判断是生成检索查询还是直接回复用户</span><br><span class="line">workflow.add_node(&quot;retrieve&quot;, ToolNode([retriever_tool]))  # 检索节点：使用检索工具（retriever_tool）从知识库中查找相关文档</span><br><span class="line">workflow.add_node(rewrite_question)                  # 重写问题节点：当检索结果不相关时，优化并重写用户的问题</span><br><span class="line">workflow.add_node(generate_answer)                   # 生成答案节点：基于检索到的信息生成最终回答</span><br><span class="line"></span><br><span class="line"># 设置流程的起始点：从 `generate_query_or_respond` 节点开始</span><br><span class="line">workflow.add_edge(START, &quot;generate_query_or_respond&quot;)</span><br><span class="line"></span><br><span class="line"># 添加条件边：决定是否进行文档检索</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    &quot;generate_query_or_respond&quot;,</span><br><span class="line">    # 使用 `tools_condition` 函数判断 LLM 的输出意图：</span><br><span class="line">    # 如果 LLM 决定调用 `retriever_tool` 工具，则进入检索；如果选择直接回复，则结束流程</span><br><span class="line">    tools_condition,</span><br><span class="line">    &#123;</span><br><span class="line">        # 将条件判断结果映射到图中的具体节点</span><br><span class="line">        &quot;tools&quot;: &quot;retrieve&quot;,   # 若需调用工具，则跳转到检索节点</span><br><span class="line">        END: END               # 若无需调用工具（即可以直接回答），则结束流程</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 在 `retrieve` 节点执行后，根据文档相关性判断下一步操作</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    &quot;retrieve&quot;,</span><br><span class="line">    # 调用 `grade_documents` 函数评估检索到的文档是否与问题相关</span><br><span class="line">    grade_documents,</span><br><span class="line">    # 根据评分结果决定流向：</span><br><span class="line">    # - 如果相关，进入 `generate_answer`</span><br><span class="line">    # - 如果不相关，进入 `rewrite_question`</span><br><span class="line">    # （该逻辑在 `grade_documents` 函数中返回 &quot;generate_answer&quot; 或 &quot;rewrite_question&quot;）</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 添加固定边：生成答案后流程结束</span><br><span class="line">workflow.add_edge(&quot;generate_answer&quot;, END)</span><br><span class="line"></span><br><span class="line"># 重写问题后，回到初始节点重新判断是否需要检索</span><br><span class="line">workflow.add_edge(&quot;rewrite_question&quot;, &quot;generate_query_or_respond&quot;)</span><br><span class="line"></span><br><span class="line"># 编译整个工作流，生成可执行的图结构</span><br><span class="line">graph = workflow.compile()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/image-20250826170834571.png" alt="image-20250826170834571">
<figcaption aria-hidden="true">image-20250826170834571</figcaption>
</figure>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/#2-create-a-retriever-tool">《Agentic
RAG》 — Agentic RAG</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Multi-Agent Workflows梳理与实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-18 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-18T00:00:00+08:00">2025-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 15:13:56" itemprop="dateModified" datetime="2025-08-28T15:13:56+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言">前言</h3>
<p>代码见<a target="_blank" rel="noopener" href="https://github.com/zxj-2023/learn-rag-langchain/tree/main/multi-agent">learn-rag-langchain/multi-agent
at main · zxj-2023/learn-rag-langchain</a></p>
<h3 id="什么是多智能体">什么是多智能体</h3>
<p>当我们谈论”多智能体”时，我们指的是由llm驱动的多个独立的agent以<strong>特定方式</strong>连接在一起。</p>
<p>每个agent可以拥有自己的提示、LLM、工具和其他自定义代码，以最佳方式与其他智能体协作。</p>
<p>这种思维方式非常适合用图来表示，就像 <code>langgraph</code>
所提供的那样。在这种方法中，每个智能体都是图中的<strong>一个节点</strong>，而它们之间的<strong>连接则表示为一条边</strong>。<strong>控制流由边管理</strong>，它们通过向图的状态中<strong>添加信息来进行通信</strong>。</p>
<h3 id="多智能体架构梳理">多智能体架构梳理</h3>
<p>langgraph给我们提供了几种<strong>多智能体架构</strong></p>
<figure>
<img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250818163359517.png" alt="image-20250818163359517">
<figcaption aria-hidden="true">image-20250818163359517</figcaption>
</figure>
<p><strong>Network</strong>:
每个智能体可以与其他所有智能体通信。任何智能体都可以决定下一步调用哪个其他智能体。</p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/multi_agent/multi-agent-collaboration/">Multi-agent
network</a></p>
<p><strong>Supervisor</strong>：每个智能体与一个单一的监督者智能体通信。监督者智能体决定下一步应该调用哪个智能体。</p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor/">代理监督者
— Agent Supervisor</a></p>
<p><strong>Hierarchical</strong>:
你可以定义一个具有监督者监督者的多代理系统。这是监督者架构的泛化，并允许更复杂的控制流程。</p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams/">层级代理团队
— Hierarchical Agent Teams</a></p>
<p><strong>Custom multi-agent workflow</strong>:
每个代理只与代理子集通信。流程的部分是确定的，只有一些代理可以决定下一步调用哪些其他代理。</p>
<h3 id="agent-supervisor">Agent Supervisor</h3>
<p>在本教程中，你将构建一个包含两个代理的监督者系统——一个研究专家和一个数学专家。</p>
<h4 id="环境">环境</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U langgraph langgraph-supervisor langchain-tavily &quot;langchain[openai]&quot;</span><br></pre></td></tr></table></figure>
<h4 id="创建工作代理">1. 创建工作代理</h4>
<p>首先，让我们创建我们的专业工作代理——研究代理和数学代理：</p>
<ul>
<li>研究代理将使用 Tavily API 访问网络搜索工具 <a target="_blank" rel="noopener" href="https://www.tavily.com/">Tavily - The Web Access Layer for AI
Agents</a></li>
<li>数学代理将访问简单的数学工具（ <code>add</code> ,
<code>multiply</code> , <code>divide</code> ）</li>
</ul>
<h5 id="研究代理">研究代理</h5>
<p>对于网络搜索，我们将使用 <code>TavilySearch</code> 工具来自
<code>langchain-tavily</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from langchain_tavily import TavilySearch</span><br><span class="line"></span><br><span class="line">web_search = TavilySearch(max_results=3,tavily_api_key=&quot;tvly-dev-&quot;)</span><br><span class="line">web_search_results = web_search.invoke(&quot;南京在哪&quot;)</span><br><span class="line"></span><br><span class="line">print(web_search_results[&quot;results&quot;][0][&quot;content&quot;])</span><br></pre></td></tr></table></figure>
<p>为了创建单个工作代理，我们将使用 LangGraph 的<a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/agents/agents/">预构建代理</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.prebuilt import create_react_agent</span><br><span class="line">from langchain_openai import ChatOpenAI</span><br><span class="line"></span><br><span class="line">llm=ChatOpenAI(</span><br><span class="line">    model=&quot;qwen3-235b-a22b-thinking-2507&quot;,</span><br><span class="line">    api_key=&quot;sk-&quot;,</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">research_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[web_search],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个研究代理。\n\n指令：\n- 仅协助与研究相关的任务，不得进行任何数学计算\n- 完成任务后，直接向主管回复\n- 仅回复你的工作结果，不得包含任何其他文字。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;research_agent&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>让我们运行代理来验证它的行为是否符合预期。<strong>我们将使用</strong>
<code>pretty_print_messages</code>
<strong>辅助工具来美观地渲染流式代理输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">from langchain_core.messages import convert_to_messages</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pretty_print_message(message, indent=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    美化打印单条消息</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        message: 要打印的消息对象</span><br><span class="line">        indent: 是否需要缩进打印</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 将消息转换为美观的HTML格式表示</span><br><span class="line">    pretty_message = message.pretty_repr(html=True)</span><br><span class="line">    if not indent:</span><br><span class="line">        # 如果不需要缩进，直接打印</span><br><span class="line">        print(pretty_message)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 如果需要缩进，为每一行添加制表符前缀</span><br><span class="line">    indented = &quot;\n&quot;.join(&quot;\t&quot; + c for c in pretty_message.split(&quot;\n&quot;))</span><br><span class="line">    print(indented)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pretty_print_messages(update, last_message=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    美化打印消息更新</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        update: 包含消息更新的数据结构</span><br><span class="line">        last_message: 是否只打印最后一条消息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    is_subgraph = False  # 标记是否为子图更新</span><br><span class="line">    </span><br><span class="line">    # 检查更新是否为元组格式（包含命名空间信息）</span><br><span class="line">    if isinstance(update, tuple):</span><br><span class="line">        ns, update = update</span><br><span class="line">        # 如果命名空间为空，跳过父图更新的打印</span><br><span class="line">        if len(ns) == 0:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 提取图ID并打印子图更新信息</span><br><span class="line">        graph_id = ns[-1].split(&quot;:&quot;)[0]</span><br><span class="line">        print(f&quot;来自子图 &#123;graph_id&#125; 的更新:&quot;)</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line">        is_subgraph = True</span><br><span class="line"></span><br><span class="line">    # 遍历每个节点的更新</span><br><span class="line">    for node_name, node_update in update.items():</span><br><span class="line">        # 构造更新标签</span><br><span class="line">        update_label = f&quot;来自节点 &#123;node_name&#125; 的更新:&quot;</span><br><span class="line">        if is_subgraph:</span><br><span class="line">            # 如果是子图，添加缩进</span><br><span class="line">            update_label = &quot;\t&quot; + update_label</span><br><span class="line"></span><br><span class="line">        print(update_label)</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">        # 将节点更新中的消息转换为消息对象列表</span><br><span class="line">        messages = convert_to_messages(node_update[&quot;messages&quot;])</span><br><span class="line">        # 如果只要求最后一条消息，则截取最后一条</span><br><span class="line">        if last_message:</span><br><span class="line">            messages = messages[-1:]</span><br><span class="line"></span><br><span class="line">        # 打印每条消息</span><br><span class="line">        for m in messages:</span><br><span class="line">            pretty_print_message(m, indent=is_subgraph)</span><br><span class="line">        print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for chunk in research_agent.stream(</span><br><span class="line">    &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;南京在哪?&quot;&#125;]&#125;</span><br><span class="line">):</span><br><span class="line">    pretty_print_messages(chunk)</span><br></pre></td></tr></table></figure>
<h5 id="数学代理">数学代理</h5>
<p>对于数学代理工具，我们将使用纯 Python 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def add(a: float, b: float):</span><br><span class="line">    &quot;&quot;&quot;将两个数字相加。&quot;&quot;&quot;</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def multiply(a: float, b: float):</span><br><span class="line">    &quot;&quot;&quot;将两个数字相乘。&quot;&quot;&quot;</span><br><span class="line">    return a * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def divide(a: float, b: float):</span><br><span class="line">    &quot;&quot;&quot;将两个数字相除。&quot;&quot;&quot;</span><br><span class="line">    return a / b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">math_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[add, multiply, divide],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个数学代理。\n\n&quot;</span><br><span class="line">        &quot;指令：\n&quot;</span><br><span class="line">        &quot;- 仅协助处理数学相关任务\n&quot;</span><br><span class="line">        &quot;- 完成任务后，直接回复给主管\n&quot;</span><br><span class="line">        &quot;- 仅回复你的工作结果，不要包含任何其他文字。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;math_agent&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>让我们运行数学代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for chunk in math_agent.stream(</span><br><span class="line">    &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;what&#x27;s (3 + 5) x 7&quot;&#125;]&#125;</span><br><span class="line">):</span><br><span class="line">    pretty_print_messages(chunk)</span><br></pre></td></tr></table></figure>
<h4 id="创建监督者-langgraph-supervisor">2.创建监督者
<code>langgraph-supervisor</code></h4>
<p>为了实现我们的多智能体系统，我们将使用预构建的
<code>langgraph-supervisor</code> 库中的 <a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/reference/supervisor/#langgraph_supervisor.supervisor.create_supervisor"><code>create_supervisor</code></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from langgraph_supervisor import create_supervisor</span><br><span class="line">from langchain.chat_models import init_chat_model</span><br><span class="line"></span><br><span class="line">supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[research_agent, math_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个管理两个代理的主管：\n&quot;</span><br><span class="line">        &quot;- 一个研究代理。将研究相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;- 一个数学代理。将数学相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;一次只分配工作给一个代理，不要并行调用代理。\n&quot;</span><br><span class="line">        &quot;不要自己做任何工作。&quot;</span><br><span class="line">    ),</span><br><span class="line">    add_handoff_back_messages=True,</span><br><span class="line">    output_mode=&quot;full_history&quot;,</span><br><span class="line">).compile()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import display, Image</span><br><span class="line"></span><br><span class="line">display(Image(supervisor.get_graph().draw_mermaid_png()))</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250819113009108.png" alt="image-20250819113009108">
<figcaption aria-hidden="true">image-20250819113009108</figcaption>
</figure>
<p>现在让我们用一个需要两个代理的查询来运行它：</p>
<p>研究代理将查找必要的 GDP 信息；数学代理将执行除法以找到纽约州 GDP
的百分比，如所请求</p>
<h4 id="从头创建监督者">3.从头创建监督者</h4>
<p>现在让我们从头实现这个多智能体系统。我们需要：</p>
<ol type="1">
<li>设置主管如何与各个代理进行沟通</li>
<li>创建监督代理</li>
<li>将监督代理和工作代理组合成一个多代理图。</li>
</ol>
<h5 id="设置代理通信">设置代理通信</h5>
<p>我们需要定义一种方式，让监督代理能够与工作代理进行通信。在多代理架构中，实现这一功能的一种常见方法是使用<strong>handoffs</strong>，即一个代理将控制权交给另一个代理。交接允许你指定：</p>
<ul>
<li><strong>destination</strong>:要转移到的目标代理</li>
<li><strong>payload</strong>:要传递给该智能体的信息</li>
</ul>
<p>我们将通过<strong>handoff
tools</strong>（转接工具）实现转接，并将这些工具交给监督代理：当监督代理调用这些工具时，它将控制权转交给工作代理，并将完整消息历史传递给该代理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from typing import Annotated</span><br><span class="line">from langchain_core.tools import tool, InjectedToolCallId</span><br><span class="line">from langgraph.prebuilt import InjectedState</span><br><span class="line">from langgraph.graph import StateGraph, START, MessagesState</span><br><span class="line">from langgraph.types import Command</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_handoff_tool(*, agent_name: str, description: str | None = None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建一个“交接”工具函数，用于在 LangGraph 的 Supervisor-Worker 架构中</span><br><span class="line">    把当前对话状态移交给指定名称的子 Agent。</span><br><span class="line"></span><br><span class="line">    参数</span><br><span class="line">    ----</span><br><span class="line">    agent_name : str</span><br><span class="line">        目标子 Agent 的名称，必须与 Supervisor 图中注册的节点名一致。</span><br><span class="line">    description : str | None</span><br><span class="line">        工具的描述文本。如果为 None，则使用默认描述 &quot;Ask &#123;agent_name&#125; for help.&quot;。</span><br><span class="line"></span><br><span class="line">    返回</span><br><span class="line">    ----</span><br><span class="line">    handoff_tool : Callable</span><br><span class="line">        一个已用 @tool 装饰的函数，可直接注入到 Supervisor 的工具列表。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 动态生成工具名，例如 agent_name=&quot;math_agent&quot; -&gt; &quot;transfer_to_math_agent&quot;</span><br><span class="line">    name = f&quot;transfer_to_&#123;agent_name&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # 如果调用者没有提供描述，则使用默认描述</span><br><span class="line">    description = description or f&quot;Ask &#123;agent_name&#125; for help.&quot;</span><br><span class="line"></span><br><span class="line">    # 用 LangGraph 的 @tool 装饰器注册工具</span><br><span class="line">    @tool(name, description=description)</span><br><span class="line">    def handoff_tool(</span><br><span class="line">        state: Annotated[MessagesState, InjectedState],</span><br><span class="line">        tool_call_id: Annotated[str, InjectedToolCallId],</span><br><span class="line">    ) -&gt; Command:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        实际执行交接逻辑的工具函数。</span><br><span class="line"></span><br><span class="line">        参数</span><br><span class="line">        ----</span><br><span class="line">        state : MessagesState</span><br><span class="line">            当前对话状态，由 LangGraph 注入。</span><br><span class="line">        tool_call_id : str</span><br><span class="line">            本次工具调用的唯一 ID，由 LangGraph 注入。</span><br><span class="line"></span><br><span class="line">        返回</span><br><span class="line">        ----</span><br><span class="line">        Command</span><br><span class="line">            一个 LangGraph Command 对象，告诉框架：</span><br><span class="line">            - goto=agent_name        : 跳转到哪个子 Agent</span><br><span class="line">            - update                 : 更新后的状态</span><br><span class="line">            - graph=Command.PARENT   : 在父图（Supervisor）作用域内执行</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 构造一条工具消息，记录交接动作</span><br><span class="line">        tool_message = &#123;</span><br><span class="line">            &quot;role&quot;: &quot;tool&quot;,</span><br><span class="line">            &quot;content&quot;: f&quot;Successfully transferred to &#123;agent_name&#125;&quot;,</span><br><span class="line">            &quot;name&quot;: name,</span><br><span class="line">            &quot;tool_call_id&quot;: tool_call_id,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 使用 Command 把对话状态连同新消息一起发送到目标 Agent</span><br><span class="line">        return Command(</span><br><span class="line">            goto=agent_name,</span><br><span class="line">            update=&#123;**state, &quot;messages&quot;: state[&quot;messages&quot;] + [tool_message]&#125;,</span><br><span class="line">            graph=Command.PARENT,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # 返回已装饰的工具函数，供 Supervisor 添加进 tools 列表</span><br><span class="line">    return handoff_tool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建研究代理的交接工具</span><br><span class="line">assign_to_research_agent = create_handoff_tool(</span><br><span class="line">    agent_name=&quot;research_agent&quot;,</span><br><span class="line">    description=&quot;Assign task to a researcher agent.&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建数学代理的交接工具</span><br><span class="line">assign_to_math_agent = create_handoff_tool(</span><br><span class="line">    agent_name=&quot;math_agent&quot;,</span><br><span class="line">    description=&quot;Assign task to a math agent.&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="创建监督代理">创建监督代理</h5>
<p>然后，我们使用刚刚定义的交接工具来创建监督代理。我们将使用预构建的
<code>create_react_agent</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">supervisor_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[assign_to_research_agent, assign_to_math_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个管理两个代理的主管：\n&quot;</span><br><span class="line">        &quot;- 一个研究代理。将研究相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;- 一个数学代理。将数学相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;一次只分配工作给一个代理，不要并行调用代理。\n&quot;</span><br><span class="line">        &quot;不要自己做任何工作。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;supervisor&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="创建多智能体图">创建多智能体图</h5>
<p>将这些内容整合起来，让我们为我们的整体多代理系统创建一个图。我们将添加监督代理和各个代理作为子图节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import END</span><br><span class="line"></span><br><span class="line"># 定义多代理主管图</span><br><span class="line">supervisor = (</span><br><span class="line">    StateGraph(MessagesState)</span><br><span class="line">    # 注意：`destinations` 仅用于可视化，不影响运行时行为</span><br><span class="line">    .add_node(supervisor_agent, destinations=(&quot;research_agent&quot;, &quot;math_agent&quot;, END))</span><br><span class="line">    .add_node(research_agent)</span><br><span class="line">    .add_node(math_agent)</span><br><span class="line">    .add_edge(START, &quot;supervisor&quot;)</span><br><span class="line">    # 总是返回到主管</span><br><span class="line">    .add_edge(&quot;research_agent&quot;, &quot;supervisor&quot;)</span><br><span class="line">    .add_edge(&quot;math_agent&quot;, &quot;supervisor&quot;)</span><br><span class="line">    .compile()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个代码中，去 <code>research_agent</code> 和
<code>math_agent</code>
的条件边是通过<strong>工具调用</strong>实现的，而不是显式的条件边。</p>
<p>工作机制：</p>
<ol type="1">
<li><p><strong>工具作为交接手段</strong>：</p>
<ul>
<li><code>assign_to_research_agent</code> 和
<code>assign_to_math_agent</code> 这两个工具被添加到
<code>supervisor_agent</code> 中</li>
<li>当 supervisor_agent 决定需要某个代理帮助时，它会调用相应的工具</li>
</ul></li>
<li><p><strong>工具内部实现交接</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def handoff_tool(...) -&gt; Command:</span><br><span class="line">    return Command(</span><br><span class="line">        goto=agent_name,  # 这里指定了要跳转到哪个代理</span><br><span class="line">        update=&#123;...&#125;,</span><br><span class="line">        graph=Command.PARENT,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li><p><strong>隐式的条件边</strong>：</p>
<ul>
<li>当 supervisor_agent 调用 <code>assign_to_research_agent</code>
工具时 → 自动跳转到 <code>research_agent</code></li>
<li>当 supervisor_agent 调用 <code>assign_to_math_agent</code> 工具时 →
自动跳转到 <code>math_agent</code></li>
</ul></li>
</ol>
</blockquote>
<blockquote>
<p>什么是 Command 机制</p>
<p>Command 机制是 LangGraph
提供的一种<strong>显式控制流程跳转</strong>的方式。它允许工具或节点直接指定下一步要执行什么操作，而不需要通过传统的条件边路由。</p>
<p>Command 的核心概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.types import Command</span><br><span class="line"></span><br><span class="line">Command(</span><br><span class="line">    goto=agent_name,           # 要跳转到的目标节点</span><br><span class="line">    update=state_update,       # 要更新的状态</span><br><span class="line">    graph=Command.PARENT      # 在哪个图中执行（父图/子图）</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>请注意，我们已经从工作代理添加了明确的边回到主管——这意味着它们保证会将控制权返回给主管。如果你希望代理直接响应用户（即，将系统转变为路由器），你可以移除这些边。</p>
<h3 id="multi-agent-network">Multi-agent network</h3>
<p>一个单一智能体通常可以使用单个领域内的一小批工具来有效运作，但即使使用像
<code>gpt-4</code> 这样强大的模型，使用多个工具时也可能效果不佳。</p>
<p>处理复杂任务的一种方法是采用“分而治之”的方法：为每个任务或领域创建一个专门的智能体，并将任务路由到正确的“专家”。这是一个多智能体网络架构的例子。</p>
<figure>
<img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250819150039818.png" alt="image-20250819150039818">
<figcaption aria-hidden="true">image-20250819150039818</figcaption>
</figure>
<p><strong>这个多agent架构，就像多个agent进行讨论，所以也叫Multi Agent
Collaboration，但是给我的感觉，比较混乱，agent直接的路由很难去定义，agent一多就搞不清楚了</strong>，所以这里也不实战了。</p>
<h3 id="hierarchical-agent-teams">Hierarchical Agent Teams</h3>
<p>对于某些应用，如果工作按层次分布，系统可能会更有效。你可以通过组合不同的子图，并创建一个顶层监督者以及中层监督者来实现这一点。</p>
<figure>
<img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250819151813264.png" alt="image-20250819151813264">
<figcaption aria-hidden="true">image-20250819151813264</figcaption>
</figure>
<p>使用预设的supervisor构建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># 1. 定义研究团队的代理</span><br><span class="line">@tool</span><br><span class="line">def web_search(query: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;执行网络搜索&quot;&quot;&quot;</span><br><span class="line">    return f&quot;搜索结果：关于&#x27;&#123;query&#125;&#x27;的最新信息...&quot;</span><br><span class="line"></span><br><span class="line">@tool</span><br><span class="line">def analyze_data(data: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;分析数据&quot;&quot;&quot;</span><br><span class="line">    return f&quot;数据分析结果：&#123;data&#125;的趋势显示...&quot;</span><br><span class="line"></span><br><span class="line">research_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[web_search, analyze_data],</span><br><span class="line">    prompt=&quot;你是一个研究专家，负责进行网络搜索和数据分析。&quot;,</span><br><span class="line">    name=&quot;research_specialist&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 2. 定义数学团队的代理</span><br><span class="line">@tool</span><br><span class="line">def calculate_statistics(numbers: list[float]) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;计算统计值&quot;&quot;&quot;</span><br><span class="line">    if not numbers:</span><br><span class="line">        return &quot;错误：数据列表为空&quot;</span><br><span class="line">    avg = sum(numbers) / len(numbers)</span><br><span class="line">    return f&quot;统计结果：平均值=&#123;avg:.2f&#125;，数据点数量=&#123;len(numbers)&#125;&quot;</span><br><span class="line"></span><br><span class="line">@tool</span><br><span class="line">def solve_equation(equation: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;解方程&quot;&quot;&quot;</span><br><span class="line">    return f&quot;方程 &#123;equation&#125; 的解为：x = 42&quot;</span><br><span class="line"></span><br><span class="line">math_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[calculate_statistics, solve_equation],</span><br><span class="line">    prompt=&quot;你是一个数学专家，负责统计计算和方程求解。&quot;,</span><br><span class="line">    name=&quot;math_specialist&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 3. 创建研究团队主管</span><br><span class="line">research_supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[research_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是研究团队的主管。\n&quot;</span><br><span class="line">        &quot;你的团队有一个研究专家，负责网络搜索和数据分析。\n&quot;</span><br><span class="line">        &quot;根据任务需求，将工作分配给研究专家。\n&quot;</span><br><span class="line">        &quot;等待专家完成任务后，总结结果并报告给上级主管。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;research_supervisor&quot;</span><br><span class="line">).compile(name=&quot;research_supervisor&quot;)</span><br><span class="line"></span><br><span class="line"># 4. 创建数学团队主管</span><br><span class="line">math_supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[math_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是数学团队的主管。\n&quot;</span><br><span class="line">        &quot;你的团队有一个数学专家，负责统计计算和方程求解。\n&quot;</span><br><span class="line">        &quot;根据任务需求，将工作分配给数学专家。\n&quot;</span><br><span class="line">        &quot;等待专家完成任务后，总结结果并报告给上级主管。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;math_supervisor&quot;</span><br><span class="line">).compile(name=&quot;math_supervisor&quot;)</span><br><span class="line"></span><br><span class="line"># 5. 创建顶层主管</span><br><span class="line">top_supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[research_supervisor, math_supervisor],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是顶层主管，管理两个专业团队：\n&quot;</span><br><span class="line">        &quot;- 研究团队：负责市场调研、数据分析等任务\n&quot;</span><br><span class="line">        &quot;- 数学团队：负责统计计算、方程求解等任务\n&quot;</span><br><span class="line">        &quot;根据任务的性质，将工作分配给相应的团队主管。\n&quot;</span><br><span class="line">        &quot;等待团队完成任务后，整合所有结果并给出最终报告。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;top_supervisor&quot;</span><br><span class="line">).compile(name=&quot;top_supervisor&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://blog.langchain.com/langgraph-multi-agent-workflows/">LangGraph：多智能体工作流
— LangGraph: Multi-Agent Workflows</a></p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/concepts/multi_agent/">Overview</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/15/%E5%AD%A6%E4%B9%A0/python-web/react/react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/15/%E5%AD%A6%E4%B9%A0/python-web/react/react/" class="post-title-link" itemprop="url">python web——react</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-15T00:00:00+08:00">2025-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-18 15:44:24" itemprop="dateModified" datetime="2025-08-18T15:44:24+08:00">2025-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/" itemprop="url" rel="index"><span itemprop="name">python-web</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/react/" itemprop="url" rel="index"><span itemprop="name">react</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言">前言</h3>
<p>为了后续自己搭建全栈项目做准备，对react做一定的了解</p>
<p>学习目标：大致看懂react的基本语法，可以在ai的协助下完成前端的搭建</p>
<h3 id="介绍">介绍</h3>
<p>React 是 Facebook（现 Meta）于 2013 年开源的一套用于构建用户界面的
JavaScript 库，现由 React 核心团队与社区共同维护。</p>
<h3 id="项目搭建">项目搭建</h3>
<p>项目创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure>
<blockquote>
<p>npx 是什么？</p>
<p>npm 5.2+ 自带的“包运行器”（Node Package eXecute）。类似uv</p>
<p>脚手架（Scaffold / Boilerplate）是什么？</p>
<ol type="1">
<li>定义：官方或社区提供的“项目模板生成器”，一条命令就能创建带目录结构、配置、脚本、依赖的完整项目骨架。</li>
<li>目的： • 省掉繁琐的初始化、Webpack/Rollup/Vite
配置、ESLint/TypeScript/测试等环境搭建。 •
统一团队规范，降低新人上手成本。</li>
</ol>
</blockquote>
<p>启动开发服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start        <span class="comment"># 或 yarn start</span></span><br></pre></td></tr></table></figure>
<p>目录速览（核心）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">├─ public/         # 静态资源，index.html 是页面模板</span><br><span class="line">├─ src/</span><br><span class="line">│  ├─ App.js       # 根组件</span><br><span class="line">│  ├─ index.js     # 应用入口（ReactDOM.createRoot）</span><br><span class="line">└─ package.json    # 依赖与脚本</span><br></pre></td></tr></table></figure>
<h3 id="jsx">JSX</h3>
<p>JSX（JavaScript XML 的缩写）是 React
引入的一种<strong>语法糖</strong>（syntactic sugar）。它让你在
JavaScript 文件里直接写<strong>类 HTML
标记</strong>，然后由构建工具（Babel、TypeScript、esbuild、swc）把它翻译成<strong>普通的
JavaScript 函数调用</strong>。</p>
<p>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 找到 public/index.html 中 id=&quot;root&quot; 的 DOM 节点，作为 React 应用的挂载点</span><br><span class="line">const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));</span><br><span class="line"></span><br><span class="line">// 2. 将根组件 &lt;App /&gt; 渲染到该挂载点</span><br><span class="line">root.render(</span><br><span class="line">  // 3. &lt;React.StrictMode&gt; 是 React 提供的开发模式辅助工具</span><br><span class="line">  //    作用：在开发阶段自动检测潜在问题（如过时的 API、副作用重复执行等）</span><br><span class="line">  //    注意：它仅在开发环境生效，生产环境不会渲染任何额外 DOM</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">    &#123;/* 4. 项目真正的根组件 App，所有业务逻辑都从这里开始 */&#125;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/React.StrictMode&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数">箭头函数</h3>
<p>React（以及所有现代 JavaScript）里，“箭头”指的是
<strong>箭头函数（Arrow Function）</strong>，语法是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 函数名 = <span class="function">(<span class="params">参数</span>) =&gt;</span> 返回值或语句块</span><br></pre></td></tr></table></figure>
<p>它的作用可以概括为 <strong>“更简洁的函数声明 + 词法作用域的
this”</strong>。</p>
<p>通俗理解：把小括号的内容变成箭头后的内容</p>
<h3 id="函数组件">函数组件</h3>
<p>函数组件 + JSX 的组合作用是： <strong>以函数的形式返回“虚拟 DOM
描述”，交由 React 渲染成真实 DOM</strong>，而不是直接返回 HTML
组件或字符串。</p>
<ol type="1">
<li>函数组件的“返回值”</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过 Babel 编译后等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello &#x27;</span>, props.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.createElement</code> 会生成一个<strong>纯 JS
对象</strong>（虚拟节点），而不是一段 HTML 字符串。</p>
<p><strong>使用示例</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 接收父组件传来的 props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Card</span>(<span class="params">&#123; title, children &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 2. 返回一段 JSX（最终会被编译成虚拟 DOM）</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Card</span> title=<span class="string">&quot;函数组件&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Card</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DOM（Document Object Model，文档对象模型）是浏览器在内存里把一份
HTML/XML
文档表示成<strong>树形结构</strong>的<strong>编程接口</strong>（API）。</p>
<p>每个节点（元素、文本、注释…）都是一个对象，拥有属性与方法，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">title.<span class="property">textContent</span> = <span class="string">&#x27;Hi React&#x27;</span>;   <span class="comment">// 改文本</span></span><br><span class="line">title.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;        <span class="comment">// 改样式</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="插值写法">插值写法</h3>
<p>在 React 中，“插值”专指<strong>把一段 JavaScript 表达式的实时结果塞进
JSX</strong> 的写法。 核心符号只有一对花括号
<code>&#123; &#125;</code>，记住口诀：<strong>“JSX 里凡是 {} 包起来的，就是
JavaScript 运行后的值。”</strong></p>
<p><strong>基本文本插值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &#x27;React&#x27;;</span><br><span class="line">&lt;h1&gt;Hello, &#123;name&#125;!&lt;/h1&gt;          // → Hello, React!</span><br></pre></td></tr></table></figure>
<p><strong>属性插值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const mytitle=&quot;hello&quot;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div title=&#123;mytitle&#125;&gt;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据渲染">数据渲染</h3>
<p><strong>条件渲染</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const mytitle=&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">  let mycontent=null</span><br><span class="line">  const flag=true</span><br><span class="line">  if(flag)&#123;</span><br><span class="line">    mycontent=&lt;h2&gt;hello&lt;/h2&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    mycontent=&lt;h2&gt;world&lt;/h2&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div title=&#123;mytitle&#125;&gt;&#123;mycontent&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>列表渲染</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const list=[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br><span class="line">  const mycontent=list.map((item)=&gt;&#123;</span><br><span class="line">    return &lt;li&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">  &#125;)</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;&#123;mycontent&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li><code>.map((item) =&gt; &#123; ... &#125;)</code> ‑
<code>Array.prototype.map</code>：遍历数组，把每个元素依次交给回调函数处理，并<strong>返回一个新数组</strong>。
‑ <code>(item)</code> 是每次循环拿到的当前元素。</li>
<li><code>return &lt;li&gt;&#123;item&#125;&lt;/li&gt;</code> ‑
每一次循环里，把当前元素 <code>item</code> 用 JSX 插值语法
<code>&#123;item&#125;</code> 放进 <code>&lt;li&gt;</code> 标签里。</li>
</ol>
</blockquote>
<h3 id="状态处理">状态处理</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const [mycontent,setmycontent]=useState(&quot;hello world&quot;);</span><br><span class="line">  function changeContent()&#123;</span><br><span class="line">    setmycontent(&quot;hello world2&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;mycontent&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;changeContent&#125;&gt;change&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useState 是 React 提供的
<strong>Hook</strong>，让<strong>函数组件也能拥有内部状态</strong>（state）。可以通过更新函数，调用后触发重新渲染。</p>
<p><strong>对象的状态更新</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const [mycontent,setmycontent]=useState(&#123;</span><br><span class="line">    title:&#x27;hello world&#x27;,</span><br><span class="line">    content :&#x27;hello world content&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">  function changeContent()&#123;</span><br><span class="line">    setmycontent(&#123;</span><br><span class="line">      ...mycontent,</span><br><span class="line">      content:&#x27;new content&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div title=&#123;mycontent.title&#125;&gt;&#123;mycontent.content&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;changeContent&#125;&gt;change&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>...mycontent</code> 是 ES6 的 <strong>对象展开运算符（object
spread）</strong>。 一句话：把 <code>mycontent</code>
里所有“旧属性”先抄出来，然后再覆盖/新增你后面写的属性。</p>
<h3 id="react组件的使用">react组件的使用</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">function App() &#123;</span><br><span class="line">return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; style=&#123;&#123; width: &#x27;100px&#x27;,backgroundColor: &#x27;grey&#x27;&#125;&#125;/&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p><code>className</code> 代替 <code>class</code> 传统 HTML 写
<code>&lt;img class="App-logo"&gt;</code>；React 组件里必须用
<code>className</code>，因为 JSX 最终会被编译成 JavaScript 对象，而
<code>class</code> 是 JS 的保留关键字。</p></li>
<li><p>样式写成<strong>对象</strong></p></li>
</ol>
<p>HTML
写行内样式：<code>style="width:100px;background-color:grey"</code> React
必须写成对象：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;&#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="string">&#x27;100px&#x27;</span>,</span><br><span class="line">  <span class="attr">backgroundColor</span>: <span class="string">&#x27;grey&#x27;</span>   <span class="comment">// 驼峰命名</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>因为 JSX 属性最终会变成 JS
对象的键值对，键名必须合法（驼峰），值可以是任何 JS
值（数字、变量、计算结果）。</p>
<ol start="3" type="1">
<li>最终产物是<strong>虚拟 DOM 节点</strong></li>
</ol>
<p><code>&lt;img src=&#123;logo&#125; ... /&gt;</code> 在浏览器里不会直接变成
<code>&lt;img&gt;</code> 标签，而是先被编译成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">src</span>: logo,</span><br><span class="line">  <span class="attr">className</span>: <span class="string">&#x27;App-logo&#x27;</span>,</span><br><span class="line">  <span class="attr">alt</span>: <span class="string">&#x27;logo&#x27;</span>,</span><br><span class="line">  <span class="attr">style</span>: &#123; <span class="attr">width</span>: <span class="string">&#x27;100px&#x27;</span>, <span class="attr">backgroundColor</span>: <span class="string">&#x27;grey&#x27;</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>React 再拿这个对象去做 diff、更新真实 DOM，而不是直接 innerHTML。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">  const imgdata=&#123;</span><br><span class="line">    className:&quot;App-logo&quot;,</span><br><span class="line">    style:&#123;</span><br><span class="line">      width:&#x27;100px&#x27;,</span><br><span class="line">      backgroundColor:&#x27;grey&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;img src=&#123;logo&#125; alt=&quot;logo&quot; &#123;...imgdata&#125;/&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 <strong>JSX 展开运算符（spread attributes）</strong> 把
<code>imgdata</code> 里的所有键值一次性“拍平”到 <code>&lt;img&gt;</code>
标签上</p>
<h3 id="组件复用">组件复用</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Article(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;&#123;props.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Article title=&quot;标签1&quot; content=&quot;内容1&quot; /&gt;</span><br><span class="line">      &lt;Article title=&quot;标签2&quot; content=&quot;内容2&quot; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件通信">组件通信</h3>
<p>组件通信的 4 条主线</p>
<p>1️⃣ 父 → 子：props 2️⃣ 子 → 父：回调函数 3️⃣ 隔代/任意：Context 4️⃣
全局/远端：状态管理库（Zustand、Redux、React Query）</p>
<h4 id="父-子">父 → 子</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">  const title = &#x27;Hello React&#x27;;</span><br><span class="line">  return &lt;Child title=&#123;title&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(&#123; title &#125;) &#123;</span><br><span class="line">  return &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子-父">子 → 父</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;父：&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Child onInc=&#123;() =&gt; setCount(c =&gt; c + 1)&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(&#123; onInc &#125;) &#123;</span><br><span class="line">  return &lt;button onClick=&#123;onInc&#125;&gt;子按钮 +1&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>父组件把“修改函数”通过 props
传给子组件，子组件在合适的时机调用它，把数据作为参数传回去。</strong></p>
<h3 id="react-hooks">react hooks</h3>
<p><strong>Hook 是什么？</strong> Hook 是 React 16.8 引入的
<strong>函数级 API</strong>，让函数组件拥有</p>
<ul>
<li>状态（useState）</li>
<li>生命周期（useEffect）</li>
<li>上下文（useContext）</li>
<li>自定义逻辑（自定义 Hook） 而不必写 class。</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kc411D7F9?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">20分钟学会React
Hooks 前端开发必看 AI编程工具 CodeGeeX 体验_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E5%AD%A6%E4%B9%A0/ai%E7%9B%B8%E5%85%B3/A2A%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E5%AD%A6%E4%B9%A0/ai%E7%9B%B8%E5%85%B3/A2A%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">A2A协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-14T00:00:00+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 15:09:28" itemprop="dateModified" datetime="2025-08-28T15:09:28+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ai%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">ai相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ai%E7%9B%B8%E5%85%B3/A2A%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">A2A协议</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言">前言</h3>
<p>就是client调用agent那一块，感觉还是比较困惑，我看例子是要通过定义给的execut和cancel函数，那就意味着agent提供者都要去自己去定义这些怎么执行的函数，还有描述agent的skill和card，工作量明显比mcp大了很多，可能这也是现在a2a传播没有mcp好的一大原因吧，我的理解，不知道对不对</p>
<hr>
<p>思考：现在利用a2a搭建多agent的现实例子多吗，从概念上，我认为a2a的思路是没问题的，但感觉下来，现在大多数的多agent的实现方式还是像langgraph中<strong>条件边</strong>来控制使用哪个agent，是不是因为a2a对于中小开发者搭建起来还是有些复杂，但我还是认为他这种于mcp类似，模块化，可以自定义的形式会是后续方向。就像现在的mcp
client，可以在市场上下载自己想要的mcp，利用a2a协议，用户可以在市场上下载想用的agent，搭建自己的多agent管家，现在市场上有类似的产品吗？</p>
<p>a2a协议其实与mcp类似，对象不同，一个是mcp client与mcp
server（tool），一个是agent client与agent
server。具体实现中，需要完成对agent
server的信息暴露与executor的编写，以便让client正确调用agent，调用前要启动服务。</p>
<p>一个agent
server所要包含的要素包括：1.AgentSkill，用于描述agent可以实现的能力</p>
<p>2.AgentCard，描述agent的信息，包括运行的url，输入和返回的数据类型，所包含的skills</p>
<p>3.AgentExecutor，定义了如何执行智能体，通过定义execute方法，以便正确调用agent
server</p>
<p>4.通过DefaultRequestHandler，封装调用agent的接口，不用再手写接口，只要提供一个
executor 和一个 store
即可，收到对话内容后，<code>DefaultRequestHandler</code>
会把对话打包成任务，交给 <code>HelloWorldAgentExecutor</code>
去执行。、</p>
<p>5.通过A2AStarletteApplication打包成应用（如fastapi），他的作用如下：1.把这个
handler 注册成真正的 HTTP 路由，于是外部就能通过 <code>POST /</code>
调用上述 JSON-RPC 方法。2.对外暴露名片</p>
<h3 id="什么是a2a协议">什么是A2A协议</h3>
<p>A2A 协议（Agent2Agent Protocol，智能体间通信协议）是 Google 在 2025
年 4 月发布并开源的首个 AI
智能体交互标准。它通过统一的通信规范，解决不同团队、不同框架、不同供应商开发的
AI 智能体如何“对话”和协同工作的问题。</p>
<blockquote>
<p>与mcp区分，<strong>MCP</strong> 解决
<strong>“单个智能体如何调用外部工具/数据”</strong>
的问题，而<strong>A2A</strong> 解决
<strong>“多个智能体如何协同完成任务”</strong> 的问题。</p>
</blockquote>
<figure>
<img src="/2025/08/14/%E5%AD%A6%E4%B9%A0/ai%E7%9B%B8%E5%85%B3/A2A%E5%8D%8F%E8%AE%AE/image-20250809222720192.png" alt="image-20250809222720192">
<figcaption aria-hidden="true">image-20250809222720192</figcaption>
</figure>
<h3 id="为什么要使用a2a协议">为什么要使用A2A协议</h3>
<p>随着 AI 应用深化，单一“万能”模型难以兼顾所有领域。A2A
鼓励构建“小而专”的智能体生态：</p>
<ul>
<li>每个智能体专注一个领域（如订票、报税、图像处理）。</li>
<li>通过 A2A
协议，它们像乐高积木一样自由组合，快速响应新的业务需求。</li>
</ul>
<p>比如你让一个agent使用多个工具，不仅会浪费tokens，也会降低其调用工具的准确性。所有，专业的领域使用专业的agent，而agent间的通信便要依靠A2A协议</p>
<h3 id="环境配置">环境配置</h3>
<p><strong>克隆仓库</strong></p>
<p>如果你还没有克隆，请克隆 A2A Samples 仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/a2aproject/a2a-samples.git -b main --depth 1</span><br><span class="line">cd a2a-samples</span><br></pre></td></tr></table></figure>
<p><strong>Python 环境和 SDK 安装</strong></p>
<p>我们推荐为 Python 项目使用虚拟环境。A2A Python SDK 使用
<code>uv</code> 进行依赖管理，但你也可以使用 <code>pip</code> 与
<code>venv</code>。</p>
<ol type="1">
<li><p><strong>创建并激活虚拟环境：</strong></p>
<p>使用 <code>venv</code>（标准库）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m venv .venv</span><br><span class="line">source .venv/bin/activate</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装所需的 Python 依赖项以及 A2A SDK
及其依赖项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r samples/python/requirements.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="agent-skills-agent-card">Agent Skills &amp; Agent Card</h3>
<h4 id="agent-skills">Agent Skills</h4>
<p>一个<strong>代理技能</strong>描述了代理可以执行的具体能力或功能。它是告诉客户端代理擅长哪些任务的构建模块。</p>
<p><code>AgentSkill</code> 的关键属性（定义在 <code>a2a.types</code>
中）：</p>
<ul>
<li><code>id</code>: 技能的唯一标识符。</li>
<li><code>name</code>: 人类可读的名称。</li>
<li><code>description</code>：对技能功能的更详细说明。</li>
<li><code>tags</code>：用于分类和发现的关键词。</li>
<li><code>examples</code>：示例提示或使用案例。</li>
<li><code>inputModes</code> / <code>outputModes</code>:
支持的输入和输出媒体类型（例如，“text/plain”，“application/json”）。</li>
</ul>
<p>在 <code>__main__.py</code> 中，你可以看到如何为 Helloworld
代理定义一个技能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">skill = AgentSkill(</span><br><span class="line">    id=&#x27;hello_world&#x27;,</span><br><span class="line">    name=&#x27;Returns hello world&#x27;,</span><br><span class="line">    description=&#x27;just returns hello world&#x27;,</span><br><span class="line">    tags=[&#x27;hello world&#x27;],</span><br><span class="line">    examples=[&#x27;hi&#x27;, &#x27;hello world&#x27;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个技能非常简单：它的名称是 “Returns hello
world”，并且主要处理文本。</p>
<h4 id="agent-card">Agent Card</h4>
<p><strong>代理卡</strong>是一个 A2A 服务器提供的 JSON 文档，通常位于
<code>.well-known/agent-card.json</code>
端点。它就像代理的数字名片。</p>
<p><code>AgentCard</code> 的关键属性（定义在 <code>a2a.types</code>
中）：</p>
<ul>
<li><code>name</code>, <code>description</code>, <code>version</code>:
基本身份信息。</li>
<li><code>url</code>：A2A 服务可访问的端点。</li>
<li><code>capabilities</code>：指定支持的 A2A 功能，如
<code>streaming</code> 或 <code>pushNotifications</code>。</li>
<li><code>defaultInputModes</code> / <code>defaultOutputModes</code>:
代理的默认媒体类型。</li>
<li><code>skills</code>: 代理提供的 <code>AgentSkill</code>
对象列表。</li>
</ul>
<p><code>helloworld</code> 示例定义其 Agent Card 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># This will be the public-facing agent card</span><br><span class="line">public_agent_card = AgentCard(</span><br><span class="line">    name=&#x27;Hello World Agent&#x27;,</span><br><span class="line">    description=&#x27;Just a hello world agent&#x27;,</span><br><span class="line">    url=&#x27;http://localhost:9999/&#x27;,</span><br><span class="line">    version=&#x27;1.0.0&#x27;,</span><br><span class="line"> 	# 默认输入模式：Agent 能够接收的输入类型列表，这里仅支持纯文本</span><br><span class="line">    default_input_modes=[&#x27;text&#x27;],</span><br><span class="line">    # 默认输出模式：Agent 能够产生的输出类型列表，这里仅返回纯文本</span><br><span class="line">    default_output_modes=[&#x27;text&#x27;],</span><br><span class="line">    # 能力声明：告知调用方 Agent 支持的能力，例如是否支持流式输出（streaming）</span><br><span class="line">    capabilities=AgentCapabilities(streaming=True),</span><br><span class="line">    skills=[skill],  # Only the basic skill for the public card</span><br><span class="line">    supports_authenticated_extended_card=True,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这张卡片告诉我们代理名为 “Hello World Agent”，运行在
<code>http://localhost:9999/</code>，支持文本交互，并具有
<code>hello_world</code>
技能。它还表明支持公开认证，意味着无需特定凭证。</p>
<h3 id="agent-executor">Agent Executor</h3>
<p>A2A 代理处理请求和生成响应/事件的核心逻辑由一个 <strong>Agent
Executor</strong> 负责。A2A Python SDK 提供了一个抽象基类
<code>a2a.server.agent_execution.AgentExecutor</code> 供你实现。</p>
<p><strong><code>AgentExecutor</code> 接口</strong></p>
<p><code>AgentExecutor</code> 类定义了两个主要方法：</p>
<ul>
<li><code>async def execute(self, context: RequestContext, event_queue: EventQueue)</code>
: 处理期望响应或事件流的传入请求。它处理用户输入（可通过
<code>context</code> 获取）并使用 <code>event_queue</code> 发送
<code>Message</code>、<code>Task</code>、<code>TaskStatusUpdateEvent</code>
或 <code>TaskArtifactUpdateEvent</code> 对象。</li>
<li><code>async def cancel(self, context: RequestContext, event_queue: EventQueue)</code>
: 处理取消正在进行的任务的请求。</li>
</ul>
<p><code>RequestContext</code>
提供有关传入请求的信息，例如用户消息和任何现有的任务详情。<code>EventQueue</code>
由执行器使用，用于将事件发送回客户端。</p>
<p><strong>Helloworld AgentExecutor</strong></p>
<p>让我们看看 <code>agent_executor.py</code>。它定义了
<code>HelloWorldAgentExecutor</code>。</p>
<ol type="1">
<li><p><strong>代理（<code>HelloWorldAgent</code>）</strong>：这是一个简单的辅助类，封装了实际的“业务逻辑”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorldAgent:</span><br><span class="line">    &quot;&quot;&quot;Hello World Agent.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    async def invoke(self) -&gt; str:</span><br><span class="line">        return &#x27;Hello World&#x27;</span><br></pre></td></tr></table></figure>
<p>它有一个简单的 <code>invoke</code> 方法，返回字符串”Hello
World”。</p></li>
<li><p><strong>执行器（<code>HelloWorldAgentExecutor</code>）</strong>：这个类实现了
<code>AgentExecutor</code> 接口。</p>
<ul>
<li><p><strong><code>__init__</code></strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorldAgentExecutor(AgentExecutor):</span><br><span class="line">    &quot;&quot;&quot;Test AgentProxy Implementation.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.agent = HelloWorldAgent()</span><br></pre></td></tr></table></figure>
<p>它实例化了 <code>HelloWorldAgent</code>。</p></li>
<li><p><strong><code>execute</code></strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async def execute(</span><br><span class="line">    self,</span><br><span class="line">    context: RequestContext,</span><br><span class="line">    event_queue: EventQueue,</span><br><span class="line">) -&gt; None:</span><br><span class="line">    result = await self.agent.invoke()</span><br><span class="line">    await event_queue.enqueue_event(new_agent_text_message(result))</span><br></pre></td></tr></table></figure>
<p>当收到一个 <code>message/send</code> 或 <code>message/stream</code>
请求时（这两种请求在这个简化的执行器中均由 <code>execute</code>
处理）：</p>
<ol type="1">
<li>它调用 <code>self.agent.invoke()</code> 来获取 “Hello World”
字符串。</li>
<li>它使用 <code>new_agent_text_message</code> 工具函数创建一个 A2A
<code>Message</code> 对象。</li>
<li>它将此消息入队到 <code>event_queue</code>。底层的
<code>DefaultRequestHandler</code>
随后会处理这个队列以向客户端发送响应。对于像这样的一条消息，在流关闭之前，它将导致一个
<code>message/send</code> 的单一响应或一个 <code>message/stream</code>
的单一事件。</li>
</ol></li>
<li><p><strong><code>cancel</code></strong>: Helloworld 示例的
<code>cancel</code>
方法简单地抛出一个异常，表明这个基本代理不支持取消操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async def cancel(</span><br><span class="line">    self, context: RequestContext, event_queue: EventQueue</span><br><span class="line">) -&gt; None:</span><br><span class="line">    raise Exception(&#x27;cancel not supported&#x27;)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<p><code>AgentExecutor</code> 充当 A2A
协议（由请求处理器和服务器应用程序管理）与您的代理特定逻辑之间的桥梁。它接收关于请求的上下文信息，并使用事件队列来通信结果或更新。</p>
<h3 id="启动server">启动server</h3>
<p>现在我们已经有了 Agent Card 和 Agent Executor，可以设置并启动 A2A
服务器。</p>
<p>A2A Python SDK 提供了一个 <code>A2AStarletteApplication</code>
类，简化了运行符合 A2A 标准的 HTTP 服务器。它使用 <a target="_blank" rel="noopener" href="https://www.starlette.io/">Starlette</a> 作为 Web 框架，通常与 <a target="_blank" rel="noopener" href="https://www.uvicorn.org/">Uvicorn</a> 等 ASGI 服务器一起运行。</p>
<p>让我们再次查看
<code>__main__.py</code>，看看服务器是如何初始化和启动的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import uvicorn</span><br><span class="line"></span><br><span class="line">from a2a.server.apps import A2AStarletteApplication</span><br><span class="line">from a2a.server.request_handlers import DefaultRequestHandler</span><br><span class="line">from a2a.server.tasks import InMemoryTaskStore</span><br><span class="line">from a2a.types import (</span><br><span class="line">    AgentCapabilities,</span><br><span class="line">    AgentCard,</span><br><span class="line">    AgentSkill,</span><br><span class="line">)</span><br><span class="line">from agent_executor import (</span><br><span class="line">    HelloWorldAgentExecutor,  # type: ignore[import-untyped]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    skill = AgentSkill(</span><br><span class="line">        id=&#x27;hello_world&#x27;,</span><br><span class="line">        name=&#x27;返回 hello world&#x27;,</span><br><span class="line">        description=&#x27;简单地返回 hello world&#x27;,</span><br><span class="line">        tags=[&#x27;hello world&#x27;],</span><br><span class="line">        examples=[&#x27;hi&#x27;, &#x27;hello world&#x27;],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    extended_skill = AgentSkill(</span><br><span class="line">        id=&#x27;super_hello_world&#x27;,</span><br><span class="line">        name=&#x27;返回 SUPER Hello World&#x27;,</span><br><span class="line">        description=&#x27;仅限已认证用户使用的更热情的问候。&#x27;,</span><br><span class="line">        tags=[&#x27;hello world&#x27;, &#x27;super&#x27;, &#x27;extended&#x27;],</span><br><span class="line">        examples=[&#x27;super hi&#x27;, &#x27;give me a super hello&#x27;],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 这是面向公众的 Agent 卡片</span><br><span class="line">    public_agent_card = AgentCard(</span><br><span class="line">        name=&#x27;Hello World Agent&#x27;,</span><br><span class="line">        description=&#x27;只是一个 hello world 代理&#x27;,</span><br><span class="line">        url=&#x27;http://localhost:9999/&#x27;,</span><br><span class="line">        version=&#x27;1.0.0&#x27;,</span><br><span class="line">        default_input_modes=[&#x27;text&#x27;],</span><br><span class="line">        default_output_modes=[&#x27;text&#x27;],</span><br><span class="line">        capabilities=AgentCapabilities(streaming=True),</span><br><span class="line">        skills=[skill],  # 公开卡片仅包含基础技能</span><br><span class="line">        supports_authenticated_extended_card=True,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 这是已认证用户的扩展 Agent 卡片</span><br><span class="line">    # 额外包含 &#x27;extended_skill&#x27;</span><br><span class="line">    specific_extended_agent_card = public_agent_card.model_copy(</span><br><span class="line">        update=&#123;</span><br><span class="line">            &#x27;name&#x27;: &#x27;Hello World Agent - Extended Edition&#x27;,  # 使用不同名称以便区分</span><br><span class="line">            &#x27;description&#x27;: &#x27;面向已认证用户的完整功能 hello world 代理。&#x27;,</span><br><span class="line">            &#x27;version&#x27;: &#x27;1.0.1&#x27;,  # 甚至可以是不同的版本</span><br><span class="line">            # capabilities 及其他字段（如 url、default_input_modes、default_output_modes、</span><br><span class="line">            # supports_authenticated_extended_card）均从 public_agent_card 继承，</span><br><span class="line">            # 除非在此处另行指定。</span><br><span class="line">            &#x27;skills&#x27;: [</span><br><span class="line">                skill,</span><br><span class="line">                extended_skill,</span><br><span class="line">            ],  # 扩展卡片包含两个技能</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    request_handler = DefaultRequestHandler(</span><br><span class="line">        agent_executor=HelloWorldAgentExecutor(),</span><br><span class="line">        task_store=InMemoryTaskStore(),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    server = A2AStarletteApplication(</span><br><span class="line">        agent_card=public_agent_card,</span><br><span class="line">        http_handler=request_handler,</span><br><span class="line">        extended_agent_card=specific_extended_agent_card,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 使用 uvicorn 启动服务，监听 0.0.0.0:9999</span><br><span class="line">    uvicorn.run(server.build(), host=&#x27;0.0.0.0&#x27;, port=9999)</span><br></pre></td></tr></table></figure>
<p>我们来分解一下：</p>
<ol type="1">
<li><strong><code>DefaultRequestHandler</code></strong>:
<ul>
<li>SDK 提供了 <code>DefaultRequestHandler</code>。这个处理器接收你的
<code>AgentExecutor</code>
实现（这里，<code>HelloWorldAgentExecutor</code>）和一个
<code>TaskStore</code>（这里，<code>InMemoryTaskStore</code>）。</li>
<li>它将传入的 A2A RPC 调用路由到你的执行器的适当方法上（比如
<code>execute</code> 或 <code>cancel</code>）。</li>
<li><code>TaskStore</code> 被 <code>DefaultRequestHandler</code>
用来管理任务的生命周期，特别是对于有状态交互、流式传输和重新订阅。即使你的代理执行器很简单，处理器也需要一个任务存储。</li>
</ul></li>
<li><strong><code>A2AStarletteApplication</code></strong>:
<ul>
<li><code>A2AStarletteApplication</code> 类使用 <code>agent_card</code>
和 <code>request_handler</code>（在其构造函数中称为
<code>http_handler</code>）进行实例化。</li>
<li><code>agent_card</code> 至关重要，因为服务器将在
<code>/.well-known/agent-card.json</code>
端点（默认情况下）上公开它。</li>
<li><code>request_handler</code> 负责通过与其 <code>AgentExecutor</code>
交互来处理所有传入的 A2A 方法调用。</li>
</ul></li>
<li><strong><code>uvicorn.run(server_app_builder.build(), ...)</code></strong>:
<ul>
<li><code>A2AStarletteApplication</code> 有一个 <code>build()</code>
方法，用于构建实际的 Starlette 应用程序。</li>
<li>然后使用 <code>uvicorn.run()</code> 运行该应用程序，使您的代理可通过
HTTP 访问。</li>
<li><code>host='0.0.0.0'</code>
使服务器可在您机器上的所有网络接口上访问。</li>
<li><code>port=9999</code> 指定监听的端口。这需要与
<code>AgentCard</code> 中的 <code>url</code> 匹配。</li>
</ul></li>
<li><code>specific_extended_agent_card</code>
<ul>
<li><strong>给同一个 Agent
准备“两张不同权限的名片”</strong>，分别用于“普通访客”和“已认证用户”。、</li>
</ul></li>
</ol>
<h3 id="与服务器交互">与服务器交互</h3>
<p>Helloworld A2A 服务器运行后，让我们向它发送一些请求。SDK
包含一个客户端（<code>A2AClient</code>），可以简化这些交互。</p>
<p>让我们看一下 <code>test_client.py</code> 的关键部分：</p>
<ol type="1">
<li><p><strong>获取代理卡 &amp; 初始化客户端</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">base_url = &#x27;http://localhost:9999&#x27;</span><br><span class="line"></span><br><span class="line">async with httpx.AsyncClient() as httpx_client:</span><br><span class="line">    # 初始化 A2ACardResolver</span><br><span class="line">    resolver = A2ACardResolver(</span><br><span class="line">        httpx_client=httpx_client,</span><br><span class="line">        base_url=base_url,</span><br><span class="line">        # agent_card_path 使用默认值，extended_agent_card_path 也使用默认值</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p><code>A2ACardResolver</code> 类是一个便捷工具。它首先从服务器端的
<code>/.well-known/agent-card.json</code> 端点（基于提供的基 URL）获取
<code>AgentCard</code>，然后使用它初始化客户端。</p></li>
<li><p><strong>发送非流式消息 (<code>send_message</code>)</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">client = A2AClient(</span><br><span class="line">    httpx_client=httpx_client, </span><br><span class="line">    agent_card=final_agent_card_to_use#这个card为经过认证处理后暴露的card</span><br><span class="line">)</span><br><span class="line">logger.info(&#x27;A2AClient initialized.&#x27;)</span><br><span class="line"></span><br><span class="line">send_message_payload: dict[str, Any] = &#123;</span><br><span class="line">    &#x27;message&#x27;: &#123;</span><br><span class="line">        &#x27;role&#x27;: &#x27;user&#x27;,</span><br><span class="line">        &#x27;parts&#x27;: [</span><br><span class="line">            &#123;&#x27;kind&#x27;: &#x27;text&#x27;, &#x27;text&#x27;: &#x27;how much is 10 USD in INR?&#x27;&#125;</span><br><span class="line">        ],</span><br><span class="line">        &#x27;messageId&#x27;: uuid4().hex,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">request = SendMessageRequest(</span><br><span class="line">    id=str(uuid4()), params=MessageSendParams(**send_message_payload)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = await client.send_message(request)</span><br><span class="line">print(response.model_dump(mode=&#x27;json&#x27;, exclude_none=True))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>send_message_payload</code> 构建了
<code>MessageSendParams</code> 的数据。</li>
<li>这些数据被封装在 <code>SendMessageRequest</code> 中。</li>
<li>它包含一个 <code>message</code> 对象，其中 <code>role</code>
设置为”用户”，内容在 <code>parts</code> 中。</li>
<li>Helloworld 代理的 <code>execute</code> 方法将入队一条”Hello
World”消息。<code>DefaultRequestHandler</code>
将获取这条消息并将其作为响应发送。</li>
<li><code>response</code> 将是一个 <code>SendMessageResponse</code>
对象，其中包含 <code>SendMessageSuccessResponse</code>（以代理的
<code>Message</code> 作为结果）或
<code>JSONRPCErrorResponse</code>。</li>
</ul></li>
<li><p><strong>处理任务 ID（Helloworld 的说明性注释）</strong>:</p>
<p>Helloworld 客户端（<code>test_client.py</code>）不会直接尝试
<code>get_task</code> 或 <code>cancel_task</code>，因为简单的 Helloworld
代理的 <code>execute</code> 方法，通过 <code>message/send</code>
调用时，会导致 <code>DefaultRequestHandler</code> 返回一个直接的
<code>Message</code> 响应，而不是 <code>Task</code>
对象。更复杂的、明确管理任务的代理（如 LangGraph 示例）会从
<code>message/send</code> 返回一个 <code>Task</code> 对象，然后其
<code>id</code> 可用于 <code>get_task</code> 或
<code>cancel_task</code>。</p></li>
<li><p><strong>发送流式消息（<code>send_message_streaming</code>）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">streaming_request = SendStreamingMessageRequest(</span><br><span class="line">    id=str(uuid4()), params=MessageSendParams(**send_message_payload)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">stream_response = client.send_message_streaming(streaming_request)</span><br><span class="line"></span><br><span class="line">async for chunk in stream_response:</span><br><span class="line">    print(chunk.model_dump(mode=&#x27;json&#x27;, exclude_none=True))</span><br></pre></td></tr></table></figure>
<ul>
<li>此方法调用代理的 <code>message/stream</code>
端点。<code>DefaultRequestHandler</code> 将调用
<code>HelloWorldAgentExecutor.execute</code> 方法。</li>
<li><code>execute</code> 方法将一个”Hello
World”消息入队，然后关闭事件队列。</li>
<li>客户端将接收这条单条消息为一个
<code>SendStreamingMessageResponse</code> 事件，然后流将终止。</li>
<li><code>stream_response</code> 是一个
<code>AsyncGenerator</code>。</li>
</ul></li>
</ol>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/a2aproject/a2a-samples?tab=readme-ov-file">a2aproject/a2a-samples:
Samples using the Agent2Agent (A2A) Protocol</a></p>
<p><a target="_blank" rel="noopener" href="https://a2a-protocol.org/latest/">Agent2Agent (A2A)
Protocol</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/a2aproject/a2a-python">a2aproject/a2a-python:
Agent2Agent (A2A) 协议的官方 Python SDK — a2aproject/a2a-python:
Official Python SDK for the Agent2Agent (A2A) Protocol</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
