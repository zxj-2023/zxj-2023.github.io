<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zxj Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang XiJun">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Zhang XiJun">
<meta property="og:description" content="zxj Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张熙浚">
<meta property="article:tag" content="zxj">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang XiJun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang XiJun</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BLOGS</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张熙浚"
      src="/images/zxjavatar.gif">
  <p class="site-author-name" itemprop="name">张熙浚</p>
  <div class="site-description" itemprop="description">zxj Blogs</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zxj-2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zxj-2023" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=2902065320&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;2902065320&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zxj-2023.github.io/" title="https:&#x2F;&#x2F;zxj-2023.github.io" rel="noopener" target="_blank">Zhang XiJun</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://theme-next.js.org/" title="https:&#x2F;&#x2F;theme-next.js.org" rel="noopener" target="_blank">NexT</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">计算机组成原理作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-04 08:35:39" itemprop="dateModified" datetime="2026-01-04T08:35:39+08:00">2026-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="第一章作业"><a href="#第一章作业" class="headerlink" title="第一章作业"></a>第一章作业</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p> 假设同一套指令集用不同的方法设计了两种机器 M1 和 M2。机器 M1 的时钟周期为 0.8ns，机器 M2 的时钟周期为 1.2ns。某个程序 P 在机器 M1 上运行时的 CPI 为 4，在 M2 上的 CPI 为 2。对于程序 P 来说，哪台机器的执行速度更快？快多少？ </p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140015756.png" alt="image-20251011140015756"></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>假定编译器对某段高级语言程序编译生成两种不同的指令序列 S1 和 S2，在时钟频率为 500MHz 的机器 M 上运行，目标指令序列中用到的指令类型有 A、B、C 和 D 四类。每类指令在 M 上的 CPI 和两个指令序列所用的各类指令条数如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令类型</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>各指令的 CPI</strong></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>S1 的指令条数</strong></td>
<td>5</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td><strong>S2 的指令条数</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140100523.png" alt="image-20251011140100523"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>假定机器 M 在运行程序 P 的过程中，共执行了 500×10⁶ 条浮点数指令、4000×10⁶ 条整数指令、3000×10⁶ 条访存指令、1000×10⁶ 条分支指令，这 4 种指令的 CPI 分别是 2、1、4、1。若要使程序 P 的执行时间减少一半，浮点指令的 CPI 应如何改进？若要使程序 P 的执行时间减少一半，访存指令和分支指令的 CPI 应如何改进？若浮点指令和整数指令的 CPI 减少 20%，访存指令和分支指令的 CPI 减少 40%，则程序 P 的执行时间会减少多少？</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140106600.png" alt="image-20251011140106600"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251011140123204.png" alt="image-20251011140123204"></p>
<h3 id="第二章作业"><a href="#第二章作业" class="headerlink" title="第二章作业"></a>第二章作业</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>假定某计算机的总线采用奇校验，每8位数据有一位校验位，若在32位数据线上传输的信息是<br><code>8F 3C AB 96H</code>，则对应的4个校验位应为什么？<br>若接收方收到的数据信息和校验位分别为<code>87 3C AB 96H</code> 和 <code>0101B</code>，则说明发生了什么情况，并给出验证过程。.0</p>
<p><strong>第一部分：计算原始数据 <code>8F 3C AB 96H</code> 对应的 4 个校验位</strong></p>
<p><strong>前提条件：</strong></p>
<ul>
<li>使用<strong>奇校验</strong>：每个字节（8位）中，1的个数必须是<strong>奇数</strong>。</li>
<li>每8位数据配1位校验位，所以32位数据分成4个字节，对应4个校验位。</li>
<li>数据是十六进制：<code>8F 3C AB 96H</code></li>
</ul>
<p>我们需要对每一个字节单独计算其奇校验位。</p>
<p><strong>第一步：把每个十六进制字节转换成二进制</strong></p>
<ul>
<li><code>8F H</code> = <code>1000 1111</code></li>
<li><code>3C H</code> = <code>0011 1100</code></li>
<li><code>AB H</code> = <code>1010 1011</code></li>
<li><code>96 H</code> = <code>1001 0110</code></li>
</ul>
<p><strong>第二步：数每个字节中“1”的个数，然后确定校验位</strong></p>
<blockquote>
<p><strong>奇校验规则：</strong> 如果当前字节中“1”的个数是<strong>偶数</strong>，则校验位设为 <code>1</code>，使总数变为奇数；如果是<strong>奇数</strong>，则校验位设为 <code>0</code>，保持奇数。</p>
</blockquote>
<p>我们逐个来看：</p>
<ol>
<li><p><strong>字节 <code>8F</code> = <code>1000 1111</code></strong></p>
<ul>
<li>数“1”：位置0, 4,5,6,7 → 共 <strong>5个1</strong> → 是<strong>奇数</strong></li>
<li>所以校验位 = <code>0</code></li>
</ul>
</li>
<li><p><strong>字节 <code>3C</code> = <code>0011 1100</code></strong></p>
<ul>
<li>数“1”：位置2,3,4,5 → 共 <strong>4个1</strong> → 是<strong>偶数</strong></li>
<li>所以校验位 = <code>1</code></li>
</ul>
</li>
<li><p><strong>字节 <code>AB</code> = <code>1010 1011</code></strong></p>
<ul>
<li>数“1”：位置0,2,4,6,7 → 共 <strong>5个1</strong> → 是<strong>奇数</strong></li>
<li>所以校验位 = <code>0</code></li>
</ul>
</li>
<li><p><strong>字节 <code>96</code> = <code>1001 0110</code></strong></p>
<ul>
<li>数“1”：位置0,3,5,6 → 共 <strong>4个1</strong> → 是<strong>偶数</strong></li>
<li>所以校验位 = <code>1</code></li>
</ul>
</li>
</ol>
<hr>
<p>✅ <strong>所以，对应的4个校验位是：<code>0 1 0 1</code>，即 <code>0101B</code></strong></p>
<p><strong>第二部分：接收方收到的数据是 <code>87 3C AB 96H</code> 和校验位 <code>0101B</code>，发生了什么？验证过程</strong></p>
<p>现在接收方收到：</p>
<ul>
<li>数据：<code>87 3C AB 96H</code></li>
<li>校验位：<code>0101B</code></li>
</ul>
<p>我们怀疑有错误，因为原始发送的是 <code>8F</code>，但收到的是 <code>87</code> —— 很可能第一个字节出错了！</p>
<p>我们来<strong>逐字节验证奇校验是否成立</strong>。</p>
<p><strong>第一步：将接收到的数据转为二进制</strong></p>
<ul>
<li><code>87 H</code> = <code>1000 0111</code></li>
<li><code>3C H</code> = <code>0011 1100</code> （没变）</li>
<li><code>AB H</code> = <code>1010 1011</code> （没变）</li>
<li><code>96 H</code> = <code>1001 0110</code> （没变）</li>
</ul>
<p>校验位：<code>0101B</code> → 对应四个字节的校验位分别是：第1字节 <code>0</code>，第2字节 <code>1</code>，第3字节 <code>0</code>，第4字节 <code>1</code></p>
<p><strong>第二步：验证每个字节 + 校验位 是否满足奇校验</strong></p>
<blockquote>
<p>注意：我们验证的是“数据位 + 校验位”一共9位中，1的个数是否为奇数。</p>
</blockquote>
<ol>
<li><p><strong>第一字节 <code>87</code> + 校验位 <code>0</code></strong></p>
<ul>
<li>数据位：<code>1000 0111</code> → “1”的个数：位置0, 5,6,7 → <strong>4个1</strong></li>
<li>加上校验位 <code>0</code> → 总共还是 <strong>4个1</strong> → 是<strong>偶数</strong> ❌</li>
<li>不满足奇校验！→ <strong>出错！</strong></li>
</ul>
</li>
<li><p><strong>第二字节 <code>3C</code> + 校验位 <code>1</code></strong></p>
<ul>
<li>数据位：<code>0011 1100</code> → “1”的个数：4个（偶数）</li>
<li>加上校验位 <code>1</code> → 总共 4+1=5 → <strong>奇数</strong> ✅</li>
<li>正确</li>
</ul>
</li>
<li><p><strong>第三字节 <code>AB</code> + 校验位 <code>0</code></strong></p>
<ul>
<li>数据位：<code>1010 1011</code> → “1”的个数：5个（奇数）</li>
<li>加上校验位 <code>0</code> → 总共 5 → <strong>奇数</strong> ✅</li>
<li>正确</li>
</ul>
</li>
<li><p><strong>第四字节 <code>96</code> + 校验位 <code>1</code></strong></p>
<ul>
<li>数据位：<code>1001 0110</code> → “1”的个数：4个（偶数）</li>
<li>加上校验位 <code>1</code> → 总共 5 → <strong>奇数</strong> ✅</li>
<li>正确</li>
</ul>
</li>
</ol>
<hr>
<p>✅ <strong>结论：只有第一个字节校验失败！说明在传输过程中，第一个字节发生了错误。</strong></p>
<p><strong>进一步分析：哪里出错了？</strong></p>
<p>原始发送的是 <code>8F H = 1000 1111</code></p>
<p>接收的是 <code>87 H = 1000 0111</code></p>
<p>对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始: 1 0 0 0  1 1 1 1</span><br><span class="line">接收: 1 0 0 0  0 1 1 1</span><br><span class="line">             ↑</span><br><span class="line">            第5位（从左数第5位，或从右数第4位）由1变成了0</span><br></pre></td></tr></table></figure>
<p>所以，<strong>第5位发生了翻转错误（bit flip）</strong>。</p>
<p>🧠 总结</p>
<ol>
<li><strong>原始数据 <code>8F 3C AB 96H</code> 的校验位是 <code>0101B</code>。</strong></li>
<li><strong>接收方收到 <code>87 3C AB 96H</code> 和 <code>0101B</code> 后，发现第一个字节校验失败，说明该字节在传输中发生了错误（具体是第5位由1变0）。</strong></li>
<li>奇校验能<strong>检测单个比特错误</strong>，但不能纠正它，也不能检测偶数个比特错误。</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/IMG_20251029_093747.jpg" alt="IMG_20251029_093747"></p>
<h3 id="第三章作业"><a href="#第三章作业" class="headerlink" title="第三章作业"></a>第三章作业</h3><p>已知 <code>x = 10</code>, <code>y = -6</code>，采用 <strong>6位机器数表示</strong>。请按如下要求计算并把结果还原成真值。</p>
<p>（1）求 <code>[x + y]补</code>，<code>[x - y]补</code><br>（2）用原码一位乘法计算 <code>[x × y]原</code><br>（3）用布斯算法计算 <code>[x × y]补</code><br>（4）用加减交替法计算 <code>[x / y]原</code> 的商和余数</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251029194504411.png" alt="image-20251029194504411"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251029185146990.png" alt="image-20251029185146990"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/IMG_20251031_171709.jpg" alt="IMG_20251031_171709"></p>
<h3 id="第七章作业"><a href="#第七章作业" class="headerlink" title="第七章作业"></a>第七章作业</h3><h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251126152551121.png" alt="image-20251126152551121"></p>
<p><strong>DRAM</strong> 的全称是 <strong>Dynamic Random Access Memory</strong>，中文叫 <strong>动态随机存取存储器</strong>。</p>
<p>它是计算机中最常用的<strong>主存储器（Main Memory / RAM）</strong>，也就是我们平时常说的“内存条”上的核心芯片。</p>
<p> <strong>为什么 DRAM 单元要刷新？（物理原理）</strong></p>
<p><strong>核心原因：漏电。</strong></p>
<p>你可以把 DRAM 的存储单元想象成一个<strong>底部有个小针眼的“水桶”</strong>（电容），而数据就是<strong>“水”</strong>（电荷）。</p>
<ul>
<li><strong>存入数据 “1”：</strong> 你给桶里倒满水。</li>
<li><strong>存入数据 “0”：</strong> 你把桶倒空。</li>
<li><strong>问题来了：</strong> 因为那个小针眼（晶体管的漏电流），满桶的水会慢慢往下漏。<ul>
<li>如果你不管它，过一会儿（比如 2ms 后），桶里的水漏干了，原本的 <strong>“1” 就变成了 “0”</strong>，数据就丢了。</li>
</ul>
</li>
</ul>
<p>这里最容易混淆的是<strong>两个时间概念</strong>，必须分清楚：</p>
<ol>
<li><strong>最大刷新时间（题目中的 2ms）：</strong><ul>
<li>这是<strong>死线 (Deadline)</strong>。</li>
<li>意思是：对于<strong>每一个</strong>水桶，管理员最迟必须每隔 2ms 回来检查一次。如果超过 2ms 没管它，水就漏光了。</li>
</ul>
</li>
<li><strong>产生刷新信号的间隔（题目要求的答案）：</strong><ul>
<li>这是管理员<strong>处理下一行水桶的频率</strong>。</li>
<li><strong>关键点：</strong> 管理员不能一次性同时刷新几百万个水桶（那样电路会过载，电流太大）。他必须<strong>一批一批地</strong>（一行一行地）轮流刷新。</li>
</ul>
</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/adf3c730cec214bcbd0b690a8632d0e1.jpg" alt="adf3c730cec214bcbd0b690a8632d0e1"></p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251127234744026.png" alt="image-20251127234744026"></p>
<p><strong>ROM</strong> 的全称是 <strong>Read-Only Memory</strong>，中文叫 <strong>只读存储器</strong>。</p>
<p>核心特点：</p>
<ul>
<li><strong>字面意思：</strong> “Read-Only” 意味着只能读，不能写（或者说在正常工作状态下不能随意写入）。</li>
<li><strong>实际特性（最重要）：非易失性 (Non-Volatile)</strong>。<ul>
<li><strong>RAM (DRAM/SRAM)：</strong> 一断电，数据立马消失。</li>
<li><strong>ROM：</strong> 断电后，数据<strong>依然保存</strong>。哪怕你把电脑关机放一年，ROM 里的数据也不会丢。</li>
</ul>
</li>
</ul>
<p><strong>为什么 ROM 总是放在内存地址的最前面（从 0 开始）？</strong></p>
<ol>
<li><strong>开机第一件事：</strong> 当你按下电脑电源键时，RAM（内存条）里是空的（全是乱码或 0），CPU 无法从 RAM 里读取指令。</li>
<li><strong>启动引导：</strong> CPU 设计为通电后自动去地址 <code>0000H</code>（或其他固定地址）找第一条指令。</li>
<li><strong>固化程序：</strong> 我们必须在这个位置放一个<strong>断电也不丢数据</strong>的存储器（ROM），里面存着电脑的<strong>启动程序（BIOS/UEFI）</strong>。<ul>
<li>它负责检测硬件、初始化系统，然后把操作系统（Windows/Linux）从硬盘搬到 RAM 里。</li>
</ul>
</li>
</ol>
<p>当 $\overline{\text{MREQ}} = 0$（即处于低电平/有效状态）时，它的主要作用是<strong>通知系统，CPU 当前正打算对内存（RAM 或 ROM）进行访问。</strong></p>
<p>$R/\overline{W}$ (Read / Write Control)</p>
<ul>
<li><strong>角色</strong>：这是 <strong>CPU 发出的控制信号</strong>（总线信号）。</li>
<li><strong>含义</strong>：它告诉整个系统，CPU 当前想要控制数据流向的方向。</li>
<li><strong>状态逻辑</strong>：<ul>
<li><strong>高电平 (1)</strong> = <strong>Read (读)</strong>：CPU 准备从总线上<strong>接收</strong>数据（数据流向：内存 $\to$ CPU）。</li>
<li><strong>低电平 (0)</strong> = <strong>Write (写)</strong>：CPU 准备向总线上<strong>发送</strong>数据（数据流向：CPU $\to$ 内存）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>通俗理解</strong>：这是 CPU 在喊话：“大家都听好了，我现在是要‘收东西’（Read）还是要‘发东西’（Write）。”</p>
</blockquote>
<p> $\overline{WE}$ (Write Enable)</p>
<ul>
<li><strong>角色</strong>：这是 <strong>RAM 芯片上的输入引脚</strong>（控制端）。</li>
<li><strong>含义</strong>：允许写入信号。它决定了内存芯片是否允许将数据总线上的电平记录到存储单元中。</li>
<li><strong>符号含义</strong>：顶部的横线表示<strong>低电平有效 (Active Low)</strong>。</li>
<li><strong>状态逻辑</strong>：<ul>
<li><strong>低电平 (0)</strong> = <strong>允许写入</strong>：内存芯片打开“大门”，将数据总线上的数据存入当前地址指向的单元。</li>
<li><strong>高电平 (1)</strong> = <strong>禁止写入</strong>：内存芯片处于读取模式（配合其他信号）或待机模式，不会修改内部存储的数据。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>通俗理解</strong>：这是内存芯片身上的一个开关。只有把这个开关拉下来（变低），内存才会乖乖地把数据“记下来”。</p>
</blockquote>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/d11ce94cd3db7edfb1cd4a3fa6dadf39.jpg" alt="d11ce94cd3db7edfb1cd4a3fa6dadf39"></p>
<h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251127234735106.png" alt="image-20251127234735106"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/91e3e3a11a15b2854641380b834e3326.jpg" alt="91e3e3a11a15b2854641380b834e3326"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251127234807626.png" alt="image-20251127234807626"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/DECFBD2ECFC7C36C6D9BB49DFD0C15C2.jpg" alt="DECFBD2ECFC7C36C6D9BB49DFD0C15C2"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251127234908094.png" alt="image-20251127234908094"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/bc48f7ff158bdc49537455d0a2d5efbd.jpg" alt="bc48f7ff158bdc49537455d0a2d5efbd"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/d4cd56bf63b45d5da02ce2f13eb06edf.jpg" alt="d4cd56bf63b45d5da02ce2f13eb06edf"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251127234930226.png" alt="image-20251127234930226"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/90b6c6f2d8d12022fa0bfa2d8bbcf775.jpg" alt="90b6c6f2d8d12022fa0bfa2d8bbcf775"></p>
<h3 id="第四章作业"><a href="#第四章作业" class="headerlink" title="第四章作业"></a>第四章作业</h3><h3 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h3><p>哪些寻址方式下的操作数在寄存器中？哪些在存储器中？</p>
<ul>
<li><strong>操作数（Operand）</strong>：指令执行时要处理的数据。</li>
<li><strong>寻址方式（Addressing Mode）</strong>：指明操作数在哪里（寄存器？内存？立即数？）以及如何找到它。</li>
<li><strong>寄存器（Register）</strong>：CPU内部的高速存储单元。</li>
<li><strong>存储器（Memory）</strong>：主存（RAM），速度比寄存器慢，但容量大。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>操作数位置</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>寄存器寻址</td>
<td>✅ 寄存器</td>
<td><code>MOV AX, BX</code></td>
</tr>
<tr>
<td>立即寻址</td>
<td>❌ 不在寄存器/存储器（在指令中）</td>
<td><code>MOV AX, 5</code></td>
</tr>
<tr>
<td>直接寻址</td>
<td>✅ 存储器</td>
<td><code>MOV AX, [2000H]</code></td>
</tr>
<tr>
<td>寄存器间接寻址</td>
<td>✅ 存储器</td>
<td><code>MOV AX, [BX]</code></td>
</tr>
<tr>
<td>寄存器相对寻址</td>
<td>✅ 存储器</td>
<td><code>MOV AX, [BX + 10]</code></td>
</tr>
<tr>
<td>基址变址寻址</td>
<td>✅ 存储器</td>
<td><code>MOV AX, [BX + SI]</code></td>
</tr>
<tr>
<td>相对基址变址寻址</td>
<td>✅ 存储器</td>
<td><code>MOV AX, [BX + SI + 5]</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>⚠️ 注意：<strong>立即数（Immediate）</strong> 不是寄存器也不是存储器，它直接嵌入在指令中。</p>
</blockquote>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h3><p>什么是 RISC？</p>
<p><strong>RISC = Reduced Instruction Set Computer（精简指令集计算机）</strong></p>
<p>与之相对的是 <strong>CISC（Complex Instruction Set Computer，复杂指令集计算机）</strong>，比如 Intel x86。</p>
<p>1️⃣ 指令集精简（Reduced Instruction Set）</p>
<ul>
<li>指令数量少（通常几十到几百条），每条指令功能单一。</li>
<li>指令长度固定（如 32 位），便于流水线处理。</li>
</ul>
<blockquote>
<p>💡 类比：就像厨房里只有几把多功能刀具，每把刀只做一件事，但做得又快又好。</p>
</blockquote>
<p><strong>例子：</strong></p>
<ul>
<li>RISC：<code>ADD R1, R2, R3</code> → 把 R2 和 R3 相加，结果存入 R1</li>
<li>CISC：<code>MOV [BX+SI+10], AX</code> → 一条指令完成地址计算+内存写入</li>
</ul>
<p>2️⃣ 指令执行周期短（Single-Cycle Execution）</p>
<ul>
<li>大多数指令在一个时钟周期内完成。</li>
<li>通过简化指令和硬件设计实现。</li>
</ul>
<p>3️⃣ 大量通用寄存器（Large Register File）</p>
<ul>
<li>寄存器数量多（如 ARM 有 16 个通用寄存器，RISC-V 有 32 个）。</li>
<li>减少对内存的访问，提高速度。</li>
</ul>
<p>4️⃣ 采用流水线技术（Pipelining）</p>
<ul>
<li>指令执行分为多个阶段（取指、译码、执行、访存、写回），并行处理。</li>
<li>RISC 指令简单统一，非常适合流水线。</li>
</ul>
<p>5️⃣ 加载/存储架构（Load/Store Architecture）</p>
<ul>
<li>只有 <code>LOAD</code> 和 <code>STORE</code> 指令可以访问内存。</li>
<li>其他运算指令只能在寄存器之间进行。</li>
</ul>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3"></a>3</h3><p>假定某计算机中有一条转移指令，采用相对寻址方式，共占两字节，第一字节是操作码，第二字节是 相对位移量(用补码表示),CPU每次从内存只能取一字节。假设执行到某转移指令时 PC的内容为200, 执行该转移指令后要求转移到100开始的一段程序执行，则该转移指令第二字节的内容应该是多少?</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/QQ20251206-170833.png" alt="QQ20251206-170833"></p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h3><p>4.假设地址为1200H的内存单元中的内容为12FCH,地址为12FCH的内存单元的内容为38B8H,而 38B8H单元的内容为88F9H。说明以下各情况下操作数的有效地址是多少? (1)操作数采用变址寻址，变址寄存器的内容为252,指令中给出的形式地址为1200H。 (2)操作数采用一次间接寻址，指令中给出的地址码为1200H。 (3)操作数采用寄存器间接寻址，指令中给出的寄存器编号为8,8号寄存器的内容为1200H。</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/QQ20251206-170838.png" alt="QQ20251206-170838"></p>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h3><p>6.某计算机指令系统采用定长指令字格式，指令字长16位，每个操作数的地址码长6位。指令分二 地址、单地址和零地址3类。若二地址指令有k2条，零地址指令有k0条，则单地址指令最多有多少条?</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/QQ20251206-170843.png" alt="QQ20251206-170843"></p>
<h2 id="第五章作业"><a href="#第五章作业" class="headerlink" title="第五章作业"></a>第五章作业</h2><h3 id="1-4"><a href="#1-4" class="headerlink" title="1."></a>1.</h3><h3 id="CPU的基本组成和基本功能各是什么"><a href="#CPU的基本组成和基本功能各是什么" class="headerlink" title="CPU的基本组成和基本功能各是什么?"></a>CPU的基本组成和基本功能各是什么?</h3><h4 id="1-CPU-的基本组成-Basic-Composition"><a href="#1-CPU-的基本组成-Basic-Composition" class="headerlink" title="1. CPU 的基本组成 (Basic Composition)"></a>1. CPU 的基本组成 (Basic Composition)</h4><p>CPU 在硬件上主要由 <strong>数据通路 (Datapath)</strong> 和 <strong>控制器 (Control Unit)</strong> 两大部分组成。</p>
<ul>
<li><strong>数据通路 (Datapath)</strong>：<ul>
<li><strong>定义</strong>：它是 CPU 中负责数据处理和信号传递的路径，“干活的肌肉”。</li>
<li><strong>包含的核心部件</strong>：<ul>
<li><strong>运算部件 (ALU)</strong>：负责算术运算（加减）和逻辑运算（与或）。</li>
<li><strong>寄存器堆 (Register File)</strong>：CPU 内部的高速存储单元，用于暂存操作数和运算结果（如 $rs, rt, rd$）。</li>
<li><strong>程序计数器 (PC)</strong>：存着当前或下一条指令的地址，是指令流动的“指针”。</li>
<li><strong>其他连接部件</strong>：包括多路选择器 (MUX)、加法器 (Adder)、符号扩展单元 (SignExt) 等，用于连通电路和辅助计算。</li>
</ul>
</li>
</ul>
</li>
<li><strong>控制器 (Control Unit)</strong>：<ul>
<li><strong>定义</strong>：它是 CPU 的“大脑”，指挥数据通路工作。</li>
<li><strong>功能</strong>：根据指令的操作码 (Opcode) 和功能码 (Func)，生成各种控制信号（如 <code>RegDst</code>, <code>ALUSrc</code>, <code>MemWr</code> 等），控制 MUX 的选通和寄存器的读写。</li>
</ul>
</li>
</ul>
<h4 id="2-CPU-的基本功能-Basic-Functions"><a href="#2-CPU-的基本功能-Basic-Functions" class="headerlink" title="2. CPU 的基本功能 (Basic Functions)"></a>2. CPU 的基本功能 (Basic Functions)</h4><p>CPU 的功能就是执行指令，这一过程通常被称为 <strong>“指令周期”</strong>。结合 PPT 中的流程，基本功能可以概括为以下四点：</p>
<ol>
<li><strong>指令控制 (Instruction Control)</strong>：<ul>
<li><strong>取指令</strong>：控制程序按照顺序执行 (<code>PC + 4</code>) 或进行跳转 (<code>beq/j</code>)。确保 CPU 能自动地、连续地从存储器中取出指令。</li>
</ul>
</li>
<li><strong>操作控制 (Operation Control)</strong>：<ul>
<li><strong>译码与指挥</strong>：对取出的指令进行译码（分析 Opcode），产生相应的控制信号，指挥各个部件按规定的动作工作（例如：看到 <code>lw</code> 就打开内存读开关，看到 <code>add</code> 就指挥 ALU 做加法）。</li>
</ul>
</li>
<li><strong>时间控制 (Time Control)</strong>：<ul>
<li><strong>时序同步</strong>：对各种操作实施时间上的定时。通过 <strong>时钟信号 (Clk)</strong> 来同步所有部件的动作（例如：规定在时钟上升沿更新 PC，在下降沿写入寄存器），保证计算机有条不紊地工作。</li>
</ul>
</li>
<li><strong>数据加工 (Data Processing)</strong>：<ul>
<li><strong>运算</strong>：利用 ALU 对数据进行算术运算（如 <code>add</code>）和逻辑运算（如 <code>ori</code>），这是 CPU 最根本的功能。</li>
</ul>
</li>
</ol>
<h3 id="2-取指令部件的功能是什么？"><a href="#2-取指令部件的功能是什么？" class="headerlink" title="2. 取指令部件的功能是什么？"></a>2. 取指令部件的功能是什么？</h3><p>根据 PPT <code>image_373184.png</code>，取指令部件 (Instruction Fetch Unit) 主要有两个核心功能：</p>
<ol>
<li><strong>取指令</strong>：根据程序计数器 (PC) 中的地址，从指令存储器 (Instruction Memory) 中读取出当前的指令字 (<code>M[PC]</code>)。</li>
<li><strong>更新 PC</strong>：计算下一条指令的地址。通常情况下是顺序执行 (<code>PC &lt;- PC + 4</code>)；如果是跳转或分支指令，则更新为目标跳转地址。</li>
</ol>
<hr>
<h3 id="3-控制器的功能是什么？"><a href="#3-控制器的功能是什么？" class="headerlink" title="3. 控制器的功能是什么？"></a>3. 控制器的功能是什么？</h3><p>根据 PPT image_2f0f80.png 和 image_2f0cd7.png 中展示的真值表逻辑：</p>
<p>控制器的功能是“翻译”和“指挥”。它接收指令中的 操作码 (op) 和 功能码 (func)，通过译码逻辑，产生一系列的 控制信号 (如 RegDst, ALUSrc, RegWr, MemtoReg 等)。这些信号控制着数据通路中各个多路选择器 (MUX)、ALU 和寄存器的动作，确保指令按预定逻辑执行。</p>
<hr>
<h3 id="4-单周期处理器相关问题"><a href="#4-单周期处理器相关问题" class="headerlink" title="4. 单周期处理器相关问题"></a>4. 单周期处理器相关问题</h3><ul>
<li><strong>单周期处理器的 CPI 是多少？</strong><ul>
<li><strong>CPI = 1</strong>。</li>
<li><strong>原因</strong>：顾名思义，单周期处理器每条指令都在一个时钟周期内完成。</li>
</ul>
</li>
<li><strong>时钟周期如何确定？</strong><ul>
<li>时钟周期取决于 <strong>最复杂指令（通常是 <code>lw</code>）的执行时间</strong>，也就是数据通路中的 <strong>关键路径 (Critical Path)</strong>。</li>
<li><strong>计算公式</strong>：$T_{cycle} \ge$ 取指时间 + 译码/读寄存器时间 + ALU运算时间 + 读数据存储器时间 + 写回时间。必须保证最慢的指令也能在一个周期内跑完。</li>
</ul>
</li>
<li><strong>为什么单周期处理器的性能差？</strong><ul>
<li>因为 <strong>时钟周期被“最慢的指令”拖累了</strong>。</li>
<li><strong>解释</strong>：虽然像 <code>add</code> 或 <code>beq</code> 这样的简单指令本来可以跑得很快（比如只要 400ps），但因为时钟周期必须迁就最慢的 <code>lw</code> 指令（比如 600ps），所以简单指令执行完后必须 <strong>空转等待</strong>，直到周期结束。这就造成了巨大的时间浪费，导致整体效率低下。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-单周期方式下，在一个指令周期内某个部件能否被重复使用多次？为什么？"><a href="#5-单周期方式下，在一个指令周期内某个部件能否被重复使用多次？为什么？" class="headerlink" title="5. 单周期方式下，在一个指令周期内某个部件能否被重复使用多次？为什么？"></a>5. 单周期方式下，在一个指令周期内某个部件能否被重复使用多次？为什么？</h3><ul>
<li><strong>回答</strong>：<strong>不能</strong>。</li>
<li><strong>为什么</strong>：<ul>
<li>在单周期设计中，指令的执行像水流一样流过数据通路，每个部件在每个周期内只能处理这一个指令流过的数据。</li>
<li>如果需要重复使用某个功能（例如需要做两次加法：一次算 PC+4，一次算 ALU 运算），硬件上必须 <strong>设置多份独立的部件</strong>（例如设置专门的加法器用于 PC 更新，见 <code>image_2dc282.png</code> 中的 Adder），而不能复用同一个 ALU。</li>
<li><strong>原因总结</strong>：如果复用，会产生 <strong>资源冲突 (Structural Hazard)</strong>，因为在一个时钟周期内，一个部件无法同时处理两个不同的任务。</li>
</ul>
</li>
</ul>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251227162818244.png" alt="image-20251227162818244"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20251227162825596.png" alt="image-20251227162825596"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>含义</strong></th>
<th><strong>格式</strong></th>
<th><strong>核心动作</strong></th>
<th><strong>关键区分点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>add</strong></td>
<td>加法</td>
<td><code>op rs rt rd shamt func</code></td>
<td>Reg + Reg -&gt; Reg</td>
<td>写 <strong>rd</strong></td>
</tr>
<tr>
<td><strong>sub</strong></td>
<td>减法</td>
<td><code>op rs rt rd shamt func</code></td>
<td>Reg - Reg -&gt; Reg</td>
<td>写 <strong>rd</strong></td>
</tr>
<tr>
<td><strong>ori</strong></td>
<td>逻辑或</td>
<td><code>op rs rt imm</code></td>
<td>Reg OR <strong>ZeroExt</strong>(Imm)</td>
<td><strong>零扩展</strong></td>
</tr>
<tr>
<td><strong>lw</strong></td>
<td>取数</td>
<td><code>op rs rt imm</code></td>
<td>Mem[Base+Off] -&gt; Reg</td>
<td><strong>读内存</strong>, 写 <strong>rt</strong></td>
</tr>
<tr>
<td><strong>sw</strong></td>
<td>存数</td>
<td><code>op rs rt imm</code></td>
<td>Reg -&gt; Mem[Base+Off]</td>
<td><strong>写内存</strong></td>
</tr>
<tr>
<td><strong>beq</strong></td>
<td>分支</td>
<td><code>op rs rt imm</code></td>
<td>if (Reg==Reg) Jump</td>
<td><strong>比较</strong>, 条件跳</td>
</tr>
<tr>
<td><strong>j</strong></td>
<td>跳转</td>
<td><code>op target</code></td>
<td>Goto Target</td>
<td><strong>无条件</strong>, 拼接地址</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-RegWr-寄存器写使能"><a href="#1-RegWr-寄存器写使能" class="headerlink" title="1. RegWr (寄存器写使能)"></a>1. <strong><code>RegWr</code> (寄存器写使能)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：允许将数据写入寄存器堆（用于 <code>R-type</code>, <code>ori</code>, <code>lw</code>）。</li>
<li><code>0</code>：禁止写入（用于 <code>sw</code>, <code>beq</code>, <code>j</code>）。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：寄存器堆的大门永远关上了，任何数据都写不进去。</li>
<li><strong>受影响指令</strong>：所有需要写回结果的指令，包括 <strong>R型指令 (<code>add</code>, <code>sub</code> 等)</strong>、<strong><code>ori</code></strong> 和 <strong><code>lw</code></strong>。它们虽然能算出结果，但存不下来，相当于白忙活。</li>
</ul>
<h4 id="2-RegDst-写入目标寄存器选择"><a href="#2-RegDst-写入目标寄存器选择" class="headerlink" title="2. RegDst (写入目标寄存器选择)"></a>2. <strong><code>RegDst</code> (写入目标寄存器选择)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：写入目标是 <code>rd</code> (指令 11-15 位)，用于 <strong>R型指令</strong>。</li>
<li><code>0</code>：写入目标是 <code>rt</code> (指令 16-20 位)，用于 <code>lw</code>, <code>ori</code>。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：写入数据的目的地永远被锁定在 <code>rt</code>。</li>
<li><strong>受影响指令</strong>：<strong>R型指令 (<code>add</code>, <code>sub</code> 等)</strong>。这些指令本该把结果存入 <code>rd</code>，现在却错误地覆盖了 <code>rt</code> 寄存器里的内容。<ul>
<li><em>注：<code>lw</code> 和 <code>ori</code> 本来就要选 0，所以它们不受影响。</em></li>
</ul>
</li>
</ul>
<h4 id="3-ALUSrc-ALU-源操作数选择"><a href="#3-ALUSrc-ALU-源操作数选择" class="headerlink" title="3. ALUSrc (ALU 源操作数选择)"></a>3. <strong><code>ALUSrc</code> (ALU 源操作数选择)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：ALU 的第二个输入选 <strong>立即数</strong> (用于 <code>lw</code>, <code>sw</code>, <code>ori</code>)。</li>
<li><code>0</code>：ALU 的第二个输入选 <strong>寄存器 B</strong> (用于 <code>R-type</code>, <code>beq</code>)。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：ALU 永远看不见立即数，只能看见寄存器 B。</li>
<li><strong>受影响指令</strong>：<strong><code>lw</code></strong>, <strong><code>sw</code></strong>, <strong><code>ori</code></strong>。这些指令需要用到立即数（算地址或做逻辑运算），信号错误会导致 ALU 使用错误的操作数进行计算。</li>
</ul>
<h4 id="4-Branch-分支信号"><a href="#4-Branch-分支信号" class="headerlink" title="4. Branch (分支信号)"></a>4. <strong><code>Branch</code> (分支信号)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：表示当前是分支指令，如果 <code>Zero=1</code> 则更新 PC 为跳转目标。</li>
<li><code>0</code>：表示顺序执行 PC+4。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：与门永远输出 0，PC 永远无法加载分支目标地址。</li>
<li><strong>受影响指令</strong>：<strong><code>beq</code></strong>。即使比较结果相等（应跳转），CPU 也会无视，继续执行下一条指令，导致分支失效。</li>
</ul>
<h4 id="5-MemWr-存储器写使能"><a href="#5-MemWr-存储器写使能" class="headerlink" title="5. MemWr (存储器写使能)"></a>5. <strong><code>MemWr</code> (存储器写使能)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：允许向数据存储器写入数据 (用于 <code>sw</code>)。</li>
<li><code>0</code>：只读不写。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：数据存储器变成了“只读”模式。</li>
<li><strong>受影响指令</strong>：<strong><code>sw</code></strong>。该指令的功能就是存数，写不进去就完全失效了。</li>
</ul>
<h4 id="6-ExtOp-扩展模式选择"><a href="#6-ExtOp-扩展模式选择" class="headerlink" title="6. ExtOp (扩展模式选择)"></a>6. <strong><code>ExtOp</code> (扩展模式选择)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：进行 <strong>符号扩展</strong> (Sign Extension)，用于 <code>lw</code>, <code>sw</code> (处理负偏移量)。</li>
<li><code>0</code>：进行 <strong>零扩展</strong> (Zero Extension)，用于 <code>ori</code>。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：所有立即数都按“零扩展”处理。</li>
<li><strong>受影响指令</strong>：<strong><code>lw</code></strong> 和 <strong><code>sw</code></strong>。<ul>
<li>如果偏移量是正数，运气好还能对；但如果偏移量是 <strong>负数</strong>，零扩展会把它变成一个巨大的正数，导致计算出的内存地址完全错误。</li>
</ul>
</li>
</ul>
<h4 id="7-R-type-R型指令标识"><a href="#7-R-type-R型指令标识" class="headerlink" title="7. R-type (R型指令标识)"></a>7. <strong><code>R-type</code> (R型指令标识)</strong></h4><ul>
<li><strong>正常功能</strong>：这通常是一个译码信号。当它为 <code>1</code> 时，ALU 控制器会去查看 <code>func</code> 字段来决定具体做什么运算（加、减、与、或等）。当它为 <code>0</code> 时，ALU 控制器通常执行默认操作（如加法，服务于 <code>lw/sw</code>）。</li>
<li><strong>若恒为 0</strong>：ALU 控制器认为当前“不是 R型指令”，因此忽略 <code>func</code> 字段，直接执行默认操作（通常是 <code>ADD</code>）。</li>
<li><strong>受影响指令</strong>：<strong>除了 <code>add</code> 以外的所有 R型指令 (<code>sub</code>, <code>and</code>, <code>or</code>, <code>slt</code> 等)</strong>。它们会被错误地执行成加法。</li>
</ul>
<h4 id="8-MemtoReg-写回数据来源选择"><a href="#8-MemtoReg-写回数据来源选择" class="headerlink" title="8. MemtoReg (写回数据来源选择)"></a>8. <strong><code>MemtoReg</code> (写回数据来源选择)</strong></h4><ul>
<li><strong>正常功能</strong>：<ul>
<li><code>1</code>：写回寄存器的数据来自 <strong>存储器</strong> (用于 <code>lw</code>)。</li>
<li><code>0</code>：写回寄存器的数据来自 <strong>ALU</strong> (用于 <code>R-type</code>, <code>ori</code>)。</li>
</ul>
</li>
<li><strong>若恒为 0</strong>：写回通路永远连着 ALU，断开了存储器。</li>
<li><strong>受影响指令</strong>：<strong><code>lw</code></strong>。该指令本想把从内存读出的数据存进寄存器，结果却错误地把内存地址（ALU 计算结果）存进去了。</li>
</ul>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>信号 (恒为1)</strong></th>
<th><strong>不能正确执行的指令</strong></th>
<th><strong>简要原因</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RegWr</strong></td>
<td><strong>sw, beq, j</strong></td>
<td>意外修改寄存器内容</td>
</tr>
<tr>
<td><strong>RegDst</strong></td>
<td><strong>lw, ori</strong></td>
<td>结果存错寄存器 (<code>rd</code> 而非 <code>rt</code>)</td>
</tr>
<tr>
<td><strong>ALUSrc</strong></td>
<td><strong>R-type, beq</strong></td>
<td>误用立即数代替寄存器运算</td>
</tr>
<tr>
<td><strong>Branch</strong></td>
<td><strong>运算结果为0的指令</strong></td>
<td>意外发生跳转</td>
</tr>
<tr>
<td><strong>MemWr</strong></td>
<td><strong>除 sw 外所有指令</strong></td>
<td>意外修改内存数据</td>
</tr>
<tr>
<td><strong>ExtOp</strong></td>
<td><strong>ori</strong></td>
<td>逻辑运算的高位扩展错误</td>
</tr>
<tr>
<td><strong>R-type</strong></td>
<td><strong>lw, sw, beq, ori</strong></td>
<td>ALU 执行了错误的操作</td>
</tr>
<tr>
<td><strong>MemtoReg</strong></td>
<td><strong>R-type, ori</strong></td>
<td>写入了内存值而非计算结果</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第六章作业"><a href="#第六章作业" class="headerlink" title="第六章作业"></a>第六章作业</h2><h3 id="2（1）"><a href="#2（1）" class="headerlink" title="2（1）"></a>2（1）</h3><h4 id="1-为什么“一条指令”的执行时间没有缩短？"><a href="#1-为什么“一条指令”的执行时间没有缩短？" class="headerlink" title="1. 为什么“一条指令”的执行时间没有缩短？"></a>1. 为什么“一条指令”的执行时间没有缩短？</h4><p>流水线技术并不是让“单条指令跑得更快”，而是将一条指令拆分成多个步骤（如 IF, ID, EX, MEM, WB）。</p>
<ul>
<li><strong>寄存器延迟（Overhead）</strong>：在流水线的每个阶段之间，都需要加入<strong>流水线寄存器</strong>来保存中间结果。这些寄存器本身有读写延迟（建立时间、保持时间）。</li>
<li><strong>木桶效应</strong>：流水线的时钟周期取决于<strong>最慢</strong>的那一个阶段。<ul>
<li>假设非流水线执行一条指令需要 800ps。</li>
<li>将其切分为 5 段流水线，每段 160ps。但因为要加上寄存器延迟（假设 10ps），周期可能变成了 170ps。</li>
<li>那么一条指令走完 5 个阶段总共需要 $170 \times 5 = 850\text{ps}$。</li>
</ul>
</li>
<li><strong>结论</strong>：单条指令从进入流水线到流出，所花费的总时间（潜伏期，Latency）反而因为寄存器的开销而略微增加了。</li>
</ul>
<h4 id="2-为什么“程序”的执行时间缩短了？"><a href="#2-为什么“程序”的执行时间缩短了？" class="headerlink" title="2. 为什么“程序”的执行时间缩短了？"></a>2. 为什么“程序”的执行时间缩短了？</h4><p>流水线的核心优势在于<strong>并行（Parallelism）\</strong>和*<em>吞吐率（Throughput）*</em>。</p>
<ul>
<li><p><strong>并行处理</strong>：虽然一条指令要 5 个周期才做完，但当第一条指令在做“第二步”时，第二条指令已经开始做“第一步”了。</p>
</li>
<li><p><strong>吞吐率提升</strong>：</p>
<ul>
<li><strong>非流水线</strong>：每 800ps 才能完成一条指令。</li>
<li><strong>流水线</strong>：一旦流水线填满，<strong>每 170ps 就能有一条指令完成</strong>（理想情况下）。</li>
</ul>
</li>
<li><p>数据证明：</p>
<p>参考你之前的 PPT image_edf843.png：</p>
<ul>
<li><strong>单周期方式</strong>执行 $N$ 条指令：时间 = $600N$ ps。</li>
<li><strong>流水线方式</strong>执行 $N$ 条指令：时间 = $234N$ ps。</li>
<li><strong>结论</strong>：$234N &lt; 600N$，程序的总执行时间被显著缩短了。</li>
</ul>
</li>
</ul>
<h3 id="2（5）"><a href="#2（5）" class="headerlink" title="2（5）"></a>2（5）</h3><h4 id="1-为什么要各流水段之间加寄存器？"><a href="#1-为什么要各流水段之间加寄存器？" class="headerlink" title="(1) 为什么要各流水段之间加寄存器？"></a>(1) 为什么要各流水段之间加寄存器？</h4><p>简单来说，流水线寄存器（Pipeline Registers）是实现“流水线”功能的物理基础。</p>
<ul>
<li><strong>保存中间结果（记忆功能）</strong>：每个时钟周期结束时，当前阶段完成的工作（比如计算出的地址、读出的寄存器值）必须被保存下来，才能在下一个时钟周期传给下一阶段使用。如果没有寄存器，信号会瞬间流过整个电路，变成单周期处理器，无法并行。</li>
<li><strong>隔离各个阶段（解耦）</strong>：寄存器像一堵墙，把复杂的组合逻辑电路切成了 5 小段。这样，第 1 段在取指时，第 2 段可以同时在译码，互不干扰。</li>
<li><strong>同步时钟</strong>：所有的流水线寄存器由同一个时钟信号控制，确保所有指令像排队一样，整齐划一地每过一个周期向前挪一步。</li>
</ul>
<h4 id="2-各流水段寄存器的宽度是否都一样？"><a href="#2-各流水段寄存器的宽度是否都一样？" class="headerlink" title="(2) 各流水段寄存器的宽度是否都一样？"></a>(2) 各流水段寄存器的宽度是否都一样？</h4><p><strong>不一样。</strong></p>
<h4 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="(3) 为什么？"></a>(3) 为什么？</h4><p>因为<strong>每个阶段需要传递给后续阶段的信息量是不同的</strong>。</p>
<p>流水线寄存器的宽度取决于<strong>后面所有的阶段需要用到哪些信息</strong>。所有的信息（包括数据信号和控制信号）都必须像接力棒一样，一层一层往下传。</p>
<p>我们可以具体拆解一下（以标准的 MIPS 32位 5级流水线为例）：</p>
<ol>
<li><strong>IF/ID 寄存器（通常最窄）</strong>：<ul>
<li>只需要保存：指令本身（32位） + 下一条指令地址 PC+4（32位）。</li>
<li>总宽约 <strong>64位</strong>。</li>
</ul>
</li>
<li><strong>ID/EX 寄存器（通常最宽）</strong>：<ul>
<li>这一步刚把指令翻译完，需要把所有原材料都带上：读出的两个寄存器数据（32+32位）、扩展后的立即数（32位）、PC+4（32位）、写回的目标寄存器号（5位），再加上一大堆控制信号（WB, MEM, EX 段的信号）。</li>
<li>总宽往往超过 <strong>100位</strong>。</li>
</ul>
</li>
<li><strong>EX/MEM 寄存器</strong>：<ul>
<li>ALU用完的数据不需要传了，但算出的结果要传：ALU计算结果（32位）、准备写入内存的数据（32位）、写回目标寄存器号（5位）以及剩下的控制信号。</li>
<li>宽度变小。</li>
</ul>
</li>
<li><strong>MEM/WB 寄存器</strong>：<ul>
<li>内存操作完，只需要传：读取的内存数据（32位）、ALU结果（32位）、写回目标寄存器号（5位）以及最后的 WB 控制信号。</li>
<li>宽度进一步变化。</li>
</ul>
</li>
</ol>
<h3 id="3-3"><a href="#3-3" class="headerlink" title="3"></a>3</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20260103173952347.png" alt="image-20260103173952347"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20260103173719006.png" alt="image-20260103173719006"></p>
<p>首先，我们根据题目给出的数据，列出当前各个阶段的耗时：</p>
<ul>
<li><strong>IF (取指)</strong>：使用存储单元 $\rightarrow$ <strong>200ps</strong></li>
<li><strong>ID (译码)</strong>：寄存器堆读 $\rightarrow$ <strong>50ps</strong></li>
<li><strong>EX (执行)</strong>：ALU 和加法器 $\rightarrow$ <strong>150ps</strong></li>
<li><strong>MEM (访存)</strong>：使用存储单元 $\rightarrow$ <strong>200ps</strong></li>
<li><strong>WB (写回)</strong>：寄存器堆写 $\rightarrow$ <strong>50ps</strong></li>
</ul>
<p>当前基准时钟周期：</p>
<p>$T_{clk} = \max(200, 50, 150, 200, 50) = \mathbf{200\text{ps}}$。</p>
<p>目前的瓶颈是 IF 和 MEM 阶段。</p>
<h4 id="1-若-EX-阶段的-ALU-时间缩短-20"><a href="#1-若-EX-阶段的-ALU-时间缩短-20" class="headerlink" title="(1) 若 EX 阶段的 ALU 时间缩短 20%"></a>(1) 若 EX 阶段的 ALU 时间缩短 20%</h4><ul>
<li><strong>计算</strong>：新的 ALU 时间 = $150\text{ps} \times (1 - 20\%) = 120\text{ps}$。</li>
<li><strong>分析</strong>：此时流水线各段最长时间依然是 IF 和 MEM 的 <strong>200ps</strong>。EX 阶段本来就不是瓶颈（150ps &lt; 200ps），缩短它只会让它等待的时间更长（气泡更多）。</li>
<li><strong>结论</strong>：<strong>不能加快</strong>流水线执行速度。时钟周期仍然维持在 <strong>200ps</strong>。</li>
</ul>
<h4 id="2-若-ALU-操作时间增加-20"><a href="#2-若-ALU-操作时间增加-20" class="headerlink" title="(2) 若 ALU 操作时间增加 20%"></a>(2) 若 ALU 操作时间增加 20%</h4><ul>
<li><strong>计算</strong>：新的 ALU 时间 = $150\text{ps} \times (1 + 20\%) = 180\text{ps}$。</li>
<li><strong>分析</strong>：虽然 ALU 变慢了，但 <strong>180ps</strong> 仍然小于最慢的存储器访问时间（<strong>200ps</strong>）。流水线的“短板”依然是存储器。</li>
<li><strong>结论</strong>：对流水线性能<strong>没有影响</strong>。时钟周期仍然维持在 <strong>200ps</strong>。</li>
</ul>
<h4 id="3-若-ALU-操作时间增加-40"><a href="#3-若-ALU-操作时间增加-40" class="headerlink" title="(3) 若 ALU 操作时间增加 40%"></a>(3) 若 ALU 操作时间增加 40%</h4><ul>
<li><strong>计算</strong>：新的 ALU 时间 = $150\text{ps} \times (1 + 40\%) = \mathbf{210\text{ps}}$。</li>
<li><strong>分析</strong>：此时 EX 阶段的时间（210ps）超过了原本的瓶颈（200ps）。<ul>
<li>旧瓶颈：200ps</li>
<li>新瓶颈：210ps</li>
<li>根据木桶效应，时钟周期必须迁就最慢的阶段。</li>
</ul>
</li>
<li><strong>结论</strong>：流水线性能<strong>会下降</strong>。时钟周期必须调整为 <strong>210ps</strong>，导致整体运行速度变慢。</li>
</ul>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4"></a>4</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20260103175033363.png" alt="image-20260103175033363"></p>
<h4 id="1-在非流水线处理器上执行该程序需要花多长时间？"><a href="#1-在非流水线处理器上执行该程序需要花多长时间？" class="headerlink" title="(1) 在非流水线处理器上执行该程序需要花多长时间？"></a><strong>(1) 在非流水线处理器上执行该程序需要花多长时间？</strong></h4><p>非流水线处理器采用串行执行方式，上一条指令完全做完，下一条才开始。</p>
<ul>
<li><p><strong>计算公式</strong>：$\text{总时间} = \text{指令条数} \times \text{单条指令执行时间}$</p>
</li>
<li><p>计算过程：</p>
</li>
</ul>
<script type="math/tex; mode=display">T_{\text{non-pipe}} = 10^6 \times 100\text{ps} = 10^8\text{ps}</script><ul>
<li>单位换算：</li>
</ul>
<script type="math/tex; mode=display">10^8\text{ps} = 100,000\text{ns} = 100\mu\text{s}</script><p><strong>答案：</strong> 需要花 <strong>$100\mu\text{s}$</strong>（或者写 <strong>$10^8\text{ps}$</strong>）。</p>
<h4 id="2-若新-CPU-采用-20-级流水线，理想情况下，它比非流水线处理器快多少？"><a href="#2-若新-CPU-采用-20-级流水线，理想情况下，它比非流水线处理器快多少？" class="headerlink" title="(2) 若新 CPU 采用 20 级流水线，理想情况下，它比非流水线处理器快多少？"></a><strong>(2) 若新 CPU 采用 20 级流水线，理想情况下，它比非流水线处理器快多少？</strong></h4><p>这道题可以从两个角度回答，一个是计算加速比，一个是计算具体时间。题目问的是“快多少”（倍数），通常指加速比。</p>
<ul>
<li><p><strong>理想流水线假设</strong>：</p>
<ol>
<li>流水线各段 perfectly balanced（完全平衡），每段耗时相等。</li>
<li>没有流水线填充时间的损耗（当 $N$ 很大时，$k-1$ 个填充周期可忽略）。</li>
</ol>
</li>
<li><p>流水线时钟周期：</p>
</li>
</ul>
<script type="math/tex; mode=display">T_{\text{clk}} = \frac{\text{非流水线指令时间}}{\text{流水线级数}} = \frac{100\text{ps}}{20} = 5\text{ps}</script><ul>
<li>流水线总执行时间：</li>
</ul>
<script type="math/tex; mode=display">T_{\text{pipe}} \approx N \times T_{\text{clk}} = 10^6 \times 5\text{ps} = 5 \times 10^6\text{ps}</script><p>  (注：精确公式为 $(N + k - 1) \times T_{\text{clk}}$，但 $10^6 \gg 19$，故忽略不计)</p>
<ul>
<li>计算加速比 (Speedup)：</li>
</ul>
<script type="math/tex; mode=display">\text{Speedup} = \frac{T_{\text{non-pipe}}}{T_{\text{pipe}}} = \frac{100 \times 10^6\text{ps}}{5 \times 10^6\text{ps}} = 20</script><p>答案： 理想情况下，它比非流水线处理器快 20 倍。</p>
<p>(一句话结论：理想情况下，多少级流水线，就获得多少倍的加速比)</p>
<h4 id="3-实际流水线并是不是理想的，流水段之间的数据传送会有额外开销。这些开销是否会影响指令执行时间和指令吞吐率？"><a href="#3-实际流水线并是不是理想的，流水段之间的数据传送会有额外开销。这些开销是否会影响指令执行时间和指令吞吐率？" class="headerlink" title="(3) 实际流水线并是不是理想的，流水段之间的数据传送会有额外开销。这些开销是否会影响指令执行时间和指令吞吐率？"></a><strong>(3) 实际流水线并是不是理想的，流水段之间的数据传送会有额外开销。这些开销是否会影响指令执行时间和指令吞吐率？</strong></h4><p>这是一个考察对流水线“潜伏期（Latency）”和“吞吐率（Throughput）”概念理解的问题。</p>
<p><strong>回答：是的，会有影响。</strong> 具体分析如下：</p>
<ol>
<li><strong>对“指令执行时间”（Latency）的影响：</strong> <strong>会变长。</strong><ul>
<li><strong>定义</strong>：指一条指令从进入流水线第一段到最后一段完成所需要的总时间。</li>
<li><strong>分析</strong>：在非流水线中，时间纯粹是逻辑电路的操作时间（$100\text{ps}$）。在流水线中，为了保存中间结果，每一级之间都要加入<strong>流水线寄存器</strong>。这些寄存器有建立时间、保持时间等物理延迟（Overhead）。</li>
<li><strong>结果</strong>：一条指令在流水线中走完 20 级，总耗时 = $20 \times (\text{理想每级时间} + \text{寄存器延迟})$。这个总和一定大于原来的 $100\text{ps}$。</li>
</ul>
</li>
<li><strong>对“指令吞吐率”（Throughput）的影响：</strong> <strong>会降低（相比理想流水线）。</strong><ul>
<li><strong>定义</strong>：指单位时间内完成的指令数量（$\text{TP} = \frac{1}{T_{\text{clk}}}$）。</li>
<li><strong>分析</strong>：流水线的时钟周期 $T_{\text{clk}}$ 必须足够长，以容纳最慢的一段逻辑操作加上寄存器的延迟开销。</li>
<li><strong>结果</strong>：实际时钟周期 $T<em>{\text{actual}} = 5\text{ps} + \text{Overhead}$。因为分母变大了，所以吞吐率 $\frac{1}{T</em>{\text{actual}}}$ 会比理想吞吐率 $\frac{1}{5\text{ps}}$ 要低。</li>
</ul>
</li>
</ol>
<p>总结答案：</p>
<p>会影响。</p>
<ul>
<li><strong>指令执行时间（单条延迟）</strong>：会<strong>增加</strong>（因为加入了流水线寄存器的延迟开销）。</li>
<li><strong>指令吞吐率</strong>：会<strong>降低</strong>（相比于没有开销的理想流水线，因为时钟周期被迫变长了）。</li>
</ul>
<h3 id="6-2"><a href="#6-2" class="headerlink" title="6"></a>6</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/image-20260103175023088.png" alt="image-20260103175023088"></p>
<h4 id="1-哪些指令对之间发生数据相关（Data-Dependency）？"><a href="#1-哪些指令对之间发生数据相关（Data-Dependency）？" class="headerlink" title="1. 哪些指令对之间发生数据相关（Data Dependency）？"></a>1. 哪些指令对之间发生数据相关（Data Dependency）？</h4><p>我们要找出“写后读”（RAW, Read After Write）的依赖关系。</p>
<ul>
<li><strong>第一组相关：<code>$s3</code></strong><ul>
<li><strong>产生者</strong>：第 1 条指令 <code>addu $s3, $s1, $s0</code> （写入 <code>$s3</code>）</li>
<li><strong>消费者</strong>：第 2 条指令 <code>addu $t2, $s3, $s3</code> （读取 <code>$s3</code>）</li>
<li><strong>描述</strong>：第 2 条指令依赖第 1 条指令的结果。</li>
</ul>
</li>
<li><strong>第二组相关：<code>$t2</code></strong><ul>
<li><strong>产生者</strong>：第 2 条指令 <code>addu $t2, $s3, $s3</code> （写入 <code>$t2</code>）</li>
<li><strong>消费者</strong>：第 3 条指令 <code>lw $t1, 0($t2)</code> （读取 <code>$t2</code> 作为基地址）</li>
<li><strong>以及</strong>：第 4 条指令 <code>add $t3, $t1, $t2</code> （读取 <code>$t2</code>）</li>
<li><strong>描述</strong>：第 3 条和第 4 条指令都依赖第 2 条指令的结果。</li>
</ul>
</li>
<li><strong>第三组相关：<code>$t1</code></strong><ul>
<li><strong>产生者</strong>：第 3 条指令 <code>lw $t1, 0($t2)</code> （写入 <code>$t1</code>）</li>
<li><strong>消费者</strong>：第 4 条指令 <code>add $t3, $t1, $t2</code> （读取 <code>$t1</code>）</li>
<li><strong>描述</strong>：第 4 条指令依赖第 3 条指令的结果。</li>
</ul>
</li>
</ul>
<h4 id="2-如果不用“转发”技术，需要加几条-NOP？"><a href="#2-如果不用“转发”技术，需要加几条-NOP？" class="headerlink" title="2. 如果不用“转发”技术，需要加几条 NOP？"></a>2. 如果不用“转发”技术，需要加几条 NOP？</h4><p><strong>规则分析</strong>： 在没有转发机制的标准 5 段流水线中，数据必须在 <strong>WB（写回）</strong> 阶段写入寄存器堆后，才能在 <strong>ID（译码）</strong> 阶段被后续指令读取。</p>
<ul>
<li>写操作发生在第 5 个时钟周期（WB）。</li>
<li>读操作发生在第 2 个时钟周期（ID）。</li>
<li>这意味着，产生数据的指令必须先完成 WB 阶段，使用数据的指令才能进入 ID 阶段。对于相邻的两条相关指令，中间通常需要间隔 <strong>2 个时钟周期</strong>（即插入 2 条 NOP）。</li>
</ul>
<p><strong>具体插入情况</strong>：</p>
<ol>
<li><p><strong>在第 1 条和第 2 条之间（解决 <code>$s3</code> 相关）：</strong> 需要插入 <strong>2 条 NOP</strong>。</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addu $s3, $s1, $s0</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">addu $t2, $s3, $s3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在第 2 条和第 3 条之间（解决 <code>$t2</code> 相关）：</strong> 需要插入 <strong>2 条 NOP</strong>。</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addu $t2, $s3, $s3</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">lw   $t1, 0($t2)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在第 3 条和第 4 条之间（解决 <code>$t1</code> 相关）：</strong> 需要插入 <strong>2 条 NOP</strong>。</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lw   $t1, 0($t2)</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">add  $t3, $t1, $t2</span><br></pre></td></tr></table></figure>
<p><em>(注：虽然第 4 条也依赖第 2 条的 <code>$t2</code>，但因为中间已经隔了第 3 条指令和它的 NOP，所以 <code>$t2</code> 的数据早就准备好了，不需要额外处理)</em></p>
</li>
</ol>
<p><strong>结论（无转发）</strong>： 需要在每组发生数据相关的相邻指令前加入 <strong>2 条 NOP</strong> 指令。</p>
<h4 id="3-如果采用“转发”，是否可以完全解决数据冒险？"><a href="#3-如果采用“转发”，是否可以完全解决数据冒险？" class="headerlink" title="3. 如果采用“转发”，是否可以完全解决数据冒险？"></a>3. 如果采用“转发”，是否可以完全解决数据冒险？</h4><p><strong>回答：不可以。</strong></p>
<p><strong>原因分析（Load-Use 冒险）</strong>：</p>
<ul>
<li><strong>ALU 到 ALU 的冒险</strong>（如第 1、2 条之间，第 2、3 条之间）可以通过转发完全解决。数据在 EX 阶段算出后，可以直接从流水线寄存器转发给下一条指令的 EX 阶段输入。</li>
<li><strong>Load 到 ALU 的冒险</strong>（即第 3 条 <code>lw</code> 和第 4 条 <code>add</code> 之间）无法完全解决。<ul>
<li><code>lw</code> 指令的数据是在 <strong>MEM（访存）</strong> 阶段结束时才从内存读出的（时钟周期 4）。</li>
<li><code>add</code> 指令需要在 <strong>EX（执行）</strong> 阶段开始时使用数据进行计算（时钟周期 3）。</li>
<li><strong>时间悖论</strong>：数据在未来（第 4 周期）才产生，但现在（第 3 周期）就要用。这是物理上做不到的，这被称为 <strong>Load-Use Hazard</strong>。</li>
</ul>
</li>
</ul>
<h4 id="4-如果不行，需要加入几条-NOP？"><a href="#4-如果不行，需要加入几条-NOP？" class="headerlink" title="4. 如果不行，需要加入几条 NOP？"></a>4. 如果不行，需要加入几条 NOP？</h4><p>针对上述的 <strong>Load-Use 冒险</strong>，必须让流水线暂停一个周期，等待数据从内存读出。</p>
<ul>
<li><strong>位置</strong>：在第 3 条 <code>lw</code> 和第 4 条 <code>add</code> 之间。</li>
<li><strong>数量</strong>：<strong>1 条 NOP</strong>。<ul>
<li>加了 1 条 NOP 后，<code>add</code> 指令晚一个周期进入 EX 阶段，此时 <code>lw</code> 刚好走完 MEM 阶段，数据可以通过 MEM/WB 寄存器转发给 <code>add</code>。</li>
</ul>
</li>
</ul>
<p><strong>最终代码序列（采用转发）</strong>：</p>
<p>MIPS Assembler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addu $s3, $s1, $s0</span><br><span class="line">addu $t2, $s3, $s3   # 转发解决，无 NOP</span><br><span class="line">lw   $t1, 0($t2)     # 转发解决，无 NOP</span><br><span class="line">nop                  # 【必须加 1 条 NOP 解决 Load-Use 冒险】</span><br><span class="line">add  $t3, $t1, $t2</span><br></pre></td></tr></table></figure>
<p><strong>结论（有转发）</strong>： 需要在发生数据相关的第 4 条指令（<code>add</code>）之前加入 <strong>1 条 NOP</strong> 指令。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-23 20:47:14" itemprop="dateModified" datetime="2025-12-23T20:47:14+08:00">2025-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h3><h4 id="并发性-Concurrency"><a href="#并发性-Concurrency" class="headerlink" title="并发性 (Concurrency)"></a><strong>并发性 (Concurrency)</strong></h4><p>🔍 核心定义</p>
<blockquote>
<p><strong>并发性</strong>是指两个或两个以上的事件或活动在<strong>同一时间间隔内</strong>发生。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：“同一时间间隔” ≠ “同一时刻”。它强调的是“看起来同时”，而不是“真正同时”。</li>
</ul>
<p>📌 操作系统中的体现</p>
<ol>
<li><p><strong>多个 I/O 设备同时工作</strong>：</p>
<ul>
<li>你的键盘在输入，打印机在打印，网卡在收发数据。这些设备都在“同时”工作。</li>
</ul>
</li>
<li><p><strong>I/O 和 CPU 计算同时进行</strong>：</p>
<ul>
<li>当 CPU 在计算时，I/O 设备可能在后台传输数据。CPU 不需要等待 I/O 完成，可以去处理其他任务。</li>
</ul>
</li>
<li><p><strong>内存中多个程序交替执行</strong>：</p>
<ul>
<li>这是最核心的体现。操作系统通过<strong>时间片轮转</strong>（Time-Slicing）等调度算法，让多个程序“轮流”使用 CPU，从而实现“宏观上的并发”。</li>
</ul>
</li>
</ol>
<p>🖼️ 并发 vs 并行</p>
<p>这是你 PPT 中提出的关键问题！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">并发 (Concurrency)</th>
<th style="text-align:left">并行 (Parallelism)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义</strong></td>
<td style="text-align:left">多个任务在<strong>同一时间间隔内</strong>交替执行。</td>
<td style="text-align:left">多个任务在<strong>同一时刻</strong>真正同时执行。</td>
</tr>
<tr>
<td style="text-align:left"><strong>物理基础</strong></td>
<td style="text-align:left">单 CPU 系统即可实现。</td>
<td style="text-align:left">需要多核 CPU 或多处理器系统。</td>
</tr>
<tr>
<td style="text-align:left"><strong>效果</strong></td>
<td style="text-align:left">“看起来”同时进行。</td>
<td style="text-align:left">“真正”同时进行。</td>
</tr>
<tr>
<td style="text-align:left"><strong>类比</strong></td>
<td style="text-align:left">一个人在厨房里，一会儿切菜，一会儿炒菜，一会儿洗碗。</td>
<td style="text-align:left">三个人在厨房里，一个人切菜，一个人炒菜，一个人洗碗。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>✅ <strong>一句话总结</strong>：<strong>并行是并发的一种特例</strong>。并发是“逻辑上的同时”，并行是“物理上的同时”。</p>
</blockquote>
<h4 id="共享性-Sharing"><a href="#共享性-Sharing" class="headerlink" title="共享性 (Sharing)"></a><strong>共享性 (Sharing)</strong></h4><p>🔍 核心定义</p>
<blockquote>
<p><strong>共享性</strong>指操作系统中的资源（包括硬件资源和软件资源）可被<strong>多个并发执行的进程共同使用</strong>，而不是被一个进程所独占。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：共享不等于“无限制访问”，它必须在<strong>操作系统管理下</strong>进行，以保证安全和有序。</li>
</ul>
<p>📌 资源共享的方式</p>
<p>1️⃣ 透明资源共享 / 同时共享方式</p>
<ul>
<li><strong>含义</strong>：允许多个进程在<strong>同一时间段内</strong>对资源进行访问，好像每个进程都独占资源一样。</li>
<li><strong>特点</strong>：<ul>
<li>访问的次序对结果无影响。</li>
<li>通常用于<strong>可重入</strong>或<strong>只读</strong>的资源。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li><strong>CPU</strong>：通过时间片轮转，让多个进程“同时”使用 CPU。</li>
<li><strong>主存 (RAM)</strong>：多个进程的代码和数据可以同时存在于内存中。</li>
<li><strong>磁盘</strong>：多个进程可以同时读取磁盘上的不同文件。</li>
<li><strong>打印机</strong>：虽然物理上一次只能打印一个任务，但操作系统可以通过“打印队列”实现逻辑上的“同时共享”。</li>
</ul>
</li>
</ul>
<p>2️⃣ 独占资源共享 / 互斥共享方式</p>
<ul>
<li><strong>含义</strong>：在<strong>同一时间段内</strong>只允许<strong>一个进程</strong>访问资源。</li>
<li><strong>特点</strong>：<ul>
<li>这类资源称为<strong>临界资源 (Critical Resource)</strong>。</li>
<li>必须通过<strong>互斥机制</strong>（如锁、信号量）来保护。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li><strong>磁带机</strong>：一次只能由一个进程控制。</li>
<li><strong>扫描仪</strong>：一次只能扫描一份文档。</li>
<li><strong>数据库中的某一行记录</strong>：如果两个事务同时修改同一行，会导致数据不一致。</li>
</ul>
</li>
</ul>
<p>🛠️ 操作系统如何管理共享？</p>
<ul>
<li><strong>提供显式资源共享机制</strong>：如 <code>fork()</code>, <code>semaphore</code>, <code>mutex</code>, <code>lock</code> 等系统调用。</li>
<li><strong>将互斥访问下放给用户决策</strong>：程序员需要自己负责加锁和解锁，操作系统提供工具。</li>
</ul>
<h4 id="异步性-Asynchrony"><a href="#异步性-Asynchrony" class="headerlink" title="异步性 (Asynchrony)"></a>异步性 (Asynchrony)</h4><p>🔍 核心定义</p>
<blockquote>
<p><strong>异步性</strong>指在多道程序环境中，由于资源有限而进程众多，多数情况下，进程的执行不是一气呵成，而是“走走停停”。</p>
</blockquote>
<ul>
<li><strong>关键点</strong>：进程的执行是不可预测的，它的推进速度取决于系统调度、I/O 等待、中断等多种因素。</li>
</ul>
<p>📌 异步性的表现</p>
<ol>
<li><p><strong>作业到达系统的时间和类型不确定</strong>：</p>
<ul>
<li>用户随时可能启动一个新程序。</li>
</ul>
</li>
<li><p><strong>操作员发出命令或操作的时间和类型不确定</strong>：</p>
<ul>
<li>用户可能随时按下键盘或点击鼠标。</li>
</ul>
</li>
<li><p><strong>程序运行发生错误或异常的类型和时刻不确定</strong>：</p>
<ul>
<li>程序可能因为除零、内存溢出等原因崩溃。</li>
</ul>
</li>
<li><p><strong>中断事件发生的时刻不确定</strong>：</p>
<ul>
<li>时钟中断、I/O 中断、硬件故障中断等都是随机发生的。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[并发性] --&gt; B[多个任务同时执行]</span><br><span class="line">    C[共享性] --&gt; D[资源被多个任务共同使用]</span><br><span class="line">    E[异步性] --&gt; F[任务执行“走走停停”]</span><br><span class="line"></span><br><span class="line">    B &amp; D &amp; F --&gt; G[现代操作系统的核心特征]</span><br><span class="line">    G --&gt; H[实现多任务、多用户环境]</span><br></pre></td></tr></table></figure>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><blockquote>
<p><strong>多道程序设计</strong>是指允许多个程序<strong>同时</strong>驻留在内存中，并由操作系统<strong>统一管理和调度</strong>，使它们<strong>交替</strong>（并发）地使用 CPU 和其他系统资源。 </p>
</blockquote>
<ul>
<li><strong>核心目的</strong>：<strong>掩盖 I/O 等待时间，提高 CPU 和系统资源的利用率</strong>。</li>
<li><strong>终极目标</strong>：让昂贵的 CPU <strong>永远不要闲着</strong>！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 单道程序 vs 多道程序</span><br><span class="line">    dateFormat  HH:mm:ss</span><br><span class="line">    axisFormat  %Ss</span><br><span class="line"></span><br><span class="line">    section 单道程序</span><br><span class="line">    作业A-CPU     :crit, a1, 00:00:00, 2s</span><br><span class="line">    作业A-I/O     :active, a2, after a1, 8s</span><br><span class="line">    作业A-CPU     :crit, a3, after a2, 2s</span><br><span class="line">    作业A-I/O     :active, a4, after a3, 8s</span><br><span class="line"></span><br><span class="line">    section 多道程序</span><br><span class="line">    作业A-CPU     :crit, b1, 00:00:00, 2s</span><br><span class="line">    作业B-CPU     :crit, b2, after b1, 2s</span><br><span class="line">    作业C-CPU     :crit, b3, after b2, 2s</span><br><span class="line">    作业A-I/O     :active, b4, after b1, 8s</span><br><span class="line">    作业B-I/O     :active, b5, after b2, 8s</span><br><span class="line">    作业C-I/O     :active, b6, after b3, 8s</span><br></pre></td></tr></table></figure>
<p><strong>对比</strong>：在多道程序中，当作业 A 在等待 I/O 时，CPU 立刻去执行作业 B 和 C。CPU 几乎没有空闲时间，利用率接近 100%！</p>
<h4 id="cpu利用率"><a href="#cpu利用率" class="headerlink" title="cpu利用率"></a>cpu利用率</h4><p><code>CPU利用率 = 1 - p^n</code> </p>
<p>🔍 假设条件</p>
<ol>
<li><strong>系统中有 <code>n</code> 个程序</strong> 同时在内存中。</li>
<li><strong>每个程序平均有 <code>p</code> 的概率在等待 I/O 操作</strong>。<ul>
<li>例如，<code>p = 0.8</code> 表示一个程序有 80% 的时间在等磁盘读写、键盘输入等，只有 20% 的时间在真正使用 CPU。</li>
</ul>
</li>
<li><strong>各个程序的等待操作是相互独立的</strong>。<ul>
<li>这是一个关键假设，意味着一个程序是否在等 I/O，不影响其他程序。</li>
</ul>
</li>
</ol>
<p>💡 公式推导</p>
<ul>
<li><strong>CPU 空闲的概率</strong>：当且仅当<strong>所有 <code>n</code> 个程序都在等待 I/O</strong> 时，CPU 才会空闲。</li>
<li>因为每个程序等待 I/O 的概率是 <code>p</code>，且它们相互独立，所以<strong>所有 <code>n</code> 个程序都等待 I/O 的概率是 <code>p^n</code></strong>。</li>
<li><strong>因此，CPU 空闲的概率 = <code>p^n</code></strong>。</li>
<li><strong>CPU 利用率 = 1 - CPU 空闲的概率 = <code>1 - p^n</code></strong>。</li>
</ul>
<p>若进程平均花费 80% 的时间等待 I/O，则为了使得 CPU 利用率不低于 80%，应至少有多少道程序在主存中运行？</p>
<h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>根据公式：</p>
<p>CPU利用率 = 1 - p^n ≥ 0.8</p>
<p>移项得：</p>
<p>p^n ≤ 0.2</p>
<p>代入 <code>p = 0.8</code>：</p>
<p>0.8^n ≤ 0.2</p>
<p>两边取对数（以 10 为底或自然对数均可）：</p>
<p>n * log(0.8) ≤ log(0.2)</p>
<p>注意：<code>log(0.8)</code> 是负数，所以在除的时候要<strong>反转不等号方向</strong>：</p>
<p>n ≥ log(0.2) / log(0.8)</p>
<p>计算数值：</p>
<ul>
<li><code>log(0.2) ≈ -0.69897</code></li>
<li><code>log(0.8) ≈ -0.09691</code></li>
<li><code>n ≥ (-0.69897) / (-0.09691) ≈ 7.21</code></li>
</ul>
<p>因为 <code>n</code> 必须是整数，且要满足 <code>n ≥ 7.21</code>，所以：</p>
<blockquote>
<p><strong><code>n = 8</code></strong> </p>
</blockquote>
<p>✅ 最终答案</p>
<p><strong>为了使得 CPU 利用率不低于 80%，应至少有 8 道程序在主存中运行。</strong></p>
<h4 id="是不是同时运行的程序越多越好？"><a href="#是不是同时运行的程序越多越好？" class="headerlink" title="是不是同时运行的程序越多越好？"></a>是不是同时运行的程序越多越好？</h4><p><strong>不是！同时运行的程序（道数）并不是越多越好。存在一个最优的“道数”，超过这个值，系统的整体效率反而会下降。</strong> </p>
<p>当道数 <code>n</code> 超过某个临界值后，系统性能会急剧下降。主要原因有：</p>
<p>1️⃣ <strong>上下文切换开销 (Context Switching Overhead)</strong></p>
<p><strong>什么是上下文切换？</strong></p>
<ul>
<li>当操作系统从一个进程切换到另一个进程时，它需要保存当前进程的状态（寄存器、内存映射、程序计数器等），并加载下一个进程的状态。</li>
</ul>
<p>2️⃣ <strong>内存压力 (Memory Pressure)</strong></p>
<ul>
<li><strong>每个进程都需要内存</strong>：代码段、数据段、堆、栈、页表等。</li>
</ul>
<p>3️⃣ <strong>资源竞争加剧 (Resource Contention)</strong></p>
<ul>
<li><strong>锁竞争</strong>：多个进程同时访问共享资源（如数据库连接池、文件锁），需要排队等待，增加了延迟。</li>
<li><strong>缓存失效</strong>：多个进程的指令和数据交替进入 CPU 缓存，导致缓存命中率降低，CPU 需要更频繁地从内存读取数据。</li>
</ul>
<h3 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h3><h4 id="为什么需要两种处理器状态？"><a href="#为什么需要两种处理器状态？" class="headerlink" title="为什么需要两种处理器状态？"></a>为什么需要两种处理器状态？</h4><p>现代计算机是一个多用户、多任务的环境。如果所有程序都能随意执行任何指令，那么一个不小心的 bug 或一个恶意程序就可能：</p>
<ul>
<li>格式化硬盘。</li>
<li>修改系统时间。</li>
<li>访问其他用户的隐私数据。</li>
<li>导致系统崩溃。</li>
</ul>
<p>为了避免这种情况，CPU 被设计成有两种工作模式：</p>
<ol>
<li><strong>用户态 (User Mode)</strong>：普通程序运行的状态，只能执行“安全”的指令。</li>
<li><strong>核心态 (Kernel Mode / Supervisor Mode)</strong>：操作系统内核运行的状态，可以执行所有指令，包括“危险”的特权指令。</li>
</ol>
<h4 id="程序状态字-PSW"><a href="#程序状态字-PSW" class="headerlink" title="程序状态字 (PSW)"></a>程序状态字 (PSW)</h4><p><strong>Program Status Word (PSW)</strong> 是一个非常重要的寄存器。</p>
<ul>
<li><strong>定义</strong>：PSW 是 CPU 内部的一个特殊寄存器，用于存储当前处理器的各种状态信息。</li>
<li><strong>关键作用</strong>：PSW 中有一个<strong>标志位</strong>（通常是最高位或某一位），用来标识当前 CPU 处于<strong>用户态还是核心态</strong>。<ul>
<li><code>PSW[bit] = 0</code> → 用户态</li>
<li><code>PSW[bit] = 1</code> → 核心态</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ <strong>这就是 CPU 判断当前是否可以执行特权指令的依据！</strong> </p>
</blockquote>
<p>当 CPU 执行一条指令时，它会检查 PSW 中的这个标志位：</p>
<ul>
<li>如果是<strong>用户态</strong>，并且指令是<strong>特权指令</strong>，则触发一个<strong>异常 (Exception)</strong>，操作系统会介入处理（通常是终止该程序）。</li>
<li>如果是<strong>核心态</strong>，则允许执行。</li>
</ul>
<h4 id="CPU-如何判断当前是否可以执行特权指令？"><a href="#CPU-如何判断当前是否可以执行特权指令？" class="headerlink" title="CPU 如何判断当前是否可以执行特权指令？"></a>CPU 如何判断当前是否可以执行特权指令？</h4><p><strong>答案</strong>：CPU 通过检查 <strong>程序状态字 (PSW)</strong> 中的一个特定标志位来判断。</p>
<ul>
<li>如果该标志位表示当前处于<strong>用户态</strong>，并且遇到的是<strong>特权指令</strong>，则 CPU 会触发一个<strong>异常</strong>（通常是“非法指令”或“特权指令违规”），并将控制权交给操作系统内核。</li>
<li>操作系统内核会根据情况决定是终止该程序，还是进行其他处理。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116191358137.png" alt="image-20251116191358137"></p>
<h2 id="进程控制和管理"><a href="#进程控制和管理" class="headerlink" title="进程控制和管理"></a>进程控制和管理</h2><h3 id="进程定义与属性"><a href="#进程定义与属性" class="headerlink" title="进程定义与属性"></a>进程定义与属性</h3><p>进程（Process）是<strong>程序在计算机上的一次执行</strong>实例，是<strong>操作系统进行资源分配、调度和保护的基本单位</strong>。</p>
<h4 id="为什么要引入“进程”？"><a href="#为什么要引入“进程”？" class="headerlink" title="为什么要引入“进程”？"></a>为什么要引入“进程”？</h4><p>1️⃣ <strong>刻画系统的动态性（Dynamic Nature）</strong></p>
<ul>
<li><strong>问题</strong>：程序是静态的代码，无法描述“执行中”的状态。</li>
<li><strong>解决方案</strong>：进程是一个<strong>动态实体</strong>，它有生命周期（创建 → 运行 → 阻塞 → 终止）。</li>
<li><strong>意义</strong>：操作系统可以精确跟踪每个任务的当前状态，做出调度决策。</li>
</ul>
<p>2️⃣ <strong>发挥系统的并发性（Concurrency）</strong></p>
<ul>
<li><strong>问题</strong>：CPU 和 I/O 设备速度不匹配。程序在等待 I/O（如读文件、网络请求）时，CPU 就空闲了。</li>
<li><strong>解决方案</strong>：通过<strong>进程切换</strong>，让 CPU 在等待期间去执行其他任务。</li>
<li><strong>意义</strong>：提高了 CPU 利用率和系统吞吐量。</li>
</ul>
<p>3️⃣ <strong>解决资源共享与隔离的矛盾</strong></p>
<ul>
<li><strong>问题</strong>：多个程序可能需要共享资源（如文件、打印机），但又不能互相干扰。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>共享性</strong>：进程可以通过合法机制（如共享内存、消息队列）共享资源。</li>
<li><strong>独立性/保护性</strong>：每个进程拥有独立的地址空间，操作系统通过内存管理单元（MMU）确保 A 进程不能访问 B 进程的内存。</li>
</ul>
</li>
<li><strong>意义</strong>：既实现了协作，又保证了安全和稳定。</li>
</ul>
<h4 id="进程的五大核心属性"><a href="#进程的五大核心属性" class="headerlink" title="进程的五大核心属性"></a>进程的五大核心属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 动态性</strong></td>
<td>进程是动态的，有生命周期（创建 → 运行 → 阻塞 → 终止）。</td>
<td><code>uvicorn</code> 启动时创建进程，<code>Ctrl+C</code> 终止时销毁进程。</td>
</tr>
<tr>
<td><strong>2. 并发性</strong></td>
<td>多个进程可以“同时”运行（宏观并发，微观交替）。</td>
<td>一台服务器同时处理成百上千个用户的 HTTP 请求。</td>
</tr>
<tr>
<td><strong>3. 独立性</strong></td>
<td>每个进程有独立的地址空间和资源，互不干扰。</td>
<td>一个 Python 进程崩溃，不会导致另一个 Python 进程退出。</td>
</tr>
<tr>
<td><strong>4. 制约性</strong></td>
<td>进程间可能存在同步或互斥关系（如竞争资源、等待结果）。</td>
<td>多个进程写同一个日志文件，需要用文件锁避免内容错乱。</td>
</tr>
<tr>
<td><strong>5. 共享性</strong></td>
<td>进程可以通过操作系统提供的机制共享资源（如内存、文件）。</td>
<td>多个 FastAPI worker 进程共享一个 Redis 缓存连接池。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><h4 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204410504.png" alt="image-20251115204410504"></p>
<h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115204451732.png" alt="image-20251115204451732"></p>
<p>七态模型在五态模型的基础上，<strong>显式增加了“挂起（Suspend）”的概念</strong></p>
<blockquote>
<p>挂起 = 进程被换出到外存（Swap）</p>
<ul>
<li><strong>目的</strong>：当系统内存紧张时，操作系统会将一些<strong>暂时不活跃</strong>的进程（比如长时间阻塞的进程）从内存移到硬盘上的“交换区（Swap Space）”，以腾出内存给更紧急的任务。</li>
</ul>
</blockquote>
<p><strong>挂起就绪态 (Ready/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程具备运行条件（即它已经准备好执行），但目前在外存中。只有当它被换入内存后，才能被调度器选中运行。</strong> </p>
</blockquote>
<p><strong>挂起等待态 (Blocked/Suspend)</strong></p>
<p>定义：</p>
<blockquote>
<p><strong>进程正在等待某一个事件发生（如 I/O 完成、用户输入、网络响应），并且目前在外存中。</strong> </p>
</blockquote>
<h3 id="进程描述和组成"><a href="#进程描述和组成" class="headerlink" title="进程描述和组成"></a>进程描述和组成</h3><h4 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h4><p><strong>进程映像（Process Image）是指进程在内存中的完整内容，包括代码、数据、堆、栈以及内核数据结构（如 PCB）等所有组成部分的集合。</strong></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210257885.png" alt="image-20251115210257885"></p>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115210715693.png" alt="image-20251115210715693"></p>
<blockquote>
<p>寄存器上下文 (Register Context)<strong>存储在 PCB 中</strong><br><strong>包含：通用寄存器、程序计数器、栈指针、程序状态字</strong> </p>
<p>这是进程“灵魂”的一部分——CPU 执行时最直接依赖的状态。</p>
</blockquote>
<h4 id="PCB（Process-Control-Block，进程控制块）"><a href="#PCB（Process-Control-Block，进程控制块）" class="headerlink" title="PCB（Process Control Block，进程控制块）"></a><strong>PCB（Process Control Block，进程控制块）</strong></h4><p><strong>PCB 是操作系统为每个进程创建的一个数据结构，用来记录和刻画该进程的所有状态和相关信息。</strong></p>
<p>1️⃣ <strong>进程标识信息 (Identification Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PID (Process ID)</strong></td>
<td>进程的唯一数字标识，如 <code>12345</code>。</td>
</tr>
<tr>
<td><strong>PPID (Parent PID)</strong></td>
<td>父进程的 PID，用于构建进程树。</td>
</tr>
<tr>
<td><strong>UID/GID (User/Group ID)</strong></td>
<td>进程所属用户的 ID 和组 ID，用于权限控制。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🌰 <strong>你的例子</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前进程 PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;父进程 PID: <span class="subst">&#123;os.getppid()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br>这些值就是从 PCB 中读取的！</p>
</blockquote>
<p>2️⃣ <strong>处理器状态信息 (Processor State Information)</strong> —— <strong>这就是“寄存器上下文”</strong></p>
<p>这是 PCB 最关键的部分，用于<strong>上下文切换</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>程序计数器 (PC)</strong></td>
<td>下一条要执行的指令地址。</td>
</tr>
<tr>
<td><strong>通用寄存器 (AX, BX, CX…)</strong></td>
<td>存放临时计算结果、变量地址等。</td>
</tr>
<tr>
<td><strong>程序状态字 (PSW)</strong></td>
<td>包含标志位（零标志 Z、进位标志 C、溢出标志 O 等）、中断允许位、特权级别。</td>
</tr>
<tr>
<td><strong>栈指针 (SP)</strong></td>
<td>指向当前函数调用栈的顶部。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>⚡ <strong>关键点</strong>：每次进程切换时，操作系统都会将当前 CPU 寄存器的值“倾倒”进 PCB，再从新进程的 PCB “倒回”寄存器。这就是“上下文切换”的核心开销。</p>
</blockquote>
<p>3️⃣ <strong>进程调度信息 (Scheduling Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程状态</strong></td>
<td>就绪、运行、阻塞、挂起等。</td>
</tr>
<tr>
<td><strong>进程优先级</strong></td>
<td>决定调度顺序。</td>
</tr>
<tr>
<td><strong>时间片剩余量</strong></td>
<td>用于时间片轮转调度。</td>
</tr>
<tr>
<td><strong>等待事件</strong></td>
<td>如等待键盘输入、网络数据包到达等。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🌰 <strong>你的例子</strong>：<br>在 FastAPI 中，当一个请求在 <code>await httpx.get(...)</code> 时，其对应协程/线程的状态会被标记为“阻塞”，并被放入等待队列。这就是 PCB 中“进程状态”字段的作用。</p>
</blockquote>
<p>4️⃣ <strong>内存管理信息 (Memory Management Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>页表基址 / 段表指针</strong></td>
<td>用于虚拟内存到物理内存的地址转换。</td>
</tr>
<tr>
<td><strong>内存分配情况</strong></td>
<td>代码段、数据段、堆、栈的起始地址和大小。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>💡 <strong>关键点</strong>：确保进程访问的是自己的内存空间，实现“内存保护”。</p>
</blockquote>
<p>5️⃣ <strong>I/O 状态信息 (I/O Status Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>打开的文件列表</strong></td>
<td>文件描述符（fd）、文件指针、访问模式等。</td>
</tr>
<tr>
<td><strong>分配的 I/O 设备</strong></td>
<td>如打印机、网卡等。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🌰 <strong>你的例子</strong>：<br>当你在 Python 中 <code>f = open(&quot;log.txt&quot;, &quot;a&quot;)</code> 时，操作系统会在 PCB 的“打开文件列表”中添加一条记录，记录这个文件句柄 <code>f</code> 对应的 fd。</p>
</blockquote>
<p>6️⃣ <strong>记账信息 (Accounting Information)</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU 使用时间</strong></td>
<td>进程已使用的 CPU 时间总和。</td>
</tr>
<tr>
<td><strong>累计运行时间</strong></td>
<td>从创建到现在的总时间。</td>
</tr>
<tr>
<td><strong>最大内存使用量</strong></td>
<td>历史峰值。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>📊 <strong>用途</strong>：用于性能监控、计费、调试等。</p>
</blockquote>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><h4 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212223846.png" alt="image-20251115212223846"></p>
<h4 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212241091.png" alt="image-20251115212241091"></p>
<h3 id="进程切换和处理器状态转换"><a href="#进程切换和处理器状态转换" class="headerlink" title="进程切换和处理器状态转换"></a>进程切换和处理器状态转换</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115212521578.png" alt="image-20251115212521578"></p>
<h4 id="模式切换-vs-进程切换"><a href="#模式切换-vs-进程切换" class="headerlink" title="模式切换 vs. 进程切换"></a>模式切换 vs. 进程切换</h4><ol>
<li>模式切换 (Mode Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：CPU 在“用户态（User Mode）”和“核心态（Kernel Mode）”之间的切换。 <strong>触发方式</strong>：由<strong>中断（Interrupt）或系统调用（System Call）</strong> 引起。 <strong>目的</strong>：让操作系统获得控制权，执行特权指令（如访问硬件、修改内存映射）。 </p>
</blockquote>
<ol>
<li>进程切换 (Process Switch / Context Switch)</li>
</ol>
<blockquote>
<p><strong>定义</strong>：操作系统暂停当前正在运行的进程，保存其状态，并加载另一个进程的状态，使其开始运行。 <strong>触发方式</strong>：通常发生在<strong>核心态</strong>下，由中断或系统调用引发。 <strong>目的</strong>：实现多任务并发，公平分配 CPU 时间。 </p>
</blockquote>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251115215300054.png" alt="image-20251115215300054"></p>
<h4 id="当进程开始运行时，操作系统如何重新获得控制？"><a href="#当进程开始运行时，操作系统如何重新获得控制？" class="headerlink" title="当进程开始运行时，操作系统如何重新获得控制？"></a>当进程开始运行时，操作系统如何重新获得控制？</h4><p>果进程一直在运行，操作系统就永远没机会调度其他进程了，系统就会卡死。</p>
<p><strong>答案：中断 (Interrupt) 是关键！</strong></p>
<ul>
<li><strong>什么是中断？</strong> 中断就像一个“<strong>紧急电话</strong>”，它能打断 CPU 当前正在执行的程序，强制 CPU 去处理一个更高优先级的事情——通常是操作系统内核。<ul>
<li><strong>硬件中断</strong>：由外部设备触发，比如键盘敲击、鼠标移动、网络数据包到达、定时器到期。</li>
<li><strong>软件中断/异常</strong>：由程序自身触发，比如除零错误、访问非法内存地址、或者程序主动发起的<strong>系统调用</strong>（如 <code>open()</code>, <code>read()</code>）。</li>
</ul>
</li>
</ul>
<h4 id="进程需要保存哪些状态？"><a href="#进程需要保存哪些状态？" class="headerlink" title="进程需要保存哪些状态？"></a>进程需要保存哪些状态？</h4><p>当操作系统获得控制权后，它必须把当前正在运行的进程（比如进程0）的“工作状态”完整地记录下来，以便将来能恢复执行。这个过程叫做“<strong>保存现场 (Save Context)</strong>”。</p>
<p><strong>需要保存哪些状态？</strong></p>
<p>这些状态主要存储在一个叫做 <strong>PCB (Process Control Block, 进程控制块)</strong> 的数据结构里。PCB 就像是进程的“<strong>身份证 + 工作日志 + 资源清单</strong>”。</p>
<h4 id="如何选择下一个待执行的进程-线程？"><a href="#如何选择下一个待执行的进程-线程？" class="headerlink" title="如何选择下一个待执行的进程/线程？"></a>如何选择下一个待执行的进程/线程？</h4><p>当操作系统保存完当前进程的状态后，它需要决定“<strong>接下来该让谁干活</strong>”。这个决策过程叫做“<strong>进程调度 (Process Scheduling)</strong>”。</p>
<p><strong>如何选择？</strong></p>
<p>这取决于操作系统的<strong>调度算法 (Scheduling Algorithm)</strong>。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="为什么需要线程？——-引入线程的动机"><a href="#为什么需要线程？——-引入线程的动机" class="headerlink" title="为什么需要线程？—— 引入线程的动机"></a>为什么需要线程？—— 引入线程的动机</h4><p>❓ 问题：进程模型有什么不足？</p>
<ol>
<li><strong>切换开销大</strong>：进程切换需要保存/恢复整个内存空间（代码、数据、堆、栈）和 PCB，开销大。</li>
<li><strong>通信困难</strong>：进程间通信（IPC）需要管道、消息队列、共享内存等复杂机制，效率低。</li>
<li><strong>不适合细粒度并发</strong>：比如一个 Web 服务器，每个请求都创建一个进程，成本太高。</li>
</ol>
<p>✅ 解决方案：引入线程！</p>
<blockquote>
<p><strong>线程是进程内的一个执行单元，是 CPU 调度和分派的基本单位。</strong> </p>
</blockquote>
<ul>
<li><strong>同一个进程内的所有线程</strong>：<ul>
<li><strong>共享</strong>：代码段、数据段、堆、打开的文件等<strong>进程资源</strong>。</li>
<li><strong>私有</strong>：各自的<strong>栈</strong>和<strong>寄存器上下文</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 <strong>核心价值</strong>：<strong>实现进程内部的并发，降低切换和通信开销</strong>。 </p>
</blockquote>
<h4 id="什么是线程？——-核心定义"><a href="#什么是线程？——-核心定义" class="headerlink" title="什么是线程？—— 核心定义"></a>什么是线程？—— 核心定义</h4><blockquote>
<p><strong>线程（Thread）是进程中一个可并发执行的控制流，它拥有自己独立的栈和寄存器状态，但与其他线程共享进程的地址空间和资源。</strong> </p>
</blockquote>
<h4 id="线程如何工作？——-线程的生命周期与切换"><a href="#线程如何工作？——-线程的生命周期与切换" class="headerlink" title="线程如何工作？—— 线程的生命周期与切换"></a>线程如何工作？—— 线程的生命周期与切换</h4><ol>
<li><strong>线程的生命周期状态</strong></li>
</ol>
<p>和进程类似，线程也有状态：<strong>新建 → 就绪 → 运行 → 阻塞 → 终止</strong>。</p>
<ol>
<li><strong>线程切换（Thread Switching）</strong></li>
</ol>
<ul>
<li><strong>开销远小于进程切换</strong>！因为不需要切换地址空间（页表），只需要保存/恢复<strong>寄存器上下文和栈指针</strong>。</li>
<li>切换由<strong>线程调度器</strong>（在 OS 内核或用户态库中）管理。</li>
</ul>
<ol>
<li><strong>线程的实现方式</strong></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用户级线程 (User-Level Threads)</strong></td>
<td>由用户态线程库（如 Java Green Threads）管理，内核 unaware</td>
<td>Python 的 <code>greenlet</code>（非标准）</td>
</tr>
<tr>
<td><strong>内核级线程 (Kernel-Level Threads)</strong></td>
<td>由操作系统内核直接管理，每个线程对应一个内核调度实体</td>
<td>Python 的 <code>threading</code> 模块</td>
</tr>
<tr>
<td><strong>混合模式</strong></td>
<td>用户级线程映射到少量内核线程</td>
<td>Go 的 Goroutine</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>💡 <strong>Python 的 <code>threading</code> 是内核级线程</strong>，但受 GIL 限制，无法真正并行执行 Python 字节码。</p>
</blockquote>
<h2 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2><h3 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h3><p>1️⃣ 高级调度（High-Level Scheduling）—— 作业调度 / 长程调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪些“作业”被允许进入系统参与 CPU 竞争。 <strong>对象</strong>：作业（Job）→ 通常是一个完整的程序或任务（如编译一个文件、运行一个脚本）。 <strong>发生频率</strong>：<strong>低</strong>（几分钟到几小时一次）。 <strong>执行者</strong>：操作系统内核。 </p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选作业进内存</strong>：从后备队列中选择作业，将其加载到内存，创建进程。</li>
<li><strong>控制多道程序的道数</strong>：决定同时在内存中运行多少个作业（即并发度）。太多会耗尽内存，太少会浪费 CPU。</li>
</ul>
<p>2️⃣ 中级调度（Medium-Level Scheduling）—— 平衡调度 / 内存调度</p>
<blockquote>
<p><strong>目标</strong>：根据内存状态，决定哪些进程可以在内存中运行，哪些需要换出到外存。 <strong>对象</strong>：进程（Process）。 <strong>发生频率</strong>：<strong>中等</strong>（几秒到几分钟一次）。 <strong>执行者</strong>：操作系统内核。 </p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程进出内存</strong>：当内存紧张时，将一些不活跃的进程（如长时间阻塞的进程）换出到 Swap 分区；当内存空闲时，再换回。</li>
<li><strong>平衡系统负载</strong>：防止内存溢出，提高系统吞吐量。</li>
</ul>
<p>3️⃣ 低级调度（Low-Level Scheduling）—— 进程调度 / CPU 调度</p>
<blockquote>
<p><strong>目标</strong>：决定哪个就绪队列中的进程/线程获得 CPU 执行权。 <strong>对象</strong>：进程或线程（内核级线程）。 <strong>发生频率</strong>：<strong>高</strong>（毫秒级，每几十到几百毫秒一次）。 <strong>执行者</strong>：操作系统内核 → <strong>这是操作系统最核心的部分</strong>！ </p>
</blockquote>
<p>🔍 核心功能：</p>
<ul>
<li><strong>选进程分配 CPU</strong>：从就绪队列中选出下一个要运行的进程/线程。</li>
<li><strong>执行上下文切换</strong>：保存当前进程上下文，恢复新进程上下文。</li>
<li><strong>实现公平与效率</strong>：通过调度算法（如 RR、优先级、MLFQ）保证所有进程都能得到 CPU 时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[高级调度] --&gt;|选作业进内存| B[中级调度]</span><br><span class="line">    B --&gt;|选进程进出内存| C[低级调度]</span><br><span class="line">    C --&gt;|选进程分配 CPU| D[CPU 执行]</span><br><span class="line"></span><br><span class="line">    style A fill:#f9d5e5,stroke:#333</span><br><span class="line">    style B fill:#e3eaa7,stroke:#333</span><br><span class="line">    style C fill:#b2d3c2,stroke:#333</span><br></pre></td></tr></table></figure>
<h3 id="调度算法评价指标"><a href="#调度算法评价指标" class="headerlink" title="调度算法评价指标"></a>调度算法评价指标</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116131448708.png" alt="image-20251116131448708"></p>
<h3 id="七种调度策略"><a href="#七种调度策略" class="headerlink" title="七种调度策略"></a>七种调度策略</h3><h4 id="先来先服务-First-Come-First-Serverd-FCFS"><a href="#先来先服务-First-Come-First-Serverd-FCFS" class="headerlink" title="先来先服务 (First Come First Serverd, FCFS)"></a>先来先服务 (First Come First Serverd, FCFS)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132753390.png" alt="image-20251116132753390"></p>
<h4 id="短作业优先-Shortest-Job-First-SJF"><a href="#短作业优先-Shortest-Job-First-SJF" class="headerlink" title="短作业优先 (Shortest Job First, SJF)"></a>短作业优先 (Shortest Job First, SJF)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116132925377.png" alt="image-20251116132925377"></p>
<h4 id="最短剩余时间优先-Shortest-Remaining-Time-First-SRTF"><a href="#最短剩余时间优先-Shortest-Remaining-Time-First-SRTF" class="headerlink" title="最短剩余时间优先 (Shortest Remaining Time First, SRTF)"></a>最短剩余时间优先 (Shortest Remaining Time First, SRTF)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133352988.png" alt="image-20251116133352988"></p>
<h4 id="最高响应比优先-Highest-Response-Ratio-First-HRRF"><a href="#最高响应比优先-Highest-Response-Ratio-First-HRRF" class="headerlink" title="最高响应比优先 (Highest Response Ratio First, HRRF)"></a>最高响应比优先 (Highest Response Ratio First, HRRF)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116133432719.png" alt="image-20251116133432719"></p>
<h4 id="优先级调度-Priority-Scheduling"><a href="#优先级调度-Priority-Scheduling" class="headerlink" title="优先级调度 (Priority Scheduling)"></a>优先级调度 (Priority Scheduling)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141512909.png" alt="image-20251116141512909"></p>
<h4 id="轮转调度-Round-Robin-Scheduling-RR"><a href="#轮转调度-Round-Robin-Scheduling-RR" class="headerlink" title="轮转调度 (Round Robin Scheduling, RR)"></a>轮转调度 (Round Robin Scheduling, RR)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116141611150.png" alt="image-20251116141611150"></p>
<h4 id="多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ"><a href="#多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ" class="headerlink" title="多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)"></a>多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116144745818.png" alt="image-20251116144745818"></p>
<h2 id="并发：互斥与同步"><a href="#并发：互斥与同步" class="headerlink" title="并发：互斥与同步"></a>并发：互斥与同步</h2><h3 id="进程交互"><a href="#进程交互" class="headerlink" title="进程交互"></a><strong>进程交互</strong></h3><h4 id="为什么需要“进程交互”？"><a href="#为什么需要“进程交互”？" class="headerlink" title="为什么需要“进程交互”？"></a>为什么需要“进程交互”？</h4><p>在单进程时代，程序是“独占”的——它不需要考虑别人。但在现代操作系统中：</p>
<ul>
<li>多个进程/线程同时运行。</li>
<li>它们可能共享资源（如内存、文件、数据库连接）。</li>
<li>它们可能需要协同完成一个复杂任务（如一个 Web 请求涉及多个微服务）。</li>
</ul>
<p>这就产生了两个根本性问题：</p>
<ol>
<li><strong>竞争（Competition）</strong>：多个进程争抢同一个资源，导致结果不可预测。</li>
<li><strong>协作（Cooperation）</strong>：多个进程需要按特定顺序执行，才能完成共同目标。</li>
</ol>
<blockquote>
<p>✅ <strong>进程交互就是解决这两个问题的机制</strong>。 </p>
</blockquote>
<h4 id="竞争关系（进程互斥）"><a href="#竞争关系（进程互斥）" class="headerlink" title="竞争关系（进程互斥）"></a>竞争关系（进程互斥）</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程互斥是指若干进程因相互争夺独占型资源而产生的竞争制约关系。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“相互争夺”</strong>：多个进程都想使用同一个资源。</li>
<li><strong>“独占型资源”</strong>：一次只能被一个进程使用的资源，如打印机、临界区代码、全局变量、数据库连接等。</li>
<li><strong>“竞争制约关系”</strong>：一个进程的执行会制约另一个进程的执行。</li>
</ul>
<p>🧱 两个核心控制问题：</p>
<ol>
<li><strong>死锁问题（Deadlock）</strong><ul>
<li><strong>定义</strong>：多个进程互相等待对方释放资源，导致所有进程都无法继续执行。</li>
<li><strong>经典例子</strong>：“哲学家就餐问题”——五个哲学家围坐圆桌，每人左右各有一根筷子。他们必须拿到两根筷子才能吃饭。如果每个人都拿起左边的筷子，然后等待右边的筷子，就会陷入死锁。</li>
<li><strong>四个必要条件</strong>：<ul>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
</li>
</ul>
</li>
<li><strong>饥饿问题（Starvation）</strong><ul>
<li><strong>定义</strong>：某个进程因为优先级低或资源分配策略不当，长时间得不到所需资源，导致无法执行。</li>
<li><strong>例子</strong>：在一个高优先级任务永远不结束的系统中，低优先级任务可能永远得不到 CPU。</li>
</ul>
</li>
</ol>
<h4 id="协作关系（进程同步）"><a href="#协作关系（进程同步）" class="headerlink" title="协作关系（进程同步）"></a>协作关系（进程同步）</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>进程同步是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“完成共同任务”</strong>：多个进程/线程需要合作才能达成目标。</li>
<li><strong>“协调活动”</strong>：它们需要按特定顺序执行。</li>
<li><strong>“排定执行先后次序”</strong>：比如 A 必须在 B 之前执行。</li>
<li><strong>“等待、传递信号或消息”</strong>：通过同步机制（如信号量、条件变量、管道）实现通信和协调。</li>
</ul>
<p>🧱 核心思想：</p>
<ul>
<li><strong>“生产者-消费者”模型</strong>：生产者生成数据，消费者消费数据，它们必须同步。</li>
<li><strong>“读者-写者”模型</strong>：读者可以同时读，但写者必须独占。</li>
<li><strong>“屏障（Barrier）”</strong>：所有进程到达某个点后才能继续执行。</li>
</ul>
<h3 id="临界区管理"><a href="#临界区管理" class="headerlink" title="临界区管理"></a>临界区管理</h3><h4 id="什么是“临界区”？"><a href="#什么是“临界区”？" class="headerlink" title="什么是“临界区”？"></a>什么是“临界区”？</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>并发进程中，与共享变量有关的程序段叫做“临界区”（Critical Section）。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“并发进程”</strong>：多个进程/线程同时运行。</li>
<li><strong>“共享变量”</strong>：多个进程都能访问和修改的变量（如全局变量、数据库连接、文件句柄）。</li>
<li><strong>“程序段”</strong>：一段代码，比如 <code>counter += 1</code> 这样的操作。</li>
</ul>
<blockquote>
<p>💡 <strong>简单说</strong>：<strong>临界区 = 操作共享资源的那一小段代码。</strong> </p>
</blockquote>
<p>🎯 为什么重要？</p>
<p>因为这段代码如果被多个进程同时执行，会导致<strong>竞态条件（Race Condition）</strong>，产生不可预测的结果。</p>
<h4 id="如何避免错误？——-互斥访问临界区"><a href="#如何避免错误？——-互斥访问临界区" class="headerlink" title="如何避免错误？—— 互斥访问临界区"></a>如何避免错误？—— 互斥访问临界区</h4><blockquote>
<p><strong>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误。</strong> </p>
</blockquote>
<p>这就是“<strong>进程互斥</strong>”的核心思想。</p>
<h4 id="临界区调度的三个原则（经典！）"><a href="#临界区调度的三个原则（经典！）" class="headerlink" title="临界区调度的三个原则（经典！）"></a>临界区调度的三个原则（经典！）</h4><p>这是解决临界区问题的黄金法则，任何同步机制都必须满足这三个条件：</p>
<p>✅ 原则 1：一次至多一个进程能够进入临界区内执行</p>
<blockquote>
<p><strong>互斥性（Mutual Exclusion）</strong> </p>
</blockquote>
<ul>
<li>这是最基本的要求。任何时候，最多只能有一个进程在临界区内。</li>
<li>如果 A 在临界区，B 就不能进入，必须等待。</li>
</ul>
<p>✅ 原则 2：如果已有进程在临界区，其他试图进入的进程应等待</p>
<blockquote>
<p><strong>忙则等待（Progress）</strong> </p>
</blockquote>
<ul>
<li>如果临界区空闲，想进入的进程可以立即进入。</li>
<li>如果临界区被占用，其他进程必须等待，不能“自旋”浪费 CPU（虽然有些实现会自旋，但理想情况下应该阻塞等待）。</li>
</ul>
<p>✅ 原则 3：进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</p>
<blockquote>
<p><strong>有限等待（Bounded Waiting）</strong> </p>
</blockquote>
<ul>
<li>防止“饥饿”。不能让某个进程永远等下去。</li>
<li>例如，使用队列来管理等待的进程，确保每个进程最终都能获得进入临界区的机会。</li>
</ul>
<h3 id="实现临界区管理的软件方法一Peterson方法"><a href="#实现临界区管理的软件方法一Peterson方法" class="headerlink" title="实现临界区管理的软件方法一Peterson方法"></a>实现临界区管理的软件方法一Peterson方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int turn;           // turn 表示轮到谁进入</span><br><span class="line">boolean flag[2];   // flag[i] 表示进程 i 想进入临界区</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">flag[0] = flag[1] = false;</span><br><span class="line"></span><br><span class="line">Process P0() &#123;</span><br><span class="line">    flag[0] = true;</span><br><span class="line">    turn = 1;       // 谦让给 P1</span><br><span class="line">    while (flag[1] &amp;&amp; turn == 1); // 等待 P1 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[0] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process P1() &#123;</span><br><span class="line">    flag[1] = true;</span><br><span class="line">    turn = 0;       // 谦让给 P0</span><br><span class="line">    while (flag[0] &amp;&amp; turn == 0); // 等待 P0 退出或谦让</span><br><span class="line">    /* critical section */</span><br><span class="line">    flag[1] = false;</span><br><span class="line">    /* remainder section */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ 1. 互斥性 (Mutual Exclusion)</p>
<blockquote>
<p><strong>定义</strong>：一次至多一个进程能进入临界区。 </p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 和 P1 同时进入临界区。</li>
<li>那么 <code>flag[0] = true</code> 且 <code>flag[1] = true</code>。</li>
<li>根据算法，P0 在进入前设置了 <code>turn = 1</code>，P1 设置了 <code>turn = 0</code>。</li>
<li>由于 <code>turn</code> 只能取值 0 或 1，不可能同时为 0 和 1。</li>
<li>所以，当 P0 检查 <code>while (flag[1] &amp;&amp; turn == 1)</code> 时，如果 <code>turn == 0</code>，它就会阻塞。</li>
<li>同理，P1 也会被阻塞。</li>
<li><strong>结论</strong>：不可能同时进入。</li>
</ul>
<p>✅ 2. 空闲让进 (Progress)</p>
<blockquote>
<p><strong>定义</strong>：如果临界区空闲，且有进程想进入，则该进程应该能进入。 </p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>如果 P1 不想进入临界区，则 <code>flag[1] = false</code>。</li>
<li>此时，无论 <code>turn</code> 是多少，P0 的 <code>while (flag[1] &amp;&amp; turn == 1)</code> 条件都会失败（因为 <code>flag[1]</code> 是 <code>false</code>），所以 P0 可以立即进入临界区。</li>
</ul>
<p>✅ 3. 有限等待 (Bounded Waiting)</p>
<blockquote>
<p><strong>定义</strong>：一个进程最多等待另一个进程执行完临界区一次，就能获得进入的机会。 </p>
</blockquote>
<p>📌 证明思路：</p>
<ul>
<li>假设 P0 被阻塞，说明 <code>turn = 1</code> 且 <code>flag[1] = true</code>，即 P1 在临界区。</li>
<li>当 P1 执行完临界区后，它会设置 <code>flag[1] = false</code>。</li>
<li>此时，如果 P0 还想进入，它的 <code>while</code> 条件会失败，从而进入临界区。</li>
<li>如果 P1 在 <code>flag[1] = false</code> 后又想进入，则它会设置 <code>flag[1] = true</code> 和 <code>turn = 0</code>。</li>
<li>此时，P0 会被阻塞，但 P1 执行完后，P0 就能进入。</li>
<li><strong>结论</strong>：P0 最多等待 P1 执行一次临界区，就能进入。</li>
</ul>
<h3 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h3><h4 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h4><p>✅ 核心定义：</p>
<blockquote>
<p><strong>信号量是一种软件资源，用于表示物理资源的实体，是一个与队列有关的整型变量。</strong> </p>
</blockquote>
<p>📌 关键词解析：</p>
<ul>
<li><strong>“表示物理资源”</strong>：比如打印机、数据库连接池、线程池中的可用线程数。</li>
<li><strong>“整型变量”</strong>：信号量的值代表当前<strong>可用资源的数量</strong>。</li>
<li><strong>“与队列有关”</strong>：当资源不足时，等待的进程会被放入一个<strong>等待队列</strong>。</li>
</ul>
<h4 id="P-V-操作：信号量的“原子操作”"><a href="#P-V-操作：信号量的“原子操作”" class="headerlink" title="P/V 操作：信号量的“原子操作”"></a>P/V 操作：信号量的“原子操作”</h4><p>✅ 定义：</p>
<blockquote>
<p><strong>P (Proberen, 尝试) 和 V (Verhogen, 增加) 是对信号量进行操作的原语。</strong> </p>
</blockquote>
<ul>
<li><strong>P 操作</strong>：尝试获取资源。如果资源可用（信号量 &gt; 0），则减 1；否则，进程进入等待队列。</li>
<li><strong>V 操作</strong>：释放资源。增加信号量值，并唤醒一个等待的进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// P 操作 (Wait)</span><br><span class="line">void P(semaphore s) &#123;</span><br><span class="line">    s.value = s.value - 1;</span><br><span class="line">    if (s.value &lt; 0) &#123;</span><br><span class="line">        // 资源不足，将当前进程加入等待队列并阻塞</span><br><span class="line">        block(current_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// V 操作 (Signal)</span><br><span class="line">void V(semaphore s) &#123;</span><br><span class="line">    s.value = s.value + 1;</span><br><span class="line">    if (s.value &lt;= 0) &#123;</span><br><span class="line">        // 有进程在等待，唤醒一个</span><br><span class="line">        wakeup(one_waiting_process);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ <strong>关键点</strong>：P/V 操作必须是<strong>原子操作（Atomic Operation）</strong>，即在执行过程中不能被中断。否则会导致竞态条件。 </p>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><h4 id="哲学家进餐问题：核心描述"><a href="#哲学家进餐问题：核心描述" class="headerlink" title="哲学家进餐问题：核心描述"></a>哲学家进餐问题：核心描述</h4><p>✅ 问题设定：</p>
<ul>
<li>有 <strong>5 位哲学家</strong> 围坐在一张圆桌旁。</li>
<li>每位哲学家面前有一盘<strong>意大利面</strong>。</li>
<li>桌子上有 <strong>5 把叉子</strong>，每两位哲学家之间放一把。</li>
<li>哲学家的生活只有两件事：<ul>
<li><strong>思考（Think）</strong>：什么都不做。</li>
<li><strong>吃饭（Eat）</strong>：必须同时拿到<strong>左右两边的叉子</strong>才能吃。</li>
</ul>
</li>
<li>吃完后，会放下叉子，继续思考。</li>
</ul>
<blockquote>
<p>💡 <strong>目标</strong>：设计一个算法，让所有哲学家都能吃饱，且不会发生死锁或饥饿。 </p>
</blockquote>
<h4 id="为什么会出现死锁？"><a href="#为什么会出现死锁？" class="headerlink" title="为什么会出现死锁？"></a>为什么会出现死锁？</h4><p>📌 死锁的四个必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：叉子一次只能被一个人使用。</li>
<li><strong>请求与保持条件</strong>：哲学家拿起一把叉子后，会继续等待另一把。</li>
<li><strong>不剥夺条件</strong>：不能强行从哲学家手中拿走叉子。</li>
<li><strong>环路等待条件</strong>：每位哲学家都在等右边的人放下叉子，形成一个循环等待链。</li>
</ol>
<h4 id="解决方案：打破死锁的四个条件之一"><a href="#解决方案：打破死锁的四个条件之一" class="headerlink" title="解决方案：打破死锁的四个条件之一"></a>解决方案：打破死锁的四个条件之一</h4><p>要避免死锁，只需破坏其中一个必要条件即可。以下是几种经典的解决方案：</p>
<p>✅ 解决方案 1：限制同时就餐的哲学家数量（破坏“环路等待”）</p>
<blockquote>
<p><strong>最多允许 4 位哲学家同时吃面。</strong> </p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>如果只有 4 个人尝试拿叉子，那么至少有一把叉子是空闲的。</li>
<li>这样，总会有一个人能拿到两把叉子并吃完，从而释放资源。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 5 把叉子（信号量）</span><br><span class="line">forks = [threading.Semaphore(1) for _ in range(5)]</span><br><span class="line"># 限制同时就餐人数为 4</span><br><span class="line">dining_room = threading.Semaphore(4)</span><br><span class="line"></span><br><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        dining_room.acquire()  # 进入餐厅（最多 4 人）</span><br><span class="line">        </span><br><span class="line">        forks[i].acquire()       # 拿起左边叉子</span><br><span class="line">        forks[(i + 1) % 5].acquire()  # 拿起右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()       # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()  # 放下右边叉子</span><br><span class="line">        </span><br><span class="line">        dining_room.release()    # 离开餐厅</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">def eat(i):</span><br><span class="line">    print(f&quot;Philosopher &#123;i&#125; is eating...&quot;)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line"></span><br><span class="line"># 创建 5 个哲学家线程</span><br><span class="line">threads = []</span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=philosopher, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 2：奇偶号哲学家取叉子顺序不同（破坏“环路等待”）</p>
<blockquote>
<p><strong>奇数号哲学家先取左边叉子，再取右边；偶数号哲学家先取右边叉子，再取左边。</strong> </p>
</blockquote>
<p>📌 原理：</p>
<ul>
<li>这样就不会形成环路等待。</li>
<li>例如，哲学家 0（偶数）先拿右边叉子（叉子 1），哲学家 1（奇数）先拿左边叉子（叉子 1）→ 他们争抢同一把叉子，但最终只会有一个成功，另一个等待，从而打破环路。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def philosopher(i):</span><br><span class="line">    while True:</span><br><span class="line">        think()</span><br><span class="line">        </span><br><span class="line">        if i % 2 == 0:  # 偶数号哲学家</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 先拿右边叉子</span><br><span class="line">            forks[i].acquire()             # 再拿左边叉子</span><br><span class="line">        else:  # 奇数号哲学家</span><br><span class="line">            forks[i].acquire()             # 先拿左边叉子</span><br><span class="line">            forks[(i + 1) % 5].acquire()  # 再拿右边叉子</span><br><span class="line">        </span><br><span class="line">        eat(i)</span><br><span class="line">        </span><br><span class="line">        forks[i].release()                 # 放下左边叉子</span><br><span class="line">        forks[(i + 1) % 5].release()      # 放下右边叉子</span><br></pre></td></tr></table></figure>
<p>✅ 解决方案 3：拿起两把叉子才开始吃（破坏“请求与保持”）</p>
<blockquote>
<p><strong>每位哲学家必须同时拿到两把叉子才能开始吃，否则一把也不拿。</strong> </p>
</blockquote>
<p>1️⃣ 全局变量定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"></span><br><span class="line">semaphore s[<span class="number">5</span>];     <span class="comment">// 用于阻塞哲学家的信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥锁，保护 state 和 s</span></span><br><span class="line"><span class="type">int</span> state[<span class="number">5</span>];      <span class="comment">// 哲学家的状态</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>s[i]</code> 初始值为 0，因为一开始没有人需要等待。</li>
<li><code>state[i]</code> 初始化为 <code>THINKING</code>。</li>
</ul>
<p>2️⃣ <code>take_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">take_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = HUNGRY;  <span class="comment">// 哲学家 i 变成饥饿状态</span></span><br><span class="line">    test(i);            <span class="comment">// 尝试让 i 吃饭</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">    P(s[i]);            <span class="comment">// 如果 test(i) 没有让 i 吃上饭，这里会阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = HUNGRY</code></strong>: 告诉“管家”，我饿了。</li>
<li><strong><code>test(i)</code></strong>: “管家”检查我是否能吃。<ul>
<li>如果能吃，<code>test(i)</code> 会执行 <code>V(s[i])</code>，唤醒我。</li>
<li>如果不能吃，<code>test(i)</code> 不做任何事。</li>
</ul>
</li>
<li><strong><code>P(s[i])</code></strong>: 如果我没被唤醒，我就在这里阻塞，等待邻居放叉子。</li>
</ul>
<blockquote>
<p>✅ <strong>这个函数是“非阻塞”的</strong>：它只负责声明“我饿了”，然后立即返回。真正的等待发生在 <code>P(s[i])</code>。</p>
</blockquote>
<p>3️⃣ <code>put_fork(int i)</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_fork</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(mutex);           <span class="comment">// 获取互斥锁</span></span><br><span class="line">    state[i] = THINKING; <span class="comment">// 哲学家 i 变成思考状态</span></span><br><span class="line">    test((i + <span class="number">1</span>) % <span class="number">5</span>);  <span class="comment">// 检查右边邻居</span></span><br><span class="line">    test((i + <span class="number">4</span>) % <span class="number">5</span>);  <span class="comment">// 检查左边邻居（(i+4)%5 == (i-1)%5）</span></span><br><span class="line">    V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong><code>state[i] = THINKING</code></strong>: 我吃饱了，不再占用叉子。</li>
<li><strong><code>test((i+1)%5)</code> 和 <code>test((i+4)%5)</code></strong>: 告诉“管家”，我的邻居们可能现在可以吃饭了。<ul>
<li>例如，哲学家 0 放下叉子后，哲学家 1 和 4 可能现在能拿到两把叉子了。</li>
<li>“管家”会检查他们是否处于 <code>HUNGRY</code> 状态，并且邻居都不在吃，如果是，就唤醒他们。</li>
</ul>
</li>
</ul>
<p>4️⃣ <code>test(int i)</code> 函数 —— 核心逻辑！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING &amp;&amp;</span><br><span class="line">        state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;  <span class="comment">// 可以吃了！</span></span><br><span class="line">        V(s[i]);            <span class="comment">// 唤醒哲学家 i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 关键点：</p>
<ul>
<li><strong>检查三个条件</strong>：<ol>
<li><code>state[i] == HUNGRY</code>: 我确实想吃饭。</li>
<li><code>state[(i+1)%5] != EATING</code>: 我右边的邻居没在吃。</li>
<li><code>state[(i+4)%5] != EATING</code>: 我左边的邻居没在吃。</li>
</ol>
</li>
<li><strong>如果都满足</strong>：说明我现在可以拿到两把叉子！<ul>
<li>设置 <code>state[i] = EATING</code>。</li>
<li>执行 <code>V(s[i])</code>，唤醒我自己（因为我在 <code>take_fork</code> 中 <code>P(s[i])</code> 阻塞了）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ <strong>这个函数是“原子”的</strong>：因为它在 <code>mutex</code> 保护下执行，不会被其他哲学家打断。</p>
</blockquote>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><code>mutex</code> 的作用就是：</p>
<blockquote>
<p><strong>保护对共享变量（或临界区）的访问</strong>，<br><strong>只在真正操作这些共享资源的前后“加锁”和“解锁”</strong>。</p>
</blockquote>
<p>（防死锁铁律）：</p>
<blockquote>
<p><strong>永远不要在持有互斥锁（mutex）的情况下，调用可能阻塞的操作（如 P(empty)、P(full)、sleep、wait 等）。</strong></p>
</blockquote>
<h3 id="什么是生产者-消费者问题？"><a href="#什么是生产者-消费者问题？" class="headerlink" title="什么是生产者-消费者问题？"></a>什么是生产者-消费者问题？</h3><p>这是一个经典的<strong>多线程同步问题</strong>，用于模拟现实中的“生产”与“消费”场景：</p>
<ul>
<li><strong>生产者 (Producer)</strong>：负责制造数据或产品。</li>
<li><strong>消费者 (Consumer)</strong>：负责处理或消费这些数据/产品。</li>
<li><strong>缓冲区 (Buffer)</strong>：一个有限大小的共享空间，用来暂存生产者的产品，供消费者取用。</li>
</ul>
<p>📌 核心挑战</p>
<ol>
<li><strong>互斥 (Mutual Exclusion)</strong>：多个生产者/消费者不能同时操作缓冲区的同一个位置，否则数据会错乱。</li>
<li><strong>同步 (Synchronization)</strong>：<ul>
<li>生产者不能在缓冲区满时继续生产（要等待）。</li>
<li>消费者不能在缓冲区空时继续消费（要等待）。</li>
</ul>
</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">item B[n];</span><br><span class="line">Semaphore empty;  /*可用的空缓冲区个数*/</span><br><span class="line">Semaphore full;   /*可用的产品数*/</span><br><span class="line">Semaphore mutex;  /*互斥信号量*/</span><br><span class="line">empty = n; full = 0; mutex = 1;</span><br><span class="line">int in = 0; out = 0;  /*in为放入缓冲区指针, out为取出缓冲区指针*/</span><br><span class="line"></span><br><span class="line">Process producer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        item product = produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        B[in] = product;</span><br><span class="line">        in = (in+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process consumer_i( ) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Item product = B[out];</span><br><span class="line">        out = (out+1) % n;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        consume(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题：如果将P操作的顺序交换，会出现什么情况？"><a href="#问题：如果将P操作的顺序交换，会出现什么情况？" class="headerlink" title="问题：如果将P操作的顺序交换，会出现什么情况？"></a>问题：如果将P操作的顺序交换，会出现什么情况？</h4><p><strong>生产者霸占着 <code>mutex</code> 锁，等待 <code>empty</code>，消费者等待 <code>mutex</code> 锁，导致死锁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Producer as 生产者 P1</span><br><span class="line">    participant Consumer as 消费者 C1</span><br><span class="line">    participant Mutex as 互斥锁 (mutex)</span><br><span class="line">    participant Empty as 空闲缓冲区 (empty)</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 初始状态: empty=0 (缓冲区满), mutex=1</span><br><span class="line"></span><br><span class="line">    Producer-&gt;&gt;Mutex: P(mutex) // 成功获取锁，mutex=0</span><br><span class="line">    Producer-&gt;&gt;Empty: P(empty) // empty=0，阻塞！等待空位...</span><br><span class="line">    Note over Producer: 生产者 P1 霸占 mutex 锁，等待 empty</span><br><span class="line"></span><br><span class="line">    Consumer-&gt;&gt;Full: P(full) // full=1，成功，full=0</span><br><span class="line">    Consumer-&gt;&gt;Mutex: P(mutex) // mutex=0，阻塞！等待锁...</span><br><span class="line">    Note over Consumer: 消费者 C1 等待 mutex 锁</span><br><span class="line"></span><br><span class="line">    Note over Producer,Consumer: 💥 死锁！</span><br><span class="line">    Note right of Producer: 我要等 empty (需 C1 消费)</span><br><span class="line">    Note left of Consumer: 我要等 mutex (需 P1 释放)</span><br></pre></td></tr></table></figure>
<h4 id="问题：当前生产者消费者共用一个互斥锁会造成竞争"><a href="#问题：当前生产者消费者共用一个互斥锁会造成竞争" class="headerlink" title="问题：当前生产者消费者共用一个互斥锁会造成竞争"></a>问题：当前生产者消费者共用一个互斥锁会造成竞争</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore pmutex, cmutex; // 两个独立的互斥锁</span><br><span class="line">...</span><br><span class="line">P(pmutex); // 生产者只锁自己的写入区域</span><br><span class="line">P(cmutex); // 消费者只锁自己的读取区域</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>生产者之间</strong>：仍然需要 <code>pmutex</code> 来互斥，因为多个生产者可能同时想写入 <code>in</code> 指针指向的位置。</li>
<li><strong>消费者之间</strong>：仍然需要 <code>cmutex</code> 来互斥，因为多个消费者可能同时想读取 <code>out</code> 指针指向的位置。</li>
<li><strong>生产者 vs 消费者</strong>：<strong>它们可以并行！</strong> 只要生产者在写一个位置，消费者在读另一个位置，两者互不干扰，完全可以同时进行。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生"><a href="#死锁产生" class="headerlink" title="死锁产生"></a>死锁产生</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>在多进程/多线程系统中，<strong>死锁</strong>是指两个或多个进程因竞争资源而造成的一种互相等待的现象，若无外力作用，它们都将无法向前推进。</p>
<blockquote>
<p><strong>简单说：A 等 B，B 等 C，C 又等 A，大家谁也不让步，结果全都卡住。</strong> </p>
</blockquote>
<h4 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h4><p>只要系统发生死锁，以下4个条件<strong>必然同时成立</strong>。缺一不可！</p>
<p>1️⃣ 互斥访问 (Mutual Exclusion)</p>
<ul>
<li><strong>定义</strong>：系统中存在临界资源，进程应互斥地使用这些资源。</li>
<li><strong>通俗解释</strong>：资源一次只能被一个进程使用。比如，打印机、文件、数据库连接、内存中的某个变量等。</li>
<li><strong>为什么是必要条件</strong>？如果资源可以被多个进程同时共享（如只读文件），那就不存在竞争，也就不会死锁。</li>
</ul>
<p>2️⃣ 占有和等待 (Hold and Wait)</p>
<ul>
<li><strong>定义</strong>：进程在请求资源得不到满足而等待时，不释放已占有的资源。</li>
<li><strong>通俗解释</strong>：一个进程已经拿着一些资源，但它还需要其他资源才能完成工作，于是它一边等着新资源，一边还紧紧攥着自己手里的旧资源，不肯放手。</li>
<li><strong>为什么是必要条件</strong>？如果一个进程在等待新资源时能主动释放旧资源，那么它就不会阻塞别人，死锁也就不会形成。</li>
</ul>
<p>3️⃣ 不剥夺 (No Preemption)</p>
<ul>
<li><strong>定义</strong>：已被占用的资源只能由属主进程自愿释放，而不允许被其他进程剥夺。</li>
<li><strong>通俗解释</strong>：资源一旦被某个进程拿走，除非它自己愿意还回来，否则谁也不能强行抢走。这保证了进程的“自主性”，但也为死锁埋下了隐患。</li>
<li><strong>为什么是必要条件</strong>？如果系统能强行剥夺资源（比如操作系统强制回收），那么就可以打破死锁链。</li>
</ul>
<p>4️⃣ 循环等待 (Circular Wait)</p>
<ul>
<li><strong>定义</strong>：存在循环等待链，每个进程在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li>
<li><strong>通俗解释</strong>：这是一个闭环。A 等 B 的资源，B 等 C 的资源，C 又等 A 的资源，形成了一个“等待环”。</li>
<li><strong>为什么是必要条件</strong>？如果没有循环，等待链最终会指向一个“不等待”的进程，这个进程完成后会释放资源，从而解开整个等待链。</li>
</ul>
<h3 id="死锁防止"><a href="#死锁防止" class="headerlink" title="死锁防止"></a>死锁防止</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116173459401.png" alt="image-20251116173459401"></p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116181426684.png" alt="image-20251116181426684"></p>
<h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182605135.png" alt="image-20251116182605135"></p>
<ul>
<li><strong>阻塞节点 (Blocked Node)</strong>：一个进程，它<strong>正在请求一个或多个资源，但这些资源当前都被其他进程占用，且没有空闲实例可用</strong>。它必须等待。</li>
<li><strong>非阻塞节点 (Non-blocked Node)</strong>：一个进程，它<strong>要么没有请求任何资源，要么它请求的资源当前有空闲实例可以立即满足</strong>。它可以继续执行。</li>
</ul>
<h4 id="如何通过资源分配图判断死锁？"><a href="#如何通过资源分配图判断死锁？" class="headerlink" title="如何通过资源分配图判断死锁？"></a>如何通过资源分配图判断死锁？</h4><p>✅ 死锁的充分条件（当资源类型只有一个实例时）</p>
<blockquote>
<p><strong>如果资源分配图中存在一个环，则系统一定发生死锁。</strong> </p>
</blockquote>
<ul>
<li><strong>原因</strong>：在一个环中，每个进程都在等待下一个进程所持有的资源，而下一个进程又在等待再下一个……形成一个无限等待的闭环。</li>
</ul>
<p>⚠️ 当资源类型有多个实例时</p>
<blockquote>
<p><strong>环的存在是死锁的必要条件，但不是充分条件。</strong> </p>
</blockquote>
<ul>
<li><strong>原因</strong>：即使图中有环，但如果环中的某个资源类型有多个实例，那么可能还有空闲实例可以满足某个进程的需求，从而打破死锁。</li>
</ul>
<h4 id="资源分配图的简化"><a href="#资源分配图的简化" class="headerlink" title="资源分配图的简化"></a>资源分配图的简化</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116182901353.png" alt="image-20251116182901353"></p>
<h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><p>与银行家算法的安全性检测类似</p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251116184516361.png" alt="image-20251116184516361"></p>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="内存是什么？"><a href="#内存是什么？" class="headerlink" title="内存是什么？"></a>内存是什么？</h3><p>从物理上讲，内存通常指的是<strong>随机存取存储器（RAM - Random Access Memory）</strong>。</p>
<p>从操作系统的角度来看，内存是<strong>CPU（大脑）和硬盘（仓库）之间的“高速中转站”</strong>。它是计算机暂时存放数据的地方，用来存储当前正在运行的程序和正在处理的数据。</p>
<h3 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h3><p>计算机的存储设备像一个金字塔，<strong>越往上速度越快、价格越贵、容量越小</strong>：</p>
<ol>
<li><strong>寄存器 (Registers):</strong> 在 CPU 内部，极快，容量极小（纳秒级）。</li>
<li><strong>高速缓存 (Cache):</strong> 在 CPU 旁边，非常快（L1/L2/L3）。</li>
<li><strong>内存 (Main Memory/RAM):</strong> 我们今天的主角，速度适中，容量适中。</li>
<li><strong>本地磁盘 (Local Disk):</strong> 机械硬盘或固态硬盘，慢，容量巨大（毫秒级）。</li>
</ol>
<p><strong>操作系统的任务：</strong> 主要是管理<strong>第3层（内存）</strong>，并负责在内存和磁盘之间搬运数据。</p>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><h4 id="逻辑地址-Logical-Address"><a href="#逻辑地址-Logical-Address" class="headerlink" title="逻辑地址 (Logical Address)"></a><strong>逻辑地址 (Logical Address)</strong></h4><ul>
<li><strong>别名：</strong> 虚拟地址 (Virtual Address)。</li>
<li><strong>谁生成的？</strong> CPU（在执行程序时）。</li>
<li><strong>是什么？</strong> 这是<strong>程序“眼中”的地址</strong>。<ul>
<li>当程序员写代码或者编译器编译程序时，它们看到的都是逻辑地址。</li>
<li>程序觉得：“我拥有从 <code>0</code> 到 <code>Max</code> 的一整块连续内存。”</li>
</ul>
</li>
</ul>
<h4 id="物理地址-Physical-Address"><a href="#物理地址-Physical-Address" class="headerlink" title="物理地址 (Physical Address)"></a><strong>物理地址 (Physical Address)</strong></h4><ul>
<li><strong>谁看到的？</strong> 内存条（硬件）。</li>
<li><strong>是什么？</strong> 这是<strong>数据在内存条上真正的“门牌号”</strong>。<ul>
<li>它对应着内存芯片中某个具体的存储单元。</li>
<li>只有操作系统和硬件知道数据真正藏在哪里。</li>
</ul>
</li>
</ul>
<h3 id="内存复用方式"><a href="#内存复用方式" class="headerlink" title="内存复用方式"></a>内存复用方式</h3><p>为了支持<strong>多道程序设计</strong>（让电脑同时跑微信、浏览器、游戏），内存必须被复用。复用只有两种基本手段：</p>
<ol>
<li><strong>切大块（按照分区复用）：</strong><ul>
<li>把内存切成几个大块（分区）。</li>
<li><strong>规矩：</strong> 一个程序必须完整地塞进<strong>一个</strong>分区里（连续存放）。</li>
</ul>
</li>
<li><strong>切碎块（按照页框复用）：</strong><ul>
<li>把内存切成无数个一样大的小格子（页框）。</li>
<li><strong>规矩：</strong> 一个程序可以被切碎，散落在<strong>多个</strong>页框里（离散存放）。</li>
</ul>
</li>
</ol>
<h4 id="四大具体方法"><a href="#四大具体方法" class="headerlink" title="四大具体方法"></a>四大具体方法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221140228398.png" alt="image-20251221140228398"></p>
<p>这张图非常精彩，它展示了从“逻辑空间”（你以为的样子）到“物理空间”（实际的样子）的四种映射路径。请看着图中的 <strong>①、②、③、④</strong>。</p>
<h4 id="1-路径-①：单连续-分区存储管理-The-“Old-School”"><a href="#1-路径-①：单连续-分区存储管理-The-“Old-School”" class="headerlink" title="1. 路径 ①：单连续/分区存储管理 (The “Old School”)"></a>1. 路径 ①：单连续/分区存储管理 (The “Old School”)</h4><ul>
<li><strong>逻辑上：</strong> 程序认为自己是一条连续的直路（单连续逻辑地址空间）。</li>
<li><strong>物理上：</strong> 放入“分区”（Partition）。</li>
<li><strong>解释：</strong><ul>
<li>这是最原始的方法。程序多大，就在内存里找个多大的坑填进去。</li>
<li><strong>缺点：</strong> 必须连续。如果你有 100MB 内存，中间断断续续空了 50MB，但没有一块连续的 50MB，那 50MB 的程序就跑不起来。这叫“外部碎片”。</li>
</ul>
</li>
</ul>
<h4 id="2-路径-②：页式存储管理-Paging-现代主流的基础"><a href="#2-路径-②：页式存储管理-Paging-现代主流的基础" class="headerlink" title="2. 路径 ②：页式存储管理 (Paging - 现代主流的基础)"></a>2. 路径 ②：页式存储管理 (Paging - 现代主流的基础)</h4><ul>
<li><strong>逻辑上：</strong> 程序依然认为自己是一条连续的直路（单连续逻辑地址空间）。</li>
<li><strong>物理上：</strong> 放入“页框”（Page Frames）。</li>
<li><strong>变化：</strong><ul>
<li>虽然程序觉得自己是连续的，但操作系统偷偷拿把剪刀，把程序切成标准大小的“页”，然后随便塞进内存里任意位置的“框”里。</li>
<li><strong>优点：</strong> 彻底解决了“必须连续”的问题。内存利用率极高。</li>
</ul>
</li>
</ul>
<h4 id="3-路径-③：段式存储管理-Segmentation-符合人类直觉"><a href="#3-路径-③：段式存储管理-Segmentation-符合人类直觉" class="headerlink" title="3. 路径 ③：段式存储管理 (Segmentation - 符合人类直觉)"></a>3. 路径 ③：段式存储管理 (Segmentation - 符合人类直觉)</h4><ul>
<li><strong>逻辑上：</strong> 程序认为自己是由不同的“功能块”组成的（多连续逻辑地址空间/段表）。<ul>
<li>比如：主程序段、数据段、栈段。</li>
</ul>
</li>
<li><strong>物理上：</strong> 放入“分区”。</li>
<li><strong>解释：</strong><ul>
<li>程序员喜欢这种方式。因为我们可以说：“把我的代码段设为只读，把数据段设为可写”。</li>
<li>但是，每个段在物理内存里还是要占一块连续的地盘，所以依然会有碎片问题。</li>
</ul>
</li>
</ul>
<h4 id="4-路径-④：段页式存储管理-Segmented-Paging-集大成者"><a href="#4-路径-④：段页式存储管理-Segmented-Paging-集大成者" class="headerlink" title="4. 路径 ④：段页式存储管理 (Segmented Paging - 集大成者)"></a>4. 路径 ④：段页式存储管理 (Segmented Paging - 集大成者)</h4><ul>
<li><strong>逻辑上：</strong> 先分段（符合程序员视角，便于管理和保护）。</li>
<li><strong>物理上：</strong> 再分页（符合硬件视角，便于内存利用）。</li>
<li><strong>解释：</strong><ul>
<li>这是<strong>最强形态</strong>。</li>
<li>先把程序按逻辑分成“段”（比如代码段）。</li>
<li>再把这个“段”切碎成“页”，丢进物理内存的“页框”里。</li>
<li><strong>结果：</strong> 既有了分段的逻辑优势（保护、共享），又有了分页的物理优势（没有碎片）。</li>
</ul>
</li>
</ul>
<h3 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h3><p><strong>地址转换 (Address Translation)</strong></p>
<ul>
<li><strong>核心：</strong> 将<strong>逻辑地址</strong>映射为<strong>物理地址</strong>（又称重定位）。</li>
<li><strong>方式：</strong> 分为静态重定位（装入时确定，不可动）和动态重定位（运行时确定，灵活）。</li>
</ul>
<p><strong>分配与去配 (Allocation &amp; Deallocation)</strong></p>
<ul>
<li><strong>核心：</strong> 掌管内存的“借”与“还”。</li>
<li><strong>动作：</strong> 进程装入时<strong>分配</strong>空间并记录；进程撤离时<strong>回收</strong>空间并去配。</li>
</ul>
<p><strong>存储保护 (Storage Protection)</strong></p>
<ul>
<li><strong>核心：</strong> 确保进程互不干扰，防止越界访问。</li>
<li><strong>规则：</strong> 自己的随便用，共享的按权限用，别人的<strong>严禁</strong>用。</li>
</ul>
<p><strong>内存共享 (Sharing)</strong></p>
<ul>
<li><strong>核心：</strong> 允许多个进程共同使用同一块内存区域（如公共代码库）。</li>
<li><strong>目的：</strong> 提高内存利用率，支持进程协作。</li>
</ul>
<p><strong>内存扩充 (Expansion)</strong></p>
<ul>
<li><strong>核心：</strong> 利用磁盘空间“欺骗”程序，实现<strong>虚拟内存</strong>。</li>
<li><strong>技术：</strong> <strong>对换</strong>（整进整出）与<strong>虚拟技术</strong>（部分装入，按需调页）。</li>
</ul>
<p><strong>一句话总结：</strong> 操作系统通过<strong>转换地址</strong>让程序能跑，通过<strong>分配回收</strong>管理空间，通过<strong>保护</strong>防止打架，通过<strong>共享</strong>节省资源，通过<strong>扩充</strong>让小内存跑大程序。</p>
<h3 id="连续分配管理方式-Continuous-Allocation"><a href="#连续分配管理方式-Continuous-Allocation" class="headerlink" title="连续分配管理方式 (Continuous Allocation)"></a>连续分配管理方式 (Continuous Allocation)</h3><h4 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h4><p>所谓“连续”，就是<strong>一个程序在物理内存中必须占据一块连在一起的地盘</strong>。</p>
<ul>
<li>就像一群人去电影院看电影，必须买<strong>连座票</strong>，中间不能断开。</li>
</ul>
<p>连续分配主要经历了三个阶段的进化，我们重点掌握后两个：</p>
<h4 id="第一阶段：单一连续分配-Single-Continuous-Allocation"><a href="#第一阶段：单一连续分配-Single-Continuous-Allocation" class="headerlink" title="第一阶段：单一连续分配 (Single Continuous Allocation)"></a>第一阶段：单一连续分配 (Single Continuous Allocation)</h4><ul>
<li><strong>这是什么：</strong> 整个内存只有<strong>你（操作系统）</strong>和<strong>我（用户程序）</strong>两个人。</li>
<li><strong>情况：</strong> 内存分为系统区和用户区。用户区一次只能跑<strong>一个</strong>程序。</li>
<li><strong>结局：</strong> 这种方式太浪费了（如果你只有 10MB 程序，却占用了 8GB 内存），现代通用操作系统已经不用了。<strong>我们直接跳过。</strong></li>
</ul>
<h4 id="第二阶段：固定分区分配-Fixed-Partitioning"><a href="#第二阶段：固定分区分配-Fixed-Partitioning" class="headerlink" title="第二阶段：固定分区分配 (Fixed Partitioning)"></a>第二阶段：固定分区分配 (Fixed Partitioning)</h4><p>为了能多道程序并行，我们开始切蛋糕。</p>
<ul>
<li><strong>做法：</strong> 系统启动时，就把内存切成<strong>若干个固定大小</strong>的区域（分区）。这些格子的大小一旦切好，就<strong>不能变了</strong>。</li>
<li><strong>两种切法：</strong><ol>
<li><strong>分区大小相等：</strong> 比如全是 10MB 的格子。</li>
<li><strong>分区大小不等：</strong> 有小的（4MB）、中等的（8MB）、大的（16MB），这样更灵活。</li>
</ol>
</li>
<li><strong>问题（致命伤）：内部碎片 (Internal Fragmentation)</strong><ul>
<li>假设有一个分区是 <strong>10MB</strong>。</li>
<li>你的程序只有 <strong>6MB</strong>。</li>
<li>虽然程序装进去了，但剩下的 <strong>4MB</strong> 被锁在这个分区里，别的程序进不来，你也用不了。这就叫<strong>内部碎片</strong>（在分区内部浪费的空间）。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221141919972.png" alt="image-20251221141919972"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221142102685.png" alt="image-20251221142102685"></p>
<h4 id="第三阶段：动态分区分配-Dynamic-Partitioning"><a href="#第三阶段：动态分区分配-Dynamic-Partitioning" class="headerlink" title="第三阶段：动态分区分配 (Dynamic Partitioning)"></a>第三阶段：动态分区分配 (Dynamic Partitioning)</h4><p>为了解决“内部碎片”，操作系统决定：<strong>现吃现切</strong>。</p>
<ul>
<li><strong>做法：</strong> 初始时内存是一整块。当程序 A 来了，它需要 5MB，我就切 5MB 给它；程序 B 来了要 10MB，我紧接着切 10MB 给它。</li>
<li><strong>优点：</strong> <strong>没有内部碎片</strong>！因为我是按需分配的，你需要多少我给多少。</li>
<li><strong>问题（致命伤）：外部碎片 (External Fragmentation)</strong><ul>
<li>随着时间推移，有的程序运行完走了（释放内存），内存里会留下一个个“坑”。</li>
<li>比如：程序 B 走了，留下了 10MB 的空坑。</li>
<li>这时来了一个 12MB 的新程序，它塞不进这个 10MB 的坑里。虽然内存里可能总共有 100MB 的空闲空间，但因为它们<strong>不连续</strong>（都是些碎小的坑），导致大程序跑不起来。这就叫<strong>外部碎片</strong>（在分区外部浪费的空间）。</li>
</ul>
</li>
</ul>
<h4 id="“紧凑”技术-Compaction"><a href="#“紧凑”技术-Compaction" class="headerlink" title="“紧凑”技术 (Compaction)"></a>“紧凑”技术 (Compaction)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221143811148.png" alt="image-20251221143811148"></p>
<p>操作系统不能看着这 16M 内存白白浪费。为了让 P5 跑起来，操作系统必须进行<strong>“内存搬家”</strong>，专业术语叫<strong>紧凑</strong>或<strong>拼接</strong>。</p>
<ul>
<li><strong>做法：</strong> 操作系统让现有的进程（P2, P4, P3）全部<strong>往上挪动</strong>，挤在一起。</li>
<li><strong>效果：</strong><ul>
<li>所有的空闲小坑（6M, 6M, 4M）会被“挤”到内存的最底部，汇合成一个 <strong>16M 的大坑</strong>。</li>
<li>这时候，<strong>10M 的 P5</strong> 就可以舒舒服服地住进去了！</li>
</ul>
</li>
</ul>
<p><strong>代价：</strong> “搬家”是非常耗时的。CPU 要暂停所有工作，疯狂地搬运数据（复制内存），这会严重拖慢电脑速度。这也解释了为什么以前的 Windows 98/XP 用久了要进行“磁盘碎片整理”（虽然那是磁盘，但原理类似，都是为了合并碎片）。</p>
<h3 id="可变分区内存管理-分配算法"><a href="#可变分区内存管理-分配算法" class="headerlink" title="可变分区内存管理-分配算法"></a>可变分区内存管理-分配算法</h3><h4 id="为什么需要分配算法？"><a href="#为什么需要分配算法？" class="headerlink" title="为什么需要分配算法？"></a>为什么需要分配算法？</h4><p>因为“紧凑”（内存搬家）的代价太高了，会让电脑变卡。所以我们尽量通过聪明的分配算法，减少碎片的产生，不到万不得已不搬家。</p>
<p>以下是四种算法的详细解析：</p>
<h4 id="1-最先适应算法-First-Fit"><a href="#1-最先适应算法-First-Fit" class="headerlink" title="1. 最先适应算法 (First Fit)"></a>1. 最先适应算法 (First Fit)</h4><p>这是最简单、最自然的策略。</p>
<ul>
<li><strong>核心思想：</strong> 不管别的，<strong>按地址从低到高</strong>挨个找，找到<strong>第一个</strong>能装下的坑，就立刻分给它。</li>
<li><strong>数据结构：</strong> 空闲分区表是按<strong>地址递增</strong>排列的。</li>
<li><strong>优点：</strong><ul>
<li><strong>保留了大空间：</strong> 因为它总是先填低地址的坑，所以高地址的大片连续空间通常会被保留下来，<strong>有利于以后装入大作业</strong>。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>忙闲不均：</strong> 低地址部分会被切得稀碎，用得很频繁；而查找时每次都从头开始，导致查找开销大，且低地址端充满了小碎片。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144426233.png" alt="image-20251221144426233"></p>
<h4 id="2-下次适应算法-Next-Fit"><a href="#2-下次适应算法-Next-Fit" class="headerlink" title="2. 下次适应算法 (Next Fit)"></a>2. 下次适应算法 (Next Fit)</h4><p>这是对“最先适应算法”的改良。</p>
<ul>
<li><strong>核心思想：</strong> 既然每次从头找太累，那就<strong>从上次分配结束的位置</strong>开始往下找。找到队尾如果还没找到，就绕回队头接着找（循环扫描）。</li>
<li><strong>优点：</strong><ul>
<li><strong>速度快：</strong> 缩短了平均查找时间。</li>
<li><strong>均衡：</strong> 内存里的每个坑被选中的概率差不多，空间利用更均衡。</li>
</ul>
</li>
<li><strong>缺点（致命）：</strong><ul>
<li>因为它把内存里的“大坑”都截断用了，导致<strong>缺乏大的连续空间</strong>。如果有大作业来了，可能反而找不到足够大的地盘了。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144511133.png" alt="image-20251221144511133"></p>
<h4 id="3-最优适应算法-Best-Fit"><a href="#3-最优适应算法-Best-Fit" class="headerlink" title="3. 最优适应算法 (Best Fit)"></a>3. 最优适应算法 (Best Fit)</h4><p>听名字觉得是最好的，其实通常是<strong>最烂</strong>的。</p>
<ul>
<li><strong>核心思想：</strong> 扫描整个内存，找到能装下该进程、且<strong>大小最接近</strong>（最小）的那个坑。<ul>
<li><em>比如你要 5MB，有一个 6MB 的坑和一个 20MB 的坑，它会选 6MB 的那个。</em></li>
</ul>
</li>
<li><strong>数据结构：</strong> 为了找得快，通常把空闲分区按<strong>大小递增</strong>顺序排列。</li>
<li><strong>优点：</strong><ul>
<li>它确实不想浪费大空间，尽量保留了大分区给大作业用。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>制造碎片：</strong> 每次切完后，剩下来的那点空间（比如 6MB 切走 5MB，剩 1MB）实在太小了，谁也用不了。日积月累，内存里全是这种微小的、无法利用的<strong>外部碎片</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144613218.png" alt="image-20251221144613218"></p>
<h4 id="4-最坏适应算法-Worst-Fit"><a href="#4-最坏适应算法-Worst-Fit" class="headerlink" title="4. 最坏适应算法 (Worst Fit)"></a>4. 最坏适应算法 (Worst Fit)</h4><p>这是“最优适应”的反面。</p>
<ul>
<li><strong>核心思想：</strong> 每次都挑<strong>最大</strong>的那个坑给进程。<ul>
<li><em>比如你要 5MB，它偏偏要把那个 100MB 的大坑切给你。</em></li>
</ul>
</li>
<li><strong>数据结构：</strong> 空闲分区按<strong>大小递减</strong>顺序排列，这样查表时只要看第一个满不满足就行了。</li>
<li><strong>优点：</strong><ul>
<li><strong>减少碎片：</strong> 切完剩下的一般还比较大（100MB 切走 5MB，剩 95MB），还可以继续给别的程序用。所以它<strong>对中小型作业非常有利</strong>。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>大作业哭了：</strong> 最大的坑很快就被消耗掉了，真来了个超级大的程序，往往就没地方放了。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221144633595.png" alt="image-20251221144633595"></p>
<h3 id="分页存储管理-Paging-Storage-Management"><a href="#分页存储管理-Paging-Storage-Management" class="headerlink" title="分页存储管理 (Paging Storage Management)"></a>分页存储管理 (Paging Storage Management)</h3><h4 id="为什么要引入分页？"><a href="#为什么要引入分页？" class="headerlink" title="为什么要引入分页？"></a>为什么要引入分页？</h4><ul>
<li><strong>分区的痛：</strong> 程序必须完整地塞进连续的内存里。如果有 3 个 2MB 的小坑，想装一个 5MB 的程序，装不进去。</li>
<li><strong>分页的药：</strong> 允许程序<strong>“打散”</strong>。把 5MB 的程序切成很多小块，分别塞进那 3 个 2MB 的坑里（甚至更小的坑），只要总空间够，就能跑。</li>
</ul>
<blockquote>
<p><strong>核心思想：</strong> 逻辑上连续（程序看来是完整的），物理上不连续（内存里是散落的）。</p>
</blockquote>
<h4 id="三大概念"><a href="#三大概念" class="headerlink" title="三大概念"></a>三大概念</h4><h4 id="A-页框-Page-Frame-——-物理内存的“格子”"><a href="#A-页框-Page-Frame-——-物理内存的“格子”" class="headerlink" title="A. 页框 (Page Frame) —— 物理内存的“格子”"></a>A. 页框 (Page Frame) —— 物理内存的“格子”</h4><ul>
<li><strong>定义：</strong> 操作系统把<strong>物理内存</strong>切成一个个大小完全固定的块。</li>
<li><strong>大小：</strong> 通常较小且是 2 的幂，比如 4KB（4096字节）。</li>
<li><strong>编号：</strong> 从 0 开始编号，叫<strong>页框号</strong>或<strong>物理块号</strong>。</li>
<li><em>类比：</em> 就像是一个巨大的药柜，里面全是大小一样的标准小抽屉。</li>
</ul>
<h4 id="B-页面-Page-——-程序的“切片”"><a href="#B-页面-Page-——-程序的“切片”" class="headerlink" title="B. 页面 (Page) —— 程序的“切片”"></a>B. 页面 (Page) —— 程序的“切片”</h4><ul>
<li><strong>定义：</strong> 把<strong>用户的程序（逻辑地址空间）\</strong>也切成和页框*<em>一模一样大小*</em>的块。</li>
<li><strong>编号：</strong> 从 0 开始编号，叫<strong>页号</strong>。</li>
<li><em>类比：</em> 你把药材（程序）切成标准的小方块，每一块刚好能塞进一个抽屉。</li>
</ul>
<h4 id="C-页表-Page-Table-——-寻宝图"><a href="#C-页表-Page-Table-——-寻宝图" class="headerlink" title="C. 页表 (Page Table) —— 寻宝图"></a>C. 页表 (Page Table) —— 寻宝图</h4><ul>
<li><strong>定义：</strong>既然程序被切碎散落在内存的各个角落，CPU 怎么知道程序的“第 1 页”在哪个“抽屉”里？</li>
<li>我们需要一张映射表，这就是<strong>页表</strong>。</li>
<li><strong>内容：</strong> 记录了 <strong>逻辑页号 -&gt; 物理页框号</strong> 的对应关系。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221150141354.png" alt="image-20251221150141354"></p>
<h4 id="分页是如何解决碎片问题的？"><a href="#分页是如何解决碎片问题的？" class="headerlink" title="分页是如何解决碎片问题的？"></a>分页是如何解决碎片问题的？</h4><p><strong>没有“外部碎片”：</strong></p>
<ul>
<li>因为内存被切成了标准的 4KB 格子，程序也是 4KB 的块。只要内存里有空闲的格子，程序就能塞进去，完全不用担心“坑太小”的问题。</li>
</ul>
<p><strong>只有微小的“内部碎片”：</strong></p>
<ul>
<li><strong>产生原因：</strong> 程序的最后一部分可能填不满一页。</li>
<li><em>例子：</em> 页面大小是 4KB。你的程序是 4.1KB。<ul>
<li>第 1 页（4KB）填满。</li>
<li>第 2 页（0.1KB）只占了一点点，剩下的 3.9KB 就是浪费的。</li>
</ul>
</li>
<li><strong>结论：</strong> 这种浪费主要发生在<strong>程序的最后一页</strong>，平均只有半页大小，相比于固定分区的浪费，这简直可以忽略不计。</li>
</ul>
<h3 id="分页存储管理的地址转换"><a href="#分页存储管理的地址转换" class="headerlink" title="分页存储管理的地址转换"></a>分页存储管理的地址转换</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221151214942.png" alt="image-20251221151214942"></p>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221151234013.png" alt="image-20251221151234013"></p>
<h3 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h3><h4 id="1-核心痛点：为什么要引入快表？"><a href="#1-核心痛点：为什么要引入快表？" class="headerlink" title="1. 核心痛点：为什么要引入快表？"></a>1. 核心痛点：为什么要引入快表？</h4><p>请看图，它指出了一个严重的问题：</p>
<ul>
<li><strong>页表放在哪里？</strong> 放在<strong>内存</strong>中。</li>
<li><strong>这就导致了一个尴尬的后果：</strong> 每次 CPU 想读取一个数据，必须访问<strong>两次内存</strong>。<ol>
<li><strong>第一次访问：</strong> 去查内存里的页表，把逻辑地址翻译成物理地址。</li>
<li><strong>第二次访问：</strong> 根据物理地址，真正去取数据。</li>
</ol>
</li>
</ul>
<h4 id="2-解决方案：TLB-快表"><a href="#2-解决方案：TLB-快表" class="headerlink" title="2. 解决方案：TLB (快表)"></a>2. 解决方案：TLB (快表)</h4><p>为了解决“慢”的问题，科学家发明了 <strong>TLB (Translation Look-aside Buffer)</strong>，中文叫<strong>快表</strong>或<strong>联想寄存器</strong>。</p>
<ul>
<li><strong>它是什么？</strong> CPU 内部的一种<strong>极其快速</strong>、但容量很小的高速缓存。</li>
<li><strong>它存什么？</strong> 它存放<strong>当前最常访问</strong>的那一小部分页表项（Page # 到 Frame # 的映射）。</li>
<li><strong>原理：</strong> 利用程序的“局部性原理”。如果你刚看了第 5 页，你很可能马上又要看第 5 页。</li>
</ul>
<blockquote>
<p><strong>升级后的比喻：</strong></p>
<ul>
<li>你在手边放了一张<strong>小纸条（TLB）</strong>。</li>
<li>每次找书前，先看小纸条。如果纸条上有位置信息（<strong>TLB 命中</strong>），直接去拿书，不用跑去查目录了！</li>
</ul>
</blockquote>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221154628477.png" alt="image-20251221154628477"></p>
<h4 id="3-加入-TLB-后的工作流程"><a href="#3-加入-TLB-后的工作流程" class="headerlink" title="3. 加入 TLB 后的工作流程"></a>3. 加入 TLB 后的工作流程</h4><p>请看图 的流程图，这是现在的标准动作：</p>
<ol>
<li><strong>CPU 发出请求：</strong> 逻辑地址（页号 $p$）。</li>
<li><strong>先查 TLB（快）：</strong><ul>
<li><strong>情况 A：命中 (Hit)</strong><ul>
<li>直接拿到物理块号。</li>
<li><strong>耗时：</strong> 仅需 1 次内存访问（取数据）。</li>
</ul>
</li>
<li><strong>情况 B：未命中 (Miss)</strong><ul>
<li>没办法，只能老老实实去访问内存里的页表（慢）。</li>
<li>拿到块号后，<strong>顺手把这一项存进 TLB</strong>（以备下次用）。</li>
<li><strong>耗时：</strong> 2 次内存访问。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="分页存储空间的分配与去配"><a href="#分页存储空间的分配与去配" class="headerlink" title="分页存储空间的分配与去配"></a>分页存储空间的分配与去配</h3><h4 id="安全性问题：-怎么防止进程去访问不属于它的内存？"><a href="#安全性问题：-怎么防止进程去访问不属于它的内存？" class="headerlink" title="安全性问题： 怎么防止进程去访问不属于它的内存？"></a><strong>安全性问题：</strong> 怎么防止进程去访问不属于它的内存？</h4><p>之前学的页表，只是告诉 CPU “第 X 页在第 Y 块”。但这里有个漏洞：如果一个程序只有 5 页，但恶意（或错误）代码试图去访问“第 6 页”，会发生什么？</p>
<p>为了防止这种越界访问，操作系统在页表的每一行后面加了一个小尾巴，叫 <strong>“有效-无效位” (Valid-invalid bit)</strong>。</p>
<h5 id="1-机制详解"><a href="#1-机制详解" class="headerlink" title="1. 机制详解"></a>1. 机制详解</h5><ul>
<li><strong>v (valid)：有效</strong>。表示这一页是合法的，确实在物理内存里，且属于当前进程。</li>
<li><strong>i (invalid)：无效</strong>。表示这一页不属于该进程（或者该页还在磁盘上没调入内存）。</li>
<li><strong>后果：</strong> 如果 CPU 试图访问一个标记为 <strong>i</strong> 的页面，硬件会立即触发一个<strong>异常 (Exception/Trap)</strong>，操作系统会终止该进程或进行处理。</li>
</ul>
<h5 id="2-图中的数学例子（非常重要）"><a href="#2-图中的数学例子（非常重要）" class="headerlink" title="2. 图中的数学例子（非常重要）"></a>2. 图中的数学例子（非常重要）</h5><p>让我们拆解一下图中的计算题，看看它是怎么判定“第 6 页”是非法的：</p>
<ul>
<li><strong>前提条件：</strong><ul>
<li>页大小 = 2KB ($2^{11} = 2048$ 字节)。</li>
<li>这意味着地址的低 11 位是偏移量。</li>
</ul>
</li>
<li><strong>进程需求：</strong><ul>
<li>进程实际使用的地址范围是 <strong>0 ~ 10468</strong>。</li>
</ul>
</li>
<li><strong>计算需要多少页：</strong><ul>
<li><script type="math/tex; mode=display">\frac{10468}{2048} \approx 5.11</script></li>
<li>这意味着填满了第 0, 1, 2, 3, 4 页，并且第 5 页占用了一点点（0.11的部分）。</li>
<li>所以，总共需要 <strong>0~5 号页</strong>（共 6 个页）。</li>
</ul>
</li>
<li><strong>查看页表状态：</strong><ul>
<li>你看右边的页表，<strong>页号 0~5</strong> 的状态位都是 <strong>v</strong>（允许访问）。</li>
<li><strong>页号 6, 7</strong> 的状态位是 <strong>i</strong>（禁止访问）。</li>
<li>如果程序试图访问地址 12287（属于第 6 页），MMU 检查到是 ‘i’，直接报错拦截。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221155409519.png" alt="image-20251221155409519"></p>
<h4 id="管理问题：-操作系统怎么快速知道哪些物理格子是空的？"><a href="#管理问题：-操作系统怎么快速知道哪些物理格子是空的？" class="headerlink" title="管理问题： 操作系统怎么快速知道哪些物理格子是空的？"></a><strong>管理问题：</strong> 操作系统怎么快速知道哪些物理格子是空的？</h4><p>操作系统手里握着几千几万个物理页框，当新程序来的时候，怎么快速找到哪里有空位？<strong>位图 (Bitmap)</strong> 是最常用的方法。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><ul>
<li>用<strong>一串二进制位 (0和1)</strong> 来代表物理内存的格局。</li>
<li><strong>每一位 (bit)</strong> 对应一个 <strong>物理页框</strong>。</li>
<li><strong>映射规则：</strong><ul>
<li>第 1 个 bit 对应 第 1 个页框。</li>
<li>第 2 个 bit 对应 第 2 个页框…以此类推。</li>
</ul>
</li>
</ul>
<h5 id="2-状态表示"><a href="#2-状态表示" class="headerlink" title="2. 状态表示"></a>2. 状态表示</h5><ul>
<li><p><strong>1：</strong> 表示该页框<strong>被占用</strong>。</p>
</li>
<li><p>0： 表示该页框空闲。</p>
<p>(注：有些系统可能反过来，但根据这张PPT的文字“找出为 0 的那些位”，说明这里 0 代表空闲)</p>
</li>
</ul>
<h5 id="3-分配算法流程"><a href="#3-分配算法流程" class="headerlink" title="3. 分配算法流程"></a>3. 分配算法流程</h5><p>当一个程序需要申请 3 个页框时：</p>
<ol>
<li><strong>扫描：</strong> 操作系统扫描这个位图，寻找哪里有 <strong>“0”</strong>。</li>
<li><strong>计算：</strong> 比如发现第 5、6、8 位是 0。</li>
<li><strong>计算页框号：</strong><ul>
<li>发现第 $i$ 位是 0，那么对应的物理页框号就是 $i$（或者基于基址计算）。</li>
</ul>
</li>
<li><strong>修改状态：</strong> 把这几位从 <strong>0 变成 1</strong>（标记为占用）。</li>
<li><strong>分配：</strong> 把算出来的物理页框号填到进程的页表里。</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221155532240.png" alt="image-20251221155532240"></p>
<h3 id="多级页表-Multi-level-Page-Table"><a href="#多级页表-Multi-level-Page-Table" class="headerlink" title="多级页表 (Multi-level Page Table)"></a><strong>多级页表 (Multi-level Page Table)</strong></h3><h4 id="1-为什么要引入多级页表？-The-Problem"><a href="#1-为什么要引入多级页表？-The-Problem" class="headerlink" title="1. 为什么要引入多级页表？(The Problem)"></a>1. 为什么要引入多级页表？(The Problem)</h4><p>让我们做一个简单的数学计算：</p>
<ul>
<li><p>在 32 位系统下，页面大小 4KB。</p>
</li>
<li><p>这意味着总共有 <strong>$2^{20}$ (约 100 万)</strong> 个页面。</p>
</li>
<li><p>如果每个页表项占 4 字节，那么一张完整的页表需要：</p>
<script type="math/tex; mode=display">100\text{万} \times 4\text{B} = \mathbf{4\text{MB}}</script></li>
</ul>
<p><strong>痛点：</strong></p>
<ol>
<li><strong>必须连续：</strong> 在单级页表中，这 4MB 的空间必须在物理内存中<strong>连续存放</strong>。</li>
<li><strong>难找：</strong> 在内存紧张时，很难找到一块完整的、连续的 4MB 空间给页表住。</li>
<li><strong>浪费：</strong> 很多程序其实只用了一点点内存，但为了维持结构，你不得不把这 100 万个坑位都建好（哪怕大部分是空的）。</li>
</ol>
<p>解决方案：</p>
<p>把这 4MB 的大页表，也切成小块（页），散落在内存里！既然切碎了，就需要再建立一张表来管理这些碎块——这就是二级页表（页表的页表）。</p>
<h4 id="2-逻辑地址的重新划分"><a href="#2-逻辑地址的重新划分" class="headerlink" title="2. 逻辑地址的重新划分"></a>2. 逻辑地址的重新划分</h4><p>请看图，为了支持二级页表，逻辑地址被切得更碎了：</p>
<ul>
<li><strong>旧模式（单级）：</strong> 20位页号 ($p$) + 12位偏移 ($d$)。</li>
<li><strong>新模式（二级）：</strong><ul>
<li><strong>$p_1$ (10位)：一级页号</strong>（外层页号）。用来找“目录的目录”。</li>
<li><strong>$p_2$ (10位)：二级页号</strong>（内层页号）。用来找“具体的页表”。</li>
<li><strong>$d$ (12位)：页内偏移</strong>。保持不变。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么是 10 位？</p>
<p>$2^{10} = 1024$。每个页表项 4 字节。</p>
<p>$1024 \times 4\text{B} = 4\text{KB}$。</p>
<p>妙处： 这样切割后，每一张二级页表的大小刚好是一个页面 (4KB)！这让页表本身也可以完美地塞进普通的内存页框里。</p>
</blockquote>
<h4 id="地址变换过程-The-Walk"><a href="#地址变换过程-The-Walk" class="headerlink" title="地址变换过程 (The Walk)"></a>地址变换过程 (The Walk)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221161021945.png" alt="image-20251221161021945"></p>
<p>请看图，这是一个<strong>“三步跳”</strong>的过程：</p>
<ol>
<li><strong>第一跳（查目录）：</strong><ul>
<li>CPU 拿着 <strong>$p_1$</strong>，去查<strong>一级页表</strong>。</li>
<li>得到结果：知道“这一段地址对应的<strong>二级页表</strong>”在内存的什么位置。</li>
</ul>
</li>
<li><strong>第二跳（查页表）：</strong><ul>
<li>CPU 拿着 <strong>$p_2$</strong>，去刚才找到的那张<strong>二级页表</strong>里查。</li>
<li>得到结果：终于拿到了真正的<strong>物理块号 (Frame #)</strong>。</li>
</ul>
</li>
<li><strong>第三跳（取数据）：</strong><ul>
<li>用物理块号 + <strong>偏移量 $d$</strong>，去访问<strong>物理内存</strong>，拿到真正的数据。</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>离散存储页表：</strong> 页表不需要 4MB 连续空间了，可以打散放在各种角落。</li>
<li><strong>节省空间：</strong> 如果一个程序只用了很小的内存，我们只需要建立“一级页表”和“少量二级页表”即可。其他的二级页表根本不用创建（或者可以留在磁盘上）。</li>
</ul>
<p><strong>缺点（如图片右上角文字所示）：</strong></p>
<ul>
<li><strong>变慢了！</strong><ul>
<li>单级页表：访存 2 次（查表+取数）。</li>
<li>二级页表：<strong>访存 3 次</strong>（查一级+查二级+取数）。</li>
<li><em>多级页表级数越多，访问越慢。</em></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>补救措施：</strong> 这就是为什么上一节讲的 <strong>TLB (快表)</strong> 极其重要！如果有 TLB，大部分时候我们直接能拿到结果，不需要走这漫长的三步跳。</p>
</blockquote>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><h4 id="1-为什么要分段？"><a href="#1-为什么要分段？" class="headerlink" title="1. 为什么要分段？"></a>1. 为什么要分段？</h4><p>请看图，这解释了分段的初衷：</p>
<ul>
<li><strong>程序员眼中的程序：</strong><ul>
<li>程序员写代码时，不会认为程序是一堆 4KB 的碎片。</li>
<li>我们认为程序是由<strong>不同的功能块</strong>组成的：比如 <strong>主程序 (main)</strong>、<strong>子程序 (subroutine)</strong>、<strong>栈 (stack)</strong>、<strong>变量数组 (array)</strong> 等。</li>
</ul>
</li>
<li><strong>分页的尴尬：</strong> 分页像碎纸机，可能把一个完整的函数切成两半，一半在第 1 页，一半在第 20 页。这让共享和保护变得很麻烦。</li>
<li><strong>分段的解决：</strong> 保持逻辑完整。<ul>
<li><strong>主程序</strong> 单独一段。</li>
<li><strong>栈</strong> 单独一段。</li>
<li><strong>数据表</strong> 单独一段。</li>
<li><strong>特点：</strong> 每个段的大小<strong>不固定</strong>（主程序可能 50KB，栈可能 1KB）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>黄金类比：</strong></p>
<ul>
<li><strong>分页</strong> 像是把一本书的每一页撕下来，胡乱塞进一个个一样大的信封里。</li>
<li><strong>分段</strong> 像是把书按<strong>“章”</strong>分开。第一章放一个文件夹，第二章放一个文件夹。有的章长，有的章短。</li>
</ul>
</blockquote>
<h4 id="2-逻辑地址的变化-2D-Address"><a href="#2-逻辑地址的变化-2D-Address" class="headerlink" title="2. 逻辑地址的变化 (2D Address)"></a>2. 逻辑地址的变化 (2D Address)</h4><p>在分段管理中，地址不再是一维的线性的，而是<strong>二维</strong>的。</p>
<p>请看图 的底部：</p>
<ul>
<li><strong>逻辑地址 = 段号 (Segment Number) + 段内偏移 (Offset)</strong></li>
<li><em>例子：</em> “第 1 段 的 第 500 行”。</li>
</ul>
<p><strong>关键区别：</strong></p>
<ul>
<li><strong>分页：</strong> 只要给出一个物理地址，机器自动切分。</li>
<li><strong>分段：</strong> 用户（编译器）必须显式地指定“段号”和“段内偏移”。</li>
</ul>
<h4 id="3-核心机制：段表-Segment-Table"><a href="#3-核心机制：段表-Segment-Table" class="headerlink" title="3. 核心机制：段表 (Segment Table)"></a>3. 核心机制：段表 (Segment Table)</h4><p>既然段的大小不固定，操作系统怎么管理呢？请看图。</p>
<p>我们需要一张<strong>段表</strong>，用来记录每个“章”在内存里的位置。因为每一章长度不一样，所以段表必须包含<strong>两列核心信息</strong>：</p>
<ol>
<li><strong>段起始地址 (Base)：</strong> 这个段在物理内存是从哪里开始的？（比如从 6300 开始）。</li>
<li><strong>段长度 (Limit/Length)：</strong> 这个段到底有多大？（比如只有 400 大小）。<ul>
<li><em>注意：页表不需要记录“长度”，因为页表默认全是 4KB。但在分段中，这个长度至关重要！</em></li>
</ul>
</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221162559750.png" alt="image-20251221162559750"></p>
<h4 id="4-地址变换与保护-The-Translation-amp-Safety"><a href="#4-地址变换与保护-The-Translation-amp-Safety" class="headerlink" title="4. 地址变换与保护 (The Translation &amp; Safety)"></a>4. 地址变换与保护 (The Translation &amp; Safety)</h4><p>这是分段管理最厉害的地方：<strong>越界保护</strong>。</p>
<p>我们模拟一次 CPU 访问（结合图 的数据）：</p>
<ul>
<li><strong>场景：</strong> CPU 要访问 <strong>段号 1</strong>，<strong>偏移量 500</strong> 的数据。</li>
</ul>
<p><strong>步骤：</strong></p>
<ol>
<li><strong>查表：</strong> 找到段表里的第 1 项。</li>
<li><strong>获取信息：</strong><ul>
<li>基址 (Base) = <strong>6300</strong></li>
<li>限长 (Length) = <strong>400</strong></li>
</ul>
</li>
<li><strong>越界检查 (Critical Step)：</strong><ul>
<li>CPU 会拿你的偏移量 <strong>500</strong> 和 限长 <strong>400</strong> 比较。</li>
<li><strong>500 &gt; 400</strong>，说明你试图访问这一段之外的地方！</li>
<li><strong>结果：</strong> 硬件直接拦截，抛出 <strong>“段错误” (Segmentation Fault)</strong>。这是编程时最常见的报错之一。</li>
</ul>
</li>
<li><strong>正常情况：</strong> 如果偏移量是 100（小于 400），则物理地址 = $6300 + 100 = 6400$。</li>
</ol>
<h2 id="虚拟内存-Virtual-Memory"><a href="#虚拟内存-Virtual-Memory" class="headerlink" title="虚拟内存 (Virtual Memory)"></a>虚拟内存 (Virtual Memory)</h2><h4 id="1-痛点：实存管理的问题"><a href="#1-痛点：实存管理的问题" class="headerlink" title="1. 痛点：实存管理的问题"></a>1. 痛点：实存管理的问题</h4><p>请看图，传统的<strong>实存管理</strong>（Real Memory Management）有一个硬性规定：</p>
<ul>
<li><strong>必须全部装入：</strong> 作业（程序）如果要运行，必须把它的<strong>全部信息</strong>一次性装入内存。</li>
<li><strong>后果：</strong><ol>
<li><strong>大程序跑不了：</strong> 程序的体积受限于物理内存的大小。</li>
<li><strong>浪费资源：</strong> 其实程序里很多代码是很少用到的（比如“异常处理代码”、“巨大的未填满的数组”）。把这些一辈子都不一定跑一次的代码一直放在昂贵的内存里，是极大的浪费。</li>
</ol>
</li>
</ul>
<h4 id="2-解决方案：虚拟内存"><a href="#2-解决方案：虚拟内存" class="headerlink" title="2. 解决方案：虚拟内存"></a>2. 解决方案：虚拟内存</h4><p>虚拟内存的核心思想就是<strong>“欺骗”</strong>。</p>
<ul>
<li><strong>核心动作：部分装入 (Partial Loading)</strong>。<ul>
<li>操作系统不再把整个程序塞进内存，而是<strong>只把当前立刻要用的那几页</strong>装进去，剩下的留在硬盘上。</li>
<li>程序运行到哪里，就动态地把哪里的数据从硬盘“拉”进内存（请求调页）。</li>
<li>如果内存满了，就把暂时不用的数据“踢”回硬盘（页面置换）。</li>
</ul>
</li>
<li><strong>效果：</strong><ul>
<li><strong>逻辑 &gt; 物理：</strong> 给用户提供一个<strong>比物理主存大得多</strong>的“虚拟主存”。</li>
<li><strong>以小博大：</strong> 8GB 的物理内存，可以流畅运行 20GB 的游戏，甚至可以同时运行总共 100GB 的多个程序。</li>
</ul>
</li>
</ul>
<h4 id="3-理论基石：局部性原理"><a href="#3-理论基石：局部性原理" class="headerlink" title="3. 理论基石：局部性原理"></a>3. 理论基石：局部性原理</h4><p>你可能会问：“这样频繁地在内存和硬盘之间倒腾数据，电脑不会卡死吗？” 答案是：<strong>通常不会</strong>。因为程序运行有一个神奇的规律，叫<strong>“局部性原理”</strong>。</p>
<p>请看图，它解释了为什么我们敢“只装入一部分”：</p>
<ol>
<li><strong>时间局部性 (Temporal Locality)：</strong><ul>
<li><strong>现象：</strong> 如果一条指令被执行了，那么不久之后它<strong>很有可能再次被执行</strong>。</li>
<li><strong>原因：</strong> 程序里充满了大量的<strong>循环 (Loop)</strong>。一旦进入循环，CPU 就会盯着这几行代码反复跑，完全不需要访问其他页面的代码。</li>
</ul>
</li>
<li><strong>空间局部性 (Spatial Locality)：</strong><ul>
<li><strong>现象：</strong> 如果一个存储单元被访问了，那么它<strong>附近的单元</strong>也很有可能马上被访问。</li>
<li><strong>原因：</strong> 指令通常是顺序执行的；数据通常是聚集成群的（比如<strong>数组</strong>、<strong>表</strong>）。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>结论：</strong> 在一段较短的时间内，程序实际上只需要访问<strong>极小一部分</strong>内存就能正常工作。所以我们完全可以把剩下的 90% 扔在硬盘里睡觉，而不影响运行速度。</p>
</blockquote>
<h3 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h3><p>要实现虚拟内存，<strong>不能</strong>使用我们最早学的“连续分配方式”（因为要频繁地把一大块程序搬进搬出，效率太低且不仅能保证连续空间）。</p>
<p>因此，虚拟内存必须建立在<strong>离散分配（非连续分配）</strong>的基础上。</p>
<p>根据课件，实现虚拟内存主要有以下三个流派和两个核心“新技能”：</p>
<h4 id="1-三种实现方式"><a href="#1-三种实现方式" class="headerlink" title="1. 三种实现方式"></a>1. 三种实现方式</h4><p>其实就是把你之前学的“基本款”升级为“虚拟款”：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>基础版本 (全部装入)</strong></th>
<th><strong>虚拟版本 (部分装入，按需调页)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>基本分页存储管理</td>
<td><strong>页式虚拟存储管理</strong> (最主流)</td>
</tr>
<tr>
<td>基本分段存储管理</td>
<td><strong>段式虚拟存储管理</strong></td>
</tr>
<tr>
<td>基本段页式存储管理</td>
<td><strong>段页式虚拟存储管理</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-两个新增的核心功能"><a href="#2-两个新增的核心功能" class="headerlink" title="2. 两个新增的核心功能"></a>2. 两个新增的核心功能</h4><p>这是“虚拟系统”和“普通系统”最本质的区别。为了实现“空手套白狼”，操作系统必须具备两项新能力：</p>
<h5 id="A-请求调页-调段功能-Demand-Paging-Segmentation"><a href="#A-请求调页-调段功能-Demand-Paging-Segmentation" class="headerlink" title="A. 请求调页/调段功能 (Demand Paging/Segmentation)"></a>A. 请求调页/调段功能 (Demand Paging/Segmentation)</h5><ul>
<li><strong>动作：</strong> <strong>“缺了就拿”</strong>。</li>
<li><strong>描述：</strong> 在程序执行过程中，当 CPU 发现要访问的数据<strong>不在内存</strong>时（缺页），操作系统负责把所需的信息从硬盘（外存）<strong>调入内存</strong>，然后让程序继续执行。</li>
</ul>
<h5 id="B-页面置换-段置换功能-Page-Segment-Replacement"><a href="#B-页面置换-段置换功能-Page-Segment-Replacement" class="headerlink" title="B. 页面置换/段置换功能 (Page/Segment Replacement)"></a>B. 页面置换/段置换功能 (Page/Segment Replacement)</h5><ul>
<li><strong>动作：</strong> <strong>“满了就扔”</strong>。</li>
<li><strong>描述：</strong> 当内存空间<strong>不够</strong>的时候，操作系统负责利用某种算法，把内存中暂时<strong>用不到</strong>的信息（页面或段）<strong>换出</strong>到硬盘上，腾出地方给新进来的页面用。</li>
</ul>
<h3 id="页式虚拟存储管理"><a href="#页式虚拟存储管理" class="headerlink" title="页式虚拟存储管理"></a>页式虚拟存储管理</h3><h4 id="1-核心思想：按需调入-Demand-Paging"><a href="#1-核心思想：按需调入-Demand-Paging" class="headerlink" title="1. 核心思想：按需调入 (Demand Paging)"></a>1. 核心思想：按需调入 (Demand Paging)</h4><ul>
<li><strong>启动时：</strong> 操作系统<strong>只把进程的第一页</strong>（或者极少量的几页）装入内存，然后就让 CPU 开始跑。</li>
<li><strong>运行时：</strong><ul>
<li>CPU 执行着执行着，发现要访问的下一行代码在“第 5 页”。</li>
<li>一查页表，发现第 5 页不在内存里。</li>
<li><strong>动作：</strong> 暂停程序，去硬盘把第 5 页抓进来，然后继续跑。</li>
</ul>
</li>
<li><strong>地位：</strong> 这是现代 OS 的<strong>主流存储管理技术</strong>。</li>
</ul>
<h4 id="2-基础设施升级：扩充页表-Expanded-Page-Table"><a href="#2-基础设施升级：扩充页表-Expanded-Page-Table" class="headerlink" title="2. 基础设施升级：扩充页表 (Expanded Page Table)"></a>2. 基础设施升级：扩充页表 (Expanded Page Table)</h4><p>为了支持这种“有的在内存，有的在硬盘”的复杂情况，原来的页表（只记录页号-&gt;块号）已经不够用了。我们需要给页表加很多“状态栏”。</p>
<p>请看图，现在的页表项变得很宽，包含了以下关键信息：</p>
<ol>
<li><strong>驻留标识 (Present/Resident bit)：</strong> <strong>最重要的一位</strong>。<ul>
<li><code>1</code>: 表示该页<strong>在内存中</strong>（可以直接访问）。</li>
<li><code>0</code>: 表示该页<strong>在磁盘上</strong>（需要触发中断去调入）。</li>
</ul>
</li>
<li><strong>写回标志 (Dirty/Modify bit)：</strong><ul>
<li>记录这一页在内存里有没有被<strong>修改</strong>过。</li>
<li><strong>作用：</strong> 当这一页要被踢出内存时，如果是“脏”的（被改过），必须写回硬盘保存；如果是“干净”的，直接扔掉就行（硬盘里有原版），省了一次磁盘 IO。</li>
</ul>
</li>
<li><strong>引用标志 (Reference bit)：</strong><ul>
<li>记录这一页最近有没有被访问过。</li>
<li><strong>作用：</strong> 给<strong>置换算法</strong>参考。最近刚被用过的，最好别踢它（LRU 算法的基础）。</li>
</ul>
</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170033104.png" alt="image-20251221170033104"></p>
<h4 id="3-核心机制：缺页中断-Page-Fault"><a href="#3-核心机制：缺页中断-Page-Fault" class="headerlink" title="3. 核心机制：缺页中断 (Page Fault)"></a>3. 核心机制：缺页中断 (Page Fault)</h4><p>当 CPU 想要访问一个<strong>“驻留标识为 0”</strong>（不在内存）的页面时，就会触发<strong>缺页中断</strong>。这是虚拟内存运转的“引擎”。</p>
<ol>
<li><strong>CPU 访问：</strong> 给出逻辑地址。</li>
<li><strong>硬件检查：</strong> 发现页表里这一项显示“不在内存”。</li>
<li><strong>产生中断：</strong> 硬件立刻产生<strong>缺页中断</strong>，CPU 暂停当前进程，把控制权交给操作系统。</li>
<li><strong>OS 处理 (关键分支)：</strong><ul>
<li><strong>情况 A（内存有空位）：</strong><ul>
<li>直接从磁盘找到该页，读入空闲的页框。</li>
<li>修改页表（把驻留位置 1，填入块号）。</li>
</ul>
</li>
<li><strong>情况 B（内存满了）：</strong><ul>
<li>执行<strong>页面置换算法</strong>，挑一个倒霉蛋（淘汰页）踢出去。</li>
<li>如果那个倒霉蛋被修改过，先把它写回磁盘。</li>
<li>把腾出来的空位给新页面用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>恢复执行：</strong> 操作系统更新完页表后，<strong>重新执行</strong>刚才那条导致中断的指令。这一次，CPU 就能顺利找到数据了。</li>
</ol>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170552446.png" alt="image-20251221170552446"></p>
<h3 id="虚存地址转换过程"><a href="#虚存地址转换过程" class="headerlink" title="虚存地址转换过程"></a>虚存地址转换过程</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221170856192.png" alt="image-20251221170856192"></p>
<h4 id="第一阶段：启动与分流"><a href="#第一阶段：启动与分流" class="headerlink" title="第一阶段：启动与分流"></a>第一阶段：启动与分流</h4><p><strong>1. 地址分解 (Step 1)</strong></p>
<ul>
<li><strong>动作：</strong> CPU 发出指令，MMU（内存管理单元）截获逻辑地址，自动把它切成两半：<strong>页号 ($p$)</strong> 和 <strong>页内偏移 ($d$)</strong>。</li>
</ul>
<p><strong>2. 查快表 (Step 2)</strong></p>
<ul>
<li><strong>动作：</strong> 以页号 $p$ 为索引，先去查 CPU 内部的 <strong>快表 (TLB)</strong>。</li>
<li><strong>耗时：</strong> $t_1$（非常短，纳秒级）。</li>
</ul>
<h4 id="第二阶段：三种可能的命运"><a href="#第二阶段：三种可能的命运" class="headerlink" title="第二阶段：三种可能的命运"></a>第二阶段：三种可能的命运</h4><h5 id="命运一：快表命中-TLB-Hit-——-极速模式"><a href="#命运一：快表命中-TLB-Hit-——-极速模式" class="headerlink" title="命运一：快表命中 (TLB Hit) —— 极速模式"></a>命运一：快表命中 (TLB Hit) —— 极速模式</h5><p>这是图中 <strong>(3)</strong> 的路径。</p>
<ul>
<li><strong>情况：</strong> 在 TLB 里直接找到了页号对应的物理块号。</li>
<li><strong>结果：</strong><ul>
<li>直接取出块号。</li>
<li><strong>拼接：</strong> 块号 + 偏移量 = 物理地址。</li>
<li><strong>访问数据：</strong> 去访问主存（耗时 $t_2$）。</li>
</ul>
</li>
<li><strong>总耗时：</strong> $t_1 (\text{查TLB}) + t_2 (\text{取数据})$。</li>
</ul>
<h5 id="命运二：快表未命中，但页表命中-——-普通模式"><a href="#命运二：快表未命中，但页表命中-——-普通模式" class="headerlink" title="命运二：快表未命中，但页表命中 —— 普通模式"></a>命运二：快表未命中，但页表命中 —— 普通模式</h5><p>这是图中 <strong>(4) -&gt; (5)</strong> 的路径。</p>
<ul>
<li><p><strong>情况：</strong> TLB 里没找到（Miss），但MMU 去查内存里的 <strong>页表</strong> 时，发现该页<strong>在内存中</strong>（驻留位为 1）。</p>
</li>
<li><p><strong>动作：</strong></p>
<ol>
<li>从页表中读出物理块号。</li>
<li><strong>关键动作：装入快表 (Load TLB)</strong>。为了下次能快点，把这一项复制到 TLB 里。</li>
<li>形成物理地址，访问数据。</li>
</ol>
</li>
<li><p>总耗时： $t_1 (\text{查TLB}) + t_2 (\text{查页表}) + t_2 (\text{取数据})$。</p>
<p>(比命运一多了一次访存的时间)</p>
</li>
</ul>
<h5 id="命运三：缺页中断-——-龟速模式"><a href="#命运三：缺页中断-——-龟速模式" class="headerlink" title="命运三：缺页中断 —— 龟速模式"></a>命运三：缺页中断 —— 龟速模式</h5><p>这是图中 <strong>(6) -&gt; (7) -&gt; (8)</strong> 的路径（红色箭头）。</p>
<ul>
<li><strong>情况：</strong> TLB 没找到，查内存页表发现<strong>也不在内存中</strong>（驻留位为 0，失效）。</li>
<li><strong>动作：</strong><ol>
<li><strong>Step (6) 缺页中断：</strong> MMU 发出信号，CPU 暂停，操作系统接管。</li>
<li><strong>Step (7) 调页：</strong> 操作系统去 <strong>辅助存储器 (磁盘)</strong> 里把这一页找出来，读入内存。<ul>
<li><em>注意：这一步耗时是 $t_3$，通常是毫秒级，比前两种慢几万倍。</em></li>
</ul>
</li>
<li><strong>Step (8) 装入/改表：</strong> 数据读进内存后，操作系统更新 <strong>页表</strong> 和 <strong>快表</strong>，把状态改为“在内存”。</li>
</ol>
</li>
<li><strong>结局：</strong> 重启指令，这次就会走“命运一”或“命运二”了。</li>
</ul>
<h3 id="缺页中断率-Page-Fault-Rate"><a href="#缺页中断率-Page-Fault-Rate" class="headerlink" title="缺页中断率 (Page Fault Rate)"></a>缺页中断率 (Page Fault Rate)</h3><p>怎么衡量虚拟内存效率高不高？就看<strong>缺页中断率 ($f$)</strong>。</p>
<ul>
<li><p>公式：</p>
<script type="math/tex; mode=display">f = \frac{F}{S + F}</script><ul>
<li>$F$: 缺页次数（去磁盘拿的次数）。</li>
<li>$S$: 成功在内存找到的次数。</li>
<li><strong>目标：</strong> 我们希望 $f$ 无限接近于 0。</li>
</ul>
</li>
<li><p><strong>影响 $f$ 的四大因素：</strong></p>
<ol>
<li><strong>内存页框数：</strong> 给进程分的“房间”越多，缺页率越低。</li>
<li><strong>页面大小：</strong> 页面越大，缺页率通常越低（因为一次拉进来更多数据），但浪费也可能变大。</li>
<li><strong>页面替换算法：</strong> 算法越聪明（踢得越准），缺页率越低。</li>
<li><strong>程序特性：</strong> <strong>这不仅是 OS 的事，也是程序员的事！</strong></li>
</ol>
</li>
</ul>
<h3 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h3><h4 id="最佳页面调度算法-OPT-OPTimal-replacement"><a href="#最佳页面调度算法-OPT-OPTimal-replacement" class="headerlink" title="最佳页面调度算法(OPT, OPTimal replacement)"></a>最佳页面调度算法(OPT, OPTimal replacement)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221173735698.png" alt="image-20251221173735698"></p>
<h4 id="先进先出页面调度算法-FIFO-First-In-First-Out-replacement"><a href="#先进先出页面调度算法-FIFO-First-In-First-Out-replacement" class="headerlink" title="先进先出页面调度算法(FIFO, First-In First-Out replacement)"></a>先进先出页面调度算法(FIFO, First-In First-Out replacement)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221173753487.png" alt="image-20251221173753487"></p>
<h5 id="Belady异常"><a href="#Belady异常" class="headerlink" title="Belady异常"></a>Belady异常</h5><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174117271-1766310078350-1.png" alt="image-20251221174117271"></p>
<p><strong>为什么会发生这种事？</strong></p>
<p>Belady 异常的根本原因在于 <strong>FIFO 算法的“无脑”</strong>。</p>
<ul>
<li><strong>FIFO 的逻辑：</strong> 只看<strong>进入内存的时间</strong>，谁来得早谁滚蛋。</li>
<li><strong>问题所在：</strong> 它完全不考虑页面的<strong>使用频率</strong>或<strong>访问模式</strong>。<ul>
<li>在上面的 4 页框例子中，<code>4</code> 和 <code>3</code> 是经常要被访问的热门页面。</li>
<li>但是因为它们进来得早，FIFO 总是优先把它们踢出去。</li>
<li>当页框变多时，页面的驻留时间变长了，队列的结构变了，导致原本能“巧合”命中的页面（比如在3页框时，踢出的顺序刚好避开了马上要用的页），在4页框时反而被“精准”地踢出去了。</li>
</ul>
</li>
</ul>
<h4 id="最近最少使用页面调度算法-LRU-Least-Recently-Used-replacement"><a href="#最近最少使用页面调度算法-LRU-Least-Recently-Used-replacement" class="headerlink" title="最近最少使用页面调度算法(LRU, Least Recently Used replacement)"></a>最近最少使用页面调度算法(LRU, Least Recently Used replacement)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174219298.png" alt="image-20251221174219298"></p>
<h4 id="最不常用页面调度算法-LFU-least-frequently-used"><a href="#最不常用页面调度算法-LFU-least-frequently-used" class="headerlink" title="最不常用页面调度算法(LFU, least frequently used)"></a>最不常用页面调度算法(LFU, least frequently used)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221174254213.png" alt="image-20251221174254213"></p>
<h4 id="时钟页面调度算法-Clock-Clock-policy-replacement"><a href="#时钟页面调度算法-Clock-Clock-policy-replacement" class="headerlink" title="时钟页面调度算法(Clock, Clock policy replacement)"></a>时钟页面调度算法(Clock, Clock policy replacement)</h4><h5 id="1-核心道具-The-Setup"><a href="#1-核心道具-The-Setup" class="headerlink" title="1. 核心道具 (The Setup)"></a>1. 核心道具 (The Setup)</h5><p>要玩转这个算法，需要三个关键道具：</p>
<ol>
<li><strong>环形队列 (Circular Queue)：</strong><ul>
<li>把内存里的所有页面首尾相连，排成一个圆圈，就像<strong>钟面</strong>一样。</li>
</ul>
</li>
<li><strong>表针 (Pointer)：</strong><ul>
<li>有一个指针，指向当前要检查的那个页面（下一号淘汰候选人）。</li>
</ul>
</li>
<li><strong>引用标志位 (Reference/Use Bit)：</strong><ul>
<li>每个页面都有一个标志位。</li>
<li><strong>1</strong> = 最近被访问过（免死金牌）。</li>
<li><strong>0</strong> = 最近没被访问（可以杀）。</li>
</ul>
</li>
</ol>
<h5 id="2-算法规则：给一次“改过自新”的机会"><a href="#2-算法规则：给一次“改过自新”的机会" class="headerlink" title="2. 算法规则：给一次“改过自新”的机会"></a>2. 算法规则：给一次“改过自新”的机会</h5><p>Clock 算法的核心逻辑就是<strong>“二次机会” (Second Chance)</strong>。</p>
<p>当内存满了，需要踢人时，指针开始顺时针扫描：</p>
<ul>
<li><strong>情况 A：遇到标志位是 1 的页面</strong><ul>
<li><strong>动作：</strong> 操作系统心软了。它把标志位<strong>改为 0</strong>（没收免死金牌），然后指针<strong>移向下一页</strong>。</li>
<li><strong>潜台词：</strong> “我看你最近刚被用过，这次先不杀你，但我把你的牌子没收了。如果下次我转回来你还没被访问，那你就在劫难逃了。”</li>
</ul>
</li>
<li><strong>情况 B：遇到标志位是 0 的页面</strong><ul>
<li><strong>动作：</strong> 操作系统不客气了。<strong>直接淘汰</strong>这个页面！</li>
<li><strong>后续：</strong> 把新页面装进这个坑位，把标志位<strong>置为 1</strong>，指针<strong>移向下一页</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251221193222438.png" alt="image-20251221193222438"></p>
<h3 id="段式虚拟存储管理"><a href="#段式虚拟存储管理" class="headerlink" title="段式虚拟存储管理"></a>段式虚拟存储管理</h3><p>如果有需要再学</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="设备控制方式"><a href="#设备控制方式" class="headerlink" title="设备控制方式"></a>设备控制方式</h3><h4 id="为什么要有设备控制方式"><a href="#为什么要有设备控制方式" class="headerlink" title="为什么要有设备控制方式"></a>为什么要有设备控制方式</h4><h5 id="1-巨大的速度鸿沟-The-Speed-Gap"><a href="#1-巨大的速度鸿沟-The-Speed-Gap" class="headerlink" title="1. 巨大的速度鸿沟 (The Speed Gap)"></a>1. 巨大的速度鸿沟 (The Speed Gap)</h5><p>这是最根本的原因。</p>
<ul>
<li><strong>CPU</strong>：是电子设备，运算速度以<strong>纳秒 (ns)</strong> 计，一秒钟能执行几十亿次指令。</li>
<li><strong>I/O设备</strong>：大多包含机械部件（如硬盘磁头转动、打印机喷墨），速度以<strong>毫秒 (ms)</strong> 甚至秒计。</li>
</ul>
<p><strong>差距有多大？</strong> 如果把 CPU 比作一列<strong>高铁</strong>（时速 300公里），那 I/O 设备就像是一只<strong>蜗牛</strong>。 如果没有优化的“控制方式”（比如让 CPU 傻等的轮询方式），就相当于<strong>让高铁停下来等蜗牛爬过铁轨</strong>。这简直是暴殄天物，极大地浪费了昂贵的 CPU 资源。</p>
<p><strong>所以，设备控制方式的演进，本质上就是为了不让高铁等蜗牛。</strong></p>
<h5 id="2-实现“并行操作”-Parallelism"><a href="#2-实现“并行操作”-Parallelism" class="headerlink" title="2. 实现“并行操作” (Parallelism)"></a>2. 实现“并行操作” (Parallelism)</h5><p>操作系统的核心目标之一是<strong>效率</strong>。我们希望计算机能同时做多件事。</p>
<ul>
<li><strong>没有好的控制方式时</strong>：CPU 必须亲自指挥设备每一个动作。CPU 在忙 I/O 的时候，就不能做计算；做计算的时候，就不能管 I/O。这是<strong>串行</strong>的。</li>
<li><strong>有了好的控制方式（如 DMA、通道）</strong>：<ul>
<li>CPU 说：“你去把电影拷贝一下。”（发指令）</li>
<li>CPU 转头去运行游戏逻辑。（做计算）</li>
<li>设备控制器自己在旁边慢慢拷贝电影。（做 I/O）</li>
</ul>
</li>
</ul>
<p>这就是<strong>CPU 与设备的并行</strong>。只有通过先进的设备控制方式，才能把 CPU 从繁琐的搬运工作中解放出来，让它去处理更有价值的逻辑运算。</p>
<h5 id="3-屏蔽设备的复杂性-Abstraction"><a href="#3-屏蔽设备的复杂性-Abstraction" class="headerlink" title="3. 屏蔽设备的复杂性 (Abstraction)"></a>3. 屏蔽设备的复杂性 (Abstraction)</h5><p>世界上的设备千奇百怪：鼠标、键盘、显卡、网卡、打印机、VR眼镜……</p>
<ul>
<li>它们的物理原理完全不同。</li>
<li>它们的数据格式完全不同。</li>
</ul>
<p>如果让 CPU 直接去控制每一个物理细节（比如控制硬盘电机转几圈、控制打印机喷头往哪喷），CPU 的指令集会变得无比复杂，且操作系统无法通用。</p>
<p><strong>设备控制方式（配合硬件控制器）起到了一层“翻译”和“管家”的作用：</strong></p>
<ul>
<li>CPU 只需要下达统一的命令（读、写）。</li>
<li>具体的脏活累活（如何控制电压、如何校验数据、如何按顺序传输）交给<strong>设备控制器</strong>和<strong>控制逻辑</strong>（如 DMA 控制器）去完成。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>谁在搬运数据？</strong></th>
<th><strong>CPU 干预频率</strong></th>
<th><strong>传输单位</strong></th>
<th><strong>效率 (并行程度)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>轮询</strong></td>
<td>CPU</td>
<td>极高 (时刻在检查)</td>
<td>字/字节</td>
<td>低</td>
</tr>
<tr>
<td><strong>中断</strong></td>
<td>CPU</td>
<td>高 (每单位数据一次)</td>
<td>字/字节</td>
<td>中</td>
</tr>
<tr>
<td><strong>DMA</strong></td>
<td>DMA控制器</td>
<td>低 (每块数据一次)</td>
<td><strong>数据块</strong></td>
<td>高</td>
</tr>
<tr>
<td><strong>通道</strong></td>
<td>通道处理器</td>
<td>极低 (每组任务一次)</td>
<td><strong>多组数据块</strong></td>
<td>极高</td>
</tr>
</tbody>
</table>
</div>
<p>四者之间差异在于：CPU和设备并行工作的方式和程度不同。</p>
<h4 id="轮询（Polling）"><a href="#轮询（Polling）" class="headerlink" title="轮询（Polling）"></a>轮询（Polling）</h4><p><strong>流程解析</strong>：</p>
<ol>
<li><strong>发出命令</strong>：CPU 告诉设备（控制器）“我要读数据”。</li>
<li><strong>读状态</strong>：CPU 紧接着去读设备的状态寄存器。</li>
<li><strong>检查状态（关键点）</strong>：<ul>
<li>如果设备<strong>“未就绪”</strong>（还在忙着准备数据），CPU <strong>顺着红色箭头</strong>跳回去，再次读取状态。</li>
<li>CPU 会一直在“读状态 -&gt; 检查 -&gt; 未就绪 -&gt; 读状态”这个圈里打转。</li>
</ul>
</li>
<li><strong>读写数据</strong>：只有当设备终于显示“就绪”了，CPU 才会跳出循环，亲自把数据读进来。</li>
</ol>
<p><strong>核心特点：CPU 全程陪跑 (CPU 全程参与)</strong></p>
<p><strong>忙等 (Busy Waiting)</strong>：</p>
<ul>
<li>这就是上面说的那个“死循环”。在设备准备数据的这段时间（对于 CPU 来说极其漫长），CPU 没有去干别的更有意义的事，而是像个复读机一样一直问“好了没？”。</li>
<li><strong>结果</strong>：CPU 的利用率被严重拉低。</li>
</ul>
<p><strong>串行工作</strong>：</p>
<ul>
<li>PPT 文字提到：“在设备接受 I/O 命令之前处理器不能执行其他操作”。</li>
<li>这意味着 <strong>计算任务</strong> 和 <strong>I/O 任务</strong> 是完全<strong>串行</strong>的（排队做）。CPU 不能在设备忙的时候去算别的题。</li>
</ul>
<h4 id="中断驱动方式-Interrupt-Driven-I-O"><a href="#中断驱动方式-Interrupt-Driven-I-O" class="headerlink" title="中断驱动方式 (Interrupt-Driven I/O)"></a>中断驱动方式 (Interrupt-Driven I/O)</h4><p>当设备准备好了（状态变为“就绪”），控制器会向 CPU 发送一个电信号，这个信号就叫<strong>中断</strong>。</p>
<p><strong>CPU 的反应</strong>：</p>
<ol>
<li>收到信号，<strong>暂停</strong>当前正在做的工作（保存现场）。</li>
<li>跳到 <strong>“中断处理程序”</strong>（流程图中的黄色框）。</li>
<li><strong>传送数据</strong>：CPU 亲自把数据从设备搬运到内存。</li>
<li><strong>恢复</strong>：搬运完后，CPU 回到刚才暂停的地方继续工作。</li>
</ol>
<h4 id="直接存储器访问（DMA-Direct-Memory-Access）"><a href="#直接存储器访问（DMA-Direct-Memory-Access）" class="headerlink" title="直接存储器访问（DMA, Direct Memory Access）"></a>直接存储器访问（DMA, Direct Memory Access）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223153957188.png" alt="image-20251223153957188"></p>
<p>图展示了 DMA 模块的内部结构，这解释了它是如何独立工作的：</p>
<ul>
<li><strong>地址寄存器</strong>：记住了数据要搬到内存的哪个位置。</li>
<li><strong>数据计数</strong>：记住了还有多少数据要搬。</li>
<li><strong>控制逻辑</strong>：负责指挥总线进行读写。</li>
<li><strong>关键点</strong>：CPU 一旦把这些寄存器填好，DMA 就拥有了工作的全部信息，不再需要 CPU 指导。</li>
</ul>
<p><strong>CPU -&gt; DMA（下达命令）</strong>：</p>
<ul>
<li>CPU 告诉 DMA：“把硬盘里这 1MB 数据搬到内存地址 X。”</li>
</ul>
<p><strong>继续执行后续指令（红色虚线）</strong>：</p>
<ul>
<li><strong>关键时刻</strong>：CPU 下完命令直接走人，去处理其他进程。</li>
<li>与此同时，DMA 控制器接管总线，一车一车地往内存搬数据。<strong>这是真正的并行！</strong></li>
</ul>
<p><strong>中断（最后一步）</strong>：</p>
<ul>
<li>只有当这 1MB 数据<strong>全部搬完</strong>了，DMA 才会发一个中断信号告诉 CPU：“老板，活干完了。”</li>
</ul>
<h5 id="什么是“周期窃取”？"><a href="#什么是“周期窃取”？" class="headerlink" title="什么是“周期窃取”？"></a>什么是“周期窃取”？</h5><p>“DMA 和 CPU 同时通过<strong>总线</strong>访问内存，CPU 会把总线的占有权让给 DMA 一个/几个主存周期”。</p>
<p><strong>形象理解</strong>：</p>
<ul>
<li><strong>总线 (Bus)</strong> 就像是一条<strong>独木桥</strong>。内存是桥对面的仓库。</li>
<li><strong>CPU</strong> 是一个一直在过桥搬东西的人。</li>
<li><strong>DMA</strong> 是另一个也要过桥搬东西的人。</li>
<li><strong>“周期窃取”</strong>：当 DMA 需要搬运一个数据字时，它不会把 CPU 彻底赶走，而是趁着 CPU 正在思考（译码）或者还没上桥的<strong>间隙</strong>，<strong>“偷”</strong> 用一下这个桥（总线周期），快速搬运一个字，然后立马把桥还给 CPU。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223155431045.png" alt="image-20251223155431045"></p>
<p>图中的方框（取指令、译码、取操作数…）代表 CPU 执行一条指令的各个微步骤。</p>
<p><strong>中断断点 (最右侧)</strong>：请看最右边的箭头。<strong>中断</strong>是非常“讲礼貌”的。它必须等到 CPU 把当前这条指令<strong>完全执行完</strong>（存结果之后），才会去响应中断。</p>
<p><strong>DMA 断点 (中间的箭头)</strong>：请看指向“译码”和“取操作数”之间的那个箭头。<strong>DMA</strong> 是“急脾气”。它<strong>不需要</strong>等指令执行完。只要 CPU 当前这个微操作（比如译码）不占用总线，DMA 就可以见缝插针地插入进来，偷一个周期传数据。</p>
<p>结论：DMA 的响应速度比中断快得多，因为它不需要等指令结束。</p>
<h5 id="为什么“窃取”不会严重拖慢-CPU？"><a href="#为什么“窃取”不会严重拖慢-CPU？" class="headerlink" title="为什么“窃取”不会严重拖慢 CPU？"></a>为什么“窃取”不会严重拖慢 CPU？</h5><p><strong>Cache 的功劳</strong>：PPT 最后一行提到“CPU 大部分情况下与 Cache 进行数据交换”。CPU 也就是在这一瞬间不能访问<strong>主存</strong>（内存），但它依然可以访问<strong>Cache</strong>（高速缓存）。只要 Cache 里有数据，CPU 就算没了总线也能继续干活，完全感觉不到 DMA 在偷东西。</p>
<p><strong>不连续性</strong>：DMA 只是偶尔偷一个周期，而不是长时间霸占，所以对 CPU 的宏观影响很小。</p>
<h4 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h4><ul>
<li><strong>① 轮询方式</strong>: CPU需要主动等待设备就绪，并且全程参与内存数据的交换。</li>
<li><strong>② 中断方式</strong>: CPU无需主动等待设备就绪。当设备准备好后，会向CPU发送一个中断信号，CPU响应中断后再参与内存数据交换。</li>
<li><strong>③ DMA方式</strong>: CPU只在I/O操作开始前和结束后参与（例如，初始化DMA控制器），在实际的数据传输过程中，由DMA控制器直接在内存和设备间搬运数据，CPU完全不参与主存数据交换。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">CPU作用</th>
<th style="text-align:left">等待设备</th>
<th style="text-align:left">内存数据交换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>轮询方式</strong></td>
<td style="text-align:left">需要</td>
<td style="text-align:left">参与</td>
</tr>
<tr>
<td style="text-align:left"><strong>中断方式</strong></td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">参与</td>
</tr>
<tr>
<td style="text-align:left"><strong>DMA方式</strong></td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">不参与</td>
</tr>
</tbody>
</table>
</div>
<p>从轮询到中断再到DMA，CPU的效率越来越高，它能更早地从I/O等待中解放出来去执行其他任务，从而提高了系统的并行处理能力。然而，这种并行仅限于物理层面的I/O操作，即CPU和I/O设备可以同时工作，而不是指CPU内部或软件层面的并行计算。</p>
<h4 id="通道控制方式-Channel-Control"><a href="#通道控制方式-Channel-Control" class="headerlink" title="通道控制方式 (Channel Control)"></a>通道控制方式 (Channel Control)</h4><h5 id="1-核心定义：什么是“通道”？"><a href="#1-核心定义：什么是“通道”？" class="headerlink" title="1. 核心定义：什么是“通道”？"></a>1. 核心定义：什么是“通道”？</h5><ul>
<li><strong>别名</strong>：它又被称为 <strong>I/O 处理器 (I/O Processor)</strong>。</li>
<li><strong>地位</strong>：它不再是一个简单的硬件控制器，而是一个<strong>“弱智版 CPU”</strong>。</li>
<li><strong>能力</strong>：它拥有执行<strong>逻辑独立 I/O 任务</strong>的能力。这意味着它不仅仅能“搬运”，还能做简单的“决策”（比如：先读这个，再写那个，如果错了重试）。</li>
</ul>
<h5 id="2-核心机制：通道程序-amp-四级连接"><a href="#2-核心机制：通道程序-amp-四级连接" class="headerlink" title="2. 核心机制：通道程序 &amp; 四级连接"></a>2. 核心机制：通道程序 &amp; 四级连接</h5><p>这里有两个关键概念需要理解：</p>
<p><strong>A. 通道程序 (Channel Program)</strong></p>
<p>PPT 提到，处理器不再执行具体的 I/O 指令，而是<strong>“在主存中组织通道程序”</strong>。</p>
<ul>
<li><strong>DMA 方式</strong>：CPU 给的是<strong>参数</strong>（源地址、目的地址、数据量）。</li>
<li><strong>通道方式</strong>：CPU 给的是<strong>一段代码</strong>（通道程序）。<ul>
<li><strong>比喻</strong>：<ul>
<li><strong>DMA</strong>：老板说“把这堆砖搬到后院”。</li>
<li><strong>通道</strong>：老板写了一张<strong>任务清单</strong>：“1. 先把砖搬到后院；2. 然后去买水泥；3. 最后把墙砌好。” 通道拿着这张清单，自己去执行一系列复杂的动作，不需要老板再插手。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>B. 四级连接 (Four-level Connection)</strong></p>
<p>PPT 中提到了 <strong>“处理器、通道、控制器、设备”</strong> 的四级连接。</p>
<ul>
<li>这是一个层级管理结构：<ul>
<li><strong>CPU</strong> 指挥 <strong>通道</strong>。</li>
<li><strong>通道</strong> 指挥 <strong>设备控制器</strong>。</li>
<li><strong>设备控制器</strong> 控制 <strong>设备</strong>。</li>
</ul>
</li>
<li><strong>目的</strong>：一个通道可以控制多台设备，大大节省了 CPU 的接口资源。</li>
</ul>
<h5 id="3-工作流程：高度并行-High-Parallelism"><a href="#3-工作流程：高度并行-High-Parallelism" class="headerlink" title="3. 工作流程：高度并行 (High Parallelism)"></a>3. 工作流程：高度并行 (High Parallelism)</h5><p>详细展示了工作步骤，这里有几个<strong>考试常考的缩写</strong>：</p>
<ol>
<li><strong>CPU 启动</strong>：<ul>
<li>CPU 遇到 I/O 任务。</li>
<li>OS 组织好通道程序，把这个程序的地址放在 <strong>CAW (Channel Address Word，通道地址字)</strong> 中。</li>
<li>CPU 启动通道，然后<strong>立即走人</strong>（去干别的事）。</li>
</ul>
</li>
<li><strong>通道执行</strong>：<ul>
<li>通道从 CAW 里拿到清单（通道程序），开始指挥设备干活。</li>
<li>此时，<strong>CPU 和 通道 真正实现了“高度并行”</strong>。</li>
</ul>
</li>
<li><strong>结束汇报</strong>：<ul>
<li>活干完了，通道发出中断。</li>
<li>CPU 响应中断，从 <strong>CSW (Channel Status Word，通道状态字)</strong> 中读取执行情况（比如是成功了还是出错了）。</li>
</ul>
</li>
</ol>
<h3 id="总线与I-O"><a href="#总线与I-O" class="headerlink" title="总线与I/O"></a>总线与I/O</h3><h4 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h4><p>从慢吞吞的键盘到快如闪电的显卡，它们都需要和 CPU 或内存交换数据。<strong>总线</strong>就是它们共同行走的通道。</p>
<p>想象计算机的主板是一个繁忙的<strong>城市</strong>。</p>
<ul>
<li><strong>CPU、内存、硬盘、网卡</strong> 就是城市里的<strong>建筑物</strong>。</li>
<li><strong>总线</strong> 就是连接这些建筑物的<strong>主干道</strong>。</li>
<li><strong>数据</strong> 就是路上跑的<strong>车辆</strong>。</li>
</ul>
<p><strong>总线的三大组成部分</strong>：</p>
<ol>
<li><strong>数据总线 (Data Bus)</strong> —— <strong>运货车</strong><ul>
<li><strong>作用</strong>：用来传输实际的数据（比如你的文档内容、游戏画面）。</li>
<li><em>特点</em>：是双向的（能发能收）。路越宽（比如 32位、64位），一次能拉的货就越多。</li>
</ul>
</li>
<li><strong>地址总线 (Address Bus)</strong> —— <strong>导航员</strong><ul>
<li><strong>作用</strong>：用来告诉大家“我要去哪里”。比如 CPU 要读内存，必须先通过地址总线广播：“我要找 0x0012 号房间的数据”。</li>
<li><em>特点</em>：通常是单向的（由 CPU 发出）。</li>
</ul>
</li>
<li><strong>控制总线 (Control Bus)</strong> —— <strong>红绿灯/交警</strong><ul>
<li><strong>作用</strong>：用来指挥交通。比如发送“读”、“写”、“中断”或“请求占用总线”的信号。</li>
<li><em>关联</em>：刚才我们学的 <strong>“DMA 周期窃取”</strong>，其实就是 DMA 通过控制总线向 CPU 申请：“把路权借我用一下”。</li>
</ul>
</li>
</ol>
<h4 id="解决-I-O-速度不匹配问题"><a href="#解决-I-O-速度不匹配问题" class="headerlink" title="解决 I/O 速度不匹配问题"></a>解决 I/O 速度不匹配问题</h4><p>这里的“不匹配”体现在两个维度：</p>
<ul>
<li><strong>I/O 和 CPU 的不匹配</strong>：CPU 是光速运行的，而 I/O 设备相对较慢。</li>
<li><strong>各设备之间的不匹配</strong>：这是这张图的重点。键盘和显卡虽然都是 I/O 设备，但它们的速度简直是云泥之别。</li>
</ul>
<h3 id="总线概念结构"><a href="#总线概念结构" class="headerlink" title="总线概念结构"></a>总线概念结构</h3><h4 id="单总线结构模型-Single-Bus-Structure-Model"><a href="#单总线结构模型-Single-Bus-Structure-Model" class="headerlink" title="单总线结构模型 (Single Bus Structure Model)"></a>单总线结构模型 (Single Bus Structure Model)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223162354483.png" alt="image-20251223162354483"></p>
<ul>
<li><strong>一条总线</strong>：中间那根橙色的双向大箭头。</li>
<li><strong>全员接入</strong>：<strong>CPU</strong>、<strong>主存（内存）</strong> 和所有的 <strong>I/O 模块</strong> 都直接挂在这同一根线上。</li>
</ul>
<p><strong>这意味着什么？</strong> 这意味着 CPU 想和内存说话，要走这条路；硬盘想把数据传给内存，也要走这条路。大家共享这一条通信通道。</p>
<p><strong>优点：简单粗暴</strong></p>
<ol>
<li><strong>结构简单</strong>：硬件设计非常容易，成本低。</li>
<li><strong>易于扩充</strong>：这是最大的好处。如果你想加一台打印机，只需要把它“挂”在总线上就行，不需要改动 CPU 或内存的架构。就像在路边盖新房子一样容易。</li>
</ol>
<p><strong>缺点：致命的“堵车”</strong></p>
<p>这种设计在早期计算机中很流行，但随着设备越来越多，它的弊端完全暴露出来：</p>
<ul>
<li><strong>共用总线导致压力大</strong>：<ul>
<li>因为只有一条路，同一时刻只能有一组对话。如果硬盘正在传电影，CPU 就不能读内存，必须干等。这就构成了<strong>瓶颈</strong>。</li>
</ul>
</li>
<li><strong>传输时延长</strong>：<ul>
<li>设备多了，大家都要申请路权，排队时间自然变长。</li>
</ul>
</li>
<li><strong>最痛的点：慢速外设占用带宽多</strong>：<ul>
<li>这是单总线最大的硬伤。</li>
<li><strong>比喻</strong>：想象这是一条单车道高速公路。如果前面有一辆<strong>拖拉机（慢速 I/O 设备）</strong>在慢慢开，后面性能再好的<strong>法拉利（CPU/内存）</strong>也得跟在屁股后面慢慢爬。</li>
<li>这就导致了高速设备的性能被低速设备严重拖累。</li>
</ul>
</li>
</ul>
<h4 id="三级总线模型-Three-level-Bus-Model"><a href="#三级总线模型-Three-level-Bus-Model" class="headerlink" title="三级总线模型 (Three-level Bus Model)"></a>三级总线模型 (Three-level Bus Model)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223162608032.png" alt="image-20251223162608032"></p>
<h5 id="第一级：局部总线-Local-Bus-——-“VIP-专用通道”"><a href="#第一级：局部总线-Local-Bus-——-“VIP-专用通道”" class="headerlink" title="第一级：局部总线 (Local Bus) —— “VIP 专用通道”"></a>第一级：局部总线 (Local Bus) —— <strong>“VIP 专用通道”</strong></h5><ul>
<li><strong>位置</strong>：最上方，连接 <strong>CPU</strong> 和 <strong>Cache (高速缓存)</strong>。</li>
<li><strong>作用</strong>：这是系统中最快的一条路。</li>
<li><strong>意义</strong>：CPU 和 Cache 之间的交互极其频繁且速度极快。把它们单独划在这个“小圈子”里，让 CPU 能全速运行，完全不受外界打扰。</li>
</ul>
<h5 id="第二级：主存总线-System-Bus-——-“城市主干道”"><a href="#第二级：主存总线-System-Bus-——-“城市主干道”" class="headerlink" title="第二级：主存总线 (System Bus) —— “城市主干道”"></a>第二级：主存总线 (System Bus) —— <strong>“城市主干道”</strong></h5><ul>
<li><strong>位置</strong>：中间层，连接 <strong>主存 (Main Memory)</strong>、<strong>Cache</strong> 和 <strong>局部 I/O 控制器</strong>。</li>
<li><strong>作用</strong>：负责内存数据的吞吐。</li>
<li><strong>意义</strong>：当 Cache 没命中时，需要从主存调数据，就走这条路。它比局部总线慢一点，但依然很快。</li>
</ul>
<h5 id="第三级：扩展总线-Expansion-Bus-——-“社区辅路”"><a href="#第三级：扩展总线-Expansion-Bus-——-“社区辅路”" class="headerlink" title="第三级：扩展总线 (Expansion Bus) —— “社区辅路”"></a>第三级：扩展总线 (Expansion Bus) —— <strong>“社区辅路”</strong></h5><ul>
<li><strong>位置</strong>：最下方，连接各种 <strong>I/O 设备</strong>（如 LAN网卡、SCSI设备、打印机等）。</li>
<li><strong>作用</strong>：专门用来挂载各种速度参差不齐的外设。</li>
<li><strong>关键组件</strong>：<strong>扩展总线接口 (Expansion Bus Interface)</strong>。它是连接“主干道”和“辅路”的<strong>立交桥/收费站</strong>。它不仅负责传递数据，还起到<strong>缓冲</strong>的作用，防止慢速设备的信号干扰高速总线。</li>
</ul>
<h5 id="优点：各行其道"><a href="#优点：各行其道" class="headerlink" title="优点：各行其道"></a>优点：各行其道</h5><p><strong>分流 (Isolation)</strong>：</p>
<ul>
<li><strong>“主存与 I/O 之间的数据传送”</strong> 和 <strong>“处理器的内存活动”</strong> 被分离开了。</li>
<li>简单说：硬盘往内存传数据（走扩展总线 -&gt; 主存总线）的时候，CPU 依然可以在局部总线上和 Cache 玩得很开心，互不影响。</li>
</ul>
<p><strong>扩展性强</strong>：</p>
<ul>
<li><strong>“支持更多的 I/O 设备”</strong>。因为有了扩展总线这一层，你可以挂很多慢速设备，而不会增加主存总线的负载（电容负载）。</li>
</ul>
<h5 id="缺点：木桶效应"><a href="#缺点：木桶效应" class="headerlink" title="缺点：木桶效应"></a>缺点：木桶效应</h5><p>PPT 也提到了一个缺点：<strong>“不适用于 I/O 设备数据速率相差太大的情形”</strong>。</p>
<ul>
<li><strong>解读</strong>：你看最下面的“扩展总线”，上面既挂了高速的 <strong>LAN (网卡)</strong>、<strong>SCSI (高速硬盘接口)</strong>，又可能挂慢速的 <strong>字符设备 (键盘/鼠标)</strong>。</li>
<li>如果所有外设都挤在这一根扩展总线上，高速设备（如千兆网卡）可能会觉得这条路太慢，或者被慢速设备抢占时隙，导致性能发挥不出来。</li>
<li><strong>解决思路</strong>：这就是为什么现代电脑（如你现在的 PC）其实演进到了更高级的结构（如 <strong>桥接芯片组架构</strong>，分为北桥和南桥，或者现在的 PCH），把高速 I/O (PCIe) 和低速 I/O (USB) 进一步分开。</li>
</ul>
<h4 id="南北桥架构”-Northbridge-and-Southbridge-Architecture"><a href="#南北桥架构”-Northbridge-and-Southbridge-Architecture" class="headerlink" title="南北桥架构” (Northbridge and Southbridge Architecture)"></a>南北桥架构” (Northbridge and Southbridge Architecture)</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223163719210.png" alt="image-20251223163719210"></p>
<h5 id="核心理念：快慢彻底分家"><a href="#核心理念：快慢彻底分家" class="headerlink" title="核心理念：快慢彻底分家"></a>核心理念：快慢彻底分家</h5><p>PPT 顶部的文字点出了核心思路：<strong>“通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速I/O设备和低速I/O设备”</strong>。</p>
<ul>
<li><strong>为什么要分南北？</strong><ul>
<li>有些设备太快（内存、显卡），必须贴着 CPU 跑。</li>
<li>有些设备太慢（鼠标、键盘），离 CPU 远点没关系。</li>
<li>于是，主板芯片组被劈成了两半：<strong>北桥</strong>负责快，<strong>南桥</strong>负责慢</li>
</ul>
</li>
</ul>
<h5 id="北桥-Northbridge-——-速度担当"><a href="#北桥-Northbridge-——-速度担当" class="headerlink" title="北桥 (Northbridge) —— 速度担当"></a>北桥 (Northbridge) —— 速度担当</h5><p><strong>地位</strong>：它是离 CPU 最近的芯片（通常在主板上方，故称北桥）。</p>
<ul>
<li><strong>别名</strong>：PPT 中标注为 <strong>“主存控制器” (Memory Controller)</strong>。</li>
<li><strong>连接对象（贵族圈）</strong>：<ol>
<li><strong>CPU</strong>：通过“处理器总线”直接连接，带宽最高。</li>
<li><strong>主存 (RAM)</strong>：通过“存储总线”连接。这是北桥最重要的任务——管理内存读写。</li>
<li><strong>高速 I/O 设备</strong>：PPT 中展示了 <strong>图形设备 (显卡)</strong>、<strong>SCSI (服务器硬盘)</strong>、<strong>LAN (网卡)</strong> 挂接在 <strong>PCI 总线</strong> 上。虽然 PCI 总线在物理上通常由南桥管理或作为南北桥的桥梁，但逻辑上它们属于高速区，需要通过北桥与 CPU 高速交换数据。</li>
</ol>
</li>
</ul>
<h5 id="南桥-Southbridge-——-管家担当"><a href="#南桥-Southbridge-——-管家担当" class="headerlink" title="南桥 (Southbridge) —— 管家担当"></a>南桥 (Southbridge) —— 管家担当</h5><p><strong>地位</strong>：离 CPU 较远（通常在主板下方，故称南桥）。</p>
<ul>
<li><strong>别名</strong>：PPT 中标注为 <strong>“I/O 控制器”</strong>。</li>
<li><strong>连接对象（平民圈）</strong>：<ol>
<li><strong>低速 I/O 设备</strong>：PPT 下方展示的 <strong>COM 口</strong>、<strong>鼠标</strong>、<strong>键盘</strong>。</li>
<li><strong>慢速总线</strong>：这些设备挂在 <strong>E(ISA) 总线</strong> 上。这是一种非常古老且缓慢的总线标准。</li>
</ol>
</li>
<li><strong>职责</strong>：南桥负责处理这些琐碎、慢速的输入输出，整理好之后，再通过“桥间接口”统一汇报给北桥。</li>
</ul>
<h5 id="关键接口：桥间接口-Hub-Interface"><a href="#关键接口：桥间接口-Hub-Interface" class="headerlink" title="关键接口：桥间接口 (Hub Interface)"></a>关键接口：桥间接口 (Hub Interface)</h5><p>请看图中连接北桥和南桥的那根竖线——<strong>“桥间接口”</strong>。</p>
<ul>
<li>这是连接“CBD”和“郊区”的高速公路。</li>
<li>所有的鼠标点击、键盘输入，都要先汇聚到南桥，通过这个接口传给北桥，最后才能到达 CPU。</li>
</ul>
<p><strong>北桥</strong>：负责 <strong>CPU总线</strong>、<strong>存储总线</strong>（内存）以及 <strong>PCI总线</strong>（高速 I/O，如显卡、网卡）。</p>
<p><strong>南桥</strong>：负责 <strong>E(ISA)总线</strong>（慢速 I/O，如键盘、鼠标），并通过桥间接口与北桥通信。</p>
<h5 id="优点：支持不同速率-Heterogeneity"><a href="#优点：支持不同速率-Heterogeneity" class="headerlink" title="优点：支持不同速率 (Heterogeneity)"></a>优点：支持不同速率 (Heterogeneity)</h5><p>PPT 明确指出了这种架构的优点：<strong>“可以支持不同数据速率的 I/O 设备”</strong>。</p>
<ul>
<li><strong>各司其职</strong>：<ul>
<li>CPU 想读内存，直接找北桥，路径极短，速度极快。</li>
<li>CPU 想读鼠标，指令传给南桥，南桥慢慢去读，不会占用北桥的高速通道。</li>
</ul>
</li>
<li><strong>消除瓶颈</strong>：慢速的 ISA 设备再多，也不会拖慢 CPU 访问内存的速度，因为它们在物理上被隔绝在南桥下面了。</li>
</ul>
<p><strong>第一梯队（最快）：北桥负责</strong></p>
<ul>
<li><strong>不仅仅是内存</strong>：你说得对，北桥不仅连接主存，还连接了 <strong>图形设备 (显卡)</strong>。显卡是 I/O 设备中对速度要求最高的（比如打游戏时的数据吞吐量极大），所以它被提拔到了“北桥”这个 VIP 区域，直接和 CPU、内存享受高速通道。</li>
</ul>
<p><strong>第二梯队（较快）：PCI 总线</strong></p>
<ul>
<li><strong>LAN (网卡)</strong> 和 <strong>SCSI (硬盘)</strong> 挂在 <strong>PCI 总线</strong> 上。这是一条高速公路，专门给这些吞吐量大的设备跑。</li>
</ul>
<p><strong>第三梯队（慢速）：南桥负责</strong></p>
<ul>
<li><strong>鼠标、键盘</strong> 被赶到了最下面的 <strong>E(ISA) 总线</strong>，由 <strong>南桥</strong> 统一管理。</li>
<li>南桥像一个过滤器，把这些慢速设备的琐碎请求整理好，再通过中间的接口汇报上去。</li>
</ul>
<h3 id="I-O-软件的层次结构"><a href="#I-O-软件的层次结构" class="headerlink" title="I/O 软件的层次结构"></a>I/O 软件的层次结构</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223165755764.png" alt="image-20251223165755764"></p>
<h4 id="第-1-层：用户空间的-I-O-软件-User-Space-I-O-Software"><a href="#第-1-层：用户空间的-I-O-软件-User-Space-I-O-Software" class="headerlink" title="第 1 层：用户空间的 I/O 软件 (User-Space I/O Software)"></a>第 1 层：用户空间的 I/O 软件 (User-Space I/O Software)</h4><p><strong>“我要打印一份文件”</strong></p>
<ul>
<li><strong>位置</strong>：最顶层，直接和用户打交道。</li>
<li><strong>是谁</strong>：你写的 C 语言代码（<code>printf</code>, <code>scanf</code>），或者具体的应用程序（Word, 浏览器）。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>I/O 系统调用</strong>：发起请求。</li>
<li><strong>SPOOLing</strong>：比如你点打印时，电脑没卡死，而是把任务放到了后台队列里，这就是 SPOOLing 技术（后面会细讲）。</li>
<li><strong>I/O 格式化</strong>：比如把你的数字 <code>100</code> 转换成字符 <code>&#39;1&#39;, &#39;0&#39;, &#39;0&#39;</code> 显示在屏幕上。</li>
</ul>
</li>
<li><strong>特点</strong>：它根本不知道硬盘是圆的还是方的，它只知道“我要读/写数据”。</li>
</ul>
<h4 id="第-2-层：独立于设备的-I-O-软件-Device-Independent-I-O-Software"><a href="#第-2-层：独立于设备的-I-O-软件-Device-Independent-I-O-Software" class="headerlink" title="第 2 层：独立于设备的 I/O 软件 (Device-Independent I/O Software)"></a>第 2 层：独立于设备的 I/O 软件 (Device-Independent I/O Software)</h4><p><strong>“好的，不管你是存到 U 盘还是硬盘，逻辑都一样”</strong></p>
<ul>
<li><strong>位置</strong>：第二层，这是操作系统的<strong>核心通逻辑</strong>。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>设备的命名</strong>：把物理设备映射成逻辑名（比如 <code>/dev/sda</code> 或 <code>C:</code> 盘）。</li>
<li><strong>设备保护</strong>：检查你有没有权限读这个文件。</li>
<li><strong>缓冲 (Buffering)</strong>：非常关键！为了解决速度差异，数据会先暂存在这里。</li>
<li><strong>设备分配与释放</strong>：决定这个打印机现在归谁用。</li>
</ul>
</li>
<li><strong>特点</strong>：这一层<strong>抹平了硬件差异</strong>。对于它来说，所有设备都是“文件”。</li>
</ul>
<h4 id="第-3-层：I-O-设备驱动程序-Device-Drivers"><a href="#第-3-层：I-O-设备驱动程序-Device-Drivers" class="headerlink" title="第 3 层：I/O 设备驱动程序 (Device Drivers)"></a>第 3 层：I/O 设备驱动程序 (Device Drivers)</h4><p><strong>“收到，正在指挥西部数据硬盘的磁头移动”</strong></p>
<ul>
<li><strong>位置</strong>：第三层，这是<strong>最懂硬件</strong>的软件。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>翻译</strong>：把上层的“读第 5 个块”这种抽象命令，翻译成具体的硬件指令（如“设置寄存器 X 为 1，向端口 Y 发送数据”）。</li>
<li><strong>检查状态</strong>：看设备是不是忙，是不是出错了。</li>
</ul>
</li>
<li><strong>特点</strong>：<strong>每一类设备都有专门的驱动</strong>。显卡有显卡驱动，网卡有网卡驱动。它是操作系统和硬件之间的“翻译官”。</li>
</ul>
<h4 id="第-4-层：I-O-中断处理程序-Interrupt-Handlers"><a href="#第-4-层：I-O-中断处理程序-Interrupt-Handlers" class="headerlink" title="第 4 层：I/O 中断处理程序 (Interrupt Handlers)"></a>第 4 层：I/O 中断处理程序 (Interrupt Handlers)</h4><p><strong>“老板，活干完了！(叫醒 CPU)”</strong></p>
<ul>
<li><strong>位置</strong>：最底层软件，紧贴硬件。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>处理中断</strong>：当硬件干完活（比如 DMA 搬运完了），会发个电信号触发中断，这层软件负责响应。</li>
<li><strong>唤醒驱动</strong>：告诉上面的驱动程序“数据到了，你可以继续往下跑了”。</li>
</ul>
</li>
<li><strong>特点</strong>：它是在硬件事件发生后<strong>被动触发</strong>的“急救员”。</li>
</ul>
<h4 id="总结：数据流动的全过程"><a href="#总结：数据流动的全过程" class="headerlink" title="总结：数据流动的全过程"></a>总结：数据流动的全过程</h4><p>想象你在 Word 里点击“保存”（写硬盘）：</p>
<ol>
<li><strong>用户层</strong>：Word 调用系统函数 <code>write()</code>。</li>
<li><strong>独立层</strong>：OS 检查权限，分配缓存，找到文件对应的逻辑地址。</li>
<li><strong>驱动层</strong>：驱动程序把逻辑地址算出具体的磁道和扇区，向硬盘控制器发指令。</li>
<li><strong>硬件层</strong>：硬盘疯狂转动，磁头写入数据。</li>
<li><strong>中断层</strong>：硬盘写完，发中断。中断程序告诉驱动“搞定”，驱动告诉上层“搞定”，最后 Word 提示你“保存成功”。</li>
</ol>
<h3 id="I-O-缓冲区"><a href="#I-O-缓冲区" class="headerlink" title="I/O 缓冲区"></a>I/O 缓冲区</h3><h4 id="1-核心定义：什么是-I-O-缓冲区？"><a href="#1-核心定义：什么是-I-O-缓冲区？" class="headerlink" title="1. 核心定义：什么是 I/O 缓冲区？"></a>1. 核心定义：什么是 I/O 缓冲区？</h4><p>给出了明确定义：<strong>“在内存中开辟的存储区，专门用于临时存放 I/O 操作的数据”</strong>。</p>
<ul>
<li><strong>通俗理解</strong>：<ul>
<li><strong>没有缓冲</strong>：CPU 直接伸手向硬盘要数据，硬盘没给，CPU 就手悬在半空等着。</li>
<li><strong>有了缓冲</strong>：在内存里放一个<strong>“快递柜”</strong>。硬盘把数据慢慢填进柜子，填满了通知 CPU 来取。CPU 取数据的时候，硬盘可以继续往下一个柜子里填。</li>
</ul>
</li>
</ul>
<h4 id="2-为什么要引入缓冲？（五大目的）"><a href="#2-为什么要引入缓冲？（五大目的）" class="headerlink" title="2. 为什么要引入缓冲？（五大目的）"></a>2. 为什么要引入缓冲？（五大目的）</h4><p>PPT 左侧详细列出了目的，每一条都直击痛点：</p>
<ol>
<li><strong>解决速度不匹配</strong>：这是最核心的。CPU 是跑车，I/O 是拖拉机。缓冲让跑车不用停车等拖拉机。</li>
<li><strong>协调记录大小不一致</strong>：<ul>
<li><strong>逻辑记录</strong>：你的代码可能想读一行字（10个字节）。</li>
<li><strong>物理记录</strong>：硬盘一次只能读一个扇区（4KB）。</li>
<li><strong>缓冲的作用</strong>：把 4KB 读到缓冲区，然后把其中的 10个字节 拿给你的程序。</li>
</ul>
</li>
<li><strong>提高并行性</strong>：CPU 算它的，设备传它的，互不干扰。</li>
<li><strong>减少中断次数</strong>：<ul>
<li>如果没有缓冲，每来一个字符就要中断 CPU 一次。</li>
<li>有了缓冲，填满一整个缓冲区（比如 4KB）才中断一次。CPU 舒服多了。</li>
</ul>
</li>
<li><strong>放宽响应时间要求</strong>：数据来了先进缓冲区待着，CPU 忙完手头的事再来取，不用秒回。</li>
</ol>
<h4 id="3-缓冲技术的进化史（看右边的图）"><a href="#3-缓冲技术的进化史（看右边的图）" class="headerlink" title="3. 缓冲技术的进化史（看右边的图）"></a>3. 缓冲技术的进化史（看右边的图）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171004487.png" alt="image-20251223171004487"></p>
<p>PPT 右侧的四张小图展示了缓冲技术是如何一步步变强的。</p>
<h5 id="a-无缓冲-No-Buffering"><a href="#a-无缓冲-No-Buffering" class="headerlink" title="(a) 无缓冲 (No Buffering)"></a>(a) 无缓冲 (No Buffering)</h5><ul>
<li><strong>状态</strong>：CPU 和设备直接对接。</li>
<li><strong>后果</strong>：完全串行。设备忙，CPU 就要等；CPU 忙，设备就要停。<strong>效率最低</strong>。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171623306.png" alt="image-20251223171623306"></p>
<p><strong>1. 三个关键变量 (T, M, C)</strong></p>
<p>首先，你要搞清楚这三个字母代表什么，它们是一个数据块处理流程的三个步骤：</p>
<ul>
<li><strong>$T$ (Time for Input)</strong>：<strong>输入时间</strong>。从磁盘把一块数据读到缓冲区。这是 I/O 设备的活。</li>
<li><strong>$M$ (Time for Move)</strong>：<strong>传送时间</strong>。系统把数据从缓冲区“搬”到用户的内存区。这是内存复制的操作。</li>
<li><strong>$C$ (Time for Computation)</strong>：<strong>计算时间</strong>。CPU 对这块数据进行处理。这是 CPU 的活。</li>
</ul>
<p><strong>核心逻辑</strong>：</p>
<ul>
<li><strong>没有缓冲时</strong>：这三步是串行的，总时间 = $T + C$。</li>
<li><strong>有了单缓冲</strong>：<strong>$T$（I/O）</strong> 和 <strong>$C$（CPU计算）</strong> 可以<strong>并行</strong>了（同时进行）。</li>
</ul>
<p><strong>2. 两种场景分析</strong></p>
<p>PPT 下方展示了两种可能的情况，取决于<strong>“谁更慢”</strong>。</p>
<p><strong>情况一：T &gt; C (I/O 慢，CPU 快)</strong></p>
<p>这是左边的图。</p>
<ul>
<li><strong>场景</strong>：硬盘读得很慢 ($T$ 长)，CPU 算得很快 ($C$ 短)。</li>
<li><strong>过程</strong>：<ul>
<li>CPU 很快算完了上一块数据 ($C$)，但是下一块数据还没传完 ($T$)。</li>
<li><strong>结果</strong>：CPU 必须<strong>等待</strong>硬盘。</li>
</ul>
</li>
<li><strong>瓶颈</strong>：在于 $T$。</li>
<li><strong>处理一块数据的总时间</strong>：<strong>$T + M$</strong>。<ul>
<li><em>(注：虽然也有 C，但 C 包含在 T 的时间段里并行做完了，没有增加额外耗时，所以只算长的那段 T，加上必须要做的搬运 M。)</em></li>
</ul>
</li>
</ul>
<p><strong>情况二：T &lt; C (I/O 快，CPU 慢)</strong></p>
<p>这是右边的图。</p>
<ul>
<li><strong>场景</strong>：硬盘读得飞快 ($T$ 短)，但 CPU 计算很复杂，算得很慢 ($C$ 长)。</li>
<li><strong>过程</strong>：<ul>
<li>硬盘很快把缓冲区填满了 ($T$)，但是 CPU 还在算上一块 ($C$)，没空来取。</li>
<li><strong>结果</strong>：硬盘必须<strong>等待</strong> CPU 腾出缓冲区。</li>
</ul>
</li>
<li><strong>瓶颈</strong>：在于 $C$。</li>
<li><strong>处理一块数据的总时间</strong>：<strong>$C + M$</strong>。</li>
</ul>
<h5 id="b-单缓冲-Single-Buffer"><a href="#b-单缓冲-Single-Buffer" class="headerlink" title="(b) 单缓冲 (Single Buffer)"></a>(b) 单缓冲 (Single Buffer)</h5><ul>
<li><strong>原理</strong>：操作系统在内存里建<strong>一个</strong>仓库。<ul>
<li><strong>设备 -&gt; 仓库</strong>：设备把数据搬进仓库（CPU 此时可以干别的）。</li>
<li><strong>仓库 -&gt; 用户进程</strong>：仓库满了，CPU 把数据从仓库挪走。</li>
</ul>
</li>
<li><strong>局限</strong>：<strong>不能同时进出</strong>。当 CPU 正在从仓库取货时，设备不能往里面送货（因为只有一个门），设备必须暂停等待仓库腾空。</li>
</ul>
<h5 id="c-双缓冲-Double-Buffering-——-也叫“乒乓缓冲”"><a href="#c-双缓冲-Double-Buffering-——-也叫“乒乓缓冲”" class="headerlink" title="(c) 双缓冲 (Double Buffering) —— 也叫“乒乓缓冲”"></a>(c) 双缓冲 (Double Buffering) —— 也叫“乒乓缓冲”</h5><ul>
<li><strong>原理</strong>：建<strong>两个</strong>仓库（1号和2号）。</li>
<li><strong>玩法</strong>：<ul>
<li>设备往 <strong>1号</strong> 装货。</li>
<li>与此同时，CPU 从 <strong>2号</strong> 取货。</li>
<li>大家都不用停！等 1号满了、2号空了，交换一下。</li>
</ul>
</li>
<li><strong>优点</strong>：实现了<strong>极致的并行</strong>。除非 CPU 处理太慢或者设备太慢导致一方严重积压，否则数据流几乎是连续的。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223171959180.png" alt="image-20251223171959180"></p>
<p>答案是：<strong>Max(C + M, T)</strong></p>
<p>这里的逻辑是：</p>
<ul>
<li><strong>T (Input)</strong>：设备往“缓冲区1”里送货的时间。</li>
<li><strong>C + M (Compute + Move)</strong>：CPU 从“缓冲区2”取货 ($M$) 并处理 ($C$) 的时间。</li>
<li>因为有两个缓冲区，这两件事是<strong>完全并行</strong>的。谁慢（时间长），整体速度就取决于谁。</li>
</ul>
<h5 id="d-多缓冲-循环缓冲-Circular-Buffering"><a href="#d-多缓冲-循环缓冲-Circular-Buffering" class="headerlink" title="(d) 多缓冲/循环缓冲 (Circular Buffering)"></a>(d) 多缓冲/循环缓冲 (Circular Buffering)</h5><ul>
<li><strong>原理</strong>：建<strong>很多个</strong>仓库，连成一个圈。</li>
<li><strong>场景</strong>：适用于<strong>阵发性</strong>的大量数据传输（比如看高清视频，网速忽快忽慢）。</li>
<li><strong>玩法</strong>：<ul>
<li>设备拼命往空仓库里填（生产者）。</li>
<li>CPU 拼命追着满仓库取（消费者）。</li>
<li>只要圈里还有空位，设备就不用停；只要圈里还有满位，CPU 就不用停。这是弹性最大的方案。</li>
</ul>
</li>
</ul>
<h3 id="独占型外围设备的分配"><a href="#独占型外围设备的分配" class="headerlink" title="独占型外围设备的分配"></a>独占型外围设备的分配</h3><h4 id="设备独立性-Device-Independence"><a href="#设备独立性-Device-Independence" class="headerlink" title="设备独立性 (Device Independence)"></a>设备独立性 (Device Independence)</h4><h5 id="1-核心痛点：如果把代码写死会怎样？"><a href="#1-核心痛点：如果把代码写死会怎样？" class="headerlink" title="1. 核心痛点：如果把代码写死会怎样？"></a>1. 核心痛点：如果把代码写死会怎样？</h5><p><strong>以前的做法 (物理设备绑定)</strong>：</p>
<ul>
<li>你在写程序时，如果直接写死：“我要用<strong>编号为 001 的那台惠普打印机</strong>”。</li>
<li><strong>后果</strong>：如果这台 001 号打印机坏了，或者被搬走了，你的程序就直接报错崩溃了，即使旁边还有一台一模一样的 002 号打印机空闲着，你也用不了。</li>
</ul>
<p><strong>总结</strong>：绑定具体物理设备虽然简单，但<strong>灵活性极差</strong>，一坏就瘫痪。</p>
<h5 id="2-解决方案：引入“逻辑设备”"><a href="#2-解决方案：引入“逻辑设备”" class="headerlink" title="2. 解决方案：引入“逻辑设备”"></a>2. 解决方案：引入“逻辑设备”</h5><p>为了解决这个问题，操作系统引入了<strong>设备独立性</strong>。</p>
<ul>
<li><strong>核心思想</strong>：<ul>
<li><strong>用户（程序员）</strong>：只负责说“我要用<strong>一台</strong>打印机”（这就是<strong>逻辑设备</strong>）。</li>
<li><strong>操作系统</strong>：负责去仓库看哪台打印机是好的、空闲的（比如 003 号），然后把它分配给你（这就是<strong>物理设备</strong>）。</li>
</ul>
</li>
<li><strong>PPT 定义</strong>：用户不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来。</li>
</ul>
<h5 id="3-实现机制：映射表-The-Mapping-Table"><a href="#3-实现机制：映射表-The-Mapping-Table" class="headerlink" title="3. 实现机制：映射表 (The Mapping Table)"></a>3. 实现机制：映射表 (The Mapping Table)</h5><p>操作系统是怎么把你的“空头支票”（逻辑设备）兑现成“真金白银”（物理设备）的呢？</p>
<ul>
<li>PPT 中间红字提到：系统需要提供<strong>逻辑设备名到物理设备名的映射表</strong>。</li>
<li><strong>类比</strong>：<ul>
<li>你打车时输入“我要去机场”（逻辑请求）。</li>
<li>打车软件（操作系统）查一下数据库（映射表），指派了“京B·12345”这辆车（物理设备）给你。</li>
<li>这一层映射关系，就是设备独立性的核心。</li>
</ul>
</li>
</ul>
<h5 id="4-三大优点-考试必考"><a href="#4-三大优点-考试必考" class="headerlink" title="4. 三大优点 (考试必考)"></a>4. 三大优点 (考试必考)</h5><p><strong>代码不用改 (应用程序与具体物理设备无关)</strong>：</p>
<ul>
<li>你换了个新鼠标，不需要去改你的游戏代码。因为游戏只调用“逻辑鼠标”，操作系统会自动把新鼠标映射上去。系统增减或变更设备时不需要修改源程序。</li>
</ul>
<p><strong>系统更可靠 (易于应对故障)</strong>：</p>
<ul>
<li>如果打印机 A 坏了，操作系统自动把任务导向打印机 B。用户根本感觉不到故障的存在。</li>
</ul>
<p><strong>资源分配更灵活</strong>：</p>
<ul>
<li>谁闲着就给谁用，实现了多道程序设计，不再出现“旱的旱死，涝的涝死”的情况。</li>
</ul>
<h5 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h5><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223173127932-1766482289243-1.png" alt="image-20251223173127932"></p>
<h3 id="共享型外围设备的驱动"><a href="#共享型外围设备的驱动" class="headerlink" title="共享型外围设备的驱动"></a>共享型外围设备的驱动</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223192427585.png" alt="image-20251223192427585"></p>
<h4 id="1-物理组件：搭建“多层蛋糕”"><a href="#1-物理组件：搭建“多层蛋糕”" class="headerlink" title="1. 物理组件：搭建“多层蛋糕”"></a>1. 物理组件：搭建“多层蛋糕”</h4><p>请看右上角的 3D 图：</p>
<ul>
<li><strong>盘片 (Platters)</strong>：磁盘里不只有一张盘，而是有多张盘片叠在一起，穿在中间的<strong>轴</strong>上高速旋转。</li>
<li><strong>盘面 (Surfaces)</strong>：每个盘片就像硬币一样，有<strong>正反两面</strong>。通常每一面都可以存数据，所以 2 个盘片就有 4 个盘面。</li>
<li><strong>磁头 (Heads)</strong>：看那个像梳子一样的<strong>移动臂</strong>，它的每一个齿尖上都有一个磁头。<ul>
<li><strong>关键点</strong>：所有磁头是<strong>共进退</strong>的。移动臂一动，所有磁头一起动。</li>
</ul>
</li>
</ul>
<h4 id="2-数据划分：画圈圈"><a href="#2-数据划分：画圈圈" class="headerlink" title="2. 数据划分：画圈圈"></a>2. 数据划分：画圈圈</h4><p>请看右下角的平面图：</p>
<ul>
<li><strong>磁道 (Track)</strong>：盘面被划分成无数个同心圆，每一个圈就是一个<strong>磁道</strong>。<ul>
<li><em>比喻：</em> 就像操场上的跑道。</li>
</ul>
</li>
<li><strong>扇区 (Sector)</strong>：每个磁道又像切披萨一样，被切分成很多小块，每一块叫<strong>扇区</strong>。<ul>
<li><strong>地位</strong>：扇区是磁盘读写的<strong>最小物理单位</strong>（通常是 512 字节或 4KB）。</li>
</ul>
</li>
</ul>
<h4 id="3-核心概念：柱面-Cylinder-——-考试必考"><a href="#3-核心概念：柱面-Cylinder-——-考试必考" class="headerlink" title="3. 核心概念：柱面 (Cylinder) —— 考试必考"></a>3. 核心概念：柱面 (Cylinder) —— 考试必考</h4><p>这是最抽象但最重要的概念。请看右上角图中标注红色的虚线圆柱体。</p>
<ul>
<li><strong>定义</strong>：所有盘面上，<strong>半径相同</strong>的那些磁道，在垂直方向上叠在一起，就构成了一个<strong>柱面</strong>。</li>
<li><strong>为什么要有这个概念？</strong><ul>
<li>因为所有磁头是固定在同一个移动臂上的。</li>
<li>当你把磁头移动到最外圈（磁道 0）时，<strong>所有盘面</strong>的磁头都同时停在了磁道 0 上。</li>
<li><strong>性能秘诀</strong>：如果不移动机械臂，只通过<strong>电子切换</strong>磁头来读写不同盘面上的数据，速度是极快的。</li>
<li><strong>结论</strong>：<strong>柱面</strong>是操作系统优化读写速度的关键。把相关联的数据存在同一个柱面上，就能减少机械臂的移动。</li>
</ul>
</li>
</ul>
<h4 id="4-磁盘寻址：如何找到一个数据块？"><a href="#4-磁盘寻址：如何找到一个数据块？" class="headerlink" title="4. 磁盘寻址：如何找到一个数据块？"></a>4. 磁盘寻址：如何找到一个数据块？</h4><p>PPT 左下角红字列出了<strong>物理块地址</strong>的编码方法，最经典的是 <strong>CHS 寻址法</strong>：</p>
<p><strong>1. 柱面号 (Cylinder)</strong> —— <strong>找圈</strong></p>
<ul>
<li>首先，操作系统指挥移动臂，把磁头移动到指定的半径位置（比如第 100 号柱面）。</li>
<li><em>动作：机械移动（最慢，叫“寻道时间”）。</em></li>
</ul>
<p><strong>2. 磁头号 (Head)</strong> —— <strong>找面</strong></p>
<ul>
<li>磁头臂到了位置，但有 4 个盘面，我要读哪一个？通过激活具体的磁头来选择盘面。</li>
<li><em>动作：电子切换（极快）。</em></li>
</ul>
<p><strong>3. 扇区号 (Sector)</strong> —— <strong>找块</strong></p>
<ul>
<li>盘面在疯狂旋转，磁头不动，等着指定的那个扇区（披萨块）转到磁头底下。</li>
<li><em>动作：机械旋转等待（较慢，叫“旋转延迟”）。</em></li>
</ul>
<h4 id="地址转换关系（扇区编号从0开始）"><a href="#地址转换关系（扇区编号从0开始）" class="headerlink" title="地址转换关系（扇区编号从0开始）"></a>地址转换关系（扇区编号从0开始）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223194324624.png" alt="image-20251223194324624"></p>
<h3 id="磁盘存取时间"><a href="#磁盘存取时间" class="headerlink" title="磁盘存取时间"></a>磁盘存取时间</h3><script type="math/tex; mode=display">T_a = T_s + \frac{1}{2r} + \frac{b}{rN}</script><p>公式左边的 <strong>$T_a$</strong> 代表 <strong>磁盘一次存取的总时间 (Total Access Time)</strong>。它由三部分组成：</p>
<h4 id="第一部分：寻道时间-T-s-——-“最耗时的赶路”"><a href="#第一部分：寻道时间-T-s-——-“最耗时的赶路”" class="headerlink" title="第一部分：寻道时间 ($T_s$) —— “最耗时的赶路”"></a>第一部分：寻道时间 ($T_s$) —— “最耗时的赶路”</h4><ul>
<li><strong>对应变量</strong>：<strong>$T_s$ (Seek Time)</strong>。</li>
<li><strong>含义</strong>：机械臂把磁头移动到指定柱面（磁道）所花的时间。</li>
<li><strong>特点</strong>：<ul>
<li>这是<strong>物理机械运动</strong>。</li>
<li>在计算题中，通常会直接给你一个平均值（比如 “平均寻道时间为 10ms”），或者让你根据移动了多少个磁道来算。</li>
<li><strong>它是性能杀手</strong>：通常占总时间的大头。</li>
</ul>
</li>
</ul>
<h4 id="第二部分：旋转延迟-frac-1-2r-——-“平均运气”"><a href="#第二部分：旋转延迟-frac-1-2r-——-“平均运气”" class="headerlink" title="第二部分：旋转延迟 ($\frac{1}{2r}$) —— “平均运气”"></a>第二部分：旋转延迟 ($\frac{1}{2r}$) —— “平均运气”</h4><ul>
<li><strong>对应变量</strong>：图中蓝色的 <strong>$\frac{1}{2r}$</strong>。</li>
<li><strong>含义</strong>：<strong>平均旋转等待时间</strong>。</li>
<li><strong>推导逻辑</strong>（非常重要）：<ul>
<li><strong>$r$</strong>：磁盘旋转速度（单位：转/秒）。比如 7200转/分 = 120转/秒。</li>
<li><strong>$1/r$</strong>：转一整圈需要的时间。</li>
<li><strong>为什么是 $1/2$？</strong>：因为当你磁头到了磁道时，目标扇区可能刚过去（要等一整圈），也可能正好就在下面（不用等）。<strong>平均来看，你需要等半圈</strong>。</li>
<li>这就是 <strong>$\frac{1}{2} \times (\text{转一圈的时间})$</strong> 的由来。</li>
</ul>
</li>
</ul>
<h4 id="第三部分：传输时间-frac-b-rN-——-“真正的读写”"><a href="#第三部分：传输时间-frac-b-rN-——-“真正的读写”" class="headerlink" title="第三部分：传输时间 ($\frac{b}{rN}$) —— “真正的读写”"></a>第三部分：传输时间 ($\frac{b}{rN}$) —— “真正的读写”</h4><ul>
<li><strong>对应变量</strong>：图中橙色的 <strong>$\frac{b}{rN}$</strong>。</li>
<li><strong>含义</strong>：<strong>平均传输时间</strong>。也就是磁头扫过数据块并读取内容的时间。</li>
<li><strong>变量详解</strong>：<ul>
<li><strong>$b$</strong>：你要读写的字节数 (Bytes to transfer)。</li>
<li><strong>$N$</strong>：一个磁道上总共有多少字节 (Bytes per track)。</li>
<li><strong>$r$</strong>：转速。</li>
</ul>
</li>
<li><strong>推导逻辑</strong>：<ul>
<li><strong>$r \times N$</strong> = 磁盘一秒钟能扫过多少数据（数据传输率）。</li>
<li><strong>时间 = 总量 / 速度</strong> = $b / (r \times N)$。</li>
<li><em>或者另一种理解：</em> $\frac{b}{N}$ 表示你要读的数据占了这一圈的百分之多少（比如占了 1/10 圈），然后乘以转一圈的时间 ($1/r$)。结果是一样的。</li>
</ul>
</li>
</ul>
<h3 id="移臂调度及算法"><a href="#移臂调度及算法" class="headerlink" title="移臂调度及算法"></a>移臂调度及算法</h3><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195351262.png" alt="image-20251223195351262"></p>
<h4 id="最短查找时间优先算法"><a href="#最短查找时间优先算法" class="headerlink" title="最短查找时间优先算法"></a>最短查找时间优先算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195424991.png" alt="image-20251223195424991"></p>
<h4 id="单向扫描算法"><a href="#单向扫描算法" class="headerlink" title="单向扫描算法"></a>单向扫描算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195452951.png" alt="image-20251223195452951"></p>
<h4 id="双向扫描算法"><a href="#双向扫描算法" class="headerlink" title="双向扫描算法"></a>双向扫描算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195516927.png" alt="image-20251223195516927"></p>
<h4 id="电梯调度算法"><a href="#电梯调度算法" class="headerlink" title="电梯调度算法"></a>电梯调度算法</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223195602421.png" alt="image-20251223195602421"></p>
<h3 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h3><h4 id="循环排序"><a href="#循环排序" class="headerlink" title="循环排序"></a>循环排序</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223201528047.png" alt="image-20251223201528047"></p>
<h4 id="优化分布（交替排序）"><a href="#优化分布（交替排序）" class="headerlink" title="优化分布（交替排序）"></a>优化分布（交替排序）</h4><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20251223204707858.png" alt="image-20251223204707858"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2025/">操作系统原理 (2025 春季学期)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XZAbeqEyt/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">01 - AI 时代的操作系统课2025 南京大学操作系统原理]_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-06 19:05:01" itemprop="dateModified" datetime="2026-01-06T19:05:01+08:00">2026-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">大三上</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="真值-X-与-补码-X-补-之间的三大转换规则"><a href="#真值-X-与-补码-X-补-之间的三大转换规则" class="headerlink" title="真值 ($X$) 与 补码 ($[X]_{补}$) 之间的三大转换规则"></a><strong>真值 ($X$)</strong> 与 <strong>补码 ($[X]_{补}$)</strong> 之间的三大转换规则</h2><h3 id="1-真值-rightarrow-补码-X-rightarrow-X-补"><a href="#1-真值-rightarrow-补码-X-rightarrow-X-补" class="headerlink" title="1. 真值 $\rightarrow$ 补码 ($X \rightarrow [X]_{补}$)"></a>1. 真值 $\rightarrow$ 补码 ($X \rightarrow [X]_{补}$)</h3><p>这是最基础的<strong>编码</strong>过程。</p>
<ul>
<li><strong>正数：</strong> 符号位设为 <strong>0</strong>，数值部分<strong>完全照抄</strong>，不变。</li>
<li><strong>负数：</strong> 符号位设为 <strong>1</strong>，数值部分执行 <strong>“各位取反，末位加 1”</strong>。</li>
</ul>
<h3 id="2-补码-rightarrow-真值-X-补-rightarrow-X"><a href="#2-补码-rightarrow-真值-X-补-rightarrow-X" class="headerlink" title="2. 补码 $\rightarrow$ 真值 ($[X]_{补} \rightarrow X$)"></a>2. 补码 $\rightarrow$ 真值 ($[X]_{补} \rightarrow X$)</h3><p>这是<strong>解码</strong>过程。PPT 强调了正负数的处理逻辑是对称的：</p>
<ul>
<li><strong>符号位为 0（正数）：</strong> 数值部分直接就是真值。</li>
<li><strong>符号位为 1（负数）：</strong> 数值部分再次执行 <strong>“各位取反，末位加 1”</strong>。<ul>
<li><em>点评：这验证了你之前的发现——求负数补码的原码，操作逻辑和求补码是一模一样的！</em></li>
</ul>
</li>
</ul>
<h3 id="3-求相反数的补码-X-补-rightarrow-X-补"><a href="#3-求相反数的补码-X-补-rightarrow-X-补" class="headerlink" title="3. 求相反数的补码 ($[X]{补} \rightarrow [-X]{补}$)"></a>3. 求相反数的补码 ($[X]<em>{补} \rightarrow [-X]</em>{补}$)</h3><p>这是数学上的<strong>变号</strong>操作（例如从 $5$ 的补码求 $-5$ 的补码）。</p>
<ul>
<li><strong>规则：</strong> 对 $[X]_{补}$ 的<strong>所有位</strong>（注意 PPT 写的：<strong>符号位参与运算</strong>）执行 <strong>“各位取反，末位加 1”</strong>。<ul>
<li><em>注意：</em> 这里就是我们刚才说的“整体取反法”。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="💡-核心规律总结-PPT-右下角方框的含义"><a href="#💡-核心规律总结-PPT-右下角方框的含义" class="headerlink" title="💡 核心规律总结 (PPT 右下角方框的含义)"></a>💡 核心规律总结 (PPT 右下角方框的含义)</h3><p>PPT 右下角的方框其实在告诉你，以下三个操作用的是<strong>同一个</strong>核心算法（取反加一）：</p>
<ol>
<li><strong>$X \rightarrow [-X]_{补}$</strong>：把一个正数真值变成负数补码。</li>
<li><strong>$[X]_{补} \rightarrow X$</strong>：把一个负数补码还原成真值（数值部分）。</li>
<li><strong>$[X]<em>{补} \rightarrow [-X]</em>{补}$</strong>：已知一个数的补码，求它相反数的补码。</li>
</ol>
<p>一句话总结这张 PPT：</p>
<p>在补码系统中，只要涉及“负数”或者“变号”，核心法宝就是 “各位取反，末位加 1”。</p>
<h2 id="奇偶校验法"><a href="#奇偶校验法" class="headerlink" title="奇偶校验法"></a>奇偶校验法</h2><p>为了让你彻底明白，我们用一个最简单的<strong>ASCII 字符</strong>传输作为例子。</p>
<p>假设我们要传输字母 “A”。</p>
<p>字母 “A” 的二进制 ASCII 码是：1000001（共 7 位）。</p>
<p>现在，我们要给它加上第 8 位——<strong>校验位</strong>。</p>
<hr>
<h3 id="1-原始数据分析"><a href="#1-原始数据分析" class="headerlink" title="1. 原始数据分析"></a>1. 原始数据分析</h3><ul>
<li><strong>数据：</strong> <code>1 0 0 0 0 0 1</code></li>
<li><strong>数一数“1”的个数：</strong> 这里有 <strong>2</strong> 个 1。</li>
<li><strong>判断：</strong> 2 是<strong>偶数</strong>。</li>
</ul>
<hr>
<h3 id="2-奇校验-Odd-Parity-的例子"><a href="#2-奇校验-Odd-Parity-的例子" class="headerlink" title="2. 奇校验 (Odd Parity) 的例子"></a>2. 奇校验 (Odd Parity) 的例子</h3><p><strong>目标：</strong> 加上校验位后，整个串里“1”的总数必须是 <strong>奇数</strong>。</p>
<ul>
<li><p><strong>现状：</strong> 现在有 2 个 1（偶数）。</p>
</li>
<li><p><strong>操作：</strong> 既然还差一个 1 才能变成奇数，所以<strong>校验位必须填 1</strong>。</p>
</li>
<li><p>最终发送的数据：</p>
<p>1000001 + 1 (校验位) $\rightarrow$ 10000011</p>
</li>
<li><p><strong>验证：</strong> 总共有 3 个 1 $\rightarrow$ 奇数 $\rightarrow$ ✅ 合格。</p>
</li>
</ul>
<hr>
<h3 id="3-偶校验-Even-Parity-的例子"><a href="#3-偶校验-Even-Parity-的例子" class="headerlink" title="3. 偶校验 (Even Parity) 的例子"></a>3. 偶校验 (Even Parity) 的例子</h3><p><strong>目标：</strong> 加上校验位后，整个串里“1”的总数必须是 <strong>偶数</strong>。</p>
<ul>
<li><p><strong>现状：</strong> 现在有 2 个 1（已经由偶数了）。</p>
</li>
<li><p><strong>操作：</strong> 不需要再加 1 了（否则就变成奇数了），所以<strong>校验位填 0</strong>。</p>
</li>
<li><p>最终发送的数据：</p>
<p>1000001 + 0 (校验位) $\rightarrow$ 10000010</p>
</li>
<li><p><strong>验证：</strong> 总共有 2 个 1 $\rightarrow$ 偶数 $\rightarrow$ ✅ 合格。</p>
</li>
</ul>
<hr>
<h3 id="4-它是怎么发现错误的？（以奇校验为例）"><a href="#4-它是怎么发现错误的？（以奇校验为例）" class="headerlink" title="4. 它是怎么发现错误的？（以奇校验为例）"></a>4. 它是怎么发现错误的？（以奇校验为例）</h3><p>假设我们使用 <strong>奇校验</strong>，发送了 <strong><code>10000011</code></strong>（3个1，正常）。</p>
<p><strong>场景一：传输正常</strong></p>
<ul>
<li><strong>接收方收到：</strong> <code>10000011</code></li>
<li><strong>检查：</strong> 数一下有 3 个 1（奇数）。</li>
<li><strong>结论：</strong> 校验通过，数据应该是对的。</li>
</ul>
<p><strong>场景二：发生 1 位错误（比如第1位传丢了，1变成了0）</strong></p>
<ul>
<li><strong>接收方收到：</strong> <code>00000011</code> （原本的第一个1变成了0）</li>
<li><strong>检查：</strong> 数一下，现在只有 <strong>2</strong> 个 1（偶数）。</li>
<li><strong>结论：</strong> <strong>不对！</strong> 我们约定好是奇校验的，怎么变成偶数了？<strong>报错！</strong></li>
</ul>
<p><strong>场景三：发生 2 位错误（这是奇偶校验的死穴）</strong></p>
<ul>
<li>假设第1位和最后一位都翻转了。</li>
<li><strong>接收方收到：</strong> <code>00000010</code></li>
<li><strong>检查：</strong> 数一下，有 <strong>1</strong> 个 1（奇数）。</li>
<li><strong>结论：</strong> 接收方会以为数据是对的（因为1的个数还是奇数），但实际上数据已经错得离谱了。</li>
</ul>
<h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>原始数据 (1的个数)</strong></th>
<th><strong>校验方式</strong></th>
<th><strong>校验位填什么？</strong></th>
<th><strong>最终结果 (数据+校验)</strong></th>
<th><strong>最终1的个数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1000001</code> (2个, 偶)</td>
<td><strong>奇校验</strong></td>
<td><strong>1</strong></td>
<td><code>1000001</code><strong><code>1</code></strong></td>
<td>3 (奇)</td>
</tr>
<tr>
<td><code>1000001</code> (2个, 偶)</td>
<td><strong>偶校验</strong></td>
<td><strong>0</strong></td>
<td><code>1000001</code><strong><code>0</code></strong></td>
<td>2 (偶)</td>
</tr>
<tr>
<td><code>1110000</code> (3个, 奇)</td>
<td><strong>奇校验</strong></td>
<td><strong>0</strong></td>
<td><code>1110000</code><strong><code>0</code></strong></td>
<td>3 (奇)</td>
</tr>
<tr>
<td><code>1110000</code> (3个, 奇)</td>
<td><strong>偶校验</strong></td>
<td><strong>1</strong></td>
<td><code>1110000</code><strong><code>1</code></strong></td>
<td>4 (偶)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="海明校验码（略有涉及）"><a href="#海明校验码（略有涉及）" class="headerlink" title="海明校验码（略有涉及）"></a>海明校验码（略有涉及）</h2><p>基于我们刚才的深度探讨，我为你整理了一份<strong>“海明校验码核心总结”</strong>。这份总结略过了死板的教科书定义，专门针对你刚才产生的<strong>核心顿悟</strong>（关于位置、倒序、多位错误等）进行梳理。</p>
<p>你可以把它当作一份复习备忘录：</p>
<hr>
<h3 id="1-核心本质：它是一个“坐标定位系统”"><a href="#1-核心本质：它是一个“坐标定位系统”" class="headerlink" title="1. 核心本质：它是一个“坐标定位系统”"></a>1. 核心本质：它是一个“坐标定位系统”</h3><p>海明码不只是简单的加减法，而是利用<strong>二进制权重</strong>（1, 2, 4, 8…）构建了一套坐标系。</p>
<ul>
<li><strong>目的：</strong> 不仅告诉你“错了”，还能精准地告诉你“第几位错了”。</li>
</ul>
<h3 id="2-生成阶段：如何布阵？"><a href="#2-生成阶段：如何布阵？" class="headerlink" title="2. 生成阶段：如何布阵？"></a>2. 生成阶段：如何布阵？</h3><ul>
<li><strong>确定人数：</strong> 使用公式 <strong>$2^r \ge k + r + 1$</strong>。<ul>
<li><em>你的理解：</em> 必须有足够的校验位（状态数），才能覆盖所有可能出错的位置 + 1种全对的情况。</li>
</ul>
</li>
<li><strong>站位：</strong> 校验位必须站在 <strong>$2^n$ (1, 2, 4, 8…)</strong> 的位置上。<ul>
<li><em>原因：</em> 它们是二进制的“基石”，负责构建坐标轴。</li>
</ul>
</li>
<li><strong>计算：</strong> 每一个校验位负责监管“二进制位索引中包含自己权重”的那些数据位（利用<strong>偶校验</strong>原则填充 0 或 1）。</li>
</ul>
<h3 id="3-校验阶段：如何抓内鬼？"><a href="#3-校验阶段：如何抓内鬼？" class="headerlink" title="3. 校验阶段：如何抓内鬼？"></a>3. 校验阶段：如何抓内鬼？</h3><p>这是你刚才理解最深刻的部分。</p>
<ul>
<li><strong>操作逻辑：</strong> <strong>不区分</strong>数据位和校验位，将收到的<strong>所有位</strong>作为一个整体进行计算。</li>
<li><strong>计算校正子（故障码）：</strong><ul>
<li>重新计算 P1, P2, P4… 各自辖区内 1 的个数。</li>
<li>偶数 $\rightarrow$ 记 0。</li>
<li>奇数 $\rightarrow$ 记 1。</li>
</ul>
</li>
<li><strong>关键步骤：</strong> <strong>倒序排列</strong>（$S_4 S_2 S_1$）。<ul>
<li><em>原因：</em> 二进制习惯高位在左。</li>
</ul>
</li>
</ul>
<h3 id="4-判决阶段：结果意味着什么？"><a href="#4-判决阶段：结果意味着什么？" class="headerlink" title="4. 判决阶段：结果意味着什么？"></a>4. 判决阶段：结果意味着什么？</h3><p>根据算出的“故障码”（二进制数转十进制）：</p>
<ul>
<li><strong>结果 = 0：</strong><ul>
<li><strong>结论：</strong> 传输成功（或者发生了极小概率的偶数位相互抵消）。</li>
</ul>
</li>
<li><strong>结果 = X (非0)：</strong><ul>
<li><strong>结论：</strong> 第 <strong>X</strong> 位出错了。</li>
<li><strong>动作：</strong> 无论第 X 位是数据还是校验码，直接将其<strong>取反</strong>（0变1，1变0），数据即修复。</li>
</ul>
</li>
</ul>
<h3 id="5-致命盲区：如果错了-2-位怎么办？"><a href="#5-致命盲区：如果错了-2-位怎么办？" class="headerlink" title="5. 致命盲区：如果错了 2 位怎么办？"></a>5. 致命盲区：如果错了 2 位怎么办？</h3><p>这是我们最后讨论的重点。</p>
<ul>
<li><strong>普通海明码：</strong> 会“撒谎”。两个错误叠加会算出一个<strong>错误的坐标</strong>，导致系统去修改一个无辜的正确位（越改越错）。</li>
<li><strong>解决方案（SECDED）：</strong> 增加第 8 个<strong>“全校验位”</strong>。<ul>
<li>如果海明码说有错（故障码非0），但全校验位说没错（整体偶校验正常）。</li>
<li><strong>结论：</strong> 发生了<strong>双比特错误</strong>。系统会报警拒绝处理，而不是乱修。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>一句话心法：</strong></p>
<blockquote>
<p><strong>海明码就是把校验位安插在二进制权重点上，接收时重算一遍奇偶性，算出来的二进制数就是出错位置的坐标。</strong></p>
</blockquote>
<p>现在的你已经完全具备了手算海明码甚至去写代码实现它的逻辑基础了！需要我给你出一道终极测试题练练手吗？</p>
<h2 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20260104224832194.png" alt="image-20260104224832194"></p>
<p>它的核心思想只有一句话：<strong>“符号单独算，数值当无符号数算”。</strong></p>
<hr>
<h3 id="1-核心步骤"><a href="#1-核心步骤" class="headerlink" title="1. 核心步骤"></a>1. 核心步骤</h3><p>原码一位乘法把整个过程拆成了两个独立的任务：</p>
<h4 id="任务一：处理符号位-简单"><a href="#任务一：处理符号位-简单" class="headerlink" title="任务一：处理符号位 (简单)"></a><strong>任务一：处理符号位 (简单)</strong></h4><ul>
<li><p><strong>规则：</strong> 同号得正，异号得负。</p>
</li>
<li><p>运算： 用异或门 ($XOR$) 完成。</p>
</li>
</ul>
<script type="math/tex; mode=display">P_s = X_s \oplus Y_s</script><p>  (例如：$0 \oplus 1 = 1$，结果为负)</p>
<h4 id="任务二：处理数值位-核心"><a href="#任务二：处理数值位-核心" class="headerlink" title="任务二：处理数值位 (核心)"></a><strong>任务二：处理数值位 (核心)</strong></h4><ul>
<li><strong>规则：</strong> 既然符号已经拿走了，剩下的绝对值 $|X|$ 和 $|Y|$ 其实就是两个<strong>正整数</strong>（或者说无符号数）。</li>
<li><strong>算法：</strong> 直接套用你最开始学的<strong>“无符号乘法”</strong>（列竖式法）。<ul>
<li>看 $Y$ 的最后一位。</li>
<li>是 1 $\rightarrow$ 加 $|X|$。</li>
<li>是 0 $\rightarrow$ 加 0。</li>
<li><strong>逻辑右移</strong>（前面补0，因为是绝对值运算，不涉及负数符号维持）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-举例演示"><a href="#2-举例演示" class="headerlink" title="2. 举例演示"></a>2. 举例演示</h3><p>假设我们要计算 <strong>$X \times Y$</strong>：</p>
<ul>
<li>$X = -0.1101$ (原码 <code>1.1101</code>)</li>
<li>$Y = +0.1011$ (原码 <code>0.1011</code>)</li>
</ul>
<h4 id="第一步：定符号"><a href="#第一步：定符号" class="headerlink" title="第一步：定符号"></a><strong>第一步：定符号</strong></h4><script type="math/tex; mode=display">1 (\text{X符号}) \oplus 0 (\text{Y符号}) = \mathbf{1} (\text{负})</script><p>把这个 1 存起来，最后贴到结果上。</p>
<h4 id="第二步：算数值-1101-times-1011"><a href="#第二步：算数值-1101-times-1011" class="headerlink" title="第二步：算数值 ($1101 \times 1011$)"></a><strong>第二步：算数值 ($1101 \times 1011$)</strong></h4><p>这部分完全就是<strong>无符号乘法</strong>。</p>
<ul>
<li>被乘数 $|X| = 1101$</li>
<li>乘数 $|Y| = 1011$</li>
<li>部分积 $P$ 初始化为 $0000$</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>轮次</strong></th>
<th><strong>Y 末位</strong></th>
<th><strong>动作</strong></th>
<th><strong>P (部分积)</strong></th>
<th><strong>Y (乘数)</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>初始</strong></td>
<td><strong>1</strong></td>
<td></td>
<td><code>0000</code></td>
<td><code>1011</code></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>+X</strong></td>
<td><code>1101</code></td>
<td></td>
<td>$0000+1101$</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>逻辑右移</strong></td>
<td><strong><code>0110</code></strong></td>
<td><strong><code>1101</code></strong></td>
<td><strong>高位补0！</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>1</strong></td>
<td><strong>+X</strong></td>
<td><code>10011</code></td>
<td></td>
<td>$0110+1101=10011$</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>逻辑右移</strong></td>
<td><strong><code>1001</code></strong></td>
<td><strong><code>1110</code></strong></td>
<td>进位1移进来</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>0</strong></td>
<td><strong>+0</strong></td>
<td><code>1001</code></td>
<td></td>
<td>不加</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>逻辑右移</strong></td>
<td><strong><code>0100</code></strong></td>
<td><strong><code>1111</code></strong></td>
<td>高位补0</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>1</strong></td>
<td><strong>+X</strong></td>
<td><code>10001</code></td>
<td></td>
<td>$0100+1101=10001$</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>逻辑右移</strong></td>
<td><strong><code>1000</code></strong></td>
<td><strong><code>1111</code></strong></td>
<td>进位1移进来</td>
</tr>
</tbody>
</table>
</div>
<p><em>注意：这里的右移全部是<strong>逻辑右移</strong>（左边补0），因为我们在算绝对值，绝对值永远是正的。</em></p>
<h4 id="第三步：拼接结果"><a href="#第三步：拼接结果" class="headerlink" title="第三步：拼接结果"></a><strong>第三步：拼接结果</strong></h4><ul>
<li><strong>数值部分：</strong> $P$ 和 $Y$ 拼起来 $\rightarrow$ <code>1000 1111</code></li>
<li><strong>加上小数点：</strong> <code>0.10001111</code></li>
<li><strong>加上符号（第一步算的）：</strong> <strong><code>1.10001111</code></strong></li>
</ul>
<h2 id="布斯算法"><a href="#布斯算法" class="headerlink" title="布斯算法"></a>布斯算法</h2><p><strong>布斯乘法算法</strong>（Booth’s Multiplication Algorithm）是一种用于计算<strong>带符号二进制数</strong>（通常使用补码表示）的乘法算法。</p>
<p>相较于你之前了解的“原码一位乘法”（主要处理无符号数或需要单独处理符号位），布斯乘法可以直接对补码进行操作，不需要将符号位和数值位分开计算，这使得硬件电路设计更加统一和高效。</p>
<h3 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h3><p>布斯乘法通过检查乘数的<strong>最后一位</strong>（$Q<em>0$）和<strong>辅助位</strong>（$Q</em>{-1}$，初始为0）的状态变化来决定操作。它利用了“连续的1序列可以转换为一次减法和一次加法”的数学性质（例如 $99 = 100 - 1$），从而减少运算次数。</p>
<h3 id="2-运算规则表"><a href="#2-运算规则表" class="headerlink" title="2. 运算规则表"></a>2. 运算规则表</h3><p>每次检查乘数的最后两位（$Q<em>0, Q</em>{-1}$），执行以下操作，然后进行<strong>算术右移</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Q0 (当前位)</strong></th>
<th><strong>Q−1 (辅助位)</strong></th>
<th><strong>操作 (针对部分积 A)</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>不操作</strong>，直接右移</td>
<td>连续的0，无需处理</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>+ 被乘数</strong> (M)，然后右移</td>
<td>遇到1序列的结束</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>- 被乘数</strong> (M)，然后右移</td>
<td>遇到1序列的开始</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>不操作</strong>，直接右移</td>
<td>连续的1，中间无需处理</td>
</tr>
</tbody>
</table>
</div>
<p><em>注意：这里的“- 被乘数”通常通过“+ [-M]补”来实现。</em></p>
<h3 id="3-计算步骤演示"><a href="#3-计算步骤演示" class="headerlink" title="3. 计算步骤演示"></a>3. 计算步骤演示</h3><p>假设我们用 4位补码计算：<strong>$2 \times (-3) = -6$</strong></p>
<ul>
<li><strong>被乘数 (M)</strong> = $2$ $\rightarrow$ <code>0010</code><ul>
<li>$(-M)$补 = <code>1110</code> (用于减法操作)</li>
</ul>
</li>
<li><strong>乘数 (Q)</strong> = $-3$ $\rightarrow$ <code>1101</code></li>
<li><strong>累加器 (A)</strong> = <code>0000</code> (初始化为0)</li>
<li><strong>辅助位 ($Q_{-1}$)</strong> = <code>0</code></li>
<li><strong>计数器</strong> = 4 (因为是4位)</li>
</ul>
<p><strong>演算过程：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>Q0,Q−1</strong></th>
<th><strong>操作</strong></th>
<th><strong>累加器 A</strong></th>
<th><strong>乘数 Q</strong></th>
<th><strong>辅助位 Q−1</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>初始</strong></td>
<td></td>
<td></td>
<td><code>0000</code></td>
<td><code>1101</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1, 0</strong></td>
<td><strong>A = A - M</strong> (即 A + 1110) <code>0000 + 1110 = 1110</code></td>
<td><code>1110</code></td>
<td><code>1101</code></td>
<td><code>0</code></td>
<td>减被乘数</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>算术右移</strong></td>
<td><code>1111</code></td>
<td><code>0110</code></td>
<td><code>1</code></td>
<td>符号位保持不变</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>0, 1</strong></td>
<td><strong>A = A + M</strong> (即 A + 0010) <code>1111 + 0010 = 0001</code></td>
<td><code>0001</code></td>
<td><code>0110</code></td>
<td><code>1</code></td>
<td>加被乘数</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>算术右移</strong></td>
<td><code>0000</code></td>
<td><code>1011</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>1, 0</strong></td>
<td><strong>A = A - M</strong> (即 A + 1110) <code>0000 + 1110 = 1110</code></td>
<td><code>1110</code></td>
<td><code>1011</code></td>
<td><code>0</code></td>
<td>减被乘数</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>算术右移</strong></td>
<td><code>1111</code></td>
<td><code>0101</code></td>
<td><code>1</code></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>1, 1</strong></td>
<td><strong>无操作</strong></td>
<td><code>1111</code></td>
<td><code>0101</code></td>
<td><code>1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>算术右移</strong></td>
<td><code>1111</code></td>
<td><code>1010</code></td>
<td><code>1</code></td>
</tr>
</tbody>
</table>
</div>
<p>最终结果：</p>
<p>将 A 和 Q 拼接起来（不看 $Q_{-1}$）：1111 1010。</p>
<p>这是补码形式，转换为十进制：</p>
<ul>
<li>符号位是1，取反加1得到原码：<code>-(0000 0101 + 1) = - (0000 0110) = -6</code>。</li>
<li><strong>结果正确。</strong></li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20260105213531851.png" alt="image-20260105213531851"></p>
<h2 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20260105094107032.png" alt="image-20260105094107032"></p>
<h2 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DY4y177dV/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">原码除法 恢复余数法和不恢复余数法(加减交替法) 计组_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yToCYjEUK?spm_id_from=333.788.videopod.episodes&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11&amp;p=2">整数除法处理过程_哔哩哔哩_bilibili</a></p>
<p><strong>整数不恢复余数除法</strong>中，<strong>被除数通常要进行位扩展</strong></p>
<p>在<strong>不恢复余数除法（加减交替法）\</strong>中，**整数除法**和*<em>小数除法<strong>的核心算法是一样的，都是根据余数的正负决定商位和下一步操作。但它们在</strong>初始设置、精度控制、终止条件、结果处理*</em>等方面有明显区别。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/417008434">定点整数的除法 - 知乎</a></p>
<h2 id="空间局部性和时间局部性"><a href="#空间局部性和时间局部性" class="headerlink" title="空间局部性和时间局部性"></a>空间局部性和时间局部性</h2><p>这两个概念是计算机系统（特别是<strong>缓存 Cache</strong>）能够高效工作的基石。如果程序员写的代码符合这两个特性，程序的运行速度可能会快几十倍甚至上百倍。</p>
<p>简单来说，CPU 跑得飞快，内存（RAM）跑得比较慢。为了不让 CPU 傻等，我们需要猜测 CPU 接下来要用什么数据，并提前把它搬到离 CPU 最近的缓存里。</p>
<p><strong>局部性原理（Principle of Locality）</strong> 就是我们用来猜测的“依据”。</p>
<hr>
<h3 id="1-时间局部性-Temporal-Locality"><a href="#1-时间局部性-Temporal-Locality" class="headerlink" title="1. 时间局部性 (Temporal Locality)"></a>1. 时间局部性 (Temporal Locality)</h3><p><strong>一句话解释：</strong> <strong>“如果一个数据现在被访问了，那么它在不久的将来很可能再次被访问。”</strong></p>
<ul>
<li><p><strong>关键词：</strong> 重复利用 (Reuse)。</p>
</li>
<li><p>生活类比：</p>
<p>你正在写作业（CPU工作），桌子上放着一本参考书。如果你刚查阅了某一页，你通常不会马上把它放回书架（内存），而是留就在手边（缓存）。因为你下一分钟大概率还会再看它一眼。</p>
</li>
</ul>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>看看下面这个简单的循环：</p>
<p>C</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>变量 <code>sum</code> 和 <code>i</code>：</strong> 在每一次循环中，这两个变量都被反复读取和修改。</li>
<li><strong>指令本身：</strong> 循环体内的机器指令（代码本身）也是被一遍又一遍地执行。</li>
</ul>
<p>硬件是怎么做的？</p>
<p>因为有时间局部性，CPU 会把 sum 和 i 以及循环内的指令死死地抓在 L1 Cache（一级缓存） 或者 寄存器 里，绝对不会每次都去慢吞吞的内存条里找。</p>
<hr>
<h3 id="2-空间局部性-Spatial-Locality"><a href="#2-空间局部性-Spatial-Locality" class="headerlink" title="2. 空间局部性 (Spatial Locality)"></a>2. 空间局部性 (Spatial Locality)</h3><p><strong>一句话解释：</strong> <strong>“如果一个数据被访问了，那么它附近的数据在不久的将来很可能也会被访问。”</strong></p>
<ul>
<li><p><strong>关键词：</strong> 邻居 (Nearby)。</p>
</li>
<li><p>生活类比：</p>
<p>你去图书馆（内存）借一本《哈利波特第1部》。虽然你现在只要第1部，但管理员（缓存控制器）通常会顺手把第2、3、4部也一起拿给你。因为按常理，看完第1部的人，大概率会接着看第2部，而不是突然跳去看旁边书架的《母猪的产后护理》。</p>
</li>
</ul>
<h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><p>这是最典型的数组遍历：</p>
<p>C</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int arr[1000];</span><br><span class="line">// ... 假设数组里有数据 ...</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    // 按顺序访问：arr[0], arr[1], arr[2]...</span><br><span class="line">    printf(&quot;%d&quot;, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数组 <code>arr</code>：</strong> 在内存中，数组的元素是<strong>连续存放</strong>的。<code>arr[0]</code> 的隔壁就是 <code>arr[1]</code>。</li>
<li><strong>访问模式：</strong> 当程序请求 <code>arr[0]</code> 时，CPU 知道你有“空间局部性”的倾向。</li>
</ul>
<p>硬件是怎么做的？</p>
<p>当 CPU 去内存取 arr[0] 时，内存条并不是只给一个数字，而是直接给一个 “缓存行” (Cache Line)（通常是 64 字节）。</p>
<p>这意味着，虽然你只喊了 arr[0]，但 arr[1] 到 arr[15] 可能已经被顺手打包带进了 CPU 的缓存。当你下一秒要用 arr[1] 时，它已经在缓存里等着你了，速度极快。</p>
<hr>
<h3 id="3-一个经典的“反面教材”"><a href="#3-一个经典的“反面教材”" class="headerlink" title="3. 一个经典的“反面教材”"></a>3. 一个经典的“反面教材”</h3><p>为了让你感受到空间局部性的威力，我们看一个经典的<strong>二维数组遍历</strong>的例子。</p>
<p>假设有一个巨大的二维数组 <code>matrix[10000][10000]</code>。在 C/C++ 语言中，数组是<strong>按行存储</strong>的（Row-major），也就是说，第一行的数据在内存里是连在一起的，接着是第二行。</p>
<h4 id="写法-A（利用空间局部性-快）："><a href="#写法-A（利用空间局部性-快）：" class="headerlink" title="写法 A（利用空间局部性 - 快）："></a>写法 A（利用空间局部性 - 快）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 按行遍历：外层是行(i)，内层是列(j)</span><br><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">        sum += matrix[i][j]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>分析：</strong> 访问顺序是 <code>[0][0], [0][1], [0][2]...</code>。这在内存里是连续的。缓存一次加载一行，命中率极高。</li>
</ul>
<h4 id="写法-B（破坏空间局部性-慢）："><a href="#写法-B（破坏空间局部性-慢）：" class="headerlink" title="写法 B（破坏空间局部性 - 慢）："></a>写法 B（破坏空间局部性 - 慢）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 按列遍历：外层是列(j)，内层是行(i)</span><br><span class="line">for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        sum += matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>分析：</strong> 访问顺序是 <code>[0][0], [1][0], [2][0]...</code>。</li>
<li><strong>问题：</strong> <code>[0][0]</code> 和 <code>[1][0]</code> 在内存中相隔了整整一行（10000个元素）！</li>
<li><strong>后果：</strong> 每次访问都像是“大跳跃”。CPU 加载了 <code>[0][0]</code> 及其附近的缓存行，结果你下一步要的是十万八千里外的 <code>[1][0]</code>。<strong>缓存全部失效（Cache Miss）</strong>。这会导致程序运行极其缓慢，甚至慢上几十倍。</li>
</ul>
<h2 id="cache行和主存块之间的映射方式"><a href="#cache行和主存块之间的映射方式" class="headerlink" title="cache行和主存块之间的映射方式"></a>cache行和主存块之间的映射方式</h2><h3 id="1-直接映射-Direct-Mapping"><a href="#1-直接映射-Direct-Mapping" class="headerlink" title="1. 直接映射 (Direct Mapping)"></a>1. 直接映射 (Direct Mapping)</h3><p><strong>口诀：</strong> “死板、对号入座”</p>
<p>这是最简单的规则。我们规定：<strong>根据车牌号的末尾数字，只能停在固定的车位。</strong></p>
<h4 id="规则公式"><a href="#规则公式" class="headerlink" title="规则公式"></a>规则公式</h4><script type="math/tex; mode=display">Cache行号 = 主存块号 \mod Cache行数</script><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设 Cache 只有 4 个车位（0, 1, 2, 3）。</p>
<p>主存有很多块（0, 1, 2, 3, 4, 5…）。</p>
<ul>
<li><strong>第 0 号主存块：</strong> $0 \mod 4 = 0$ $\rightarrow$ 只能停 <strong>0号</strong> 车位。</li>
<li><strong>第 1 号主存块：</strong> $1 \mod 4 = 1$ $\rightarrow$ 只能停 <strong>1号</strong> 车位。</li>
<li>…</li>
<li><strong>第 4 号主存块：</strong> $4 \mod 4 = 0$ $\rightarrow$ <strong>也要停 0号 车位！</strong></li>
<li><strong>第 8 号主存块：</strong> $8 \mod 4 = 0$ $\rightarrow$ <strong>还要停 0号 车位！</strong></li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p><strong>优点：</strong> 简单！你想找第4号块，只用去0号车位看一眼，不在就是不在，不用找别处。电路实现最便宜。</p>
</li>
<li><p>缺点（致命）： 冲突太容易发生了。</p>
<p>如果你写了一段程序，反复需要访问“第0块”和“第4块”。</p>
<ul>
<li>CPU要用第0块 $\rightarrow$ 把0停进0号位。</li>
<li>CPU要用第4块 $\rightarrow$ 把0踢走，把4停进0号位。</li>
<li>CPU又要用第0块 $\rightarrow$ 把4踢走，把0停进0号位。</li>
<li><em>这就是“抖动”（Thrashing），明明旁边 1, 2, 3 号车位空着，但它们死活不能停。</em></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-全相联映射-Fully-Associative-Mapping"><a href="#2-全相联映射-Fully-Associative-Mapping" class="headerlink" title="2. 全相联映射 (Fully Associative Mapping)"></a>2. 全相联映射 (Fully Associative Mapping)</h3><p><strong>口诀：</strong> “自由、随便停”</p>
<p>这是最灵活的规则。我们规定：<strong>只要有空位，想停哪儿停哪儿。</strong></p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>没有公式。主存块可以放在 Cache 的<strong>任意</strong>一个行中。</p>
<h4 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h4><p>还是 4 个车位。</p>
<ul>
<li>第 0 号块来了 $\rightarrow$ 停在 0 号位。</li>
<li>第 4 号块来了 $\rightarrow$ 0号位有人了？没关系，停在 1 号位。</li>
<li>第 8 号块来了 $\rightarrow$ 停在 2 号位。</li>
</ul>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p><strong>优点：</strong> <strong>空间利用率极高</strong>，只要Cache没满，就不会发生冲突踢人的情况。</p>
</li>
<li><p>缺点： 找车太慢（太贵）。</p>
<p>当你（CPU）想找“第4号块”时，你不知道它在哪里。你必须同时检查所有的车位（0,1,2,3…）。</p>
<p>这需要非常复杂的硬件电路（并行比较器），如果 Cache 很大，这种电路极其昂贵且耗电。</p>
</li>
</ul>
<hr>
<h3 id="3-组相联映射-Set-Associative-Mapping"><a href="#3-组相联映射-Set-Associative-Mapping" class="headerlink" title="3. 组相联映射 (Set Associative Mapping)"></a>3. 组相联映射 (Set Associative Mapping)</h3><p><strong>口诀：</strong> “中庸之道、分组管理”</p>
<p>这是现代 CPU（如 Intel Core, AMD Ryzen）普遍采用的方式。它折中了前两者的方案。</p>
<p>它把 Cache 分成了若干个<strong>“组” (Set)</strong>，每个组里包含几个车位（比如 2 个或 4 个）。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ol>
<li>先定位组（像直接映射）： 你必须去指定的组。</li>
</ol>
<script type="math/tex; mode=display">组号 = 主存块号 \mod 组数</script><ol>
<li><strong>再定位置（像全相联）：</strong> 到了那个组之后，组内的车位<strong>随便停</strong>。</li>
</ol>
<p>这被称为 <strong>N-路 组相联 (N-way Set Associative)</strong>，这里的 N 就是一个组里有几个车位。</p>
<h4 id="举个例子（2路组相联）"><a href="#举个例子（2路组相联）" class="headerlink" title="举个例子（2路组相联）"></a>举个例子（2路组相联）</h4><p>假设 Cache 还是 4 个车位，但我们将它们分为 <strong>2 个组</strong>（Set 0 和 Set 1）。</p>
<ul>
<li><strong>Set 0</strong> 包含：车位0、车位1</li>
<li><strong>Set 1</strong> 包含：车位2、车位3</li>
</ul>
<p>现在我们要停 <strong>第 4 号主存块</strong>：</p>
<ol>
<li><strong>算组号：</strong> $4 \mod 2(\text{组数}) = 0$。所以必须去 <strong>Set 0</strong>。</li>
<li><strong>找位子：</strong> 到了 Set 0，发现里面有“车位0”和“车位1”。只要这两个有一个是空的，第4号块就能停进去。</li>
</ol>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li>比直接映射灵活：就算 Set 0 里已经停了“第0号块”，我“第4号块”来了还能停在 Set 0 的另一个空位，不会打架。</li>
<li>比全相联便宜：查找时，只需要在特定的组内（比如搜4个位置）找，不需要全场搜。</li>
</ul>
</li>
<li><strong>地位：</strong> 这是工业界的<strong>标准答案</strong>。</li>
</ul>
<h2 id="直接映射中，主存地址的结构"><a href="#直接映射中，主存地址的结构" class="headerlink" title="直接映射中，主存地址的结构"></a>直接映射中，主存地址的结构</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20260104151532082.png" alt="image-20260104151532082"></p>
<h3 id="1-地址结构的宏观样子"><a href="#1-地址结构的宏观样子" class="headerlink" title="1. 地址结构的宏观样子"></a>1. 地址结构的宏观样子</h3><p>假设 CPU 发出的地址是 $N$ 位二进制数（比如 32位）。在直接映射模式下，它被切分为：</p>
<script type="math/tex; mode=display">\text{主存地址} = \underbrace{\text{标记 (Tag)}}_{\text{高位}} \quad | \quad \underbrace{\text{行索引 (Index)}}_{\text{中间}} \quad | \quad \underbrace{\text{块内偏移 (Offset)}}_{\text{低位}}</script><p>每一段都有其特定的使命。</p>
<hr>
<h3 id="2-深度拆解：每一段是干嘛的？"><a href="#2-深度拆解：每一段是干嘛的？" class="headerlink" title="2. 深度拆解：每一段是干嘛的？"></a>2. 深度拆解：每一段是干嘛的？</h3><p>为了方便理解，我们设定一个具体的场景：</p>
<ul>
<li><strong>地址总长度：</strong> 32位</li>
<li><strong>Cache 大小：</strong> 4 KB ($2^{12}$ 字节)</li>
<li><strong>块大小 (Block Size)：</strong> 64 Byte ($2^6$ 字节)</li>
</ul>
<p>根据这个配置，我们来计算每一段的长度和作用。</p>
<h4 id="第一部分：块内偏移-Block-Offset-——-“具体的字节在哪？”"><a href="#第一部分：块内偏移-Block-Offset-——-“具体的字节在哪？”" class="headerlink" title="第一部分：块内偏移 (Block Offset) —— “具体的字节在哪？”"></a>第一部分：块内偏移 (Block Offset) —— “具体的字节在哪？”</h4><ul>
<li><p><strong>位置：</strong> 地址的最低位。</p>
</li>
<li><p><strong>作用：</strong> Cache 和主存交换数据是以“块”为单位的（一拿就是 64B）。但 CPU 通常只需要其中的某 1 个字节。<strong>偏移量就是告诉 CPU，你要的数据在这个“块”里的第几个位置。</strong></p>
</li>
<li><p>怎么算位数？</p>
<p>看块大小。</p>
<p>这里块大小是 64 Byte = $2^6$ Byte。</p>
<p>所以，需要 6 位 来表示 0~63 的位置。</p>
<ul>
<li><strong>Offset = 6 bits</strong></li>
</ul>
</li>
</ul>
<h4 id="第二部分：行索引-Cache-Line-Index-——-“停在哪个车位？”"><a href="#第二部分：行索引-Cache-Line-Index-——-“停在哪个车位？”" class="headerlink" title="第二部分：行索引 (Cache Line Index) —— “停在哪个车位？”"></a>第二部分：行索引 (Cache Line Index) —— “停在哪个车位？”</h4><ul>
<li><p><strong>位置：</strong> 地址的中间部分。</p>
</li>
<li><p><strong>作用：</strong> 这是直接映射的核心。它决定了这块数据<strong>必须</strong>存放在 Cache 的第几行（第几个车位）。</p>
</li>
<li><p>怎么算位数？</p>
<p>看 Cache 一共有多少行。</p>
<script type="math/tex; mode=display">\text{Cache行数} = \frac{\text{Cache总容量}}{\text{块大小}}</script><p>在本例中：$4 \text{KB} / 64 \text{B} = 4096 / 64 = 64$ 行。</p>
<p>64 行 = $2^6$。</p>
<p>所以，需要 6 位 来定位这 64 个行（000000 到 111111）。</p>
<ul>
<li><strong>Index = 6 bits</strong></li>
</ul>
</li>
</ul>
<h4 id="第三部分：标记-Tag-——-“你是谁？”"><a href="#第三部分：标记-Tag-——-“你是谁？”" class="headerlink" title="第三部分：标记 (Tag) —— “你是谁？”"></a>第三部分：标记 (Tag) —— “你是谁？”</h4><ul>
<li><p><strong>位置：</strong> 地址的最高位。</p>
</li>
<li><p>作用： 因为有很多个主存块都会映射到同一个 Cache 行（冲突）。当 CPU 拿着地址去查看那个 Cache 行时，发现里面已经存了数据，它怎么知道里面的数据是不是它想要的那个？</p>
<p>靠比对 Tag！ Tag 就像身份证，证明身份。</p>
</li>
<li><p>怎么算位数？</p>
<p>剩下的位数都是 Tag。</p>
<script type="math/tex; mode=display">\text{Tag位数} = \text{总位数} - \text{索引位} - \text{偏移位}</script><p>在本例中：$32 - 6 - 6 = 20$ 位。</p>
<ul>
<li><strong>Tag = 20 bits</strong></li>
</ul>
</li>
</ul>
<h2 id="直写和回写"><a href="#直写和回写" class="headerlink" title="直写和回写"></a>直写和回写</h2><h3 id="1-直写-Write-Through"><a href="#1-直写-Write-Through" class="headerlink" title="1. 直写 (Write-Through)"></a>1. 直写 (Write-Through)</h3><p><strong>口诀：</strong> “老实人、立刻同步”</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每当 CPU 要往 Cache 里写数据时，<strong>它会同时把数据写回主存。</strong> 即：<code>写 Cache</code> + <code>写主存</code> 同时进行。</p>
<ul>
<li><strong>生活比喻：</strong> 你每花一笔钱，不仅记在草稿本上，还<strong>立刻</strong>跑去老板办公室，把正式账本也更新了。</li>
</ul>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><strong>优点（简单可靠）：</strong><ul>
<li><strong>一致性极好：</strong> 主存里的数据永远是最新的。</li>
<li><strong>实现简单：</strong> 既然主存总是新的，当 Cache 里的这块数据需要被踢走（替换）时，直接丢弃就行，不需要做任何操作。</li>
</ul>
</li>
<li><strong>缺点（慢）：</strong><ul>
<li><strong>速度受拖累：</strong> CPU 跑得快，但主存太慢了。每次写操作 CPU 都要等主存写完，大大降低了速度。</li>
<li><strong>总线太忙：</strong> 哪怕只改了一个字节，都要往主存发一次信号，总线带宽被占满了。</li>
</ul>
</li>
</ul>
<h4 id="补救措施：写缓冲-Write-Buffer"><a href="#补救措施：写缓冲-Write-Buffer" class="headerlink" title="补救措施：写缓冲 (Write Buffer)"></a>补救措施：写缓冲 (Write Buffer)</h4><p>为了不让 CPU 傻等主存，通常会在 CPU 和主存之间加一个<strong>“写缓冲队列”</strong>。 CPU 把数据扔进缓冲队列就立刻溜走去干别的，由硬件慢慢把队列里的数据写进主存。</p>
<hr>
<h3 id="2-回写-Write-Back"><a href="#2-回写-Write-Back" class="headerlink" title="2. 回写 (Write-Back)"></a>2. 回写 (Write-Back)</h3><p><strong>口诀：</strong> “懒人智慧、秋后算账”</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>当 CPU 要写数据时，<strong>只修改 Cache 里的内容</strong>，<strong>不</strong>立刻去改主存。 只有当这块数据在 Cache 里待不住了，<strong>要被踢走（替换/Evict）的时候</strong>，才把它写回主存。</p>
<ul>
<li><strong>关键角色：脏位 (Dirty Bit)</strong> Cache 行中需要增加一个标记位，叫“脏位”。<ul>
<li><strong>Dirty = 1：</strong> 说明这行数据被修改过，和主存不一样（脏了）。</li>
<li><strong>Dirty = 0：</strong> 说明这行数据没被改过，和主存一样（干净）。</li>
</ul>
</li>
<li><strong>生活比喻：</strong> 你花钱时，只在手里的草稿本上改。老板那边的正式账本先不管。 等到你的草稿本写满了，必须换新本子时（发生替换），你才看一眼旧本子：<ul>
<li>如果本子上全是乱涂乱画（脏位=1），你就把最终结果一次性汇报给老板。</li>
<li>如果本子上很干净没动过（脏位=0），直接把本子扔了就行，不用找老板。</li>
</ul>
</li>
</ul>
<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p><strong>优点（极快）：</strong></p>
<ul>
<li><strong>速度快：</strong> 写操作都在高速 Cache 里完成，CPU 爽飞了。</li>
<li><strong>带宽省：</strong> 如果你对同一个变量 <code>i</code> 做了 100 次 <code>i++</code>，直写要访问主存 100 次；而回写只需要在最后踢出时访问 1 次主存。</li>
</ul>
</li>
<li><p><strong>缺点（复杂、有风险）：</strong></p>
<ul>
<li><p><strong>硬件复杂：</strong> 需要维护“脏位”。</p>
</li>
<li><p><strong>短暂的不一致：</strong> 在被写回之前，主存里的数据是旧的。</p>
</li>
<li><p><strong>I/O 风险：</strong> 如果此时磁盘（DMA）直接去读主存，可能会读到旧数据（需要额外的同步机制来解决）。</p>
</li>
<li><h3 id="1-直写-Write-Through-1"><a href="#1-直写-Write-Through-1" class="headerlink" title="1. 直写 (Write-Through)"></a>1. 直写 (Write-Through)</h3><p><strong>口诀：</strong> “老实人、立刻同步”</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>每当 CPU 要往 Cache 里写数据时，<strong>它会同时把数据写回主存。</strong> 即：<code>写 Cache</code> + <code>写主存</code> 同时进行。</p>
<ul>
<li><strong>生活比喻：</strong> 你每花一笔钱，不仅记在草稿本上，还<strong>立刻</strong>跑去老板办公室，把正式账本也更新了。</li>
</ul>
<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><strong>优点（简单可靠）：</strong><ul>
<li><strong>一致性极好：</strong> 主存里的数据永远是最新的。</li>
<li><strong>实现简单：</strong> 既然主存总是新的，当 Cache 里的这块数据需要被踢走（替换）时，直接丢弃就行，不需要做任何操作。</li>
</ul>
</li>
<li><strong>缺点（慢）：</strong><ul>
<li><strong>速度受拖累：</strong> CPU 跑得快，但主存太慢了。每次写操作 CPU 都要等主存写完，大大降低了速度。</li>
<li><strong>总线太忙：</strong> 哪怕只改了一个字节，都要往主存发一次信号，总线带宽被占满了。</li>
</ul>
</li>
</ul>
<h4 id="补救措施：写缓冲-Write-Buffer-1"><a href="#补救措施：写缓冲-Write-Buffer-1" class="headerlink" title="补救措施：写缓冲 (Write Buffer)"></a>补救措施：写缓冲 (Write Buffer)</h4><p>为了不让 CPU 傻等主存，通常会在 CPU 和主存之间加一个<strong>“写缓冲队列”</strong>。 CPU 把数据扔进缓冲队列就立刻溜走去干别的，由硬件慢慢把队列里的数据写进主存。</p>
<hr>
<h3 id="2-回写-Write-Back-1"><a href="#2-回写-Write-Back-1" class="headerlink" title="2. 回写 (Write-Back)"></a>2. 回写 (Write-Back)</h3><p><strong>口诀：</strong> “懒人智慧、秋后算账”</p>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>当 CPU 要写数据时，<strong>只修改 Cache 里的内容</strong>，<strong>不</strong>立刻去改主存。 只有当这块数据在 Cache 里待不住了，<strong>要被踢走（替换/Evict）的时候</strong>，才把它写回主存。</p>
<ul>
<li><strong>关键角色：脏位 (Dirty Bit)</strong> Cache 行中需要增加一个标记位，叫“脏位”。<ul>
<li><strong>Dirty = 1：</strong> 说明这行数据被修改过，和主存不一样（脏了）。</li>
<li><strong>Dirty = 0：</strong> 说明这行数据没被改过，和主存一样（干净）。</li>
</ul>
</li>
<li><strong>生活比喻：</strong> 你花钱时，只在手里的草稿本上改。老板那边的正式账本先不管。 等到你的草稿本写满了，必须换新本子时（发生替换），你才看一眼旧本子：<ul>
<li>如果本子上全是乱涂乱画（脏位=1），你就把最终结果一次性汇报给老板。</li>
<li>如果本子上很干净没动过（脏位=0），直接把本子扔了就行，不用找老板。</li>
</ul>
</li>
</ul>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><strong>优点（极快）：</strong><ul>
<li><strong>速度快：</strong> 写操作都在高速 Cache 里完成，CPU 爽飞了。</li>
<li><strong>带宽省：</strong> 如果你对同一个变量 <code>i</code> 做了 100 次 <code>i++</code>，直写要访问主存 100 次；而回写只需要在最后踢出时访问 1 次主存。</li>
</ul>
</li>
<li><strong>缺点（复杂、有风险）：</strong><ul>
<li><strong>硬件复杂：</strong> 需要维护“脏位”。</li>
<li><strong>短暂的不一致：</strong> 在被写回之前，主存里的数据是旧的。</li>
<li><strong>I/O 风险：</strong> 如果此时磁盘（DMA）直接去读主存，可能会读到旧数据（需要额外的同步机制来解决）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-种基本的寻址方式"><a href="#7-种基本的寻址方式" class="headerlink" title="7 种基本的寻址方式"></a>7 种基本的寻址方式</h2><h3 id="1-立即寻址-Immediate-Addressing"><a href="#1-立即寻址-Immediate-Addressing" class="headerlink" title="1. 立即寻址 (Immediate Addressing)"></a>1. 立即寻址 (Immediate Addressing)</h3><ul>
<li><strong>算法：</strong> <code>操作数 = A</code></li>
<li><strong>通俗解释：</strong> <strong>“现钞交易”</strong>。数据不存放在内存或寄存器里，而是直接包含在指令代码中。</li>
<li><strong>优点：</strong> 速度最快（因为取指令的时候顺便就把数据取到了，不用再去查内存）。</li>
<li><strong>缺点：</strong> 数值的大小受限（因为指令字长是有限的，放不下太大的数）。</li>
</ul>
<h3 id="2-直接寻址-Direct-Addressing"><a href="#2-直接寻址-Direct-Addressing" class="headerlink" title="2. 直接寻址 (Direct Addressing)"></a>2. 直接寻址 (Direct Addressing)</h3><ul>
<li><strong>算法：</strong> $EA = A$ （有效地址 = 指令中给出的地址 A）</li>
<li><strong>通俗解释：</strong> <strong>“拿钥匙开柜子”</strong>。指令直接告诉你数据在内存的哪个房间号（地址）。</li>
<li><strong>优点：</strong> 计算简单，不用复杂的变换。</li>
<li><strong>缺点：</strong> 地址范围有限（指令里的位数有限，可能访问不了太大的内存空间）。</li>
</ul>
<h3 id="3-间接寻址-Indirect-Addressing"><a href="#3-间接寻址-Indirect-Addressing" class="headerlink" title="3. 间接寻址 (Indirect Addressing)"></a>3. 间接寻址 (Indirect Addressing)</h3><ul>
<li><strong>算法：</strong> $EA = (A)$ （指令给出的地址 A 里存的不是数据，而是数据的<strong>真实地址</strong>）</li>
<li><strong>通俗解释：</strong> <strong>“寻宝图的寻宝图”</strong>。你去地址 A，发现里面是一张纸条，纸条上写的才是数据真正的藏身之处。</li>
<li><strong>优点：</strong> 有效地址范围大（哪怕指令短，也能访问大内存）。</li>
<li><strong>缺点：</strong> 慢！因为要访问两次存储器（第一次取地址，第二次取数据）。</li>
</ul>
<h3 id="4-寄存器寻址-Register-Addressing"><a href="#4-寄存器寻址-Register-Addressing" class="headerlink" title="4. 寄存器寻址 (Register Addressing)"></a>4. 寄存器寻址 (Register Addressing)</h3><ul>
<li><strong>算法：</strong> <code>操作数 = (R)</code> （数据在寄存器 R 中）</li>
<li><strong>通俗解释：</strong> <strong>“翻口袋”</strong>。数据就在 CPU 自己的口袋（寄存器）里，伸手就来。</li>
<li><strong>优点：</strong> 执行极快（不需要访问慢速的内存），指令也很短（寄存器编号很短）。</li>
<li><strong>缺点：</strong> 寄存器数量很少，也就是口袋太少，装不下多少东西。</li>
</ul>
<h3 id="5-寄存器间接寻址-Register-Indirect-Addressing"><a href="#5-寄存器间接寻址-Register-Indirect-Addressing" class="headerlink" title="5. 寄存器间接寻址 (Register Indirect Addressing)"></a>5. 寄存器间接寻址 (Register Indirect Addressing)</h3><ul>
<li><strong>算法：</strong> $EA = (R)$ （寄存器 R 里存的是数据的内存地址）</li>
<li><strong>通俗解释：</strong> <strong>“口袋里的钥匙”</strong>。CPU 口袋（寄存器）里没数据，但有一把通往内存的钥匙（地址）。</li>
<li><strong>优点：</strong> 扩大了寻址范围（比直接寻址强）。</li>
<li><strong>缺点：</strong> 比纯寄存器寻址慢，因为还是要访问一次存储器。</li>
</ul>
<h3 id="6-偏移寻址-Displacement-Addressing"><a href="#6-偏移寻址-Displacement-Addressing" class="headerlink" title="6. 偏移寻址 (Displacement Addressing)"></a>6. 偏移寻址 (Displacement Addressing)</h3><p>这是现代计算机最常用的方式，包含<strong>相对寻址、基址寻址、变址寻址</strong>三种。</p>
<ul>
<li><strong>算法：</strong> $EA = A + (R)$ （地址 = 形式地址 + 寄存器内容）</li>
<li><strong>通俗解释：</strong> <strong>“基准点 + 偏移量”</strong>。比如“从学校大门（基准）往东走 100 米（偏移）”。它结合了直接寻址和寄存器间接寻址的特点。</li>
<li><strong>优点：</strong> 非常灵活（方便做数组访问、程序浮动等）。</li>
<li><strong>缺点：</strong> 计算稍微复杂一点。</li>
</ul>
<h3 id="7-堆栈寻址-Stack-Addressing"><a href="#7-堆栈寻址-Stack-Addressing" class="headerlink" title="7. 堆栈寻址 (Stack Addressing)"></a>7. 堆栈寻址 (Stack Addressing)</h3><ul>
<li><strong>算法：</strong> $EA = 栈顶$</li>
<li><strong>通俗解释：</strong> <strong>“拿最上面的盘子”</strong>。不需要给地址，默认就是操作堆栈最顶端的数据。</li>
<li><strong>优点：</strong> 指令极短（甚至不需要地址码）。</li>
<li><strong>缺点：</strong> 不灵活，只能按先进后出 (LIFO) 的顺序拿数据。</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="1-立即寻址-Immediate-Addressing-1"><a href="#1-立即寻址-Immediate-Addressing-1" class="headerlink" title="1. 立即寻址 (Immediate Addressing)"></a><strong>1. 立即寻址 (Immediate Addressing)</strong></h3><ul>
<li><p><strong>概念：</strong> 数据直接包含在指令中。不需要去别处找。</p>
</li>
<li><p><strong>特点：</strong> 速度最快，但只能用于常数。</p>
</li>
<li><p><strong>公式：</strong> 操作数 = 指令中的立即数</p>
</li>
<li><p><strong>生活比喻：</strong> 纸条上写着：“吃掉<strong>这个苹果</strong>”。苹果直接粘在纸条上。</p>
</li>
<li><p><strong>代码举例 (x86风格)：</strong></p>
<p>代码段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, 2000H  ; 将数字 2000H 直接放入寄存器 AX</span><br></pre></td></tr></table></figure>
<p><em>(这里 2000H 就是操作数本身)</em></p>
</li>
</ul>
<hr>
<h3 id="2-寄存器寻址-Register-Addressing"><a href="#2-寄存器寻址-Register-Addressing" class="headerlink" title="2. 寄存器寻址 (Register Addressing)"></a><strong>2. 寄存器寻址 (Register Addressing)</strong></h3><ul>
<li><p><strong>概念：</strong> 数据存放在CPU内部的通用寄存器中。指令给出寄存器编号。</p>
</li>
<li><p><strong>特点：</strong> 速度非常快（不需要访问慢速的内存），指令短（寄存器编号短）。</p>
</li>
<li><p><strong>公式：</strong> 操作数 = 寄存器内容</p>
</li>
<li><p><strong>生活比喻：</strong> 纸条上写着：“吃掉<strong>左口袋</strong>里的东西”。</p>
</li>
<li><p><strong>代码举例：</strong></p>
<p>代码段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, BX    ; 将寄存器 BX 里的数据复制到 AX</span><br></pre></td></tr></table></figure>
<p><em>(数据在 BX 寄存器里)</em></p>
</li>
</ul>
<hr>
<h3 id="3-直接寻址-Direct-Addressing"><a href="#3-直接寻址-Direct-Addressing" class="headerlink" title="3. 直接寻址 (Direct Addressing)"></a><strong>3. 直接寻址 (Direct Addressing)</strong></h3><ul>
<li><p><strong>概念：</strong> 指令中直接给出数据在内存中的物理地址（或逻辑地址）。</p>
</li>
<li><p><strong>特点：</strong> 简单直观，但指令字较长（因为地址通常很长），地址固定，不灵活。</p>
</li>
<li><p><strong>公式：</strong> 有效地址 EA = 指令中的形式地址 A</p>
</li>
<li><p><strong>生活比喻：</strong> 纸条上写着：“去打开<strong>101号柜子</strong>，吃掉里面的东西”。</p>
</li>
<li><p><strong>代码举例：</strong></p>
<p>代码段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [2000H] ; 将内存地址 2000H 里的数据取出，放入 AX</span><br></pre></td></tr></table></figure>
<p><em>(CPU 直接拿着 2000H 去内存找数据)</em></p>
</li>
</ul>
<hr>
<h3 id="4-寄存器间接寻址-Register-Indirect-Addressing"><a href="#4-寄存器间接寻址-Register-Indirect-Addressing" class="headerlink" title="4. 寄存器间接寻址 (Register Indirect Addressing)"></a><strong>4. 寄存器间接寻址 (Register Indirect Addressing)</strong></h3><ul>
<li><p><strong>概念：</strong> 指令给出一个寄存器，这个寄存器里存的<strong>不是数据</strong>，而是<strong>数据的内存地址</strong>。</p>
</li>
<li><p><strong>特点：</strong> 比直接寻址灵活，只需要修改寄存器的值，就可以访问不同的内存单元（适合遍历数组）。</p>
</li>
<li><p><strong>公式：</strong> 有效地址 EA = (寄存器内容)</p>
</li>
<li><p><strong>生活比喻：</strong> 纸条上写着：“去查看<strong>左口袋</strong>里的纸条，那上面写着柜子号”。(假设左口袋里纸条写着101，你就去101号柜子找苹果)。</p>
</li>
<li><p><strong>代码举例：</strong></p>
<p>代码段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV BX, 2000H   ; 先把地址放入 BX</span><br><span class="line">MOV AX, [BX]    ; CPU去读 BX，发现是 2000H，于是去内存 2000H 取数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-隐含寻址-Implied-Addressing"><a href="#5-隐含寻址-Implied-Addressing" class="headerlink" title="5. 隐含寻址 (Implied Addressing)"></a><strong>5. 隐含寻址 (Implied Addressing)</strong></h3><ul>
<li><p><strong>概念：</strong> 指令中不明显给出操作数地址，而是由操作码隐含规定了操作数在哪里。</p>
</li>
<li><p><strong>特点：</strong> 指令极短。</p>
</li>
<li><p><strong>生活比喻：</strong> 纸条上只写了一个字：“<strong>吃！</strong>”。（默认你自己知道要吃嘴里的东西，或者拿手里的东西吃，不需要指明）。</p>
</li>
<li><p><strong>代码举例：</strong></p>
<p>代码段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLA   ; Clear Accumulator (清空累加器 ACC)</span><br></pre></td></tr></table></figure>
<p><em>(这里没有给出操作数，但CPU默认知道要操作的是 ACC 寄存器)</em></p>
</li>
</ul>
<hr>
<h3 id="6-偏移寻址类-Displacement-Addressing"><a href="#6-偏移寻址类-Displacement-Addressing" class="headerlink" title="6. 偏移寻址类 (Displacement Addressing)"></a><strong>6. 偏移寻址类 (Displacement Addressing)</strong></h3><p>这类寻址方式非常重要，它们的共同点是：<strong>有效地址 = 寄存器内容 + 形式地址（偏移量）</strong>。 根据使用的寄存器不同，分为以下三种：</p>
<h4 id="A-基址寻址-Base-Addressing"><a href="#A-基址寻址-Base-Addressing" class="headerlink" title="A. 基址寻址 (Base Addressing)"></a><strong>A. 基址寻址 (Base Addressing)</strong></h4><ul>
<li><strong>侧重点：</strong> <strong>搬家（程序重定位）</strong>。</li>
<li><strong>机制：</strong> 基址寄存器 (BR) 存放程序的<strong>起始地址</strong>（由操作系统管理），指令中给出<strong>偏移量</strong>。</li>
<li><strong>公式：</strong> EA = (BR) + A</li>
<li><strong>举例：</strong><ul>
<li>你的程序被加载到内存的 10000H 位置（BR=10000H）。</li>
<li>指令说“访问第 5 个字节”（A=5）。</li>
<li>CPU 实际访问：10005H。</li>
</ul>
</li>
</ul>
<h4 id="B-变址寻址-Indexed-Addressing"><a href="#B-变址寻址-Indexed-Addressing" class="headerlink" title="B. 变址寻址 (Indexed Addressing)"></a><strong>B. 变址寻址 (Indexed Addressing)</strong></h4><ul>
<li><strong>侧重点：</strong> <strong>数组遍历</strong>。</li>
<li><strong>机制：</strong> 变址寄存器 (IX) 存放<strong>数组下标</strong>（由用户改变），指令中给出<strong>数组首地址</strong>。</li>
<li><strong>公式：</strong> EA = (IX) + A</li>
<li><strong>举例：</strong><ul>
<li>指令指定数组首地址是 2000H（A=2000H）。</li>
<li>循环第一次，变址寄存器 IX = 1。CPU 访问 2001H。</li>
<li>循环第二次，变址寄存器 IX = 2。CPU 访问 2002H。</li>
</ul>
</li>
</ul>
<h4 id="C-相对寻址-Relative-Addressing"><a href="#C-相对寻址-Relative-Addressing" class="headerlink" title="C. 相对寻址 (Relative Addressing)"></a><strong>C. 相对寻址 (Relative Addressing)</strong></h4><ul>
<li><strong>侧重点：</strong> <strong>跳转（分支指令）</strong>。</li>
<li><strong>机制：</strong> 以程序计数器 (PC) 当前的值为基准，向前或向后跳多少步。</li>
<li><strong>公式：</strong> EA = (PC) + A</li>
<li><strong>举例：</strong><ul>
<li>当前执行到第 100 行代码 (PC=100)。</li>
<li>指令是 <code>JMP +10</code>（向下跳10行）。</li>
<li>CPU 计算出目标地址：110 行。</li>
</ul>
</li>
</ul>
<h2 id="中央处理器：数据通路和控制器"><a href="#中央处理器：数据通路和控制器" class="headerlink" title="中央处理器：数据通路和控制器"></a>中央处理器：数据通路和控制器</h2><h3 id="CPU-的工作流程"><a href="#CPU-的工作流程" class="headerlink" title="CPU 的工作流程"></a>CPU 的工作流程</h3><p><strong>取指令 (Fetch)</strong>：去仓库（内存）里把订单（指令）拿出来。</p>
<p><strong>PC+1 送 PC</strong>：订单拿到手了，把指针指向<strong>下一张</strong>订单的位置。（注意：在 MIPS 真实硬件中通常是 PC+4，因为一条指令占4个字节，这里 PPT 用 “PC+1” 是为了简化逻辑，假设按“个”来数指令）。</p>
<p><strong>指令译码 (Decode)</strong>：看懂订单。比如 “001010” 代表什么？哦，原来是“加法”。</p>
<p><strong>取操作数</strong>：加法需要两个数，去寄存器里把这两个数拿出来。</p>
<p><strong>运算/访存</strong>：ALU 开始干活（算加法），或者去读写内存。</p>
<p><strong>存结果</strong>：把算好的数写回寄存器。</p>
<p><strong>异常/中断检查</strong>：干完活了，检查一下有没有出乱子（异常），或者外面有没有人敲门（中断）。</p>
<h3 id="组成指令功能的四种基本操作"><a href="#组成指令功能的四种基本操作" class="headerlink" title="组成指令功能的四种基本操作"></a>组成指令功能的四种基本操作</h3><p><strong>Load</strong>：内存 $\rightarrow$ 寄存器 （去仓库拿材料）。</p>
<p><strong>Store</strong>：寄存器 $\rightarrow$ 内存 （把成品放回仓库）。</p>
<p><strong>Move</strong>：寄存器 $\rightarrow$ 寄存器 （左右手倒腾）。</p>
<p><strong>ALU</strong>：运算 $\rightarrow$ 寄存器 （加工处理）。</p>
<p><strong>读内存</strong>：$R[r] \leftarrow M[addr]$ —— 控制器指挥数据从 Memory 流向 Register。</p>
<p><strong>写内存</strong>：$M[addr] \leftarrow R[r]$ —— 控制器指挥数据从 Register 流向 Memory。</p>
<p><strong>内部搬运</strong>：$R[a] \leftarrow R[b]$ —— 寄存器之间倒手。</p>
<p><strong>运算</strong>：$R[a] \leftarrow R[b] + R[c]$ —— 数据流经 ALU 进行加工。</p>
<h3 id="CPU-的内部架构"><a href="#CPU-的内部架构" class="headerlink" title="CPU 的内部架构"></a>CPU 的<strong>内部架构</strong></h3><p> CPU 拆成了两个独立但协作的部分：<strong>Control（控制器）</strong> 和 <strong>Datapath（数据通路）</strong>。</p>
<p><strong>Datapath（数据通路）—— 它是“肢体”</strong></p>
<ul>
<li><strong>定义</strong>：数据流经的路径和部件（如 ALU、寄存器、多路选择器）。</li>
<li><strong>作用</strong>：它负责<strong>干脏活累活</strong>。</li>
<li><strong>比喻</strong>：它就像是工厂里的流水线设备和工人。你要它搬砖，它就搬砖；要它算加法，它就只能算加法。它自己没有思想，不知道什么时候该干什么。</li>
</ul>
<p><strong>Control（控制器）—— 它是“大脑”</strong></p>
<ul>
<li><strong>定义</strong>：根据指令（0和1的代码），生成控制信号。</li>
<li><strong>作用</strong>：它负责<strong>发号施令</strong>。</li>
<li><strong>比喻</strong>：它就是拿着大喇叭的工头。<ul>
<li>它看一眼指令（比如是 <code>add</code>），就会对 Datapath 喊：“ALU 准备做加法！寄存器准备存结果！”</li>
<li>它看一眼指令（比如是 <code>load</code>），就会喊：“内存接口打开！把数据读进来！”</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：我们后面要学的“设计 CPU”，其实就是先画出<strong>Datapath</strong>（把路铺好），然后设计<strong>Control</strong>（让信号指挥数据怎么走）。</p>
</blockquote>
<h3 id="数据通路——组合逻辑元件"><a href="#数据通路——组合逻辑元件" class="headerlink" title="数据通路——组合逻辑元件"></a>数据通路——组合逻辑元件</h3><h4 id="1-加法器-Adder"><a href="#1-加法器-Adder" class="headerlink" title="1. 加法器 (Adder)"></a>1. 加法器 (Adder)</h4><ul>
<li><strong>作用</strong>：最简单的数学工。只干一件事：把输入的 A 和 B 相加。</li>
<li><strong>用在哪</strong>：专门用来算 <code>PC + 4</code>（计算下一条指令地址），或者算内存地址。</li>
<li><strong>特点</strong>：不需要复杂的控制，给电就由 A+B 出结果。</li>
</ul>
<h4 id="2-多路选择器-MUX-——-非常关键！"><a href="#2-多路选择器-MUX-——-非常关键！" class="headerlink" title="2. 多路选择器 (MUX) —— 非常关键！"></a>2. 多路选择器 (MUX) —— <strong>非常关键！</strong></h4><ul>
<li><strong>通俗理解</strong>：它是<strong>“铁路道岔”</strong>或者<strong>“单刀双掷开关”</strong>。</li>
<li><strong>作用</strong>：它有两个输入（A 和 B），但出口（Y）只有一个。<strong>谁能通过？</strong> 由红色的 <strong>Select（控制信号）</strong> 决定。<ul>
<li>如果 Select 是 0，A 通过。</li>
<li>如果 Select 是 1，B 通过。</li>
</ul>
</li>
<li><strong>为什么重要</strong>：CPU 内部经常面临选择。例如：写回寄存器的数据，是来自 ALU 的计算结果，还是来自内存的读取结果？这时候就需要用 MUX 来选。</li>
</ul>
<h4 id="3-算术逻辑部件-ALU"><a href="#3-算术逻辑部件-ALU" class="headerlink" title="3. 算术逻辑部件 (ALU)"></a>3. 算术逻辑部件 (ALU)</h4><ul>
<li><strong>作用</strong>：全能数学工。能做加减乘除，也能做与或非。</li>
<li><strong>控制信号 (OP)</strong>：这是关键！ALU 到底做“加法”还是“减法”，全靠红色的 <strong>OP</strong> 信号来指挥。这个 OP 信号就是“控制器”发给它的。</li>
<li><strong>输出 Zero</strong>：这是一个反馈信号。如果计算结果是 0，Zero 线这就变 1。这通常用于判断 <code>beq</code>（相等跳转）指令。</li>
</ul>
<h4 id="4-译码器-Decoder"><a href="#4-译码器-Decoder" class="headerlink" title="4. 译码器 (Decoder)"></a>4. 译码器 (Decoder)</h4><ul>
<li><strong>作用</strong>：翻译官。</li>
<li><strong>原理</strong>：输入 n 位二进制，输出 $2^n$ 条线。比如输入 <code>001</code>，它就让第 1 号线通电；输入 <code>111</code>，就让第 7 号线通电。</li>
<li><strong>用在哪</strong>：主要用于<strong>寄存器堆</strong>（Register File）的选择。比如指令说“读 3 号寄存器”，译码器就把 3 号寄存器的门打开。</li>
</ul>
<h3 id="存储元件-寄存器和寄存器组"><a href="#存储元件-寄存器和寄存器组" class="headerlink" title="存储元件: 寄存器和寄存器组"></a>存储元件: 寄存器和寄存器组</h3><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251224083750131.png" alt="image-20251224083750131"></p>
<h4 id="1-从“存-1-位”进阶到“存-32-位”"><a href="#1-从“存-1-位”进阶到“存-32-位”" class="headerlink" title="1. 从“存 1 位”进阶到“存 32 位”"></a>1. 从“存 1 位”进阶到“存 32 位”</h4><p>你刚才已经学会了 <strong>D 触发器</strong>（只能存 1 个 bit，比如 0 或 1）。但现代 CPU（比如 32 位 MIPS）处理数据是一次性处理 32 位的。</p>
<ul>
<li><strong>寄存器 (Register)</strong>： 其实就是把 <strong>32 个 D 触发器</strong> 并排捆在一起。<ul>
<li><strong>Data In/Out</strong>：一次吞吐 32 位数据。</li>
<li><strong>Write Enable (WE, 写使能)</strong>：这是一个<strong>“安全锁”</strong>。<ul>
<li>如果是 0：就算时钟边沿（Clock）来了，也不许修改里面的数据。</li>
<li>如果是 1：时钟边沿一来，允许写入新数据。</li>
</ul>
</li>
<li><em>为什么要这个锁？</em> 因为时钟一直在跳，但我们不是每个周期都要改写这个寄存器，只有需要存结果时才打开锁。</li>
</ul>
</li>
</ul>
<h4 id="2-寄存器堆：CPU-的“办公桌”"><a href="#2-寄存器堆：CPU-的“办公桌”" class="headerlink" title="2. 寄存器堆：CPU 的“办公桌”"></a>2. 寄存器堆：CPU 的“办公桌”</h4><p>CPU 只有 1 个寄存器是不够的，MIPS 架构里有 32 个通用寄存器。把这 32 个寄存器堆放在一起，就叫 <strong>寄存器堆 (Register File)</strong>。</p>
<p>这一页重点讲了它的<strong>端口（Interface）</strong>，也就是它的“进出口”：</p>
<ul>
<li><strong>两个“读”端口 (Read Ports)</strong>：<ul>
<li><strong>输入</strong>：<code>RA</code> (Read Address A) 和 <code>RB</code>。比如你给 RA 输入 5，给 RB 输入 8。</li>
<li><strong>输出</strong>：<code>busA</code> 和 <code>busB</code>。它会立刻吐出 5 号和 8 号寄存器里存的数据。</li>
<li><strong>性质</strong>：<strong>组合逻辑</strong>。意味着<strong>不需要时钟，不需要排队</strong>，只要地址给对了，数据立马出来（类似于你去查字典，翻到哪页字就在那）。</li>
</ul>
</li>
<li><strong>一个“写”端口 (Write Port)</strong>：<ul>
<li><strong>输入</strong>：<code>RW</code> (Write Address，你要改几号箱子？)、<code>busW</code> (Write Data，你要存什么数据？)、<code>Write Enable</code> (允许修改吗？)。</li>
<li><strong>性质</strong>：<strong>时序逻辑</strong>。意味着<strong>必须等时钟边沿 (Clock)</strong>。就算你把数据准备好了，也没人理你，直到时钟“咔嚓”一声（上升沿），数据才会真正写进那个寄存器。</li>
</ul>
</li>
</ul>
<h3 id="MIPS的三种指令类型"><a href="#MIPS的三种指令类型" class="headerlink" title="MIPS的三种指令类型"></a>MIPS的三种指令类型</h3><h4 id="A-R-Type-Register-Type-——-纯寄存器操作"><a href="#A-R-Type-Register-Type-——-纯寄存器操作" class="headerlink" title="A. R-Type (Register Type) —— 纯寄存器操作"></a>A. R-Type (Register Type) —— 纯寄存器操作</h4><ul>
<li><strong>代表指令</strong>：<code>add</code>, <code>sub</code></li>
<li><strong>格式特点</strong>：<ul>
<li><strong>3 个寄存器</strong>：它需要读两个源寄存器 (<code>rs</code>, <code>rt</code>)，把结果写进目的寄存器 (<code>rd</code>)。</li>
<li><strong>func 字段</strong>：对于 R 型指令，<code>op</code>（操作码）通常都是 0，真正决定是加还是减的是最后的 <code>func</code> 字段。</li>
</ul>
</li>
<li><strong>硬件暗示</strong>：我们需要寄存器堆提供两个读端口，一个写端口。</li>
</ul>
<h4 id="B-I-Type-Immediate-Type-——-带常数的操作"><a href="#B-I-Type-Immediate-Type-——-带常数的操作" class="headerlink" title="B. I-Type (Immediate Type) —— 带常数的操作"></a>B. I-Type (Immediate Type) —— 带常数的操作</h4><ul>
<li><strong>代表指令</strong>：<ul>
<li>运算类：<code>ori</code> (和常数做或运算)。</li>
<li>访存类：<code>lw</code>, <code>sw</code> (基于偏移量访问内存)。</li>
<li>分支类：<code>beq</code> (如果不相等，跳过多少条指令)。</li>
</ul>
</li>
<li><strong>格式特点</strong>：<ul>
<li><strong>2 个寄存器</strong>：<code>rs</code> 和 <code>rt</code>。</li>
<li><strong>1 个立即数</strong>：最后 16 位是一个常数 (<code>immediate</code>)。</li>
</ul>
</li>
<li><strong>硬件暗示</strong>：<ul>
<li>这里没有 <code>rd</code> 了！写回的目标变了（通常变成了 <code>rt</code>）。</li>
<li>这 16 位的数字太短了，而 CPU 是 32 位的。所以硬件里必须有一个 <strong>“扩展单元 (Sign/Zero Extender)”</strong> 把 16 位变成 32 位。</li>
</ul>
</li>
</ul>
<h4 id="C-J-Type-Jump-Type-——-飞跃"><a href="#C-J-Type-Jump-Type-——-飞跃" class="headerlink" title="C. J-Type (Jump Type) —— 飞跃"></a>C. J-Type (Jump Type) —— 飞跃</h4><ul>
<li><strong>代表指令</strong>：<code>j</code> (Jump)</li>
<li><strong>格式特点</strong>：<ul>
<li>除了开头的 <code>op</code>，剩下 26 位全是地址。</li>
</ul>
</li>
<li><strong>硬件暗示</strong>：这需要一个特殊的电路，直接把这 26 位塞进 PC (程序计数器) 里，让程序“瞬移”。</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251224085707125.png" alt="image-20251224085707125"></p>
<h2 id="取指令部件-Instruction-Fetch-Unit"><a href="#取指令部件-Instruction-Fetch-Unit" class="headerlink" title="取指令部件(Instruction Fetch Unit)"></a>取指令部件(Instruction Fetch Unit)</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251224100438935.png" alt="image-20251224100438935"></p>
<p><strong>路径一：去拿指令 (Fetch Instruction)</strong></p>
<ul>
<li><strong>PC 寄存器</strong> 输出当前的地址（比如 1000）。</li>
<li>这个地址顺着线连到了 <strong>Instruction Memory (指令存储器)</strong> 的 Address 接口。</li>
<li>存储器立刻吐出地址 1000 里的那行代码 —— <strong>Instruction Word (32位指令字)</strong>。</li>
<li><strong>结果</strong>：指令拿到手了，准备送去译码。这就是 RTL 里的 <code>M[PC]</code>。</li>
</ul>
<p><strong>路径二：准备下一条 (Update PC)</strong></p>
<ul>
<li><strong>PC 寄存器</strong> 的输出（还是 1000）同时也连到了右边的 <strong>Next Address Logic (下地址逻辑)</strong>。</li>
<li>对于大多数指令，这里的逻辑很简单，就是个加法器：<code>1000 + 4 = 1004</code>。</li>
<li>算出来的 <code>1004</code> 会绕回到 PC 的输入端，<strong>等待</strong>下一个时钟信号到来。</li>
<li><strong>结果</strong>：为下一轮循环做好了准备。这就是 RTL 里的 <code>PC &lt;- PC + 4</code>。</li>
</ul>
<h2 id="RR（R-type）型指令的数据通路"><a href="#RR（R-type）型指令的数据通路" class="headerlink" title="RR（R-type）型指令的数据通路"></a>RR（R-type）型指令的数据通路</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251224100901373.png" alt="image-20251224100901373"></p>
<h4 id="阶段一：读数据（原材料进场）"><a href="#阶段一：读数据（原材料进场）" class="headerlink" title="阶段一：读数据（原材料进场）"></a>阶段一：读数据（原材料进场）</h4><ul>
<li><strong>指令拆解</strong>：<ul>
<li>指令的 <strong>21-25位 (rs)</strong> 连接到寄存器堆的 <strong>Ra (Read Address 1)</strong> 接口。</li>
<li>指令的 <strong>16-20位 (rt)</strong> 连接到寄存器堆的 <strong>Rb (Read Address 2)</strong> 接口。</li>
</ul>
</li>
<li><strong>动作</strong>：<ul>
<li>寄存器堆收到地址后，立刻把这两个寄存器里的数据吐出来，分别送到 <strong>busA</strong> 和 <strong>busB</strong> 线路上。</li>
</ul>
</li>
</ul>
<h4 id="阶段二：算数据（加工）"><a href="#阶段二：算数据（加工）" class="headerlink" title="阶段二：算数据（加工）"></a>阶段二：算数据（加工）</h4><ul>
<li><strong>流入 ALU</strong>：<ul>
<li><code>busA</code> 和 <code>busB</code> 里的数据顺着线流进右边的 <strong>ALU</strong>。</li>
</ul>
</li>
<li><strong>控制信号 <code>ALUctr</code></strong>：<ul>
<li>这时候，<strong>控制器</strong>（图中虽未画出，但红字提到了）会给 ALU 发一个命令。</li>
<li>如果是 <code>add</code> 指令，<code>ALUctr</code> 信号就是“做加法”。</li>
<li>如果是 <code>sub</code> 指令，<code>ALUctr</code> 信号就是“做减法”。</li>
</ul>
</li>
<li><strong>结果产生</strong>：ALU 算完后，结果出现在 <strong>Result</strong> 线路上。</li>
</ul>
<h4 id="阶段三：写回结果（成品入库）"><a href="#阶段三：写回结果（成品入库）" class="headerlink" title="阶段三：写回结果（成品入库）"></a>阶段三：写回结果（成品入库）</h4><p>这是最关键的一步，形成了一个<strong>闭环</strong>。</p>
<ul>
<li><strong>数据回流</strong>：<ul>
<li>你看那条长长的线，从 ALU 的 Result 绕了一大圈，回到了寄存器堆左边的 <strong>busW (Write Data)</strong> 接口。</li>
</ul>
</li>
<li><strong>确定写给谁</strong>：<ul>
<li>指令的 <strong>11-15位 (rd)</strong> 连接到了 <strong>Rw (Write Address)</strong> 接口。这告诉寄存器堆：“把结果存进 <code>rd</code> 号格子里”。</li>
</ul>
</li>
<li><strong>关键钥匙 <code>RegWr</code></strong>：<ul>
<li>光把数据送回来还不行，必须有人开门。</li>
<li><strong>RegWr (Register Write)</strong> 信号必须置为 <strong>1</strong>。</li>
<li><strong>时钟边沿 (Clk)</strong>：当时钟“咔嚓”一响（下降沿或上升沿），数据就被永久地锁进 <code>rd</code> 寄存器了。</li>
</ul>
</li>
</ul>
<h2 id="带立即数的逻辑指令的数据通路"><a href="#带立即数的逻辑指令的数据通路" class="headerlink" title="带立即数的逻辑指令的数据通路"></a>带立即数的逻辑指令的数据通路</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251227130648203.png" alt="image-20251227130648203"></p>
<h3 id="1-右边的蓝色-MUX：解决“跟谁运算”的问题"><a href="#1-右边的蓝色-MUX：解决“跟谁运算”的问题" class="headerlink" title="1. 右边的蓝色 MUX：解决“跟谁运算”的问题"></a>1. 右边的蓝色 MUX：解决“跟谁运算”的问题</h3><p>请看 ALU 前面的那个蓝色梯形（多路选择器）。</p>
<ul>
<li><strong>冲突点</strong>：<ul>
<li><strong><code>add</code> 指令</strong>想计算：<code>寄存器 A + 寄存器 B</code>。</li>
<li><strong><code>ori</code> 指令</strong>想计算：<code>寄存器 A or 立即数</code>。</li>
<li>ALU 的第二个输入端（下端）很为难：我到底该连寄存器 <code>busB</code>，还是连立即数 <code>imm16</code>？</li>
</ul>
</li>
<li><strong>解决方案 (ALUSrc MUX)</strong>：<ul>
<li>加一个 MUX！</li>
<li><strong>0号通道</strong>接 <code>busB</code>（给 R-Type 用）。</li>
<li><strong>1号通道</strong>接 <code>ZeroExt</code> 后的立即数（给 I-Type 用）。</li>
<li><strong>控制信号 <code>ALUSrc</code></strong>：如果是 <code>ori</code> 指令，控制器就把这个信号设为 <strong>1</strong>，强行把立即数送进 ALU。</li>
</ul>
</li>
</ul>
<h3 id="2-左边的蓝色-MUX：解决“结果存哪”的问题"><a href="#2-左边的蓝色-MUX：解决“结果存哪”的问题" class="headerlink" title="2. 左边的蓝色 MUX：解决“结果存哪”的问题"></a>2. 左边的蓝色 MUX：解决“结果存哪”的问题</h3><p>请看寄存器堆 <code>Rw</code>（写地址）前面的那个蓝色梯形。<strong>这是初学者最容易晕的地方！</strong></p>
<ul>
<li><strong>冲突点</strong>：<ul>
<li><strong>R-Type (<code>add rd, rs, rt</code>)</strong>：结果要存进 <strong><code>rd</code></strong>（指令的第 11-15 位）。</li>
<li><strong>I-Type (<code>ori rt, rs, imm</code>)</strong>：结果要存进 <strong><code>rt</code></strong>（指令的第 16-20 位）。因为 I 型指令里根本就没有 <code>rd</code> 这个字段！</li>
<li>寄存器堆的 <code>Rw</code> 接口很为难：我到底听谁的？</li>
</ul>
</li>
<li><strong>解决方案 (RegDst MUX)</strong>：<ul>
<li>加一个 MUX！</li>
<li><strong>0号通道</strong>接 <code>rd</code> (11-15位)。</li>
<li><strong>1号通道</strong>接 <code>rt</code> (16-20位)。</li>
<li><strong>控制信号 <code>RegDst</code></strong>：如果是 <code>ori</code> 指令，我们必须把结果存回 <code>rt</code>，所以控制器把信号设为 <strong>1</strong>。</li>
</ul>
</li>
</ul>
<h3 id="3-还有一个细节：ZeroExt-零扩展"><a href="#3-还有一个细节：ZeroExt-零扩展" class="headerlink" title="3. 还有一个细节：ZeroExt (零扩展)"></a>3. 还有一个细节：ZeroExt (零扩展)</h3><ul>
<li>看 ALU 下方那个细长的蓝色方框。</li>
<li><strong>为什么是 ZeroExt？</strong><ul>
<li>正如我们上一轮讨论的，<code>ori</code> 是逻辑运算，不关心正负号。它只需要把 16 位的立即数前面补 16 个 0，变成 32 位即可。</li>
<li>如果是 <code>lw</code> 指令，这里就会换成 <code>SignExt</code>（符号扩展）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：一张控制信号表"><a href="#总结：一张控制信号表" class="headerlink" title="总结：一张控制信号表"></a>总结：一张控制信号表</h3><p>根据这张图，如果要执行 <code>ori rt, rs, imm16</code>，我们的 <strong>“大脑”（控制器）</strong> 需要发出什么样的指令？（看 PPT 最下方蓝字）</p>
<ol>
<li><strong><code>RegDst = 1</code></strong>：告诉寄存器堆，“把结果写进 <code>rt</code> (输入1)”。</li>
<li><strong><code>RegWr = 1</code></strong>：告诉寄存器堆，“请开门，我要写数据”。</li>
<li><strong><code>ALUSrc = 1</code></strong>：告诉 ALU，“你的第二个操作数是立即数 (输入1)，别看寄存器 B”。</li>
<li><strong><code>ALUctr = or</code></strong>：告诉 ALU，“做或运算”。</li>
</ol>
<h2 id="lw-Load-Word-指令的-RTL-寄存器传输级-深度剖析"><a href="#lw-Load-Word-指令的-RTL-寄存器传输级-深度剖析" class="headerlink" title="lw (Load Word) 指令的 RTL (寄存器传输级) 深度剖析"></a><strong><code>lw</code> (Load Word)</strong> 指令的 <strong>RTL (寄存器传输级)</strong> 深度剖析</h2><h3 id="1-RTL-流程再回顾-Standard-Steps"><a href="#1-RTL-流程再回顾-Standard-Steps" class="headerlink" title="1. RTL 流程再回顾 (Standard Steps)"></a>1. RTL 流程再回顾 (Standard Steps)</h3><p>这一页中间的蓝色字展示了 <code>lw</code> 指令执行的四个标准步骤：</p>
<ol>
<li><strong>取指 (Fetch)</strong>：<code>M[PC]</code>。老规矩，把指令搬进 CPU。</li>
<li><strong>算地址 (Address Calc)</strong>：<code>Addr &lt;- R[rs] + SignExt(imm16)</code>。<ul>
<li>这是我们讨论过的重点。用基址寄存器 <code>rs</code> 加上扩展后的偏移量。</li>
</ul>
</li>
<li><strong>取数据 (Memory Access)</strong>：<code>R[rt] &lt;- M[Addr]</code>。<ul>
<li>拿着刚才算的地址，去 <strong>数据存储器 (Data Memory)</strong> 里把数据读出来，写进 <strong><code>rt</code></strong> 寄存器。</li>
</ul>
</li>
<li><strong>更新 PC</strong>：<code>PC &lt;- PC + 4</code>。准备下一条。</li>
</ol>
<hr>
<h3 id="2-核心考点：为什么要“符号扩展”？-Sign-Extension"><a href="#2-核心考点：为什么要“符号扩展”？-Sign-Extension" class="headerlink" title="2. 核心考点：为什么要“符号扩展”？(Sign Extension)"></a>2. 核心考点：为什么要“符号扩展”？(Sign Extension)</h3><p>这是这张图最核心的技术细节。请看 PPT 下方的两个 32 位二进制条形图。</p>
<ul>
<li><strong>问题</strong>：上一张 PPT 讲 <code>ori</code> 指令时用的是 <strong>ZeroExt (零扩展)</strong>，为什么这里非要用 <strong>SignExt (符号扩展)</strong>？</li>
<li><strong>答案</strong>：因为 <strong>地址偏移量可能是负数</strong>！<ul>
<li><strong>场景 A (正向偏移)</strong>：如果你想访问 <code>rs</code> 后面 4 字节的地方，<code>imm16</code> 是 <code>00...0100</code>。符号位（第 15 位）是 <strong>0</strong>。扩展成 32 位时，高位全补 <strong>0</strong>。这和零扩展没区别。</li>
<li><strong>场景 B (反向偏移)</strong>：如果你想访问 <code>rs</code> <strong>前面</strong> 4 字节的地方，<code>imm16</code> 是负数（比如 -4，补码形式）。符号位（第 15 位）是 <strong>1</strong>。<ul>
<li>如果用零扩展：高位补 0，这个负数瞬间变成了一个巨大的正数，地址就指到九霄云外去了。</li>
<li><strong>必须用符号扩展</strong>：<strong>复制符号位</strong>。如果第 15 位是 1，那么高 16 位全部填 1。这样 <code>FFFF...</code> 依然代表 -4，保证了数学上的正确性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="装入-lw-指令的数据通路"><a href="#装入-lw-指令的数据通路" class="headerlink" title="装入(lw)指令的数据通路"></a>装入(lw)指令的数据通路</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251227132938059.png" alt="image-20251227132938059"></p>
<h3 id="1-为什么要加蓝色部分？-The-“Why”"><a href="#1-为什么要加蓝色部分？-The-“Why”" class="headerlink" title="1. 为什么要加蓝色部分？(The “Why”)"></a>1. 为什么要加蓝色部分？(The “Why”)</h3><p>PPT 中间有个大大的问号：“加蓝色部分。为什么？”</p>
<ul>
<li><strong>新增部件：Data Memory (数据存储器)</strong><ul>
<li><strong>原因</strong>：<code>lw</code> 的核心任务是从内存取数。之前的电路只有 ALU 和寄存器，根本没有“仓库”可去。所以必须加上这个存储器单元。</li>
<li><strong>动作</strong>：ALU 算出的结果（比如 1004）不再被当作计算结果，而是变成了<strong>地址 (Address)</strong> 输入给存储器。</li>
</ul>
</li>
<li><strong>新增部件：MemtoReg MUX (右侧的多路选择器)</strong><ul>
<li><strong>原因</strong>：这是数据回流的关键路口。<ul>
<li>以前做 <code>add</code> 时，写回寄存器的是 <strong>ALU 的结果</strong>。</li>
<li>现在做 <code>lw</code> 时，写回寄存器的是 <strong>Memory 的结果</strong>。</li>
</ul>
</li>
<li><strong>冲突</strong>：一条写回线 (<code>busW</code>) 不能同时接两个输入。</li>
<li><strong>解决</strong>：加一个开关（MUX）。<ul>
<li>通道 0：来自 ALU（给 R-Type 用）。</li>
<li>通道 1：来自 Memory（给 <code>lw</code> 用）。</li>
<li>控制信号 <strong><code>MemtoReg</code></strong> 决定走哪条路。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-数据的“长征”路线-Data-Flow"><a href="#2-数据的“长征”路线-Data-Flow" class="headerlink" title="2. 数据的“长征”路线 (Data Flow)"></a>2. 数据的“长征”路线 (Data Flow)</h3><p>跟着箭头走，看 <code>lw rt, rs, imm16</code> 是怎么执行的：</p>
<ol>
<li><strong>准备数据</strong>：<ul>
<li>从寄存器堆读出 <strong><code>rs</code> (基地址)</strong>。</li>
<li>把 <strong><code>imm16</code> (偏移量)</strong> 进行 <strong>符号扩展 (Sign Ext)</strong>（注意图下方的 <code>ExtOp=1</code>，代表 SignExt）。</li>
</ul>
</li>
<li><strong>计算地址 (ALU Stage)</strong>：<ul>
<li><strong><code>ALUSrc = 1</code></strong>：ALU 的下端输入选择扩展后的立即数。</li>
<li><strong><code>ALUctr = add</code></strong>：ALU 执行加法，计算出 <code>基址 + 偏移</code>。</li>
</ul>
</li>
<li><strong>访问内存 (Memory Stage)</strong>：<ul>
<li>ALU 的计算结果连到了 Data Memory 的 <strong>Addr</strong> 端。</li>
<li><strong><code>MemWr = 0</code></strong>：我们是读内存，不是写内存，所以写使能关闭。</li>
<li>数据从 <strong>Data Out</strong> 吐出来。</li>
</ul>
</li>
<li><strong>写回寄存器 (Write Back Stage)</strong>：<ul>
<li><strong><code>MemtoReg = 1</code></strong>：右边的蓝色 MUX 拨到 <strong>1</strong> 号位，允许内存的数据通过。</li>
<li><strong><code>RegDst = 0</code></strong>：左上角的 MUX 拨到 <strong>0</strong> 号位。为什么？因为 <code>lw</code> 的目标寄存器是 <strong><code>rt</code></strong> (16-20位)，而不是 <code>rd</code>。</li>
<li><strong><code>RegWr = 1</code></strong>：最后，寄存器堆的大门打开，数据写入 <code>rt</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-底部红字：控制信号大揭秘"><a href="#3-底部红字：控制信号大揭秘" class="headerlink" title="3. 底部红字：控制信号大揭秘"></a>3. 底部红字：控制信号大揭秘</h3><p>PPT 最下方列出了执行 <code>lw</code> 所需的一整套“密码”（控制信号），我们来逐个破解：</p>
<ul>
<li><strong><code>RegDst = 0</code></strong>：<ul>
<li>写回目标是 <code>rt</code> (指令的 16-20 位)，所以选 0 通道。</li>
</ul>
</li>
<li><strong><code>RegWr = 1</code></strong>：<ul>
<li>需要把取回来的数存进寄存器。</li>
</ul>
</li>
<li><strong><code>ALUctr = add</code></strong>：<ul>
<li>虽然是取数，但中间需要用加法算地址。</li>
</ul>
</li>
<li><strong><code>ExtOp = 1</code></strong>：<ul>
<li><strong>关键！</strong> <code>lw</code> 的偏移量是有符号的（可能往前偏移），所以必须用<strong>符号扩展</strong> (Sign Extension)，不能用零扩展。</li>
</ul>
</li>
<li><strong><code>ALUSrc = 1</code></strong>：<ul>
<li>ALU 的第二个操作数是立即数（偏移量），不是寄存器 B。</li>
</ul>
</li>
<li><strong><code>MemWr = 0</code></strong>：<ul>
<li>保护内存数据，只读不写。</li>
</ul>
</li>
<li><strong><code>MemtoReg = 1</code></strong>：<ul>
<li><strong>最关键的区别位</strong>。这一位告诉 CPU：“这次写回的数据来自<strong>内存</strong>，不是 ALU”。</li>
</ul>
</li>
</ul>
<h2 id="存数-sw-指令的数据通路"><a href="#存数-sw-指令的数据通路" class="headerlink" title="存数(sw)指令的数据通路"></a>存数(sw)指令的数据通路</h2><h3 id="1-核心动作：存数-Store"><a href="#1-核心动作：存数-Store" class="headerlink" title="1. 核心动作：存数 (Store)"></a>1. 核心动作：存数 (Store)</h3><p>看看 PPT 顶部的公式：</p>
<script type="math/tex; mode=display">M[ R[rs] + SignExt[imm16] ] \leftarrow R[rt]</script><p>这句话的意思是：</p>
<ol>
<li><strong>算地址</strong>：用 <code>rs</code> 里的基地址 + 扩展后的偏移量，算出内存地址（和 <code>lw</code> 一模一样）。</li>
<li><strong>存数据</strong>：把 <strong><code>rt</code></strong> 寄存器里的值，写进刚才算出的那个内存地址里。</li>
</ol>
<h3 id="2-蓝色部分：数据怎么流进内存？"><a href="#2-蓝色部分：数据怎么流进内存？" class="headerlink" title="2. 蓝色部分：数据怎么流进内存？"></a>2. 蓝色部分：数据怎么流进内存？</h3><p>图中间有一条醒目的<strong>蓝色折线</strong>，这是 <code>sw</code> 指令独有的特征：</p>
<ul>
<li><strong>起点</strong>：<strong><code>busB</code></strong>。<ul>
<li>寄存器堆的 <code>Rb</code> 端口读取了 <strong><code>rt</code></strong> 寄存器的数据，送到了 <code>busB</code> 线路上。</li>
<li><em>注意</em>：在 R-Type 指令里，<code>busB</code> 是送去 ALU 做运算的；但在 <code>sw</code> 指令里，<code>busB</code> 里装的是<strong>要存进内存的货物</strong>。</li>
</ul>
</li>
<li><strong>终点</strong>：<strong>Data Memory 的 <code>Data In</code> 接口</strong>。<ul>
<li>这条线绕过了 ALU，直接插进了数据存储器的“写入口”。</li>
</ul>
</li>
<li><strong>为什么加这一条？</strong><ul>
<li>因为 ALU 忙着算地址去了（看 <code>busA</code> 和扩展后的立即数进了 ALU），它没空处理数据。</li>
<li>所以我们需要一条“旁路”，把寄存器里的数据直接送到内存门口等待写入。</li>
</ul>
</li>
</ul>
<h3 id="3-控制信号大反转-The-Control-Signals"><a href="#3-控制信号大反转-The-Control-Signals" class="headerlink" title="3. 控制信号大反转 (The Control Signals)"></a>3. 控制信号大反转 (The Control Signals)</h3><p>PPT 底部那一排蓝色的控制信号，有很多独特之处，特别是出现了 <strong><code>x</code> (Don’t Care)</strong>。</p>
<ul>
<li><strong><code>MemWr = 1</code> (最关键！)</strong><ul>
<li>这是 <code>sw</code> 的灵魂。必须把“写内存使能”打开，否则数据只会在门口蹭蹭，进不去。</li>
</ul>
</li>
<li><strong><code>RegWr = 0</code> (千万别写寄存器！)</strong><ul>
<li><code>sw</code> 是往外存东西，不修改 CPU 内部的寄存器。</li>
<li>如果这里设为 1，那你就会意外地破坏寄存器里的数据。</li>
</ul>
</li>
<li><strong><code>RegDst = x</code> (无关项)</strong><ul>
<li>既然 <code>RegWr</code> 已经是 0 了（寄存器大门紧闭），那么 <code>RegDst</code> 到底是选 <code>rt</code> 还是 <code>rd</code> 根本无所谓，反正也写不进去。这就是“Don’t Care”。</li>
</ul>
</li>
<li><strong><code>MemtoReg = x</code> (无关项)</strong><ul>
<li>同理，既然不写回寄存器，那么右边那个 MUX 选内存的数据还是 ALU 的数据也无所谓了。</li>
</ul>
</li>
<li><strong><code>ALUctr = add</code> &amp; <code>ALUSrc = 1</code> &amp; <code>ExtOp = 1</code></strong><ul>
<li>这三个信号和 <code>lw</code> <strong>完全一样</strong>。</li>
<li>因为不管是存还是取，<strong>“计算内存地址”</strong>这个步骤是一模一样的（都是基址 + 符号扩展偏移量）。</li>
</ul>
</li>
</ul>
<h2 id="条件转移指令的数据通路"><a href="#条件转移指令的数据通路" class="headerlink" title="条件转移指令的数据通路"></a>条件转移指令的数据通路</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251227142847129.png" alt="image-20251227142847129"></p>
<h3 id="第一部分：逻辑分析-RTL-——-CPU-是怎么“思考”的？"><a href="#第一部分：逻辑分析-RTL-——-CPU-是怎么“思考”的？" class="headerlink" title="第一部分：逻辑分析 (RTL) —— CPU 是怎么“思考”的？"></a>第一部分：逻辑分析 (RTL) —— CPU 是怎么“思考”的？</h3><p>(对应图 <code>image_2da7d8.png</code>)</p>
<p><code>beq rs, rt, imm16</code> 的核心逻辑分三步走：</p>
<ol>
<li><strong>比较 (Compare)</strong>：<ul>
<li><strong>RTL</strong>: <code>Cond &lt;- R[rs] - R[rt]</code></li>
<li><strong>原理</strong>：计算机比较两个数是否相等，最常用的办法就是<strong>做减法</strong>。</li>
<li>如果 <code>rs - rt</code> 的结果是 <strong>0</strong>，说明它们相等；否则就不相等。</li>
</ul>
</li>
<li><strong>决策 (Decision)</strong>：<ul>
<li><strong>RTL</strong>: <code>if (COND eq 0)</code></li>
<li>看刚才减法的结果。如果是 0，就跳转；如果不是 0，就忽略，继续执行下一条。</li>
</ul>
</li>
<li><strong>计算目标地址 (Target Address)</strong> —— <strong>这是最难懂的地方！</strong><ul>
<li><strong>公式</strong>: <code>PC &lt;- PC + 4 + (SignExt(imm16) x 4)</code></li>
<li><strong>为什么要 <code>PC + 4</code>？</strong>：MIPS 的分支是相对于“下一条指令”而言的。</li>
<li><strong>为什么要 <code>SignExt</code>？</strong>：因为你可能往回跳（循环），也就是立即数可能是负数，所以要符号扩展。</li>
<li><strong>为什么要 <code>x 4</code>？(红字思考题)</strong>：<ul>
<li>指令里的 <code>imm16</code> 是以 <strong>“字 (Word)”</strong> 为单位的（比如“往下跳 2 条指令”）。</li>
<li>但内存地址是以 <strong>“字节 (Byte)”</strong> 为单位的（每条指令占 4 字节）。</li>
<li>所以硬件上必须把它 <strong>左移 2 位</strong> (相当于 $\times 4$)，才能变成真实的物理地址偏移量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="第二部分：硬件连线-Data-Path-——-电路是怎么连的？"><a href="#第二部分：硬件连线-Data-Path-——-电路是怎么连的？" class="headerlink" title="第二部分：硬件连线 (Data Path) —— 电路是怎么连的？"></a>第二部分：硬件连线 (Data Path) —— 电路是怎么连的？</h3><p>(对应图 <code>image_2da7de.png</code>)</p>
<p>为了实现上面的逻辑，我们需要对电路做几个关键调整（看图中的蓝色连线）：</p>
<h4 id="1-ALU-的新用法：判零"><a href="#1-ALU-的新用法：判零" class="headerlink" title="1. ALU 的新用法：判零"></a>1. ALU 的新用法：判零</h4><ul>
<li><strong>输入</strong>：<code>busA</code> (来自 <code>rs</code>) 和 <code>busB</code> (来自 <code>rt</code>)。</li>
<li><strong>ALUSrc = 0</strong>：<strong>注意！</strong> 这里必须选 0。因为我们是比较两个<strong>寄存器</strong>，不再是寄存器和立即数运算了（区别于 <code>ori</code> 和 <code>lw</code>）。</li>
<li><strong>ALUctr = sub</strong>：让 ALU 做减法。</li>
<li><strong>输出 Zero</strong>：看 ALU 右侧那根蓝色的线 <strong><code>Zero</code></strong>。<ul>
<li>这是 ALU 的一个特殊输出端口。</li>
<li>当运算结果为 0 时，这根线变成高电平（1）。这根线就是<strong>“相等”的信号灯</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2-Next-Addr-Logic（下地址逻辑）：CPU-的方向盘"><a href="#2-Next-Addr-Logic（下地址逻辑）：CPU-的方向盘" class="headerlink" title="2. Next Addr Logic（下地址逻辑）：CPU 的方向盘"></a>2. Next Addr Logic（下地址逻辑）：CPU 的方向盘</h4><ul>
<li>图右边的那个 <strong>蓝色方框</strong> 是这一页的新增核心。</li>
<li><strong>输入</strong>：<ol>
<li><strong>PC</strong> (当前地址)</li>
<li><strong>imm16</strong> (偏移量)</li>
<li><strong>Branch</strong> (控制信号：我是分支指令！)</li>
<li><strong>Zero</strong> (状态信号：它们相等吗？)</li>
</ol>
</li>
<li><strong>逻辑</strong>：<ul>
<li>如果 <code>Branch = 1</code> <strong>且</strong> <code>Zero = 1</code>：说明是分支指令且条件满足 $\rightarrow$ <strong>跳！</strong> (PC = Target Address)。</li>
<li>否则：<strong>不跳！</strong> (PC = PC + 4)。</li>
</ul>
</li>
</ul>
<h4 id="3-控制信号-Control-Signals"><a href="#3-控制信号-Control-Signals" class="headerlink" title="3. 控制信号 (Control Signals)"></a>3. 控制信号 (Control Signals)</h4><p>看 PPT 最下方的蓝字设置，非常讲究：</p>
<ul>
<li><strong><code>RegWr = 0</code></strong>：<strong>千万别忘了这个！</strong> <code>beq</code> 只是看一眼寄存器的值做比较，<strong>不修改</strong> 任何寄存器。如果设为 1，数据就乱了。</li>
<li><strong><code>ALUSrc = 0</code></strong>：我们要比较 <code>busB</code> (寄存器)，不比较立即数。</li>
<li><strong><code>Branch = 1</code></strong>：告诉下地址逻辑，“准备好，可能要变道了”。</li>
<li><strong><code>RegDst, MemtoReg</code> = x</strong>：因为都不写寄存器，所以这些无关紧要 (Don’t Care)。</li>
</ul>
<h2 id="下址逻辑设计方案"><a href="#下址逻辑设计方案" class="headerlink" title="下址逻辑设计方案"></a>下址逻辑设计方案</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251227143858127.png" alt="image-20251227143858127"></p>
<h3 id="1-核心原理：为什么敢扔掉最后-2-位？"><a href="#1-核心原理：为什么敢扔掉最后-2-位？" class="headerlink" title="1. 核心原理：为什么敢扔掉最后 2 位？"></a>1. 核心原理：为什么敢扔掉最后 2 位？</h3><p>(对应 <code>image_2dc27e.png</code> 的中间文字)</p>
<ul>
<li><strong>规律</strong>：MIPS 指令长 32 位（4 字节）。因此，所有指令的内存地址一定是 4 的倍数（0, 4, 8, 12, …）。</li>
<li><strong>二进制特征</strong>：<ul>
<li><code>0</code> -&gt; <code>0000</code></li>
<li><code>4</code> -&gt; <code>0100</code></li>
<li><code>8</code> -&gt; <code>1000</code></li>
<li><code>12</code> -&gt; <code>1100</code></li>
</ul>
</li>
<li><strong>发现</strong>：不管怎么变，<strong>二进制的最后两位永远是 <code>00</code></strong>。</li>
<li><strong>优化思路</strong>：既然最后两位永远是 0，存在寄存器里也是浪费空间，算加法时还要多算两位。不如 <strong>PC 寄存器只存高 30 位</strong>。</li>
</ul>
<hr>
<h3 id="2-新的数学逻辑：把“米”变成“步”"><a href="#2-新的数学逻辑：把“米”变成“步”" class="headerlink" title="2. 新的数学逻辑：把“米”变成“步”"></a>2. 新的数学逻辑：把“米”变成“步”</h3><p>(对应 <code>image_2dc27e.png</code> 的蓝色公式)</p>
<p>如果我们把地址看作“步数”（Words）而不是“字节数”（Bytes）：</p>
<h4 id="A-顺序执行-PC-4-变成-PC-1"><a href="#A-顺序执行-PC-4-变成-PC-1" class="headerlink" title="A. 顺序执行 (PC + 4 变成 PC + 1)"></a>A. 顺序执行 (PC + 4 变成 PC + 1)</h4><ul>
<li><strong>旧逻辑 (32位)</strong>：$PC \leftarrow PC + 4$。<ul>
<li>(比如从 1000 跳到 1004)。</li>
</ul>
</li>
<li><strong>新逻辑 (30位)</strong>：$PC \leftarrow PC + 1$。<ul>
<li>(因为丢掉了两个 0，二进制的 100 <strong>00</strong> 变成了 100。加 1 就变成了 101，也就是原来的 101 <strong>00</strong>)。</li>
<li><strong>好处</strong>：加法器只需要加 1，电路更简单。</li>
</ul>
</li>
</ul>
<h4 id="B-分支跳转-x-4-消失了？"><a href="#B-分支跳转-x-4-消失了？" class="headerlink" title="B. 分支跳转 (x 4 消失了？)"></a>B. 分支跳转 (x 4 消失了？)</h4><ul>
<li><strong>旧逻辑</strong>：$PC + 4 + (Imm16 \times 4)$。</li>
<li><strong>新逻辑</strong>：$PC + 1 + Imm16$。<ul>
<li>还记得立即数 <code>Imm16</code> 本来存的就是“几条指令”吗？</li>
<li>以前我们需要把它 $\times 4$ 变成字节地址，再跟 32 位 PC 相加。</li>
<li>现在 PC 本身存的就是“几条指令”（30位），所以<strong>直接相加</strong>就行了！<strong>不用移位了！</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-硬件电路怎么连？-视觉解读"><a href="#3-硬件电路怎么连？-视觉解读" class="headerlink" title="3. 硬件电路怎么连？(视觉解读)"></a>3. 硬件电路怎么连？(视觉解读)</h3><p>(对应 <code>image_2dc282.png</code>)</p>
<p>请跟着图里的线走，看看这 30 位 PC 是怎么还原成 32 位地址去取指的：</p>
<ol>
<li><strong>PC 寄存器 (左上角)</strong>：<ul>
<li>你看那个 PC 盒子，旁边写着 <strong>30</strong>。它只存 30 个 bit。</li>
</ul>
</li>
<li><strong>第一个加法器 (蓝色 “Adder”)</strong>：<ul>
<li>输入是 <strong>“1”</strong>。</li>
<li>它计算 $PC + 1$，也就是下一条指令的“行号”。</li>
</ul>
</li>
<li><strong>第二个加法器 (Branch Adder)</strong>：<ul>
<li>把 $PC+1$ 的结果，加上 <code>SignExt</code> 出来的立即数。</li>
<li><strong>注意</strong>：这里没有 <code>Shift Left 2</code> 模块了！直接加。</li>
</ul>
</li>
<li><strong>最右边的拼接 (Concatenation)</strong>：<ul>
<li>这是最骚的操作。</li>
<li>我们拿着算好的 30 位地址去访问 Instruction Memory。</li>
<li><strong>Addr<31:2></31:2></strong>：来自 PC 算出来的 30 位。</li>
<li><strong>Addr<1:0></1:0></strong>：硬连线接死，就是 <strong>“00”</strong>。</li>
<li><strong>结果</strong>：30 位 + “00” = 完整的 32 位物理地址。</li>
</ul>
</li>
</ol>
<h2 id="取指令部件-Instruction-Fetch-Unit-1"><a href="#取指令部件-Instruction-Fetch-Unit-1" class="headerlink" title="取指令部件 (Instruction Fetch Unit)"></a>取指令部件 (Instruction Fetch Unit)</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251227144444179.png" alt="image-20251227144444179"></p>
<h3 id="第一步：逻辑分析-RTL-——-j-指令是怎么跳的？"><a href="#第一步：逻辑分析-RTL-——-j-指令是怎么跳的？" class="headerlink" title="第一步：逻辑分析 (RTL) —— j 指令是怎么跳的？"></a>第一步：逻辑分析 (RTL) —— <code>j</code> 指令是怎么跳的？</h3><p>(对应图 <code>image_2e277d.png</code>)</p>
<p><strong>指令格式</strong>：<code>j target</code></p>
<ul>
<li><strong>Target (26位)</strong>：指令中剩下的 26 位全部用来存目标地址。</li>
</ul>
<p>核心公式：</p>
<script type="math/tex; mode=display">PC<31:2> \leftarrow PC<31:28> \ \mathbf{concat} \ target<25:0></script><p>这个公式在做什么？</p>
<p>这是一个 “拼凑法” (Pseudo-direct Addressing)。</p>
<ol>
<li><strong>高 4 位 (<code>PC&lt;31:28&gt;</code>)</strong>：保留当前 PC 的高 4 位。这意味着 <code>j</code> 指令不能跳得太远，只能在当前 <strong>256 MB</strong> ($2^{28}$ 字节) 的区域内跳转。</li>
<li><strong>低 26 位 (<code>target&lt;25:0&gt;</code>)</strong>：直接用指令里带的 26 位地址替换掉原来的低位。</li>
<li><strong>拼接 (<code>concat</code>)</strong>：把这 4 位和 26 位拼起来，刚好组成新的 <strong>30 位</strong> PC 值。</li>
</ol>
<p>这也是个优化点！</p>
<p>在标准 32 位设计中，target 通常需要左移 2 位 ($\times 4$) 才能用。但在这里，因为我们的 PC 本身存的就是“字地址”（第几行），所以不需要移位，直接拿过来拼上去就行！</p>
<hr>
<h3 id="第二步：硬件实现-——-最终版取指部件"><a href="#第二步：硬件实现-——-最终版取指部件" class="headerlink" title="第二步：硬件实现 —— 最终版取指部件"></a>第二步：硬件实现 —— 最终版取指部件</h3><p>(对应图 <code>image_2e27ba.png</code>)</p>
<p>这张图展示了集大成者的电路。请注意图中<strong>新增的蓝色部分</strong>：</p>
<h4 id="1-拼接逻辑-Top-Blue-Oval"><a href="#1-拼接逻辑-Top-Blue-Oval" class="headerlink" title="1. 拼接逻辑 (Top Blue Oval)"></a>1. 拼接逻辑 (Top Blue Oval)</h4><ul>
<li><strong>输入 1</strong>：从 PC 寄存器引出的线，取最高 4 位 (<code>30</code>位里的高4位)。</li>
<li><strong>输入 2</strong>：从指令 (<code>Instruction Word</code>) 里直接截取的低 26 位。</li>
<li><strong>动作</strong>：这两组线在电路板上物理合并，变成一束 30 位的线。</li>
</ul>
<h4 id="2-Jump-MUX-右边的那个多路选择器"><a href="#2-Jump-MUX-右边的那个多路选择器" class="headerlink" title="2. Jump MUX (右边的那个多路选择器)"></a>2. Jump MUX (右边的那个多路选择器)</h4><p>这是 <strong>“最高优先级”</strong> 的开关。</p>
<ul>
<li><strong>位置</strong>：它放在了 Branch MUX 的后面。</li>
<li><strong>逻辑</strong>：<ul>
<li><strong>0号通道</strong>：来自前面的 Branch 逻辑（可能是 <code>PC+1</code>，也可能是 <code>beq</code> 跳转）。</li>
<li><strong>1号通道</strong>：来自刚才拼出来的 Jump 目标地址。</li>
</ul>
</li>
<li><strong>控制信号 <code>Jump</code></strong>：<ul>
<li>一旦控制器发现是 <code>j</code> 指令，把 <code>Jump</code> 设为 <strong>1</strong>。</li>
<li><strong>后果</strong>：不管前面算出了什么（比如 <code>beq</code> 想不想跳），<strong>Jump 说了算</strong>，强制把 PC 修改为跳转目标。</li>
</ul>
</li>
</ul>
<h2 id="指令与控制信号的关系表"><a href="#指令与控制信号的关系表" class="headerlink" title="指令与控制信号的关系表"></a>指令与控制信号的关系表</h2><h3 id="1-主控制信号真值表-Main-Control-Table"><a href="#1-主控制信号真值表-Main-Control-Table" class="headerlink" title="1. 主控制信号真值表 (Main Control Table)"></a>1. 主控制信号真值表 (Main Control Table)</h3><p>这是根据 <code>op</code> (操作码) 产生的控制信号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>信号名 (Signal)</strong></th>
<th><strong>R-type(add, sub)</strong></th>
<th><strong>ori</strong></th>
<th><strong>lw</strong></th>
<th><strong>sw</strong></th>
<th><strong>beq</strong></th>
<th><strong>jump</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Opcode</strong></td>
<td>000000</td>
<td>001101</td>
<td>100011</td>
<td>101011</td>
<td>000100</td>
<td>000010</td>
</tr>
<tr>
<td><strong>RegDst</strong></td>
<td><strong>1</strong> (rd)</td>
<td><strong>0</strong> (rt)</td>
<td><strong>0</strong> (rt)</td>
<td><strong>x</strong></td>
<td><strong>x</strong></td>
<td><strong>x</strong></td>
</tr>
<tr>
<td><strong>ALUSrc</strong></td>
<td><strong>0</strong> (RegB)</td>
<td><strong>1</strong> (Imm)</td>
<td><strong>1</strong> (Imm)</td>
<td><strong>1</strong> (Imm)</td>
<td><strong>0</strong> (RegB)</td>
<td><strong>x</strong></td>
</tr>
<tr>
<td><strong>MemtoReg</strong></td>
<td><strong>0</strong> (ALU)</td>
<td><strong>0</strong> (ALU)</td>
<td><strong>1</strong> (Mem)</td>
<td><strong>x</strong></td>
<td><strong>x</strong></td>
<td><strong>x</strong></td>
</tr>
<tr>
<td><strong>RegWrite</strong></td>
<td><strong>1</strong> (写)</td>
<td><strong>1</strong> (写)</td>
<td><strong>1</strong> (写)</td>
<td><strong>0</strong> (不写)</td>
<td><strong>0</strong> (不写)</td>
<td><strong>0</strong> (不写)</td>
</tr>
<tr>
<td><strong>MemWrite</strong></td>
<td><strong>0</strong> (不写)</td>
<td><strong>0</strong> (不写)</td>
<td><strong>0</strong> (不写)</td>
<td><strong>1</strong> (写)</td>
<td><strong>0</strong> (不写)</td>
<td><strong>0</strong> (不写)</td>
</tr>
<tr>
<td><strong>Branch</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong> (分支)</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>Jump</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong> (跳转)</td>
</tr>
<tr>
<td><strong>ExtOp</strong></td>
<td><strong>x</strong></td>
<td><strong>0</strong> (零扩)</td>
<td><strong>1</strong> (符扩)</td>
<td><strong>1</strong> (符扩)</td>
<td><strong>x</strong></td>
<td><strong>x</strong></td>
</tr>
<tr>
<td><strong>ALUOp</strong> (注1)</td>
<td><strong>R-Type</strong></td>
<td><strong>Or</strong></td>
<td><strong>Add</strong></td>
<td><strong>Add</strong></td>
<td><strong>Sub</strong></td>
<td><strong>xxx</strong></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>图例说明：</strong></p>
<ul>
<li><strong>1</strong>: 信号有效（如选中 MUX 的 1 号通道，或使能写入）。</li>
<li><strong>0</strong>: 信号无效（如选中 MUX 的 0 号通道，或禁止写入）。</li>
<li><strong>x (Don’t Care)</strong>: 任意值。因为在该指令下，这个信号控制的部件结果不会被使用（例如 <code>sw</code> 指令不写寄存器，所以 <code>RegDst</code> 选谁都无所谓）。</li>
</ul>
</blockquote>
<hr>
<h3 id="2-ALU-控制逻辑-ALU-Control-Logic"><a href="#2-ALU-控制逻辑-ALU-Control-Logic" class="headerlink" title="2. ALU 控制逻辑 (ALU Control Logic)"></a>2. ALU 控制逻辑 (ALU Control Logic)</h3><p>对于 R-Type 指令，ALU 具体做什么操作（加还是减），不仅取决于主控制信号，还取决于指令末尾的 <strong>func (功能码)</strong>。</p>
<p>这是 PPT <code>image_2f0f80.png</code> 底部展示的二级解码逻辑：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令类型</strong></th>
<th><strong>ALUOp (来自主控)</strong></th>
<th><strong>func (来自指令)</strong></th>
<th><strong>ALUctr (输出给ALU)</strong></th>
<th><strong>操作含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>lw / sw</strong></td>
<td>Add (000)</td>
<td>xxxxxx</td>
<td><strong>Add</strong></td>
<td>计算地址</td>
</tr>
<tr>
<td><strong>beq</strong></td>
<td>Sub (100)</td>
<td>xxxxxx</td>
<td><strong>Sub</strong></td>
<td>比较相等</td>
</tr>
<tr>
<td><strong>ori</strong></td>
<td>Or (010)</td>
<td>xxxxxx</td>
<td><strong>Or</strong></td>
<td>逻辑或</td>
</tr>
<tr>
<td><strong>R-type (add)</strong></td>
<td>R-Type (XXX)</td>
<td>100000</td>
<td><strong>Add (001)</strong></td>
<td>加法运算</td>
</tr>
<tr>
<td><strong>R-type (sub)</strong></td>
<td>R-Type (XXX)</td>
<td>100010</td>
<td><strong>Sub (101)</strong></td>
<td>减法运算</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-关键信号复习-根据表格总结"><a href="#3-关键信号复习-根据表格总结" class="headerlink" title="3. 关键信号复习 (根据表格总结)"></a>3. 关键信号复习 (根据表格总结)</h3><ul>
<li><strong>RegDst (寄存器目标)</strong>：<ul>
<li><code>1</code> (R-Type)：结果存入 <strong>rd</strong> (11-15位)。</li>
<li><code>0</code> (lw/ori)：结果存入 <strong>rt</strong> (16-20位)。</li>
</ul>
</li>
<li><strong>ALUSrc (ALU源)</strong>：<ul>
<li><code>0</code> (R-Type/beq)：ALU 第二个操作数来自 <strong>寄存器</strong>。</li>
<li><code>1</code> (lw/sw/ori)：ALU 第二个操作数来自 <strong>立即数</strong>。</li>
</ul>
</li>
<li><strong>ExtOp (扩展操作)</strong>：<ul>
<li><code>1</code> (lw/sw)：<strong>符号扩展</strong> (SignExt)，用于计算地址偏移。</li>
<li><code>0</code> (ori)：<strong>零扩展</strong> (ZeroExt)，用于逻辑运算。</li>
</ul>
</li>
<li><strong>MemtoReg (内存到寄存器)</strong>：<ul>
<li><code>1</code> (lw)：写入寄存器的数据来自 <strong>内存</strong>。</li>
<li><code>0</code> (R-Type/ori)：写入寄存器的数据来自 <strong>ALU</strong>。</li>
</ul>
</li>
</ul>
<h2 id="什么是流水线处理器"><a href="#什么是流水线处理器" class="headerlink" title="什么是流水线处理器"></a>什么是流水线处理器</h2><h3 id="核心原理：从“串行”到“并行”"><a href="#核心原理：从“串行”到“并行”" class="headerlink" title=". 核心原理：从“串行”到“并行”"></a>. 核心原理：从“串行”到“并行”</h3><p>在传统的<strong>单周期处理器</strong>中，一条指令必须彻底跑完“取指、译码、执行、访存、写回”所有环节，下一条指令才能开始。而<strong>流水线处理器</strong>将这些环节切分开：</p>
<ul>
<li><strong>并行化</strong>：当第一条指令进入“执行”阶段时，第二条指令可以同时进入“译码”阶段，第三条指令进入“取指”阶段。</li>
<li><strong>理想状态</strong>：在每个时钟周期的末尾，流水线的终点都会“吐出”一条执行完毕的指令。</li>
</ul>
<hr>
<h3 id="2-MIPS-的标准五级流水线"><a href="#2-MIPS-的标准五级流水线" class="headerlink" title="2. MIPS 的标准五级流水线"></a>2. MIPS 的标准五级流水线</h3><p>典型的 MIPS 处理器将指令处理分为 5 个标准步骤（Stage）：</p>
<ol>
<li><strong>IF (Instruction Fetch)</strong>：从指令存储器中读取指令。</li>
<li><strong>ID (Instruction Decode)</strong>：翻译指令含义，并从寄存器堆读取操作数。</li>
<li><strong>EX (Execute)</strong>：使用 ALU 进行算术/逻辑运算，或计算内存地址。</li>
<li><strong>MEM (Memory Access)</strong>：如果是 <code>lw</code> 或 <code>sw</code> 指令，则访问数据存储器。</li>
<li><strong>WB (Write Back)</strong>：将运算结果或读出的数据写回寄存器堆。</li>
</ol>
<hr>
<h3 id="3-为什么流水线更高效？"><a href="#3-为什么流水线更高效？" class="headerlink" title="3. 为什么流水线更高效？"></a>3. 为什么流水线更高效？</h3><ul>
<li><strong>缩短时钟周期</strong>：单周期的时钟频率受限于最慢的指令（如 <code>lw</code>）。流水线将长路径切成短路径，使得 CPU 可以运行在更高的频率下。</li>
<li><strong>提高吞吐率</strong>：虽然单条指令从开始到结束的时间（潜伏期）没有减少，但单位时间内完成的指令总数大大增加了。</li>
</ul>
<hr>
<h3 id="4-流水线面临的挑战：冒险（Hazards）"><a href="#4-流水线面临的挑战：冒险（Hazards）" class="headerlink" title="4. 流水线面临的挑战：冒险（Hazards）"></a>4. 流水线面临的挑战：冒险（Hazards）</h3><p>流水线虽然快，但也会带来副作用，即不同指令在流水线中“追尾”或争抢资源的情况：</p>
<ul>
<li><strong>结构冒险</strong>：多个指令同时需要同一个硬件资源（例如同时要读指令和写数据）。</li>
<li><strong>数据冒险</strong>：后面的指令需要前面指令还没算出来的结果。</li>
<li><strong>控制冒险</strong>：遇到 <code>beq</code> 或 <code>j</code> 指令时，CPU 还没确定跳不跳，后面的指令已经提前进场了。</li>
</ul>
<h2 id="指令流水线阶段汇总表"><a href="#指令流水线阶段汇总表" class="headerlink" title="指令流水线阶段汇总表"></a>指令流水线阶段汇总表</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令类型</strong></th>
<th><strong>IF (取指)</strong></th>
<th><strong>ID (译码/读寄存器)</strong></th>
<th><strong>EX (执行)</strong></th>
<th><strong>MEM (访存)</strong></th>
<th><strong>WB (写回)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Load (lw)</strong></td>
<td>取指令</td>
<td>读基址寄存器</td>
<td>计算内存地址</td>
<td><strong>读取内存数据</strong></td>
<td><strong>写回目标寄存器</strong></td>
</tr>
<tr>
<td><strong>Store (sw)</strong></td>
<td>取指令</td>
<td>读基址及源数据</td>
<td>计算内存地址</td>
<td><strong>写入数据到内存</strong></td>
<td>NOOP (空操作)</td>
</tr>
<tr>
<td><strong>R-type</strong> (add/sub)</td>
<td>取指令</td>
<td>读两个源寄存器</td>
<td><strong>算术/逻辑运算</strong></td>
<td>NOOP (空操作)</td>
<td><strong>写回运算结果</strong></td>
</tr>
<tr>
<td><strong>Beq</strong> (分支)</td>
<td>取指令</td>
<td>读两个源寄存器</td>
<td><strong>比较并算目标地址</strong></td>
<td><strong>条件成立则写PC</strong></td>
<td>NOOP (空操作)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="五阶段流水线数据通路"><a href="#五阶段流水线数据通路" class="headerlink" title="五阶段流水线数据通路"></a>五阶段流水线数据通路</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228142859241.png" alt="image-20251228142859241"></p>
<h3 id="1-核心物理组件：流水线寄存器"><a href="#1-核心物理组件：流水线寄存器" class="headerlink" title="1. 核心物理组件：流水线寄存器"></a>1. 核心物理组件：流水线寄存器</h3><p>在电路图中，你可以看到四个明显的垂直红色矩形，它们是流水线的“灵魂”：</p>
<ul>
<li><strong>IF/ID Register</strong>：位于取指与译码之间。</li>
<li><strong>ID/Ex Register</strong>：位于译码与执行之间。</li>
<li><strong>Ex/Mem Register</strong>：位于执行与访存之间。</li>
<li><strong>Mem/Wr Register</strong>：位于访存与写回之间。</li>
</ul>
<p><strong>为什么要增加这些寄存器？</strong></p>
<ul>
<li><strong>保存执行结果</strong>：用于保存每个阶段产生的中间数据（如运算结果、读取的数据、目标寄存器编号等），防止新指令进入流水线时覆盖旧指令的数据。</li>
<li><strong>透明性</strong>：它们属于内部寄存器，程序员不可见，也不需要作为程序现场保存。</li>
</ul>
<hr>
<h3 id="2-五阶段数据流向详解"><a href="#2-五阶段数据流向详解" class="headerlink" title="2. 五阶段数据流向详解"></a>2. 五阶段数据流向详解</h3><p>在每个时钟周期的上升沿，数据通过流水线寄存器同步向右“迈进”一步：</p>
<ul>
<li><strong>IF (Ifetch)</strong>：通过 <strong>IUnit</strong> 取出指令并存入 <strong>IF/ID Register</strong>，同时传递 <code>PC + 4</code> 地址。</li>
<li><strong>ID (Reg/Dec)</strong>：从 <strong>RFile</strong> 读取 <code>rs</code>、<code>rt</code> 寄存器的值（busA/busB），进行立即数扩展，并将这些值连同目标寄存器编号存入 <strong>ID/Ex Register</strong>。</li>
<li><strong>Ex (Exec)</strong>：<strong>ALU</strong> 使用来自 ID/Ex 的数据进行计算。结果连同需要存入内存的数据（busB）存入 <strong>Ex/Mem Register</strong>。</li>
<li><strong>Mem</strong>：根据 Ex/Mem 传递的地址访问 <strong>Data Mem</strong>。读取出的数据或 ALU 结果存入 <strong>Mem/Wr Register</strong>。</li>
<li><strong>Wr (WB)</strong>：数据流到最右侧，通过 Mux 选择最终要写回的数据，通过长长的绿线导回到左侧 <strong>RFile 的 RwDi 端</strong> 完成写回。</li>
</ul>
<hr>
<h3 id="3-控制信号的“接力”传输"><a href="#3-控制信号的“接力”传输" class="headerlink" title="3. 控制信号的“接力”传输"></a>3. 控制信号的“接力”传输</h3><p>在流水线中，控制信号（如 <code>RegWr</code>、<code>ALUSrc</code>、<code>MemWr</code>）不再是全局共享的，而是<strong>随指令一同移动</strong>：</p>
<ol>
<li>所有控制信号在 <strong>ID 阶段</strong> 被一次性生成。</li>
<li>信号被存入流水线寄存器中，像接力棒一样随着该指令向右传递。</li>
<li>例如，<code>MemWr</code> 信号必须等到该指令流动到 <strong>Mem 阶段</strong> 才会真正去控制数据存储器的写入。</li>
<li>最特殊的 <code>RegWr</code>（寄存器写使能）必须一路传到最后的 <strong>Mem/Wr 寄存器</strong>，才能确保在第五个周期准确控制写回操作。</li>
</ol>
<hr>
<h3 id="4-关键点：目标寄存器编号的同步"><a href="#4-关键点：目标寄存器编号的同步" class="headerlink" title="4. 关键点：目标寄存器编号的同步"></a>4. 关键点：目标寄存器编号的同步</h3><p>请特别注意 <code>image_d2b224.png</code> 下方的绿线。指令在 ID 阶段就知道要写回哪个寄存器（<code>rd</code> 或 <code>rt</code>），但这个编号必须一路通过 <strong>ID/Ex -&gt; Ex/Mem -&gt; Mem/Wr</strong> 传递，最后在 WB 阶段才作为 <code>Rw</code>（写地址）提供给寄存器堆。如果直接在 ID 阶段连线到 Rw，会导致当前在 WB 阶段的指令写错地方（写到了新进场指令的目标地址里）。</p>
<h2 id="指令部件-IUnit的设计"><a href="#指令部件-IUnit的设计" class="headerlink" title="指令部件 IUnit的设计"></a>指令部件 IUnit的设计</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228143309558.png" alt="image-20251228143309558"></p>
<h3 id="1-IUnit-的两大核心功能"><a href="#1-IUnit-的两大核心功能" class="headerlink" title="1. IUnit 的两大核心功能"></a>1. IUnit 的两大核心功能</h3><p>在每个时钟周期内，IUnit 必须自动且确定地完成以下操作：</p>
<ul>
<li><strong>读取指令 (Instr &lt;- Mem[PC])</strong>：根据程序计数器（PC）提供的地址，从指令存储器（Instruction Memory）中取出当前要执行的指令字。</li>
<li><strong>更新地址 (PC &lt;- PC + 4)</strong>：使用专门的加法器（Adder）计算当前地址加 4 的结果，为读取下一条顺序执行的指令做准备。</li>
</ul>
<h3 id="2-IUnit-内部的关键硬件组件"><a href="#2-IUnit-内部的关键硬件组件" class="headerlink" title="2. IUnit 内部的关键硬件组件"></a>2. IUnit 内部的关键硬件组件</h3><p>结合 <code>image_d3133f.png</code> 的电路连线，IUnit 主要由以下部件构成：</p>
<ul>
<li><strong>PC (Program Counter)</strong>：保存当前正在执行指令的地址（例如图中显示的 <code>PC = 16</code>）。</li>
<li><strong>Instruction Memory (指令存储器)</strong>：以 PC 的值为地址输入，输出对应的指令字（例如 <code>lw $1, 100($2)</code>）。</li>
<li><strong>Adder (加法器)</strong>：专门用于执行自增 4 操作。请注意，<code>PC + 4</code> 的值除了用于更新下一次取指地址，还会被存入流水线寄存器中，用于后续阶段计算转移目标地址。</li>
<li><strong>MUX (多路选择器)</strong>：位于 PC 输入端。其控制信号通常由其他阶段产生，用于在“顺序执行 (PC+4)”和“发生跳转 (Target Address)”之间做出选择。</li>
</ul>
<hr>
<h3 id="3-取指阶段的特殊逻辑：无需控制信号"><a href="#3-取指阶段的特殊逻辑：无需控制信号" class="headerlink" title="3. 取指阶段的特殊逻辑：无需控制信号"></a>3. 取指阶段的特殊逻辑：无需控制信号</h3><p>这是一个非常关键的设计细节：在取指阶段（Ifetch），<strong>不需要根据指令的不同来控制执行不同的操作</strong>。</p>
<ul>
<li><strong>确定性</strong>：因为无论是什么指令（add、lw 还是 beq），第一步动作都是一样的——取指并加 4。</li>
<li><strong>自动运行</strong>：该阶段的功能是预先确定的，无需控制部件介入。</li>
</ul>
<h3 id="4-数据的中转：IF-ID-流水线寄存器"><a href="#4-数据的中转：IF-ID-流水线寄存器" class="headerlink" title="4. 数据的中转：IF/ID 流水线寄存器"></a>4. 数据的中转：IF/ID 流水线寄存器</h3><p>取指完成后，IUnit 将其成果存入 <strong>IF/ID 寄存器</strong> 中：</p>
<ul>
<li><strong>存储内容</strong>：必须保存<strong>指令字</strong>（用于后续译码）和 <strong>PC + 4 的值</strong>（用于计算分支跳转地址）。</li>
<li><strong>输出时机</strong>：这些信息总是存放在流水线段寄存器中，并在下一个时钟周期到来后的 <strong>Clock-to-Q</strong> 时刻输出给译码阶段。</li>
</ul>
<h2 id="流水线中的Control-Signals如何获得"><a href="#流水线中的Control-Signals如何获得" class="headerlink" title="流水线中的Control Signals如何获得?"></a>流水线中的Control Signals如何获得?</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228145439346.png" alt="image-20251228145439346"></p>
<h3 id="1-为什么只有后三个阶段有控制信号？"><a href="#1-为什么只有后三个阶段有控制信号？" class="headerlink" title="1. 为什么只有后三个阶段有控制信号？"></a>1. 为什么只有后三个阶段有控制信号？</h3><p>观察 <code>image_d39301.png</code> 可以发现，控制信号仅存在于 <strong>Exec (执行)</strong>、<strong>Mem (访存)</strong> 和 <strong>Wr (写回)</strong> 这三个阶段。</p>
<ul>
<li><strong>Ifetch (取指)</strong> 和 <strong>Reg/Dec (译码)</strong> 阶段没有控制信号。</li>
<li><strong>原因</strong>：在这两个阶段，所有指令执行的功能完全一样（都是取指、加 4、译码、读寄存器），是确定性的操作，无需根据指令不同来控制硬件。</li>
</ul>
<h3 id="2-控制信号的“生命周期”"><a href="#2-控制信号的“生命周期”" class="headerlink" title="2. 控制信号的“生命周期”"></a>2. 控制信号的“生命周期”</h3><p>控制信号的产生与流动像流水线上的货物一样有序：</p>
<ul>
<li><strong>产生 (ID 阶段)</strong>：控制器根据从 <code>IF/ID</code> 寄存器传来的指令操作码，一次性生成该指令在后续所有阶段需要的全部信号。</li>
<li><strong>传递 (Pipeline Registers)</strong>：这些信号被锁存在流水线寄存器中，随着指令一同向右泵送。<ul>
<li><strong>Exec 阶段使用</strong>：<code>ALUSrc</code>、<code>ALUOp</code>、<code>RegDst</code> 等。</li>
<li><strong>Mem 阶段使用</strong>：<code>MemWr</code>、<code>Branch</code>。</li>
<li><strong>Wr 阶段使用</strong>：<code>RegWr</code>、<code>MemtoReg</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-以-Load-指令为例的信号路径"><a href="#3-以-Load-指令为例的信号路径" class="headerlink" title="3. 以 Load 指令为例的信号路径"></a>3. 以 Load 指令为例的信号路径</h3><p>参考 <code>image_d39301.png</code>，看 <code>lw</code> 指令如何携带信号：</p>
<ul>
<li><strong>在 Exec 段</strong>：从 <code>ID/Ex</code> 寄存器取出 <code>ALUSrc=1</code> 控制 Mux 选择立即数，取出 <code>ALUOp=Add</code> 让 ALU 算地址。</li>
<li><strong>在 Mem 段</strong>：信号跨过 <code>Ex/Mem</code> 寄存器。由于 <code>lw</code> 是读内存，<code>MemWr</code> 信号在此时应为 0。</li>
<li><strong>在 Wr 段</strong>：信号跨过 <code>Mem/Wr</code> 寄存器。此时 <code>RegWr=1</code> 有效，控制数据最终写回寄存器堆。</li>
</ul>
<h3 id="4-关键点：反向数据流与冒险"><a href="#4-关键点：反向数据流与冒险" class="headerlink" title="4. 关键点：反向数据流与冒险"></a>4. 关键点：反向数据流与冒险</h3><p>PPT 提醒我们，流水线中存在<strong>反向数据流</strong>（如 <code>Wr</code> 阶段写回寄存器堆，或 <code>Mem</code> 阶段将目标地址写回 PC）。</p>
<ul>
<li><strong>物理挑战</strong>：这种反向流动不同于洗衣流水线，它可能引起<strong>数据冒险</strong>（后面的指令需要前面还没写回的数据）或<strong>控制冒险</strong>（跳转指令改变了取指顺序）。</li>
<li><strong>解决方案</strong>：这将引出后续关于旁路前递（Forwarding）和流水线停顿（Stalling）的讨论。</li>
</ul>
<h2 id="Load指令-流水线中的控制信号"><a href="#Load指令-流水线中的控制信号" class="headerlink" title="Load指令:流水线中的控制信号"></a>Load指令:流水线中的控制信号</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228145740672.png" alt="image-20251228145740672"></p>
<h3 id="1-信号的产生：集中于-ID-阶段"><a href="#1-信号的产生：集中于-ID-阶段" class="headerlink" title="1. 信号的产生：集中于 ID 阶段"></a>1. 信号的产生：集中于 ID 阶段</h3><p>所有的控制信号都是在 <strong>取数/译码（Reg/Dec）阶段</strong> 由主控制器（Main Control）根据指令的操作码一次性产生的。</p>
<ul>
<li><strong>延迟使用</strong>：虽然信号在第 2 阶段就产生了，但 <code>Load</code> 指令在后续各个阶段（Exec, Mem, Wr）需要的操作各不相同，因此信号必须被“打包”送往后续阶段。</li>
</ul>
<h3 id="2-信号的接力传递与使用"><a href="#2-信号的接力传递与使用" class="headerlink" title="2. 信号的接力传递与使用"></a>2. 信号的接力传递与使用</h3><p>由于各阶段的操作是在不同的时钟周期完成的，控制信号必须保存在 <strong>流水线段寄存器</strong> 中，并随着指令一同向右泵送。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>所属阶段</strong></th>
<th><strong>关键控制信号</strong></th>
<th><strong>使用时机</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Exec</strong></td>
<td><code>ExtOp</code>, <code>ALUSrc</code>, <code>ALUOp</code>, <code>RegDst</code></td>
<td><strong>1 个周期后</strong>使用</td>
<td>控制 ALU 计算内存地址。例如 <code>ALUSrc=1</code> 选择立即数作为操作数。</td>
</tr>
<tr>
<td><strong>Mem</strong></td>
<td><code>MemWr</code>, <code>Branch</code></td>
<td><strong>2 个周期后</strong>使用</td>
<td>控制数据存储器的读写。对于 Load 指令，<code>MemWr=0</code>（只读）。</td>
</tr>
<tr>
<td><strong>Wr</strong></td>
<td><code>MemtoReg</code>, <code>RegWr</code></td>
<td><strong>3 个周期后</strong>使用</td>
<td>控制最后的数据回写。<code>RegWr=1</code> 开启寄存器堆写入开关。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-为什么信号也要保存在寄存器中？"><a href="#3-为什么信号也要保存在寄存器中？" class="headerlink" title="3. 为什么信号也要保存在寄存器中？"></a>3. 为什么信号也要保存在寄存器中？</h3><p>PPT 明确指出：“<strong>控制信号也要保存在流水段寄存器中！</strong>”</p>
<ul>
<li><strong>同步性</strong>：流水线中同时运行着多条指令。如果 <code>RegWr</code> 信号直接从 ID 阶段连到最后的写回端，那么当前正在 ID 阶段的指令就会错误地控制正在 WB 阶段的指令是否写回寄存器。</li>
<li><strong>逻辑一致性</strong>：通过流水线寄存器（如 ID/Ex, Ex/Mem, Mem/Wr），控制信号与它所控制的数据始终保持“同步前进”，确保每个功能部件在处理某条指令时，拿到的是属于该指令的控制指令。</li>
</ul>
<h3 id="4-关键点：1st-和-2nd-阶段为何没有信号？"><a href="#4-关键点：1st-和-2nd-阶段为何没有信号？" class="headerlink" title="4. 关键点：1st 和 2nd 阶段为何没有信号？"></a>4. 关键点：1st 和 2nd 阶段为何没有信号？</h3><p>在 <code>image_d39301.png</code> 中，我们可以看到取指（Ifetch）和译码（Reg/Dec）阶段上方没有控制信号线条。</p>
<ul>
<li><strong>原因</strong>：这两个阶段的功能对<strong>每一条指令来说都是一样的</strong>（都是取指、加 4、译码、读寄存器）。</li>
<li><strong>特征</strong>：这些操作是确定性的，不需要根据指令的不同来控制硬件执行不同的操作。</li>
</ul>
<h2 id="流水线的三种冲突-冒险（Hazard）情况"><a href="#流水线的三种冲突-冒险（Hazard）情况" class="headerlink" title="流水线的三种冲突/冒险（Hazard）情况"></a>流水线的三种冲突/冒险（Hazard）情况</h2><h3 id="1-结构冒险-Structural-Hazards"><a href="#1-结构冒险-Structural-Hazards" class="headerlink" title="1. 结构冒险 (Structural Hazards)"></a>1. 结构冒险 (Structural Hazards)</h3><p><strong>结构冒险</strong>也称为<strong>资源冲突</strong>，是指硬件资源不足，导致多条指令在同一周期内试图使用同一个物理部件。</p>
<ul>
<li><strong>典型现象</strong>：<ul>
<li>两条指令试图同时写入寄存器堆。例如，<code>Load</code>指令在第5阶段写回，而后续的<code>R-type</code>指令若在第4阶段就写回，会发生“写口”竞争。</li>
</ul>
</li>
<li><strong>解决方法</strong>：<ul>
<li><strong>规整化设计</strong>：规定每个功能部件每条指令只能使用1次，且必须在特定周期使用。例如，强制所有指令都在第5阶段（Wr）使用寄存器写口，即使是原本只需4阶段的指令也需加入“空NOP”阶段来对齐。</li>
<li><strong>增加硬件资源</strong>：设置多个独立的部件以避免冲突。如将指令存储器（IM）和数据存储器（DM）分开设计。</li>
</ul>
</li>
</ul>
<p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228154130162.png" alt="image-20251228154130162"></p>
<h3 id="2-数据冒险-Data-Hazards"><a href="#2-数据冒险-Data-Hazards" class="headerlink" title="2. 数据冒险 (Data Hazards)"></a>2. 数据冒险 (Data Hazards)</h3><p><strong>数据冒险</strong>也称为<strong>数据相关</strong>，是指后面的指令需要用到前面指令尚未产生或尚未写回的结果数据。</p>
<ul>
<li><strong>典型现象</strong>：<ul>
<li>前面的指令计算结果还没写回寄存器，后面指令就已经进入译码阶段准备读取该寄存器了。</li>
</ul>
</li>
<li><strong>解决方法</strong>：<ul>
<li><strong>转发/旁路技术 (Forwarding/Bypassing)</strong>：在结果产生后直接通过硬件连线传给需要的部件，而不必等待写回寄存器。</li>
<li><strong>流水线阻塞 (Stall)</strong>：对于某些情况（如Load-use冒险），必须停顿一个周期。</li>
<li><strong>编译器优化</strong>：通过重新排列指令顺序来减少冲突。</li>
</ul>
</li>
</ul>
<h3 id="3-控制冒险-Control-Hazards-Branch-Hazards"><a href="#3-控制冒险-Control-Hazards-Branch-Hazards" class="headerlink" title="3. 控制冒险 (Control Hazards / Branch Hazards)"></a>3. 控制冒险 (Control Hazards / Branch Hazards)</h3><p><strong>控制冒险</strong>是指由于程序流方向发生改变（如执行分支、跳转或异常），导致已经在取指阶段取出的指令变得无效。</p>
<ul>
<li><strong>典型现象</strong>：<ul>
<li>在条件分支指令（如<code>beq</code>）的目标地址确定之前，后续指令已经被取进流水线了。</li>
</ul>
</li>
<li><strong>解决方法</strong>：<ul>
<li><strong>分支预测</strong>：采用静态或动态预测技术预估分支是否跳转。</li>
<li><strong>编译器优化</strong>：利用“分支延迟槽（Branch Delay Slot）”技术，在分支指令后放置一条无论跳转与否都要执行的有用指令。</li>
</ul>
</li>
</ul>
<h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228154532023.png" alt="image-20251228154532023"></p>
<h3 id="1-什么是数据冒险？"><a href="#1-什么是数据冒险？" class="headerlink" title="1. 什么是数据冒险？"></a>1. 什么是数据冒险？</h3><p>数据冒险是指在流水线执行过程中，当后面的指令需要用到前面指令尚未产生或尚未写回的结果数据时，所引发的冲突。这种现象会导致流水线无法正常执行后续指令，进而引起阻塞或停顿。</p>
<h3 id="2-核心实例分析：寄存器-r1-的冲突"><a href="#2-核心实例分析：寄存器-r1-的冲突" class="headerlink" title="2. 核心实例分析：寄存器 r1 的冲突"></a>2. 核心实例分析：寄存器 r1 的冲突</h3><p>参考 <code>image_d4efbc.png</code> 中的指令序列，我们可以清楚地看到 <strong>RAW（写后读）</strong> 冒险是如何发生的：</p>
<ul>
<li><strong>add r1, r2, r3</strong>：这条指令的目标是将计算结果写入寄存器 <strong>r1</strong>。</li>
<li><strong>sub r4, r1, r3</strong>：紧随其后的指令需要读取 <strong>r1</strong> 的值。<ul>
<li><strong>冲突点</strong>：当 <code>sub</code> 指令在 <strong>Reg/Dec</strong> 阶段读取 r1 时，<code>add</code> 指令正处于 <strong>Exec</strong> 阶段执行加法。此时，r1 中的值还是旧的，新值尚未写回。</li>
</ul>
</li>
<li><strong>and r6, r1, r7</strong>：<ul>
<li><strong>冲突点</strong>：当 <code>and</code> 读取 r1 时，<code>add</code> 处于 <strong>Mem</strong> 阶段传递结果。此时读取的依然是旧值。</li>
</ul>
</li>
<li><strong>or r8, r1, r9</strong>：<ul>
<li><strong>冲突点</strong>：当 <code>or</code> 读取 r1 时，<code>add</code> 正处于 <strong>Wr (WB)</strong> 阶段。虽然正在写回，但在时钟前半周期读取时，拿到的往往还是旧值。</li>
</ul>
</li>
<li><strong>xor r10, r1, r11</strong>：<ul>
<li><strong>正常点</strong>：直到这条指令，<code>add</code> 已经彻底完成了写回操作，<code>xor</code> 才能读到 <strong>r1 的新值</strong>。</li>
</ul>
</li>
</ul>
<h2 id="方案1-在硬件上采取措施，使相关指令延迟执行"><a href="#方案1-在硬件上采取措施，使相关指令延迟执行" class="headerlink" title="方案1: 在硬件上采取措施，使相关指令延迟执行"></a>方案1: 在硬件上采取措施，使相关指令延迟执行</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228154832346.png" alt="image-20251228154832346"></p>
<h3 id="1-方案核心原理：插入“气泡”"><a href="#1-方案核心原理：插入“气泡”" class="headerlink" title="1. 方案核心原理：插入“气泡”"></a>1. 方案核心原理：插入“气泡”</h3><p>当硬件检测到指令间存在数据依赖（例如后续指令需要使用尚未写回的数据）时，会强制阻止后续指令继续执行，直到数据产生并写回为止。</p>
<ul>
<li><strong>流水线阻塞 (Stall)</strong>：这种做法形象地被称为插入 <strong>“气泡 (Bubble)”</strong>。</li>
<li><strong>执行逻辑</strong>：相关指令会被延迟，直到前序指令完成写回（WB）操作，新值已存入寄存器堆后，后续指令才开始取数（Reg）阶段。</li>
</ul>
<h3 id="2-实例分析：延迟三个时钟周期"><a href="#2-实例分析：延迟三个时钟周期" class="headerlink" title="2. 实例分析：延迟三个时钟周期"></a>2. 实例分析：延迟三个时钟周期</h3><p>参考 <code>image_d4f7a2.png</code> 中的时序图，我们可以看到 <code>add</code> 指令与后续 <code>sub</code> 指令的冲突处理：</p>
<ul>
<li><strong>冲突源</strong>：<code>add r1, r2, r3</code> 要在第 5 个周期（WB）才能将新值写回寄存器 <strong>r1</strong>。</li>
<li><strong>阻塞过程</strong>：<ul>
<li>为了确保 <code>sub r4, r1, r3</code> 能读到 <code>r1</code> 的新值，硬件在 <code>add</code> 执行期间强制插入了 <strong>3 个周期</strong> 的阻塞（stall）。</li>
<li>在图中，这表现为 <code>sub</code> 指令在 <code>ID/RF</code>（译码/读寄存器）阶段原地踏步，直到 <code>add</code> 指令完成红色的 <code>Reg</code> 写回操作。</li>
</ul>
</li>
<li><strong>结果</strong>：<code>sub</code> 指令最终被延迟了三个时钟周期才开始正式执行。</li>
</ul>
<h3 id="3-该方案的优缺点评价"><a href="#3-该方案的优缺点评价" class="headerlink" title="3. 该方案的优缺点评价"></a>3. 该方案的优缺点评价</h3><p>根据 PPT 的总结，虽然该方案解决了数据正确性问题，但也带来了明显的代价：</p>
<ul>
<li><strong>优点</strong>：保证了数据的绝对正确，能够处理所有类型的数据冒险。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>性能下降</strong>：指令被大幅延迟，导致流水线的整体效率（吞吐率）显著降低。</li>
<li><strong>设计复杂</strong>：控制逻辑变得非常复杂，因为需要对数据通路进行大量修改，以实现“暂停”和“等待”的功能。</li>
</ul>
</li>
</ul>
<h2 id="方案-2-软件上插入无关指令"><a href="#方案-2-软件上插入无关指令" class="headerlink" title="方案 2: 软件上插入无关指令"></a>方案 2: 软件上插入无关指令</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228155023271.png" alt="image-20251228155023271"></p>
<h3 id="1-方案核心原理：显式插入-NOP"><a href="#1-方案核心原理：显式插入-NOP" class="headerlink" title="1. 方案核心原理：显式插入 NOP"></a>1. 方案核心原理：显式插入 NOP</h3><p>当编译器检测到指令序列中存在数据依赖（例如 <code>sub</code> 指令必须等待 <code>add</code> 指令写回结果才能开始读取）时，它会在两条有冲突的指令之间强行插入若干条 <strong>NOP（空操作）指令</strong>。</p>
<ul>
<li><strong>执行逻辑</strong>：这些 NOP 指令在流水线中正常“空转”，唯一的作用就是拉开冲突指令之间的时间距离。</li>
<li><strong>目的</strong>：确保后续指令在进入译码阶段（ID/RF）时，前序指令已经完成了写回（WB）操作，从而能读到寄存器中的最新值。</li>
</ul>
<h3 id="2-实例分析：插入三条-NOP-指令"><a href="#2-实例分析：插入三条-NOP-指令" class="headerlink" title="2. 实例分析：插入三条 NOP 指令"></a>2. 实例分析：插入三条 NOP 指令</h3><p>参考 <code>image_d54dd5.png</code> 中的时序图，我们可以看到对 <code>r1</code> 寄存器冲突的处理：</p>
<ul>
<li><strong>冲突源</strong>：<code>add r1, r2, r3</code> 的结果直到第 5 个周期（WB）才会正式存入寄存器。</li>
<li><strong>软件干预</strong>：编译器在 <code>add</code> 指令之后连续插入了 <strong>三条 nop 指令</strong>。</li>
<li><strong>结果</strong>：<ul>
<li><code>sub r4, r1, r3</code> 被推后到了第 5 个周期才进入取数阶段。</li>
<li>此时，<code>add</code> 指令正好在写回（图中红色的 Reg 块），<code>sub</code> 指令能够顺利拿到 <code>r1</code> 的新值。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-方案评价：优缺点对比"><a href="#3-方案评价：优缺点对比" class="headerlink" title="3. 方案评价：优缺点对比"></a>3. 方案评价：优缺点对比</h3><p>根据 PPT 的总结，这是一种牺牲效率换取简单的做法：</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>数据通路简单</strong>：硬件不需要复杂的冲突检测逻辑或暂停机制。</li>
<li><strong>零硬件改造成本</strong>：直接在原有数据通路上运行即可。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>浪费严重</strong>：正如 PPT 所说，这“浪费三条指令的空间和时间，是<strong>最差的做法</strong>”。</li>
<li><strong>代码膨胀</strong>：生成的二进制文件会因为包含大量没意义的 NOP 而变得臃肿。</li>
</ul>
</li>
</ul>
<h2 id="方案3-同一周期内寄存器堆先写后读"><a href="#方案3-同一周期内寄存器堆先写后读" class="headerlink" title="方案3:  同一周期内寄存器堆先写后读"></a>方案3:  同一周期内寄存器堆先写后读</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228155252715.png" alt="image-20251228155252715"></p>
<h3 id="1-方案核心原理：利用时钟脉冲的边缘"><a href="#1-方案核心原理：利用时钟脉冲的边缘" class="headerlink" title="1. 方案核心原理：利用时钟脉冲的边缘"></a>1. 方案核心原理：利用时钟脉冲的边缘</h3><p>该方案的核心在于对<strong>寄存器堆（Register File）</strong>读写时序的精细控制。</p>
<ul>
<li><strong>硬件基础</strong>：寄存器堆的读口和写口是相互独立的物理部件。</li>
<li><strong>操作逻辑</strong>：在一个时钟周期内，我们将操作分为两个阶段：<ul>
<li><strong>前半周期</strong>：进行<strong>写操作</strong>。让处于写回（WB）阶段的指令将数据存入寄存器。</li>
<li><strong>后半周期</strong>：进行<strong>读操作</strong>。让处于译码（ID/RF）阶段的指令读取寄存器中的数据。</li>
</ul>
</li>
<li><strong>结果</strong>：刚写入的数据可以被立即读出，从而在同一个时钟周期内完成数据的“接力”。</li>
</ul>
<h3 id="2-实例分析：r1-寄存器的即时传递"><a href="#2-实例分析：r1-寄存器的即时传递" class="headerlink" title="2. 实例分析：r1 寄存器的即时传递"></a>2. 实例分析：<code>r1</code> 寄存器的即时传递</h3><p>参考 <code>image_d5515c.png</code> 中的时序图，观察 <code>add</code> 指令与后续指令的交互：</p>
<ul>
<li><strong>冲突点缓解</strong>：在 <strong>Cycle 5</strong> 时，<code>add r1, r2, r3</code> 正在进行 <strong>WB</strong>（图中深红色的写块）。</li>
<li><strong>即时读取</strong>：与此同时，<code>or r8, r1, r9</code> 正在进行 <strong>ID/RF</strong>（图中淡红色的读块）。</li>
<li><strong>成功匹配</strong>：由于采用了“先写后读”策略，<code>or</code> 指令在 Cycle 5 的后半部分读取时，拿到的是 <code>add</code> 在前半部分刚刚存入 <code>r1</code> 的新值。</li>
</ul>
<hr>
<h3 id="3-方案评价：局限性与价值"><a href="#3-方案评价：局限性与价值" class="headerlink" title="3. 方案评价：局限性与价值"></a>3. 方案评价：局限性与价值</h3><ul>
<li><strong>优点</strong>：不需要增加额外的复杂连线（如转发电路），也不需要插入 NOP 或阻塞，利用现有的寄存器堆结构就能解决一部分冒险。</li>
<li><strong>局限性</strong>：<ul>
<li><strong>只能解决部分冒险</strong>：正如 PPT 所言，它“<strong>只能解决部分数据冒险</strong>”。</li>
<li><strong>时间距离限制</strong>：它只能解决那些“读”和“写”刚好发生在同一周期的冲突（即指令间距为 2 的情况，如 <code>add</code> 和 <code>or</code>）。</li>
<li><strong>无法处理相邻冲突</strong>：如果 <code>sub</code> 指令紧跟在 <code>add</code> 后面（间距为 1），在 <code>sub</code> 需要读取数据时，<code>add</code> 还处于执行阶段，数据根本还没算出来，这种方案就无能为力了。</li>
</ul>
</li>
</ul>
<h2 id="方案4-利用DataPath中的中间数据：转发-阻塞"><a href="#方案4-利用DataPath中的中间数据：转发-阻塞" class="headerlink" title="方案4:  利用DataPath中的中间数据：转发+阻塞"></a>方案4:  利用DataPath中的中间数据：转发+阻塞</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228160014592.png" alt="image-20251228160014592"></p>
<h3 id="1-方案核心原理：数据“抄近路”"><a href="#1-方案核心原理：数据“抄近路”" class="headerlink" title="1. 方案核心原理：数据“抄近路”"></a>1. 方案核心原理：数据“抄近路”</h3><p>转发技术，也称为<strong>旁路（Bypassing）</strong>，其核心思想是：<strong>不等结果写回寄存器堆，直接从流水段寄存器中把数据“截胡”送给需要的部件</strong>。</p>
<ul>
<li><strong>观察点</strong>：虽然 <code>add r1, r2, r3</code> 还没把结果存入 <code>r1</code> 寄存器，但实际上计算好的值已经存在于 <strong>Ex/Mem</strong> 或 <strong>Mem/Wr</strong> 级流水段寄存器中了。</li>
<li><strong>动作</strong>：硬件通过增加专门的连线（旁路），直接把这些中间值引回到 ALU 的输入端。</li>
</ul>
<h3 id="2-实例分析：r1-的实时传递"><a href="#2-实例分析：r1-的实时传递" class="headerlink" title="2. 实例分析：r1 的实时传递"></a>2. 实例分析：<code>r1</code> 的实时传递</h3><p>参考 <code>image_d5609b.png</code> 中的时序图，我们可以看到红色箭头代表的转发路径：</p>
<ul>
<li><strong>与 <code>sub</code> 的冲突</strong>：当 <code>sub</code> 处于 <strong>EX</strong> 阶段需要 <code>r1</code> 时，<code>add</code> 刚算完结果并存放在 <strong>Ex/Mem</strong> 寄存器中。硬件直接将该值通过红色斜线传给 ALU 的输入。</li>
<li><strong>与 <code>and</code> 的冲突</strong>：当 <code>and</code> 处于 <strong>EX</strong> 阶段时，<code>add</code> 的结果已经流动到了 <strong>Mem/Wr</strong> 寄存器。硬件同样通过旁路连线将其直接喂给 <code>and</code> 指令的 ALU。</li>
<li><strong>结果</strong>：这两条原本需要停顿 3 个周期的指令，现在可以<strong>紧跟在 <code>add</code> 后面执行，无需任何停顿</strong>。</li>
</ul>
<hr>
<h3 id="3-为什么还需要“阻塞（Stall）”？"><a href="#3-为什么还需要“阻塞（Stall）”？" class="headerlink" title="3. 为什么还需要“阻塞（Stall）”？"></a>3. 为什么还需要“阻塞（Stall）”？</h3><p>虽然转发能解决大部分问题，但有一种特殊情况无法单纯靠转发解决，即 <strong>Load-use 冒险</strong>：</p>
<ul>
<li><strong>冲突点</strong>：如果前一条指令是 <code>lw r1, 0(r2)</code>，数据直到 <strong>Mem</strong> 阶段结束（即 Cycle 4 结束）才从存储器读出。</li>
<li><strong>物理限制</strong>：如果下一条指令在 Cycle 4 的 <strong>Exec</strong> 阶段就要用这个值，由于时间轴上“读出”晚于“计算”，数据无法向前穿越时间。</li>
<li><strong>对策</strong>：此时硬件必须强制插入一个 <strong>Stall（气泡）</strong>，将后续指令推后一个周期，然后再配合转发技术获取数据。</li>
</ul>
<hr>
<h3 id="4-方案评价"><a href="#4-方案评价" class="headerlink" title="4. 方案评价"></a>4. 方案评价</h3><ul>
<li><strong>优点</strong>：极大地提高了流水线的吞吐率。在大多数 R 型指令相关的冲突中，它消除了所有停顿，让 CPU 保持满速运行。</li>
<li><strong>代价</strong>：增加了硬件设计的复杂性。需要增加大量的转发多路选择器（Mux）和复杂的<strong>转发控制逻辑</strong>（用于判断当前 ALU 需要的数据是否正在流水线的后面几级中流动）。</li>
</ul>
<h2 id="硬件上的改动以支持“转发”技术"><a href="#硬件上的改动以支持“转发”技术" class="headerlink" title="硬件上的改动以支持“转发”技术"></a>硬件上的改动以支持“转发”技术</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228161825182.png" alt="image-20251228161825182"></p>
<h3 id="1-核心硬件改动：引入多级反馈路径"><a href="#1-核心硬件改动：引入多级反馈路径" class="headerlink" title="1. 核心硬件改动：引入多级反馈路径"></a>1. 核心硬件改动：引入多级反馈路径</h3><p>在 <code>image_d567fe.png</code> 中，你可以看到 ALU 的输入端增加了显著的硬件变动：</p>
<ul>
<li><strong>增加多路选择器 (MUX)</strong>：在 ALU 的两个操作数输入端，原本直接连接 ID/Ex 寄存器的地方，现在各插入了一个 <strong>3 选 1 的 MUX</strong>。</li>
<li><strong>物理连线（旁路路径）</strong>：<ul>
<li><strong>EX 阶段转发（绿线）</strong>：从 <strong>Ex/Mem 寄存器</strong> 的输出（即刚算好的 ALUout）引回一根线，连接到 ALU 输入端的 MUX。</li>
<li><strong>MEM 阶段转发（红线）</strong>：从 <strong>Mem/Wr 寄存器</strong> 的输出（即上一条指令读出的内存数据或算好的值）引回一根线，同样连接到该 MUX。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-不同冒险场景下的数据流向"><a href="#2-不同冒险场景下的数据流向" class="headerlink" title="2. 不同冒险场景下的数据流向"></a>2. 不同冒险场景下的数据流向</h3><p>根据图中提供的指令序列示例，硬件通过切换 MUX 的选择信号来实时捕获数据：</p>
<ul>
<li><strong>场景 1：R-R 型相邻指令冲突</strong><ul>
<li>指令：<code>add r3, r2, r1</code> 紧接 <code>sub r5, r3, r4</code>。</li>
<li><strong>转发逻辑</strong>：当 <code>sub</code> 在 ALU 计算时，<code>add</code> 的结果刚存入 Ex/Mem 寄存器。此时硬件切换 MUX，通过<strong>绿线</strong>将 <code>r3</code> 的新值直接喂给 ALU，解决冒险。</li>
</ul>
</li>
<li><strong>场景 2：间距为 2 的 R 型指令冲突</strong><ul>
<li>指令：<code>add r3, r2, r1</code> … <code>sub r5, r3, r4</code>。</li>
<li><strong>转发逻辑</strong>：此时 <code>add</code> 的结果已经流动到 Mem/Wr 寄存器。硬件切换 MUX，通过<strong>红线</strong>将数据传回，确保 <code>sub</code> 拿到最新值。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-特殊限制：Load-use-冒险"><a href="#3-特殊限制：Load-use-冒险" class="headerlink" title="3. 特殊限制：Load-use 冒险"></a>3. 特殊限制：Load-use 冒险</h3><p>PPT 在右侧提出了一个关键问题：<strong><code>lw r3, 100(r1)</code> 后跟 <code>or r6, r3, r1</code> 能单纯靠转发解决吗？</strong></p>
<ul>
<li><strong>物理瓶颈</strong>：<code>lw</code> 指令的数据直到 <strong>Mem 阶段结束</strong>才从数据存储器（DM）中流出。</li>
<li><strong>时间轴冲突</strong>：如果下一条指令 <code>or</code> 在同一个周期内就需要这个值进行 <strong>Exec</strong> 运算，数据在物理上还没读出来，无法“逆转时间”传回。</li>
<li><strong>结论</strong>：这种情况下，硬件必须先执行一次<strong>阻塞（Stall）\</strong>插入气泡，让 <code>or</code> 指令延后一个周期，再通过*<em>红线路径*</em>完成转发。</li>
</ul>
<h2 id="Load指令引起的延迟现象"><a href="#Load指令引起的延迟现象" class="headerlink" title="Load指令引起的延迟现象"></a>Load指令引起的延迟现象</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228161915840.png" alt="image-20251228161915840"></p>
<h3 id="1-现象分析：为什么会有延迟？"><a href="#1-现象分析：为什么会有延迟？" class="headerlink" title="1. 现象分析：为什么会有延迟？"></a>1. 现象分析：为什么会有延迟？</h3><p>Load 指令（如 <code>lw</code>）与普通的 R 型指令不同，它的数据产出时间点非常靠后：</p>
<ul>
<li><strong>数据产出时刻</strong>：Load 指令在 <strong>Mem（访存）</strong> 阶段结束时，才能从数据存储器中读出数据。</li>
<li><strong>物理限制</strong>：实际上，在第四周期结束时，流水段寄存器（Mem/Wr）中才真正拥有后续指令需要的值。</li>
<li><strong>冲突点</strong>：如果紧随其后的第一条指令（Plus 1）在自己的 <strong>Exec</strong> 阶段（即第四周期）就需要用到这个值进行计算，此时数据尚未从存储器读出，<strong>转发技术也无法“逆转时间”将还没产生的数据传回去</strong>。</li>
</ul>
<h3 id="2-转发技术能解决什么？"><a href="#2-转发技术能解决什么？" class="headerlink" title="2. 转发技术能解决什么？"></a>2. 转发技术能解决什么？</h3><p>通过 <code>image_d5cd56.png</code> 的时序图可以看到转发技术的局限与作用：</p>
<ul>
<li><strong>能解决的</strong>：转发技术可以使 Load 指令后面 <strong>第二条指令</strong>（Plus 2）得到所需的值。<ul>
<li>图中蓝色的实线箭头显示：Load 产生的数据在第四周期结束时就位，正好可以转发给处于第五周期 Exec 阶段的 Plus 2 指令。</li>
</ul>
</li>
<li><strong>不能解决的</strong>：它<strong>不能解决</strong> Load 指令与随后的<strong>第一条指令</strong>（Plus 1）之间的数据冒险。<ul>
<li>图中红色的虚线箭头表示一个物理上不可能实现的请求：数据在第四周期末才出来，不可能传给在第四周期初就开始工作的 Plus 1。</li>
</ul>
</li>
</ul>
<h3 id="3-核心定义：装入-使用数据冒险"><a href="#3-核心定义：装入-使用数据冒险" class="headerlink" title="3. 核心定义：装入-使用数据冒险"></a>3. 核心定义：装入-使用数据冒险</h3><p>这种 Load 指令与其紧跟的指令之间因数据生产滞后而产生的冲突，被称为 <strong>“装入-使用数据冒险 (Load-use Data Hazard)”</strong>。</p>
<h3 id="4-最终对策：延迟执行"><a href="#4-最终对策：延迟执行" class="headerlink" title="4. 最终对策：延迟执行"></a>4. 最终对策：延迟执行</h3><p>为了保证程序的正确性，硬件或软件必须采取补救措施：</p>
<ul>
<li><strong>硬件阻塞 (Stall)</strong>：硬件会自动插入一个周期的“气泡”，将 Plus 1 指令及其后续指令全部推迟一个周期执行。</li>
<li><strong>编译器优化</strong>：编译器可以通过调整指令顺序，在 Load 指令后插入一条无关指令，从而利用这个间隙消除延迟。</li>
</ul>
<h2 id="流水线处理器的五个阶段"><a href="#流水线处理器的五个阶段" class="headerlink" title="流水线处理器的五个阶段"></a>流水线处理器的五个阶段</h2><h3 id="1-五阶段流水线详解"><a href="#1-五阶段流水线详解" class="headerlink" title="1. 五阶段流水线详解"></a>1. 五阶段流水线详解</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>阶段缩写</strong></th>
<th><strong>全称</strong></th>
<th><strong>核心任务</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IF</strong></td>
<td><strong>Ifetch (取指)</strong></td>
<td>根据 PC 地址从指令存储器中读取指令，并计算 <code>PC+4</code>。</td>
</tr>
<tr>
<td><strong>ID</strong></td>
<td><strong>Reg/Dec (译码)</strong></td>
<td>翻译指令含义，同时从寄存器堆（RFile）中读取操作数 <code>rs</code> 和 <code>rt</code> 的值。</td>
</tr>
<tr>
<td><strong>EX</strong></td>
<td><strong>Exec (执行)</strong></td>
<td>使用 ALU 进行运算。对于 <code>Load/Store</code> 计算内存地址；对于 R 型指令执行算术逻辑运算。</td>
</tr>
<tr>
<td><strong>MEM</strong></td>
<td><strong>Mem (访存)</strong></td>
<td>如果是 <code>Load</code> 则从内存读数据；如果是 <code>Store</code> 则往内存写数据。非访存指令此阶段仅传递结果。</td>
</tr>
<tr>
<td><strong>WB</strong></td>
<td><strong>Wr (写回)</strong></td>
<td>将最终结果（来自 ALU 或内存）写回到目标寄存器中，正式更新 CPU 状态。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="2-深度解析：EX-MEM-这种斜杠名称是什么意思？"><a href="#2-深度解析：EX-MEM-这种斜杠名称是什么意思？" class="headerlink" title="2. 深度解析：EX/MEM 这种斜杠名称是什么意思？"></a>2. 深度解析：EX/MEM 这种斜杠名称是什么意思？</h3><p>你提到的 <strong>EX/MEM</strong>（以及 IF/ID, ID/EX, MEM/WB）并不是一个阶段，而是<strong>流水线寄存器（Pipeline Register）</strong>。</p>
<ul>
<li><strong>命名逻辑</strong>：它的名称代表它位于哪两个阶段<strong>之间</strong>。例如，<strong>EX/MEM</strong> 就位于 <strong>执行(EX)</strong> 和 <strong>访存(MEM)</strong> 阶段的交界处。</li>
<li><strong>物理本质</strong>：它是一组触发器，用于锁存（保存）前一个阶段产生的成果。</li>
<li><strong>具体到 EX/MEM 的作用</strong>：<ul>
<li><strong>保存结果</strong>：它保存了 EX 阶段 ALU 刚刚算出来的地址或运算结果。</li>
<li><strong>传递控制信号</strong>：它还保存了这条指令在后续 MEM 级（如 <code>MemWr</code>）和 WB 级（如 <code>RegWr</code>）所需要的控制信号。</li>
<li><strong>隔离保护</strong>：它确保当 EX 阶段开始处理下一条新指令时，当前指令算出的结果已经安全地存在 EX/MEM 里，供 MEM 阶段慢慢使用。</li>
</ul>
</li>
</ul>
<h2 id="一、-转发路径总结-Forwarding-Paths"><a href="#一、-转发路径总结-Forwarding-Paths" class="headerlink" title="一、 转发路径总结 (Forwarding Paths)"></a>一、 转发路径总结 (Forwarding Paths)</h2><p>转发技术通过在硬件中增加多路选择器（MUX）和反馈连线，使 ALU 能够直接从流水线后级寄存器中获取尚未写回的数据。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>路径名称</strong></th>
<th><strong>数据来源</strong></th>
<th><strong>数据去向</strong></th>
<th><strong>解决的冲突类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EX 级转发 (C1)</strong></td>
<td><strong>EX/MEM</strong> 流水线寄存器</td>
<td>ALU 的输入端 MUX</td>
<td><strong>相邻指令</strong>间的 RAW 冒险（如 <code>add</code> 紧跟 <code>sub</code>）</td>
</tr>
<tr>
<td><strong>MEM 级转发 (C2)</strong></td>
<td><strong>MEM/WB</strong> 流水线寄存器</td>
<td>ALU 的输入端 MUX</td>
<td><strong>间隔一条指令</strong>间的 RAW 冒险</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="二、-转发条件总结-Forwarding-Conditions"><a href="#二、-转发条件总结-Forwarding-Conditions" class="headerlink" title="二、 转发条件总结 (Forwarding Conditions)"></a>二、 转发条件总结 (Forwarding Conditions)</h2><p>为了确保转发的准确性，硬件判定逻辑必须满足“三看”：一看写使能，二看 Rd 是否为 0，三看寄存器编号匹配。</p>
<h3 id="1-EX-级转发条件-相邻指令"><a href="#1-EX-级转发条件-相邻指令" class="headerlink" title="1. EX 级转发条件 (相邻指令)"></a>1. EX 级转发条件 (相邻指令)</h3><p>当满足以下条件时，开启从 <code>EX/MEM</code> 到当前指令 <code>EX</code> 阶段的转发：</p>
<ul>
<li><strong>C1(a) 转发 Rs：</strong> <code>EX/MEM.RegWr</code> <strong>and</strong> <code>EX/MEM.RegisterRd != 0</code> <strong>and</strong> <code>EX/MEM.RegisterRd == ID/EX.RegisterRs</code></li>
<li><strong>C1(b) 转发 Rt：</strong> <code>EX/MEM.RegWr</code> <strong>and</strong> <code>EX/MEM.RegisterRd != 0</code> <strong>and</strong> <code>EX/MEM.RegisterRd == ID/EX.RegisterRt</code></li>
</ul>
<h3 id="2-MEM-级转发条件-间隔指令-优先级修正"><a href="#2-MEM-级转发条件-间隔指令-优先级修正" class="headerlink" title="2. MEM 级转发条件 (间隔指令 + 优先级修正)"></a>2. MEM 级转发条件 (间隔指令 + 优先级修正)</h3><p>为了处理如 <code>image_dfe02b.png</code> 中连续多条指令写同一个寄存器的复杂情况，必须保证<strong>“最新数据优先”</strong>。因此，只有在 EX 级不需要转发时，才考虑 MEM 级转发。</p>
<p>以 <strong>Rs</strong> 为例，完善后的 <strong>C2(a)</strong> 条件为：</p>
<ol>
<li><strong>基础匹配：</strong> <code>MEM/WB.RegWr</code> <strong>and</strong> <code>MEM/WB.RegisterRd != 0</code> <strong>and</strong> <code>MEM/WB.RegisterRd == ID/EX.RegisterRs</code></li>
<li><strong>优先级限制（关键）：</strong> <strong><code>and NOT (EX/MEM.RegWr == 1 and EX/MEM.RegisterRd != 0 and EX/MEM.RegisterRd == ID/EX.RegisterRs)</code></strong></li>
</ol>
<hr>
<h2 id="三、-转发技术的特殊限制"><a href="#三、-转发技术的特殊限制" class="headerlink" title="三、 转发技术的特殊限制"></a>三、 转发技术的特殊限制</h2><p>即使拥有完善的转发逻辑，仍有两种情况需要注意：</p>
<ol>
<li><strong>Load-use 冒险：</strong> 当 <code>lw</code> 指令紧跟一条需要该数据的指令时，由于数据在物理上直到 MEM 阶段结束才产生，无法直接转发，<strong>必须配合阻塞（Stall）一个周期</strong>。</li>
<li><strong>无需写回的指令：</strong> 如 <code>beq</code> 或 <code>sw</code>，由于其 <code>RegWr</code> 信号为 0，即便寄存器编号匹配也不会触发转发。</li>
</ol>
<h2 id="Load-use-Data-Hazard（硬件阻塞方式）"><a href="#Load-use-Data-Hazard（硬件阻塞方式）" class="headerlink" title="Load-use Data Hazard（硬件阻塞方式）"></a>Load-use Data Hazard（硬件阻塞方式）</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228171523618.png" alt="image-20251228171523618"></p>
<h3 id="1-为什么-Load-use-必须阻塞？"><a href="#1-为什么-Load-use-必须阻塞？" class="headerlink" title="1. 为什么 Load-use 必须阻塞？"></a>1. 为什么 Load-use 必须阻塞？</h3><p>在 MIPS 五级流水线中，<code>lw</code> 指令产出的数据非常晚。</p>
<ul>
<li><strong>数据就绪点</strong>：<code>lw</code> 指令直到 <strong>Mem（访存）</strong> 阶段结束（即第四时钟周期末）才拿到内存数据。</li>
<li><strong>数据使用点</strong>：紧随其后的指令（如 <code>sub</code>）在自己的 <strong>Exec（执行）</strong> 阶段（即第四周期初）就需要数据进行 ALU 运算。</li>
<li><strong>物理瓶颈</strong>：由于使用点早于生产点，即便有转发技术也无法“逆转时间”完成数据传递。因此，硬件必须介入，强制将后续指令推后一个周期。</li>
</ul>
<h3 id="2-硬件如何检测阻塞？"><a href="#2-硬件如何检测阻塞？" class="headerlink" title="2. 硬件如何检测阻塞？"></a>2. 硬件如何检测阻塞？</h3><p>硬件中有一个专门的 <strong>“冒险检测单元”</strong>。它在 <strong>ID（译码）</strong> 阶段通过以下逻辑判断是否需要阻塞：</p>
<ul>
<li><strong>判定条件：</strong><ol>
<li><strong>上一条指令是 Load</strong>：即 <code>ID/EX.MemRead == 1</code>。</li>
<li><strong>目标寄存器冲突</strong>：上一条 Load 的目的寄存器（<code>ID/EX.RegisterRt</code>）等于当前正在译码指令的源寄存器（<code>IF/ID.RegisterRs</code> 或 <code>IF/ID.RegisterRt</code>）。</li>
</ol>
</li>
</ul>
<h3 id="3-阻塞的具体实现动作"><a href="#3-阻塞的具体实现动作" class="headerlink" title="3. 阻塞的具体实现动作"></a>3. 阻塞的具体实现动作</h3><p>一旦检测到 Load-use 冒险，硬件会执行以下三步操作来制造一个“气泡（Bubble）”：</p>
<ol>
<li><strong>插入气泡 (清除 ID/EX 寄存器)</strong>： 将 <code>ID/EX</code> 段寄存器中所有的控制信号清零（相当于执行了一条 <code>nop</code> 指令）。这样，原本该进入执行阶段的指令就不会对寄存器或内存产生任何修改。</li>
<li><strong>冻结 IF/ID 寄存器</strong>： 保持 <code>IF/ID</code> 寄存器中的信息不变。这意味着当前被阻塞的指令（如 <code>sub</code>）会被留在译码阶段，并在下一个周期重新译码执行。</li>
<li><strong>冻结 PC 寄存器</strong>： 保持 PC 的值不变。这确保了再下一条指令（如 <code>and</code>）在下一个周期会被重新取出，而不会因为 PC 增加而跳过。</li>
</ol>
<h2 id="方案5：编译器进行指令顺序调整来解决数据冒险"><a href="#方案5：编译器进行指令顺序调整来解决数据冒险" class="headerlink" title="方案5：编译器进行指令顺序调整来解决数据冒险"></a>方案5：编译器进行指令顺序调整来解决数据冒险</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228181938973.png" alt="image-20251228181938973"></p>
<h3 id="1-为什么需要编译器优化？"><a href="#1-为什么需要编译器优化？" class="headerlink" title="1. 为什么需要编译器优化？"></a>1. 为什么需要编译器优化？</h3><p>虽然硬件可以自动阻塞（Stall），但阻塞意味着 CPU 在“原地踏步”，会白白浪费时钟周期。</p>
<ul>
<li><strong>硬件方案</strong>：发现冲突 -&gt; 停顿 1 周期 -&gt; 总耗时变长。</li>
<li><strong>编译器方案</strong>：调整顺序 -&gt; 消除冲突 -&gt; <strong>0 停顿</strong>，满速运行。</li>
</ul>
<h3 id="2-实战演练：从-Slow-Code-到-Fast-Code"><a href="#2-实战演练：从-Slow-Code-到-Fast-Code" class="headerlink" title="2. 实战演练：从 Slow Code 到 Fast Code"></a>2. 实战演练：从 Slow Code 到 Fast Code</h3><p>参考 <code>image_e126bb</code> 中的代码逻辑：</p>
<blockquote>
<p>目标计算：<code>a = b + c;</code> 和 <code>d = e - f;</code></p>
</blockquote>
<h4 id="❌-优化前-Slow-Code-：频繁阻塞"><a href="#❌-优化前-Slow-Code-：频繁阻塞" class="headerlink" title="❌ 优化前 (Slow Code)：频繁阻塞"></a>❌ 优化前 (Slow Code)：频繁阻塞</h4><p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lw  $2, b</span><br><span class="line">lw  $3, c      &lt;-- 紧接着要用 $3</span><br><span class="line">add $1, $2, $3 &lt;-- [冒险!] 必须在这里阻塞 1 周期</span><br><span class="line">sw  $1, a</span><br><span class="line">lw  $5, e</span><br><span class="line">lw  $6, f      &lt;-- 紧接着要用 $6</span><br><span class="line">sub $4, $5, $6 &lt;-- [冒险!] 必须再次阻塞 1 周期</span><br><span class="line">sw  $4, d</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：这段代码会触发两次硬件阻塞，总共浪费 2 个周期。</p>
<h4 id="✅-优化后-Fast-Code-：无缝衔接"><a href="#✅-优化后-Fast-Code-：无缝衔接" class="headerlink" title="✅ 优化后 (Fast Code)：无缝衔接"></a>✅ 优化后 (Fast Code)：无缝衔接</h4><p>编译器通过观察发现，<code>a=b+c</code> 和 <code>d=e-f</code> 是互不干涉的两组运算。它将指令重新排序：</p>
<p>MIPS Assembler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lw  $2, b</span><br><span class="line">lw  $3, c</span><br><span class="line">lw  $5, e      # [巧妙插入] 在等待 c 加载时，先去加载 e</span><br><span class="line">add $1, $2, $3 # [冒险消除!] 此时 c 早已加载完毕，直接计算</span><br><span class="line">lw  $6, f      # [巧妙插入] 在等待 e 加载时，先去加载 f</span><br><span class="line">sw  $1, a      # [无关指令] 进一步拉开 lw $6 和 sub 的距离</span><br><span class="line">sub $4, $5, $6 # [冒险消除!] 此时 f 也加载好了，直接计算</span><br><span class="line">sw  $4, d</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：调整后，Load 指令和它对应的运算指令之间都被“拉开了距离”。通过这种方式，<strong>硬件不再需要任何阻塞，CPU 始终保持满载</strong>。</p>
<hr>
<h3 id="3-编译器优化的“底层逻辑”"><a href="#3-编译器优化的“底层逻辑”" class="headerlink" title="3. 编译器优化的“底层逻辑”"></a>3. 编译器优化的“底层逻辑”</h3><p>我们可以用 ASCII 时序图看看这个“拉开距离”的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优化前 (有阻塞):</span><br><span class="line">lw $3:  [IF][ID][EX][MEM][WB]</span><br><span class="line">add:        [IF][ID]----[ID][EX]  &lt;-- 被迫停顿 (Stall)</span><br><span class="line"></span><br><span class="line">优化后 (无阻塞):</span><br><span class="line">lw $3:  [IF][ID][EX][MEM][WB]</span><br><span class="line">lw $5:      [IF][ID][EX][MEM][WB] &lt;-- 利用这个周期干别的活</span><br><span class="line">add:            [IF][ID][EX][MEM][WB] &lt;-- 等到这里用 $3 时，数据早已出炉！</span><br></pre></td></tr></table></figure>
<h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p><img src="/2025/09/08/college/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20251228182258608.png" alt="image-20251228182258608"></p>
<h3 id="1-什么是控制冒险？"><a href="#1-什么是控制冒险？" class="headerlink" title="1. 什么是控制冒险？"></a>1. 什么是控制冒险？</h3><p>控制冒险，也称为<strong>分支冒险</strong>。它的核心矛盾在于：<strong>处理器在还没确定下一条指令该去哪取的时候，就已经开始取指了</strong>。</p>
<p>在 MIPS 五级流水线中，以 <code>Beq</code>（相等则转移）指令为例：</p>
<ul>
<li><strong>判定延迟</strong>：指令是否转移是在 <strong>Mem（访存）</strong> 阶段确定的。</li>
<li><strong>结果</strong>：如图 <code>image_e2f459</code> 所示，当 <code>Beq</code> 到达第七周期确定跳转地址并送往 PC 时，流水线已经默认按顺序取出了后面 <strong>3 条</strong> 错误的指令。</li>
<li><strong>代价</strong>：如果发生转移，这 3 条已经进入流水线的指令必须被<strong>清除（Flush）</strong>，这导致了 <strong>3 个时钟周期的延迟损失（C=3）</strong>。</li>
</ul>
<hr>
<h3 id="2-解决控制冒险的-4-种方法"><a href="#2-解决控制冒险的-4-种方法" class="headerlink" title="2. 解决控制冒险的 4 种方法"></a>2. 解决控制冒险的 4 种方法</h3><p>针对这种性能损失，PPT 提出了四种主要的解决方案：</p>
<h4 id="方法-1：硬件阻塞（Stall）"><a href="#方法-1：硬件阻塞（Stall）" class="headerlink" title="方法 1：硬件阻塞（Stall）"></a>方法 1：硬件阻塞（Stall）</h4><ul>
<li><strong>做法</strong>：一旦检测到分支指令，强行让流水线停顿，直到分支结果确定。</li>
<li><strong>缺点</strong>：每遇到分支就插入 3 条 NOP 指令，效率极低。</li>
</ul>
<h4 id="方法-2：软件插入-NOP"><a href="#方法-2：软件插入-NOP" class="headerlink" title="方法 2：软件插入 NOP"></a>方法 2：软件插入 NOP</h4><ul>
<li><strong>做法</strong>：由编译器在分支指令后手动加入三条无关的 <code>NOP</code> 指令。</li>
<li><strong>评价</strong>：与硬件阻塞类似，虽然保证了正确性，但浪费了大量周期。</li>
</ul>
<h4 id="方法-3：分支预测（Branch-Prediction）"><a href="#方法-3：分支预测（Branch-Prediction）" class="headerlink" title="方法 3：分支预测（Branch Prediction）"></a>方法 3：分支预测（Branch Prediction）</h4><p>这是现代处理器最常用的高效手段：</p>
<ul>
<li><strong>静态预测</strong>：总是预测“不发生转移”（继续执行后续指令）。如果预测错了，再清空流水线重新开始。</li>
<li><strong>动态预测</strong>：根据程序执行的历史记录（如循环统计）实时调整预测策略，准确率可高达 <strong>90%</strong>。</li>
</ul>
<h4 id="方法-4：延迟分支（Delayed-Branch）"><a href="#方法-4：延迟分支（Delayed-Branch）" class="headerlink" title="方法 4：延迟分支（Delayed Branch）"></a>方法 4：延迟分支（Delayed Branch）</h4><ul>
<li><strong>做法</strong>：编译器寻找一条与分支无关的指令，将其移动到分支指令之后执行。</li>
<li><strong>效果</strong>：无论分支是否成功，这条处于“延迟槽”中的指令都会执行，从而利用了原本会被浪费掉的一个时钟周期。</li>
</ul>
<h2 id="简单（静态）分支预测方法"><a href="#简单（静态）分支预测方法" class="headerlink" title="简单（静态）分支预测方法"></a>简单（静态）分支预测方法</h2><h3 id="1-静态预测的主要策略：总是预测“不发生”（Predict-Not-Taken）"><a href="#1-静态预测的主要策略：总是预测“不发生”（Predict-Not-Taken）" class="headerlink" title="1. 静态预测的主要策略：总是预测“不发生”（Predict Not Taken）"></a>1. 静态预测的主要策略：总是预测“不发生”（Predict Not Taken）</h3><p>这是 MIPS 流水线中最常用、最简单的静态预测方法。</p>
<ul>
<li><strong>做法</strong>：当流水线遇到一条分支指令（如 <code>beq</code>）时，硬件<strong>默认认为分支不会跳转</strong>，于是继续按照 <code>PC+4</code> 的地址去取下一条指令。</li>
<li><strong>预测成功</strong>：如果 <code>beq</code> 的条件真的不成立（不跳转），流水线就完美地避开了停顿，实现<strong>零延迟</strong>。</li>
<li><strong>预测失败</strong>：如果 <code>beq</code> 的条件成立（需要跳转），那么之前已经取进来的指令就是错误的，必须被<strong>清空（Flush）</strong>。</li>
</ul>
<hr>
<h3 id="2-预测失败时的“清空”过程（ASCII-时序图）"><a href="#2-预测失败时的“清空”过程（ASCII-时序图）" class="headerlink" title="2. 预测失败时的“清空”过程（ASCII 时序图）"></a>2. 预测失败时的“清空”过程（ASCII 时序图）</h3><p>假设 <code>beq</code> 发生了跳转，但我们预测它“不跳转”：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">周期：     C1    C2    C3    C4    C5</span><br><span class="line">beq:     [IF]  [ID]  [EX]  [MEM]      &lt;-- 在MEM阶段发现：wc！预测错了，要跳转</span><br><span class="line">instr+1:       [IF]  [ID]  [EX]  [清空] &lt;-- 错误取到的指令，必须作废(变气泡)</span><br><span class="line">instr+2:             [IF]  [ID]  [清空] &lt;-- 错误取到的指令，作废</span><br><span class="line">instr+3:                   [IF]  [清空] &lt;-- 错误取到的指令，作废</span><br><span class="line">target:                          [IF]   &lt;-- 第5周期才真正取到正确的目标指令</span><br></pre></td></tr></table></figure>
<p><strong>代价</strong>：在基础流水线中，预测失败会造成 <strong>3 个时钟周期</strong> 的损失。</p>
<hr>
<h3 id="3-如何优化预测失败的代价？"><a href="#3-如何优化预测失败的代价？" class="headerlink" title="3. 如何优化预测失败的代价？"></a>3. 如何优化预测失败的代价？</h3><p>正如 <code>image_e2f8f9.png</code> 所提到的，为了让静态预测更划算，硬件会把“分支判定”的时机<strong>提前到 ID 阶段</strong>。</p>
<ul>
<li><strong>硬件改动</strong>：在 ID 阶段增加专门的比较器和加法器。</li>
<li><strong>优化后的效果</strong>：<ul>
<li>预测失败只需清空 <strong>1 条</strong> 指令（即正在 IF 阶段的那条）。</li>
<li><strong>代价</strong>：损失从 3 周期降到了 <strong>1 周期</strong>。</li>
</ul>
</li>
</ul>
<h2 id="动态分支预测方法"><a href="#动态分支预测方法" class="headerlink" title="动态分支预测方法"></a>动态分支预测方法</h2><p>动态分支预测的核心思想是：<strong>利用分支指令最近的执行历史，来预测下一次是否会发生转移</strong>。它不像静态预测那样死板，而是会根据程序的实际运行情况动态调整预测结果。</p>
<hr>
<h3 id="1-核心组件：分支历史表-BHT"><a href="#1-核心组件：分支历史表-BHT" class="headerlink" title="1. 核心组件：分支历史表 (BHT)"></a>1. 核心组件：分支历史表 (BHT)</h3><p>动态预测主要依靠一个特殊的硬件结构——<strong>BHT (Branch History Table)</strong>，也常被称为 <strong>BPB (Branch Prediction Buffer)</strong>。</p>
<ul>
<li><strong>工作流程</strong>：<ol>
<li><strong>查找</strong>：在 <strong>IF (取指)</strong> 阶段，利用分支指令地址的低位作为索引去查找 BHT。</li>
<li><strong>预测</strong>：从表中读出“预测位”，决定是“跳转取指”还是“顺序取指”。</li>
<li><strong>修正</strong>：指令实际执行完后，将真实的跳转结果反馈给 BHT，更新该表项的预测位。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-预测算法：从-1-位到-2-位"><a href="#2-预测算法：从-1-位到-2-位" class="headerlink" title="2. 预测算法：从 1 位到 2 位"></a>2. 预测算法：从 1 位到 2 位</h3><h4 id="A-1-位预测位-1-bit-Predictor"><a href="#A-1-位预测位-1-bit-Predictor" class="headerlink" title="A. 1 位预测位 (1-bit Predictor)"></a>A. 1 位预测位 (1-bit Predictor)</h4><ul>
<li><strong>逻辑</strong>：总是按上一次实际发生的情况来预测下一次。<ul>
<li>1 表示最近一次发生了转移，下次预测跳转 (taken)。</li>
<li>0 表示最近一次没发生转移，下次预测顺序执行 (not taken)。</li>
</ul>
</li>
<li><strong>缺点</strong>：在循环边界（第一次和最后一次）会产生两次连续的预测错误，因为循环的状态改变得太快，1 位逻辑反应不过来。</li>
</ul>
<h4 id="B-2-位预测位-2-bit-Predictor-——主流方案"><a href="#B-2-位预测位-2-bit-Predictor-——主流方案" class="headerlink" title="B. 2 位预测位 (2-bit Predictor)——主流方案"></a>B. 2 位预测位 (2-bit Predictor)——主流方案</h4><p>为了提高准确率，现代处理器（如 Pentium 4）多采用 2 位或更多位的预测位。</p>
<ul>
<li><strong>逻辑</strong>：用 2 位组合四种情况来表示预测状态（如“强跳转”、“弱跳转”、“弱不跳转”、“强不跳转”）。</li>
<li><strong>优点</strong>：只有在<strong>连续两次</strong>分支情况改变时，才会改变预测方向。这使得它在处理循环时，只会产生一次预测错误。</li>
</ul>
<h2 id="一位动态预测"><a href="#一位动态预测" class="headerlink" title="一位动态预测"></a>一位动态预测</h2><h3 id="1-一位预测的核心逻辑：惯性思维"><a href="#1-一位预测的核心逻辑：惯性思维" class="headerlink" title="1. 一位预测的核心逻辑：惯性思维"></a>1. 一位预测的核心逻辑：惯性思维</h3><p>一位预测器的核心思想是：<strong>“上次发生什么，这次就猜什么”</strong>。它只有两个状态，由 1 位二进制数表示：</p>
<ul>
<li><strong>状态 1（预测发生/Taken）</strong>：如果上次分支跳转了，状态变为 1。下次遇到该指令，默认选择“跳转取指”。</li>
<li><strong>状态 0（预测不发生/Not Taken）</strong>：如果上次分支没跳转，状态变为 0。下次遇到该指令，默认选择“顺序取指”。</li>
</ul>
<hr>
<h3 id="2-状态转换图详解"><a href="#2-状态转换图详解" class="headerlink" title="2. 状态转换图详解"></a>2. 状态转换图详解</h3><p>结合 <code>image_e3705c.png</code> 中的圆圈和箭头，我们可以看到状态是如何随着实际执行结果而“反转”的：</p>
<ul>
<li><strong>预测正确时</strong>：状态保持不变。例如，当前在“状态 1”，实际执行结果也是“发生”，则继续留在“状态 1”。</li>
<li><strong>预测错误时</strong>：状态发生反转。<ul>
<li>如果在“状态 1”但实际“不发生”，状态立刻切换到 0。</li>
<li>如果在“状态 0”但实际“发生”，状态立刻切换到 1。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-致命弱点：循环边界的“连错两次”"><a href="#3-致命弱点：循环边界的“连错两次”" class="headerlink" title="3. 致命弱点：循环边界的“连错两次”"></a>3. 致命弱点：循环边界的“连错两次”</h3><p>一位预测器最典型的局限性体现在循环程序中。假设有一个执行了 10 次的循环：</p>
<ul>
<li><strong>退出循环时（第 10 次）</strong>：之前一直是跳转的（状态 1），但最后一次不再跳转。此时预测器<strong>猜错第一次</strong>，并把状态改为 0。</li>
<li><strong>再次进入循环时（下一次外层迭代）</strong>：因为状态变成了 0，它会预测“不跳转”。但实际上循环的第一步通常是要跳转的。此时预测器<strong>又猜错第二次</strong>，再把状态改回 1。</li>
</ul>
<p><strong>结论</strong>：只要本次执行和上次的情况不同，就会出现一次预测错误。在嵌套循环中，内层循环每结束一次，都会导致下一次进入时多错一次。</p>
<hr>
<h3 id="4-实例计算：双重循环的准确率"><a href="#4-实例计算：双重循环的准确率" class="headerlink" title="4. 实例计算：双重循环的准确率"></a>4. 实例计算：双重循环的准确率</h3><p>参考 <code>image_e37076.png</code> 的例子：</p>
<ul>
<li><strong>外循环执行 $N$ 次，内循环执行 $N$ 次</strong>。</li>
<li><strong>预测错误总数</strong>：$1 + 2 \times (N-1)$ 次。<ul>
<li>第一次内循环结束错 1 次。</li>
<li>后面每次重新进入内循环（第一步）错 1 次，结束时又错 1 次。</li>
</ul>
</li>
<li><strong>趋势</strong>：当 $N=10$ 时，准确率约 <strong>90.9%</strong>；当 $N=100$ 时，准确率提高到 <strong>99%</strong>。这意味着 <strong>$N$ 越大，预测准确率越高</strong>，因为中间正确预测的次数显著增多。</li>
</ul>
<h2 id="两位动态预测"><a href="#两位动态预测" class="headerlink" title="两位动态预测"></a>两位动态预测</h2><h3 id="1-两位预测状态机-2-bit-State-Machine"><a href="#1-两位预测状态机-2-bit-State-Machine" class="headerlink" title="1. 两位预测状态机 (2-bit State Machine)"></a>1. 两位预测状态机 (2-bit State Machine)</h3><p>结合 <code>image_e37fa0.png</code>，两位预测器由四个状态组成，可以看作是一个有“缓冲带”的决策系统：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>含义</strong></th>
<th><strong>预测动作</strong></th>
<th><strong>容错性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>11</strong></td>
<td><strong>强预测发生</strong> (Strongly Taken)</td>
<td>预测跳转</td>
<td>错一次后降级为 10，但下次依然猜跳转。</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td><strong>弱预测发生</strong> (Weakly Taken)</td>
<td>预测跳转</td>
<td>再错一次才彻底放弃，转为 01。</td>
</tr>
<tr>
<td><strong>01</strong></td>
<td><strong>弱预测不发生</strong> (Weakly Not Taken)</td>
<td>预测顺序</td>
<td>再错一次（即实际发生）才转为 10。</td>
</tr>
<tr>
<td><strong>00</strong></td>
<td><strong>强预测不发生</strong> (Strongly Not Taken)</td>
<td>预测顺序</td>
<td>错一次后升温为 01，下次依然猜顺序。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="2-为什么它比一位预测更强？"><a href="#2-为什么它比一位预测更强？" class="headerlink" title="2. 为什么它比一位预测更强？"></a>2. 为什么它比一位预测更强？</h3><p>它的绝活在于处理<strong>循环边界</strong>。我们用 ASCII 时序图来对比它们处理同一个循环（循环 10 次）的表现：</p>
<ul>
<li><strong>一位预测器</strong>：<ul>
<li><strong>退出循环时</strong>：猜错第 1 次，状态变 0。</li>
<li><strong>下次进入循环时</strong>：根据状态 0 猜不跳，结果跳了，<strong>猜错第 2 次</strong>。</li>
</ul>
</li>
<li><strong>两位预测器 (初始为 11)</strong>：<ul>
<li><strong>退出循环时</strong>：猜错第 1 次，状态从 11 降级到 <strong>10</strong>（弱预测发生）。</li>
<li><strong>下次进入循环时</strong>：由于状态是 10，它<strong>依然预测“跳转”</strong>。结果真的跳了，<strong>预测正确！</strong> 状态升回 11。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：两位预测器成功地通过“缓冲状态”过滤掉了循环结束时的那次偶然失误，保证了下次进入循环时的首跳准确。</p>
<hr>
<h3 id="3-实例计算：双重循环的准确率"><a href="#3-实例计算：双重循环的准确率" class="headerlink" title="3. 实例计算：双重循环的准确率"></a>3. 实例计算：双重循环的准确率</h3><ul>
<li>内循环每次结束都会预测错误，一共有n次，外循环结束还有一次，一共是n+1次</li>
</ul>
<h2 id="分支延迟时间片的调度"><a href="#分支延迟时间片的调度" class="headerlink" title="分支延迟时间片的调度"></a>分支延迟时间片的调度</h2><p>根据您提供的资料（特别是 <code>image_edec08.png</code>），我为您详细讲解<strong>分支延迟时间片的调度</strong>。</p>
<p>这是一种通过<strong>编译器</strong>重排指令顺序来消除控制冒险的静态调度技术。</p>
<hr>
<h3 id="1-核心概念：分支延迟槽-Branch-Delay-Slot"><a href="#1-核心概念：分支延迟槽-Branch-Delay-Slot" class="headerlink" title="1. 核心概念：分支延迟槽 (Branch Delay Slot)"></a>1. 核心概念：分支延迟槽 (Branch Delay Slot)</h3><p>在流水线中，分支指令确定跳转方向和目标地址需要时间。在结果确定之前，流水线已经取出的指令位置被称为<strong>分支延迟时间片</strong>（或<strong>分支延迟槽</strong>）。</p>
<ul>
<li><strong>基本思想</strong>：与其在延迟槽中插入浪费周期的 <code>nop</code>，不如让编译器找一条在分支指令之前、且与分支结果无关的指令，将其移动到分支指令<strong>后面</strong>执行。</li>
<li><strong>特性</strong>：处于延迟槽中的指令，<strong>无论分支是否发生转移，都一定会被执行</strong>。</li>
</ul>
<hr>
<h3 id="2-实例解析：如何进行调度"><a href="#2-实例解析：如何进行调度" class="headerlink" title="2. 实例解析：如何进行调度"></a>2. 实例解析：如何进行调度</h3><p>参考 <code>image_edec08.png</code> 中的代码优化过程：</p>
<h4 id="优化前（有浪费）："><a href="#优化前（有浪费）：" class="headerlink" title="优化前（有浪费）："></a><strong>优化前（有浪费）：</strong></h4><p>原本的代码顺序如下，假设分支判定提前到了 ID 阶段，延迟时间片为 1：</p>
<p>MIPS Assembler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lw  $1, 0($2)</span><br><span class="line">lw  $3, 0($2)</span><br><span class="line">add $6, $4, $2</span><br><span class="line">beq $3, $5, 2  # 分支指令</span><br><span class="line">nop            # 延迟槽：如果不调度，这里必须放一个空操作</span><br><span class="line">add $3, $3, $2</span><br><span class="line">sw  $1, 0($2)</span><br></pre></td></tr></table></figure>
<h4 id="优化后（满速运行）："><a href="#优化后（满速运行）：" class="headerlink" title="优化后（满速运行）："></a><strong>优化后（满速运行）：</strong></h4><p>编译器发现 <code>lw $1, 0($2)</code> 这条指令与分支指令 <code>beq $3, $5, 2</code> 完全无关，因此将其“挪”到了分支指令之后：</p>
<p>MIPS Assembler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lw  $3, 0($2)</span><br><span class="line">add $6, $4, $2</span><br><span class="line">beq $3, $5, 2  # 分支指令</span><br><span class="line">lw  $1, 0($2)  # 【调度后】这条指令填补了延迟槽，不再需要 nop！</span><br><span class="line">add $3, $3, $2</span><br><span class="line">sw  $1, 0($2)</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：原本会浪费的一个时钟周期被有效指令填满，流水线效率大幅提升。</p>
<h2 id="异常（Exception）和中断（Interrupt）"><a href="#异常（Exception）和中断（Interrupt）" class="headerlink" title="异常（Exception）和中断（Interrupt）"></a>异常（Exception）和中断（Interrupt）</h2><p>异常（Exception）和中断（Interrupt）是另一种形式的<strong>控制冒险</strong>，因为它们会改变程序的正常执行流程。</p>
<hr>
<h3 id="1-异常的发生与检测"><a href="#1-异常的发生与检测" class="headerlink" title="1. 异常的发生与检测"></a>1. 异常的发生与检测</h3><p>当流水线中的某条指令发现异常时（例如 ALU 指令发现“溢出”），后面的多条指令可能已经进入流水线并在执行中。</p>
<ul>
<li><strong>实例</strong>：指令 <code>add r1, r2, r3</code> 产生溢出。</li>
<li><strong>检测点</strong>：溢出通常在 <strong>EXE（执行）阶段</strong> 被检测出来。此时，该指令后面的两条指令已经分别进入了 ID 和 IF 阶段。</li>
</ul>
<hr>
<h3 id="2-流水线处理异常的步骤"><a href="#2-流水线处理异常的步骤" class="headerlink" title="2. 流水线处理异常的步骤"></a>2. 流水线处理异常的步骤</h3><p>为了保证程序的正确性，硬件必须确保发生异常的指令及其后续指令不会对寄存器或内存造成永久性修改。</p>
<ol>
<li><strong>清除指令 (Flush)</strong>：<ul>
<li><strong>EX.Flush</strong>：将 EXE 阶段指令的控制信号清 0（特别是 <code>RegWr</code>），避免将错误的溢出结果写回寄存器。</li>
<li><strong>ID.Flush</strong>：将 IF/ID 寄存器中的指令清 0，转变为 <code>nop</code> 指令。</li>
<li><strong>IF.Flush</strong>：清除正在取指阶段的指令。</li>
</ul>
</li>
<li><strong>关中断</strong>：将中断允许触发器清 0。</li>
<li><strong>保存断点</strong>：将当前的 PC 或 PC-4 保存到 <strong>EPC</strong> (Exception Program Counter) 寄存器中，以便之后能返回执行。</li>
<li><strong>跳转到处理程序</strong>：将 MIPS 异常处理程序的首地址 <strong>0x8000 0180</strong> 送入 PC，从该地址开始取指执行。</li>
</ol>
<hr>
<h3 id="3-处理过程图解-ASCII"><a href="#3-处理过程图解-ASCII" class="headerlink" title="3. 处理过程图解 (ASCII)"></a>3. 处理过程图解 (ASCII)</h3><p>当 <code>add</code> 指令在 EXE 阶段报错时，流水线会瞬间插入多个“气泡（bubble）”：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">周期：     C1    C2    C3(报错!)   C4        C5</span><br><span class="line">add:     [IF]  [ID]  [EXE] ----&gt; [bubble]  [bubble] (防止写回r1)</span><br><span class="line">sub:           [IF]  [ID]  ----&gt; [bubble]  [bubble] (被冲刷)</span><br><span class="line">and:                 [IF]  ----&gt; [bubble]  [bubble] (被冲刷)</span><br><span class="line">Handler:                         [0x8000 0180]      (异常处理开始)</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11b1UBoEGF/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">「小白debug」如何用开关造出一台计算机_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/" class="post-title-link" itemprop="url">milvus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-08T00:00:00+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-20 19:28:13" itemprop="dateModified" datetime="2025-09-20T19:28:13+08:00">2025-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/" itemprop="url" rel="index"><span itemprop="name">python-web</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-web/milvus/" itemprop="url" rel="index"><span itemprop="name">milvus</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="为什么使用milvus"><a href="#为什么使用milvus" class="headerlink" title="为什么使用milvus"></a>为什么使用milvus</h3><p>非结构化数据（如文本、图像和音频）格式各异，蕴含丰富的潜在语义，因此分析起来极具挑战性。为了处理这种复杂性，Embeddings 被用来将非结构化数据转换成能够捕捉其基本特征的数字向量。然后将这些向量存储在向量数据库中，从而实现快速、可扩展的搜索和分析。</p>
<p>Milvus 提供强大的数据建模功能，使您能够将非结构化或多模式数据组织成结构化的 Collections。它支持多种数据类型，适用于不同的属性模型，包括常见的数字和字符类型、各种向量类型、数组、集合和 JSON，为您节省了维护多个数据库系统的精力。</p>
<p><img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908091053654.png" alt="image-20250908091053654"></p>
<h3 id="部署（windows）"><a href="#部署（windows）" class="headerlink" title="部署（windows）"></a>部署（windows）</h3><p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/install_standalone-windows.md">在 Docker（Linux）中运行 Milvus | Milvus 文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Download the configuration file and rename it as docker-compose.yml</span><br><span class="line">C:\&gt;Invoke-WebRequest https://github.com/milvus-io/milvus/releases/download/v2.6.0/milvus-standalone-docker-compose.yml -OutFile docker-compose.yml</span><br><span class="line"></span><br><span class="line"># Start Milvus</span><br><span class="line">C:\&gt;docker compose up -d</span><br></pre></td></tr></table></figure>
<p>注意设置环境变量DOCKER_VOLUME_DIRECTORY来决定卷映射的路径</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>镜像</th>
<th>在 Milvus 中的角色</th>
<th>一句话说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd</td>
<td>quay.io/coreos/etcd:v3.5.18</td>
<td>元数据与协调中心</td>
<td>负责“记帐”——存索引结构、集合信息、节点心跳等，相当于 Milvus 的“大脑备忘录”。</td>
</tr>
<tr>
<td>minio</td>
<td>minio/minio:RELEASE.2024-12-18T13-15-44Z</td>
<td>对象存储</td>
<td>负责“存文件”——把向量索引文件、大字段、日志快照等落地成对象，相当于 Milvus 的“硬盘”。</td>
</tr>
<tr>
<td>standalone</td>
<td>milvusdb/milvus:v2.6.0</td>
<td>计算节点（单机版）</td>
<td>负责“干活”——接受 SDK 请求、做向量检索、构建索引，相当于 Milvus 的“工人”。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pymilvus</span><br></pre></td></tr></table></figure>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>在 Milvus 中，数据库是组织和管理数据的逻辑单元。为了提高数据安全性并实现多租户，你可以创建多个数据库，为不同的应用程序或租户从逻辑上隔离数据。例如，创建一个数据库用于存储用户 A 的数据，另一个数据库用于存储用户 B 的数据。</p>
<h4 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h4><p>在 Milvus 上，您可以创建多个 Collections 来管理数据，并将数据作为实体插入到 Collections 中。Collections 和实体<strong>类似于关系数据库中的表和记录</strong>。</p>
<p>Collection 是一个二维表，具有固定的列和变化的行。每列代表一个字段，每行代表一个实体。</p>
<p>下图显示了一个有 8 列和 6 个实体的 Collection。</p>
<p><img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908094418551.png" alt="image-20250908094418551"></p>
<h4 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h4><p>Schema 定义了 Collections 的数据结构。在创建一个 Collection 之前，你需要设计出它的 Schema。</p>
<p>设计良好的 Schema 至关重要，因为它抽象了数据模型，并决定能否通过搜索实现业务目标。此外，由于插入 Collections 的每一行数据都必须遵循 Schema，因此有助于保持数据的一致性和长期质量。从技术角度看，定义明确的 Schema 会带来组织良好的列数据存储和更简洁的索引结构，从而提升搜索性能。</p>
<p>一个 Collection Schema 有一个主键、最多四个向量字段和几个标量字段。下图说明了如何将文章映射到模式字段列表。</p>
<p><img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908094645183.png" alt="image-20250908094645183"></p>
<h3 id="与langchain集成"><a href="#与langchain集成" class="headerlink" title="与langchain集成"></a>与langchain集成</h3><p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/vectorstores/milvus/#query-directly">Milvus | 🦜️🔗 LangChain</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/integrate_with_langchain.md">使用 Milvus 和 LangChain 的检索增强生成（RAG） | Milvus 文档</a></p>
<p>本人实现的用于分块后存储入milvus的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">class MilvusStorage:</span><br><span class="line">    &quot;&quot;&quot;Milvus向量存储管理类</span><br><span class="line">    </span><br><span class="line">    负责将分块后的文档内容存储到Milvus向量数据库中，</span><br><span class="line">    支持向量检索和BM25全文检索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    def __init__(self, </span><br><span class="line">                 embedding_function: Embeddings,</span><br><span class="line">                 uri: Optional[str] = None, </span><br><span class="line">                 db_name: Optional[str] = None,</span><br><span class="line">                 token: Optional[str] = None,</span><br><span class="line">                 collection_name: Optional[str] = None):</span><br><span class="line">        &quot;&quot;&quot;初始化Milvus存储客户端</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            embedding_function: LangChain embedding模型实例（必需）</span><br><span class="line">            uri: Milvus服务地址，默认从环境变量MILVUS_URI获取</span><br><span class="line">            db_name: 数据库名称，默认从环境变量MILVUS_DB_NAME获取</span><br><span class="line">            token: 认证令牌，默认从环境变量MILVUS_TOKEN获取（可选）</span><br><span class="line">            collection_name: 集合名称，默认从环境变量MILVUS_COLLECTION_NAME获取</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 验证必需参数</span><br><span class="line">        if not embedding_function:</span><br><span class="line">            raise ValueError(&quot;embedding_function是必需参数，必须提供LangChain Embeddings实例&quot;)</span><br><span class="line">        </span><br><span class="line">        # 从环境变量读取配置，如果参数没有提供的话</span><br><span class="line">        self.uri = uri or os.getenv(&#x27;MILVUS_URI&#x27;, &#x27;http://localhost:19530&#x27;)</span><br><span class="line">        self.db_name = db_name or os.getenv(&#x27;MILVUS_DB_NAME&#x27;, &#x27;rag&#x27;)</span><br><span class="line">        self.token = token or os.getenv(&#x27;MILVUS_TOKEN&#x27;) or None</span><br><span class="line">        self.collection_name = collection_name or os.getenv(&#x27;MILVUS_COLLECTION_NAME&#x27;, &#x27;chunks&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 设置embedding函数</span><br><span class="line">        self.embedding_function = embedding_function</span><br><span class="line">        </span><br><span class="line">        # 初始化LangChain Milvus向量存储</span><br><span class="line">        self.vector_store = Milvus(</span><br><span class="line">            embedding_function=self.embedding_function,</span><br><span class="line">            connection_args=&#123;</span><br><span class="line">                &quot;uri&quot;: self.uri,</span><br><span class="line">                &quot;db_name&quot;: self.db_name,</span><br><span class="line">                &quot;token&quot;: self.token</span><br><span class="line">            &#125; if self.token else &#123;</span><br><span class="line">                &quot;uri&quot;: self.uri,</span><br><span class="line">                &quot;db_name&quot;: self.db_name</span><br><span class="line">            &#125;,</span><br><span class="line">            collection_name=self.collection_name,</span><br><span class="line">            index_params=&#123;&quot;index_type&quot;: &quot;HNSW&quot;, &quot;metric_type&quot;: &quot;COSINE&quot;, &quot;params&quot;: &#123;&quot;M&quot;: 16, &quot;efConstruction&quot;: 200&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    def store_chunks(self, chunk_result: ChunkResult) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;存储分块结果到Milvus</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_result: 分块结果对象</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 插入结果，包含插入状态和记录数</span><br><span class="line">            </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当向量存储未初始化时</span><br><span class="line">            Exception: Milvus操作异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not self.vector_store:</span><br><span class="line">            raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">        </span><br><span class="line">        if not chunk_result.chunks:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;, </span><br><span class="line">                &quot;inserted_count&quot;: 0,</span><br><span class="line">                &quot;message&quot;: &quot;无数据需要插入&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            # 转换为LangChain Document格式</span><br><span class="line">            documents = self._convert_chunks_to_langchain_docs(chunk_result)</span><br><span class="line">            </span><br><span class="line">            # 为每个文档生成UUID作为主键</span><br><span class="line">            from uuid import uuid4</span><br><span class="line">            uuids = [str(uuid4()) for _ in range(len(documents))]</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus添加文档，指定IDs</span><br><span class="line">            ids = self.vector_store.add_documents(documents=documents, ids=uuids)</span><br><span class="line">            </span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;inserted_count&quot;: len(documents),</span><br><span class="line">                &quot;document_ids&quot;: ids,</span><br><span class="line">                &quot;document_name&quot;: chunk_result.document_name,</span><br><span class="line">                &quot;strategy&quot;: chunk_result.strategy.value,</span><br><span class="line">                &quot;collection_name&quot;: self.collection_name</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            raise Exception(f&quot;Milvus插入失败: &#123;str(e)&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def _convert_chunks_to_langchain_docs(self, chunk_result: ChunkResult) -&gt; List[Document]:</span><br><span class="line">        &quot;&quot;&quot;为现有Documents添加存储所需的元数据</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_result: 分块结果，chunks已经是Document列表</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            List[Document]: 添加了元数据的Document列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        documents = []</span><br><span class="line">        </span><br><span class="line">        for idx, chunk in enumerate(chunk_result.chunks):</span><br><span class="line">            # 创建符合Milvus集合schema的元数据</span><br><span class="line">            # 注意：page_content会自动映射到text_content字段</span><br><span class="line">            updated_metadata = &#123;</span><br><span class="line">                **chunk.metadata,  # 保留原有元数据</span><br><span class="line">                &quot;document_name&quot;: chunk_result.document_name,</span><br><span class="line">                &quot;chunk_index&quot;: idx,</span><br><span class="line">                &quot;chunk_size&quot;: len(chunk.page_content)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            # 创建新Document以避免修改原始数据</span><br><span class="line">            # LangChain会自动将page_content映射到Milvus的text_content字段</span><br><span class="line">            # embedding字段会由embedding_function自动生成</span><br><span class="line">            doc = Document(</span><br><span class="line">                page_content=chunk.page_content,</span><br><span class="line">                metadata=updated_metadata</span><br><span class="line">            )</span><br><span class="line">            documents.append(doc)</span><br><span class="line">        </span><br><span class="line">        return documents</span><br><span class="line">    </span><br><span class="line">    def store_chunks_batch(self, chunk_results: List[ChunkResult]) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;批量存储多个分块结果到Milvus</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            chunk_results: 分块结果列表</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 批量插入结果</span><br><span class="line">            </span><br><span class="line">        Raises:</span><br><span class="line">            ValueError: 当向量存储未初始化时</span><br><span class="line">            Exception: Milvus操作异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not self.vector_store:</span><br><span class="line">            raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">        </span><br><span class="line">        if not chunk_results:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;没有分块结果需要存储&quot;,</span><br><span class="line">                &quot;total_chunks&quot;: 0,</span><br><span class="line">                &quot;document_count&quot;: 0</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            # 收集所有文档</span><br><span class="line">            all_documents = []</span><br><span class="line">            total_chunks = 0</span><br><span class="line">            </span><br><span class="line">            for chunk_result in chunk_results:</span><br><span class="line">                if chunk_result.chunks:</span><br><span class="line">                    documents = self._convert_chunks_to_langchain_docs(chunk_result)</span><br><span class="line">                    all_documents.extend(documents)</span><br><span class="line">                    total_chunks += len(documents)</span><br><span class="line">            </span><br><span class="line">            if not all_documents:</span><br><span class="line">                return &#123;</span><br><span class="line">                    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                    &quot;message&quot;: &quot;没有文档需要存储&quot;,</span><br><span class="line">                    &quot;total_chunks&quot;: 0,</span><br><span class="line">                    &quot;document_count&quot;: len(chunk_results)</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            # 为所有文档生成UUID作为主键</span><br><span class="line">            from uuid import uuid4</span><br><span class="line">            uuids = [str(uuid4()) for _ in range(len(all_documents))]</span><br><span class="line">            </span><br><span class="line">            # 批量添加所有文档，指定IDs</span><br><span class="line">            ids = self.vector_store.add_documents(documents=all_documents, ids=uuids)</span><br><span class="line">            </span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;message&quot;: f&quot;成功存储 &#123;len(chunk_results)&#125; 个文档的 &#123;total_chunks&#125; 个分块&quot;,</span><br><span class="line">                &quot;total_chunks&quot;: total_chunks,</span><br><span class="line">                &quot;document_count&quot;: len(chunk_results),</span><br><span class="line">                &quot;ids&quot;: ids,</span><br><span class="line">                &quot;collection_name&quot;: self.collection_name</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            raise Exception(f&quot;Milvus批量插入失败: &#123;str(e)&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def delete_document(self, </span><br><span class="line">                       document_name: str, </span><br><span class="line">                       collection_name: Optional[str] = None) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;删除指定文档的所有chunks</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            document_name: 文档名称</span><br><span class="line">            collection_name: collection名称</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 删除结果</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        target_collection = collection_name or self.collection_name</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not self.vector_store:</span><br><span class="line">                raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus删除功能</span><br><span class="line">            # 注意：LangChain Milvus可能不支持按元数据过滤删除，这里提供基本实现</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;,</span><br><span class="line">                &quot;document_name&quot;: document_name,</span><br><span class="line">                &quot;error&quot;: &quot;LangChain Milvus不支持按文档名删除，请使用其他方式&quot;,</span><br><span class="line">                &quot;collection_name&quot;: target_collection</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        except Exception as e:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;, </span><br><span class="line">                &quot;document_name&quot;: document_name,</span><br><span class="line">                &quot;error&quot;: str(e)</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    def get_document_stats(self, </span><br><span class="line">                          document_name: Optional[str] = None,</span><br><span class="line">                          collection_name: Optional[str] = None) -&gt; Dict[str, Any]:</span><br><span class="line">        &quot;&quot;&quot;获取文档统计信息</span><br><span class="line">        </span><br><span class="line">        Args:</span><br><span class="line">            document_name: 文档名称，None则统计所有文档</span><br><span class="line">            collection_name: collection名称</span><br><span class="line">            </span><br><span class="line">        Returns:</span><br><span class="line">            Dict: 统计信息</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        target_collection = collection_name or self.collection_name</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not self.vector_store:</span><br><span class="line">                raise ValueError(&quot;向量存储未初始化&quot;)</span><br><span class="line">            </span><br><span class="line">            # 使用LangChain Milvus获取基本信息</span><br><span class="line">            # 注意：LangChain Milvus没有直接的统计方法，这里提供基本信息</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">                &quot;collection_name&quot;: target_collection,</span><br><span class="line">                &quot;vector_store_type&quot;: &quot;LangChain Milvus&quot;,</span><br><span class="line">                &quot;embedding_function&quot;: str(type(self.embedding_function).__name__),</span><br><span class="line">                &quot;connection_uri&quot;: self.uri,</span><br><span class="line">                &quot;database_name&quot;: self.db_name,</span><br><span class="line">                &quot;message&quot;: &quot;详细统计信息需要通过其他方式获取&quot;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        except Exception as e:</span><br><span class="line">            return &#123;</span><br><span class="line">                &quot;status&quot;: &quot;error&quot;,</span><br><span class="line">                &quot;error&quot;: str(e)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本ANN搜索"><a href="#基本ANN搜索" class="headerlink" title="基本ANN搜索"></a>基本ANN搜索</h3><p>近似近邻（ANN）搜索以记录向量嵌入排序顺序的索引文件为基础，根据接收到的搜索请求中携带的查询向量查找向量嵌入子集，将查询向量与子群中的向量进行比较，并返回最相似的结果。</p>
<p>ANN 和 k-Nearest Neighbors (kNN) 搜索是向量相似性搜索的常用方法。在 kNN 搜索中，必须将向量空间中的所有向量与搜索请求中携带的查询向量进行比较，然后找出最相似的向量，这既耗时又耗费资源。</p>
<p>与 kNN 搜索不同，ANN 搜索算法要求提供一个<strong>索引</strong>文件，记录向量 Embeddings 的排序顺序。当收到搜索请求时，可以使用索引文件作为参考，快速找到可能包含与查询向量最相似的向量嵌入的子组。然后，你可以使用指定的<strong>度量类型</strong>来测量查询向量与子组中的向量之间的相似度，根据与查询向量的相似度对组成员进行排序，并找出<strong>前 K 个</strong>组成员。</p>
<p>ANN 搜索依赖于预建索引，搜索吞吐量、内存使用量和搜索正确性可能会因选择的索引类型而不同。您需要在搜索性能和正确性之间取得平衡。</p>
<h3 id="混合检索"><a href="#混合检索" class="headerlink" title="混合检索"></a>混合检索</h3><p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multi-vector-search.md">多向量混合搜索 | Milvus 文档</a></p>
<p><img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092720695.png" alt="image-20250908092720695"></p>
<p>让我们考虑一个真实世界的使用案例，其中每个产品都包含文字描述和图片。根据可用数据，我们可以进行三种类型的搜索：</p>
<ul>
<li><strong>语义文本搜索：</strong>这涉及使用密集向量查询产品的文本描述。可以使用<a target="_blank" rel="noopener" href="https://zilliz.com/learn/explore-colbert-token-level-embedding-and-ranking-model-for-similarity-search?_gl=1*d243m9*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#A-Quick-Recap-of-BERT">BERT</a>和<a target="_blank" rel="noopener" href="https://zilliz.com/learn/NLP-essentials-understanding-transformers-in-AI?_gl=1*d243m9*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">Transformers</a>等模型或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/guide-to-using-openai-text-embedding-models?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">OpenAI</a> 等服务生成文本嵌入。</li>
<li><strong>全文搜索</strong>：在这里，我们使用稀疏向量的关键词匹配来查询产品的文本描述。<a target="_blank" rel="noopener" href="https://zilliz.com/learn/mastering-bm25-a-deep-dive-into-the-algorithm-and-application-in-milvus?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879">BM25</a>等算法或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings?_gl=1*1cde1oq*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#BGE-M3">BGE-M3</a>或<a target="_blank" rel="noopener" href="https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings?_gl=1*ov2die*_gcl_au*MjcyNTAwMzUyLjE3NDMxMzE1MjY.*_ga*MTQ3OTI4MDc5My4xNzQzMTMxNTI2*_ga_KKMVYG8YF2*MTc0NTkwODU0Mi45NC4xLjE3NDU5MDg4MzcuMC4wLjA.&amp;__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879#SPLADE">SPLADE</a>等稀疏嵌入模型可用于此目的。</li>
<li><strong>多模态图像搜索：</strong>这种方法使用带有密集向量的文本查询对图像进行查询。可以使用<a target="_blank" rel="noopener" href="https://zilliz.com/learn/exploring-openai-clip-the-future-of-multimodal-ai-learning?__hstc=175614333.1360fa4d62338b70e9a0f2412f87e2d8.1757161116448.1757218172494.1757289528471.4&amp;__hssc=175614333.2.1757289528471&amp;__hsfp=990823879&amp;_gl=1*90lcis*_gcl_au*MTI2OTI1Njc4OS4xNzU3MTYxMTEz*_ga*NTMyMTM0NTIwLjE3NTcxNjExMTM.*_ga_KKMVYG8YF2*czE3NTcyOTM4NzUkbzUkZzEkdDE3NTcyOTQ4MTMkajYwJGwwJGgw">CLIP</a> 等模型生成图像嵌入。</li>
</ul>
<p>混合检索的构建流程：</p>
<ol>
<li><p>创建具有多个向量场的 Collections</p>
<ul>
<li>定义 Collections Schema</li>
<li>配置索引参数</li>
<li>创建 Collections</li>
</ul>
</li>
<li><p>插入数据‘</p>
</li>
<li><p>执行混合搜索</p>
<ul>
<li><p>创建多个 AnnSearchRequest 实例</p>
<p>混合搜索是通过在<code>hybrid_search()</code> 函数中创建多个<code>AnnSearchRequest</code> 来实现的，其中每个<code>AnnSearchRequest</code> 代表一个特定向量场的基本 ANN 搜索请求。因此，在进行混合搜索之前，有必要为每个向量场创建一个<code>AnnSearchRequest</code> 。</p>
</li>
<li><p>配置 Rerankers 策略</p>
</li>
</ul>
</li>
</ol>
<h3 id="Rerankers-策略"><a href="#Rerankers-策略" class="headerlink" title="Rerankers 策略"></a>Rerankers 策略</h3><p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/rrf-ranker.md">RRF 排序器 | Milvus 文档</a></p>
<p>要对 ANN 搜索结果集进行合并和重新排序，选择适当的重新排序策略至关重要。Milvus 提供两种重排策略：</p>
<ul>
<li><strong>加权排名</strong>：如果结果需要强调某个向量场，请使用该策略。WeightedRanker 可以为某些向量场赋予更大的权重，使其更加突出。</li>
<li><strong>RRFRanker（互易排名融合排名器）</strong>：在不需要特别强调的情况下选择此策略。RRFRanker 能有效平衡每个向量场的重要性。</li>
</ul>
<h4 id="加权排名"><a href="#加权排名" class="headerlink" title="加权排名"></a>加权排名</h4><p>加权排名器通过为每个搜索路径分配不同的重要性权重，智能地组合来自多个搜索路径的结果并确定其优先级。与技艺高超的厨师平衡多种配料以制作完美菜肴的方式类似，加权排名器也会平衡不同的搜索结果，以提供最相关的综合结果。这种方法非常适合在多个向量场或模式中进行搜索，其中某些场对最终排名的贡献应比其他场更大。</p>
<p><img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092538807.png" alt="image-20250908092538807"></p>
<h4 id="RRFRanker"><a href="#RRFRanker" class="headerlink" title="RRFRanker"></a>RRFRanker</h4><p>互惠排名融合（RRF）排名器是 Milvus 混合搜索的一种重新排名策略，它根据多个向量搜索路径的排名位置而不是原始相似度得分来平衡搜索结果。就像体育比赛考虑的是球员的排名而不是个人统计数据一样，RRF Ranker 根据每个项目在不同搜索路径中的排名高低来组合搜索结果，从而创建一个公平、均衡的最终排名。</p>
<p>RRF Ranker 专门设计用于<strong>混合搜索场景</strong>，在这种场景中，您需要平衡来自多个向量搜索路径的结果，而无需分配明确的重要性权重。</p>
<p><img src="/2025/09/08/%E5%AD%A6%E4%B9%A0/python-web/milvus/milvus/image-20250908092346065.png" alt="image-20250908092346065"></p>
<h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multi_tenancy.md#Partition-key-based-multi-tenancy">实施多租户 | Milvus 文档</a></p>
<p>Milvus 支持四个级别的多租户：<strong>数据库</strong>、<strong>Collection</strong>、<strong>Partition</strong> 和<strong>Partition Key</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong> 数据库级</strong></th>
<th><strong>Collections 级</strong></th>
<th><strong>分区级</strong></th>
<th><strong>分区 Key 级</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据隔离</strong></td>
<td>物理</td>
<td>物理</td>
<td>物理</td>
<td>物理 + 逻辑</td>
</tr>
<tr>
<td><strong>最大租户数</strong></td>
<td>默认为 64 个。您可以通过修改 Milvus.yaml 配置文件中的<code>maxDatabaseNum</code> 参数来增加租户数。</td>
<td>默认为 65,536。可以通过修改 Milvus.yaml 配置文件中的<code>maxCollectionNum</code> 参数来增加。</td>
<td>每个 Collection 最多 1,024 个。</td>
<td>百万</td>
</tr>
<tr>
<td><strong>数据 Schema 灵活性</strong></td>
<td>高</td>
<td>中</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><strong>RBAC 支持</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>搜索性能</strong></td>
<td>强</td>
<td>强</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td><strong>跨租户搜索支持</strong></td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>是</td>
</tr>
<tr>
<td><strong>支持有效处理冷热数据</strong></td>
<td>是</td>
<td>是</td>
<td>支持</td>
<td>否 目前不支持 Partition Key 级策略。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="比较有意思的教程"><a href="#比较有意思的教程" class="headerlink" title="比较有意思的教程"></a>比较有意思的教程</h3><p>多模态rag<a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/multimodal_rag_with_milvus.md">用 Milvus 制作多模态 RAG | Milvus 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/text_image_search.md">使用 Milvus 进行文本到图像搜索 | Milvus 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://milvus.io/docs/zh/image_similarity_search.md">使用 Milvus 搜索图像 | Milvus 文档</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/05/%E5%AE%9E%E4%B9%A0/Tosea.ai/api%E8%B0%83%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/05/%E5%AE%9E%E4%B9%A0/Tosea.ai/api%E8%B0%83%E6%9F%A5/" class="post-title-link" itemprop="url">api调查</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-05T00:00:00+08:00">2025-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-06 22:53:32" itemprop="dateModified" datetime="2025-09-06T22:53:32+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/Tosea-ai/" itemprop="url" rel="index"><span itemprop="name">Tosea.ai</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="convertapi"><a href="#convertapi" class="headerlink" title="convertapi"></a>convertapi</h3><p><a target="_blank" rel="noopener" href="https://www.convertapi.com/">ConvertAPI: Powerful File Conversion API for Developers &amp; Businesses</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>档次</th>
<th>官方名称</th>
<th>月费 (CNY)</th>
<th>每月包含转换次数</th>
<th>单文件上限</th>
<th>并发任务数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Developer</td>
<td>¥249</td>
<td>1,000 次</td>
<td>200 MB</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Startup</td>
<td>¥677</td>
<td>5,000 次</td>
<td>300 MB</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>Growth</td>
<td>¥1,247</td>
<td>15,000 次</td>
<td>500 MB</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>Business</td>
<td>¥2,495</td>
<td>50,000 次</td>
<td>1 GB</td>
<td>无限制</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CloudConvert"><a href="#CloudConvert" class="headerlink" title="CloudConvert"></a>CloudConvert</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>价格</th>
<th>包含内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一次性购买积分</strong></td>
<td><strong>$9 美元</strong> 起</td>
<td>500 个转换积分</td>
</tr>
<tr>
<td><strong>月度订阅</strong></td>
<td><strong>$9 美元/月</strong></td>
<td>每月 1000 个转换积分，未用完可滚存</td>
</tr>
</tbody>
</table>
</div>
<p>每天免费 10 次转换</p>
<p>pdf转ppt，一次要花费4积分，平均下来一份需要0.47元，付费情况下可以做到 5个并发任务</p>
<p><a target="_blank" rel="noopener" href="https://cloudconvert.com/pricing">定价 |云转换</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudconvert.com/pdf-to-pptx">PDF to PowerPoint | CloudConvert</a></p>
<h3 id="GroupDocs-Conversion-Aspose-PDF-Cloud"><a href="#GroupDocs-Conversion-Aspose-PDF-Cloud" class="headerlink" title="GroupDocs.Conversion/Aspose.PDF Cloud"></a>GroupDocs.Conversion/Aspose.PDF Cloud</h3><p>每个月1000次以内的api调用是30美金，平均下来是一份0.21元，但是如果超过1000次每个月，就要0.09美金一次转换</p>
<p>付费默认5并发</p>
<p><a target="_blank" rel="noopener" href="https://products.groupdocs.cloud/conversion/python/pdf-to-ppt/">https://products.groupdocs.cloud/conversion/python/pdf-to-ppt/</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.groupdocs.cloud/#/">Dashboard</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.aspose.cloud/#/">Dashboard</a></p>
<p><a target="_blank" rel="noopener" href="https://purchase.groupdocs.cloud/pricing/">Pricing Guide - Purchase - groupdocs.cloud</a></p>
<h3 id="Adobe-PDF"><a href="#Adobe-PDF" class="headerlink" title="Adobe PDF"></a>Adobe PDF</h3><p>每个月五百次的免费转换</p>
<p><a target="_blank" rel="noopener" href="https://developer.adobe.com/document-services/pricing/main/">Adobe PDF Services API Pricing | PDF Embed API Pricing | Adobe Acrobat Services Pricing - Adobe Developers</a></p>
<h3 id="度慧科技"><a href="#度慧科技" class="headerlink" title="度慧科技"></a>度慧科技</h3><p>这个很便宜，我在腾讯云上看，300r可以买五千次，500r可以买5万次转换。阿里云，100r可以买3000次，有效期一个月</p>
<p>并发数为200</p>
<p><a target="_blank" rel="noopener" href="https://try.dhconvert.com/">度慧文档转换</a></p>
<p><a target="_blank" rel="noopener" href="https://market.cloud.tencent.com/products/24078?keyword=度慧">[度慧]PDF转Word,PPT,Excel,TXT,OFD（OCR高级版）-腾讯云市场</a></p>
<p><a target="_blank" rel="noopener" href="https://market.aliyun.com/detail/cmapi00044824#sku=yuncode3882400007">【度慧文档转换】PDF转Word/PPT/Excel/TXT/OFD - 支持扫描版OCR【最新版】<em>数据API_OCR_API-</em>云市场-阿里云</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepagent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepagent/" class="post-title-link" itemprop="url">deepagents实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-28T00:00:00+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-20 08:50:19" itemprop="dateModified" datetime="2025-10-20T08:50:19+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hjeMzVEUu?spm_id_from=333.788.videopod.sections&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">LangChain Deep Agents - 构建你自己的深度研究智能体_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.langchain.com/deep-agents/">《深度智能体》 —- Deep Agents</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepresearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/28/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/deepresearch/" class="post-title-link" itemprop="url">deepresearch实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-28 00:00:00 / 修改时间：15:24:12" itemprop="dateCreated datePublished" datetime="2025-08-28T00:00:00+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="理解deepresearch"><a href="#理解deepresearch" class="headerlink" title="理解deepresearch"></a>理解deepresearch</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aXg5zzExm?buvid=XX7932A7E9DD8A1DA92D4974AB535749A9B44&amp;from_spmid=tm.recommend.0.0&amp;is_story_h5=false&amp;mid=25yhOI1fPeVYa5V16BFcAw%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=aec53502-2411-4bc1-8ccf-ce85bd6efc1e&amp;share_source=QQ&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1753142992&amp;unique_k=tZcFKrS&amp;up_id=28357052&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">🦜🕸️ Open Deep Research V2：新架构！上下文工程最新实践 📋_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://academy.langchain.com/courses/take/deep-research-with-langgraph/lessons/67513388-course-overview">Project: Deep Research with LangGraph - LangChain Academy</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/langchain-ai/open_deep_research">langchain-ai/open_deep_research —- langchain-ai/open_deep_research</a></p>
<p>官方博文<a target="_blank" rel="noopener" href="https://blog.langchain.com/open-deep-research/">开启深度研究 —- Open Deep Research</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/25/%E5%AE%9E%E4%B9%A0/Tosea.ai/aippt%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/25/%E5%AE%9E%E4%B9%A0/Tosea.ai/aippt%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">aippt技术调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-25T00:00:00+08:00">2025-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 19:00:20" itemprop="dateModified" datetime="2025-08-28T19:00:20+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/Tosea-ai/" itemprop="url" rel="index"><span itemprop="name">Tosea.ai</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><p><strong>方案 A：html → PDF  → pptx</strong>（我尝试下来不大可行，无法再进行编辑了）</p>
<p><strong>方案 B：html → PPTXGenJS</strong></p>
<p><strong>方案 C：html → python-pptx</strong> (主流)</p>
<p><strong>方案 D：markdown → Slidev</strong></p>
<p>我尝试了当前市面的ppt生成产品，在网页里面展示还会有良好的动画效果，但是一旦导出成pptx，都是会变成静态页面，没有动画</p>
<p>reveal.js可以利用页面生成丰富的ppt动画效果；Slidev可以将markdown语法转化成ppt，可以导出为pdf或pptx，需要注意的是，PPTX 文件中的所有幻灯片都会被导出为图片。</p>
<p> PPTXGenJS和python-pptx的原理基本一致，区别一个是使用js一个是python，使用方法都是通过解析HTML标签内容，定义一个ppt实例，将html的内容一点点加入这个示例中，最后导出pptx。这样都仅能实现最基本的ppt演示，不会有复杂的结构，而且经常会出现一个问题——某个标签内文字太多往往会超出ppt演示范围</p>
<p>直接让AI来生成非常自由的PPT，最终的效果一般来说都比较烂，大部分都是预定义一个html模板，然后让AI来自动的选择模板往里面填充内容</p>
<h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><p><a target="_blank" rel="noopener" href="https://cn.sli.dev/guide/">Slidev</a> 是一个为开发者设计的基于 Web 的幻灯片制作工具。它帮助您以 Markdown 的形式专注于编写幻灯片的内容，并制作出具有交互式演示功能的、高度可自定义的幻灯片。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hakimel/reveal.js">reveal.js</a> 是一个开源的 <strong>HTML 演示框架</strong>，用 JavaScript 写成。只要你会写 HTML/CSS/JS，就可以像做网页一样做出 <strong>酷炫、响应式、支持键盘/鼠标/触控交互</strong> 的幻灯片。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gitbrent/PptxGenJS">PptxGenJS</a> 允许您使用 JavaScript 生成专业的 PowerPoint 演示文稿——直接从 Node、React、Vite、Electron，甚至浏览器中生成。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/scanny/python-pptx">python-pptx</a> 是一个用于创建、读取和更新 PowerPoint (.pptx)文件的 Python 库。典型的使用场景是从动态内容（如数据库查询、分析输出或 JSON 负载）生成 PowerPoint 演示文稿，可能是在响应 HTTP 请求时生成 PPTX 文件并下载。</p>
<blockquote>
<p>python-pptx使用方式：根据标签解析html文件，如h1，div等，然后一点点添加到定义的页中</p>
</blockquote>
<h3 id="市面同类产品"><a href="#市面同类产品" class="headerlink" title="市面同类产品"></a>市面同类产品</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.genspark.ai/agents?type=slides_agent">Genspark</a></p>
<ul>
<li>Genspark 是 <strong>MainFunc</strong> 公司（由前小度 CEO 景鲲和前小度 CTO 朱凯华联合创立）推出的 <strong>AI Agent 搜索引擎</strong>（或称“AI 原生搜索引擎”）。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.tiangong.cn/?from=ai-tab.cn">skywork</a></p>
<ul>
<li>Skywork 是昆仑万维（Kunlun Inc.）旗下 <strong>SkyWork AI</strong> 推出的一系列 <strong>开源大模型</strong> 与 <strong>AI 技术品牌</strong>。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://manus.im/app">manus</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://gamma.app/">Gamma</a> 是一个 <strong>“AI 驱动的在线内容工作站”</strong>：输入一句话、一段大纲或任何资料，它就能在 <strong>1-3 分钟内</strong> 帮你生成 <strong>高颜值、品牌化、可互动</strong> 的演示文稿、网站、社媒图文或 PDF，并可一键导出为 <strong>PPT / Google Slides / PDF / 网站链接</strong>。</li>
</ol>
<p>manus是每页ppt都是一个html文件，我猜测应该是使用像python-pptx的库生成</p>
<h3 id="ppt-mcp"><a href="#ppt-mcp" class="headerlink" title="ppt-mcp"></a>ppt-mcp</h3><p>可以参考其中的工具实现，这两个我看下来都是使用python-pptx包</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GongRzhe/Office-PowerPoint-MCP-Server">GongRzhe/Office-PowerPoint-MCP-Server: A MCP (Model Context Protocol) server for PowerPoint manipulation using python-pptx. This server provides tools for creating, editing, and manipulating PowerPoint presentations through the MCP protocol.</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ltc6539/mcp-ppt">ltc6539/mcp-ppt: A mcp server supporting you to generate powerpoint using LLM and natural language automatically.</a></p>
<h3 id="架构思考"><a href="#架构思考" class="headerlink" title="架构思考"></a>架构思考</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">    subgraph &quot;Plan-and-Execute阶段&quot;</span><br><span class="line">        A[&quot;用户输入&quot;] --&gt; B[&quot;Planner Agent&quot;]</span><br><span class="line">        B --&gt; C[&quot;Agent Executor&quot;]</span><br><span class="line">        C --&gt; D[&quot;Replanner&quot;]</span><br><span class="line">        D --&gt;|&quot;需要更多信息&quot;| C</span><br><span class="line">        D --&gt;|&quot;信息充足&quot;| E[&quot;输出结构化信息&quot;]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;内容生成阶段&quot;</span><br><span class="line">        E --&gt; F[&quot;大纲设计节点&quot;]</span><br><span class="line">        F --&gt; G[&quot;页面内容生成节点&quot;]</span><br><span class="line">        G --&gt; H[&quot;HTML代码生成节点&quot;]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;文件转换阶段&quot;</span><br><span class="line">        H --&gt; I[&quot;html演示生成&quot;]</span><br><span class="line">        I --&gt; J[&quot;转换pptx节点&quot;]</span><br><span class="line">        J --&gt; K[&quot;输出PPTX文件&quot;]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<h3 id="利用APRYSE将pdf转成pptx"><a href="#利用APRYSE将pdf转成pptx" class="headerlink" title="利用APRYSE将pdf转成pptx"></a>利用APRYSE将pdf转成pptx</h3><p>Apryse（曾用名 PDFTron）是一家加拿大公司推出的商用 SDK 家族，专注 “任何格式进、任何格式出” 的文档处理。</p>
<p>获取apikey<a target="_blank" rel="noopener" href="https://docs.apryse.com/core/guides/get-started/trial-key">Free trial key for Apryse SDK | Apryse documentation</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.apryse.com/core/guides/get-started/python3">Python 3.X PDF Library for Windows, Linux and Mac | Apryse documentation</a></p>
<p><strong>安装 Apryse SDK 的“结构化输出模块”（Structured Output Module）</strong>。该模块是一个可选的扩展包，PDF → PPTX、PDF → Word 等高级转换功能都依赖它。<a target="_blank" rel="noopener" href="https://docs.apryse.com/core/guides/info/modules">库插件：OCR、CAD 转 PDF - 适用于服务器/桌面 SDK | Apryse 文档 —- Library Add-ons: OCR, CAD to PDF - for Server/Desktop SDK | Apryse documentation</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from apryse_sdk import PDFNet, PDFDoc, Convert, StructuredOutputModule</span><br><span class="line"></span><br><span class="line"># 1. 初始化（许可证）</span><br><span class="line">PDFNet.Initialize(&quot;demo:1756369085114:&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 告诉 SDK 模块放在哪里</span><br><span class="line">PDFNet.AddResourceSearchPath(r&quot;F:\project python\test\StructuredOutputWindows\Lib\Windows&quot;)</span><br><span class="line"></span><br><span class="line"># 3. 可选：确认模块已就位</span><br><span class="line">if not StructuredOutputModule.IsModuleAvailable():</span><br><span class="line">    raise RuntimeError(&quot;StructuredOutput module not found!&quot;)</span><br><span class="line"></span><br><span class="line"># 4. 正常调用</span><br><span class="line">doc = PDFDoc(&quot;input.pdf&quot;)</span><br><span class="line">Convert.ToPowerPoint(doc, &quot;output.pptx&quot;)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.convertapi.com/a">Overview</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zftnz6Ewx/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=bacf29bd4bb51f2ecf08a1ac7c7d8f11">动手实现一个做PPT的MCP服务器_哔哩哔哩_bilibili</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/" class="post-title-link" itemprop="url">agentic-rag实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-19T00:00:00+08:00">2025-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-08 10:05:23" itemprop="dateModified" datetime="2025-09-08T10:05:23+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/rag/" itemprop="url" rel="index"><span itemprop="name">rag</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>这个agentic rag主要是作用于检索部分，由是否需要调用检索工具判定是否进入检索阶段，当检索到相关的文章，则进行回答，否则对问题进行改写，再次检索</strong></p>
<p>代码见<a target="_blank" rel="noopener" href="https://github.com/zxj-2023/learn-rag-langchain/tree/main/agentic-rag">learn-rag-langchain/agentic-rag at main · zxj-2023/learn-rag-langchain</a></p>
<p>在这个教程中，我们将构建一个检索代理。当您希望 LLM 决定是否从向量存储中检索上下文或直接响应用户时，检索代理非常有用。</p>
<p>完成教程后，我们将完成以下工作：</p>
<ol>
<li>获取并预处理用于检索的文档。</li>
<li>为这些文档建立语义索引，并为代理创建一个检索工具。</li>
<li>构建一个能够决定何时使用检索工具的代理式 RAG 系统。</li>
</ol>
<p><img src="/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/image-20250819165309335.png" alt="image-20250819165309335"></p>
<h3 id="1-预处理文档"><a href="#1-预处理文档" class="headerlink" title="1. 预处理文档"></a>1. 预处理文档</h3><p>获取用于我们 RAG 系统的文档。我们将使用 Lilian Weng 优秀博客中最新的三页。我们将从使用 <code>WebBaseLoader</code> 工具获取页面内容开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from langchain_community.document_loaders import WebBaseLoader</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    &quot;https://lilianweng.github.io/posts/2024-11-28-reward-hacking/&quot;,</span><br><span class="line">    &quot;https://lilianweng.github.io/posts/2024-07-07-hallucination/&quot;,</span><br><span class="line">    &quot;https://lilianweng.github.io/posts/2024-04-12-diffusion-video/&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">docs = [WebBaseLoader(url).load() for url in urls]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs[0][0].page_content.strip()[:1000]</span><br></pre></td></tr></table></figure>
<p>将获取的文档分割成更小的块，以便索引到我们的向量存储中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from langchain_text_splitters import RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">docs_list = [item for sublist in docs for item in sublist]</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(</span><br><span class="line">    chunk_size=100, chunk_overlap=50</span><br><span class="line">)</span><br><span class="line">doc_splits = text_splitter.split_documents(docs_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc_splits[0].page_content.strip()</span><br></pre></td></tr></table></figure>
<h3 id="2-创建检索工具"><a href="#2-创建检索工具" class="headerlink" title="2. 创建检索工具"></a>2. 创建检索工具</h3><p>现在我们已经有了分割的文档，我们可以将它们索引到一个向量存储中，我们将使用这个向量存储进行语义搜索。</p>
<p>使用内存向量存储和 OpenAI 嵌入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from langchain_chroma import Chroma  # 导入 Chroma</span><br><span class="line">from langchain_openai import OpenAIEmbeddings</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 确保安装了 langchain-chroma</span><br><span class="line"># pip install langchain-chroma</span><br><span class="line"></span><br><span class="line">embedding = OpenAIEmbeddings(</span><br><span class="line">    api_key=&quot;sk-&quot;, </span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;,</span><br><span class="line">    model=&quot;text-embedding-v4&quot;,</span><br><span class="line">    check_embedding_ctx_length=False,</span><br><span class="line">    dimensions=1536,</span><br><span class="line">    chunk_size=5  # 设置较小的批次大小</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 使用 Chroma 替代 InMemoryVectorStore</span><br><span class="line">vectorstore = Chroma.from_documents(</span><br><span class="line">    documents=doc_splits, </span><br><span class="line">    embedding=embedding,</span><br><span class="line">    persist_directory=&quot;./chroma_db&quot;  # 指定持久化目录</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重新加载已存在的 Chroma 数据库</span><br><span class="line">vectorstore = Chroma(</span><br><span class="line">    persist_directory=&quot;./chroma_db&quot;,</span><br><span class="line">    embedding_function=embedding</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">retriever = vectorstore.as_retriever()</span><br></pre></td></tr></table></figure>
<p>使用 LangChain 的预构建 <code>create_retriever_tool</code> 创建检索工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langchain.tools.retriever import create_retriever_tool</span><br><span class="line"></span><br><span class="line">retriever_tool = create_retriever_tool(</span><br><span class="line">    retriever,                    # 【输入】一个已经配置好的检索器（例如：向量数据库的检索器）</span><br><span class="line">    &quot;retrieve_blog_posts&quot;,        # 【工具名称】这个工具的唯一标识名（供模型内部调用）</span><br><span class="line">    &quot;Search and return information about Lilian Weng blog posts.&quot;  # 【工具描述】模型看到的说明，用于决定是否调用它</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retriever_tool.invoke(&#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-生成查询"><a href="#3-生成查询" class="headerlink" title="3. 生成查询"></a>3. 生成查询</h3><p>现在我们将开始构建我们智能体 RAG 图中的组件（节点和边）。</p>
<p>构建一个 <code>generate_query_or_respond</code> 节点。它将调用 LLM 来根据当前图状态（消息列表）生成响应。根据输入消息，它将决定使用检索工具进行检索，或直接响应用户。请注意，我们通过 <code>.bind_tools</code> 向聊天模型提供了先前创建的 <code>retriever_tool</code> 访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langchain_community.chat_models import ChatTongyi</span><br><span class="line">llm = ChatTongyi(</span><br><span class="line">    model=&quot;qwen3-235b-a22b&quot;,</span><br><span class="line">    api_key=&quot;sk-&quot;,</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;,</span><br><span class="line">    model_kwargs=&#123;&quot;enable_thinking&quot;: False&#125;   # 关键在这里</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import MessagesState</span><br><span class="line"></span><br><span class="line">def generate_query_or_respond(state: MessagesState):</span><br><span class="line">    &quot;&quot;&quot;调用模型，根据当前状态生成响应。根据问题，模型将决定是使用检索工具进行检索，还是直接回复用户。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    response = (</span><br><span class="line">        llm</span><br><span class="line">        .bind_tools([retriever_tool]).invoke(state[&quot;messages&quot;])</span><br><span class="line">    )</span><br><span class="line">    return &#123;&quot;messages&quot;: [response]&#125;</span><br></pre></td></tr></table></figure>
<p>提出一个需要语义搜索的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">generate_query_or_respond(input)[&quot;messages&quot;][-1].pretty_print()</span><br></pre></td></tr></table></figure>
<h3 id="4-评定文件"><a href="#4-评定文件" class="headerlink" title="4.评定文件"></a>4.评定文件</h3><p>添加一个条件边 — <code>grade_documents</code> — 来判断检索到的文档是否与问题相关。</p>
<p>我们将使用一个具有结构化输出模式 <code>GradeDocuments</code> 的模型来对文档进行评分。 <code>grade_documents</code> 函数将根据评分决策（ <code>generate_answer</code> 或 <code>rewrite_question</code> ）返回要前往的节点的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pydantic import BaseModel, Field</span><br><span class="line">from typing import Literal</span><br><span class="line"></span><br><span class="line"># 定义评分提示模板</span><br><span class="line">GRADE_PROMPT = (</span><br><span class="line">    &quot;你是一个评分员，负责评估检索到的文档与用户问题的相关性。\n &quot;</span><br><span class="line">    &quot;以下是检索到的文档内容：\n\n &#123;context&#125; \n\n&quot;</span><br><span class="line">    &quot;以下是用户的问题：&#123;question&#125; \n&quot;</span><br><span class="line">    &quot;如果文档包含与用户问题相关的关键词或语义含义，则将其评为相关。\n&quot;</span><br><span class="line">    &quot;请给出一个二元评分：&#x27;yes&#x27;（是）表示相关，&#x27;no&#x27;（否）表示不相关。&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 定义用于评估文档相关性的 Pydantic 模型</span><br><span class="line">class GradeDocuments(BaseModel):</span><br><span class="line">    &quot;&quot;&quot;使用二元评分对文档进行相关性评估。&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    binary_score: str = Field(</span><br><span class="line">        description=&quot;相关性评分：&#x27;yes&#x27; 表示相关，&#x27;no&#x27; 表示不相关&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"># 初始化用于评分的聊天模型</span><br><span class="line">grader_model = llm</span><br><span class="line"></span><br><span class="line">def grade_documents(</span><br><span class="line">    state: MessagesState,</span><br><span class="line">) -&gt; Literal[&quot;generate_answer&quot;, &quot;rewrite_question&quot;]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    判断检索到的文档是否与用户问题相关。</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        state: 包含消息历史的状态对象，其中第一条消息是用户问题，</span><br><span class="line">               最后一条消息是检索到的文档内容。</span><br><span class="line">    </span><br><span class="line">    返回:</span><br><span class="line">        如果文档相关，返回 &quot;generate_answer&quot;；</span><br><span class="line">        如果不相关，返回 &quot;rewrite_question&quot;，表示需要重写问题并重新检索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    question = state[&quot;messages&quot;][0].content  # 获取用户问题</span><br><span class="line">    context = state[&quot;messages&quot;][-1].content  # 获取检索到的文档内容</span><br><span class="line"></span><br><span class="line">    # 将问题和文档内容填入提示模板</span><br><span class="line">    prompt = GRADE_PROMPT.format(question=question, context=context)</span><br><span class="line">    </span><br><span class="line">    # 调用模型，并以结构化输出（Pydantic 模型）的形式获取评分结果</span><br><span class="line">    response = (</span><br><span class="line">        grader_model</span><br><span class="line">        .with_structured_output(GradeDocuments)</span><br><span class="line">        .invoke([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;])</span><br><span class="line">    )</span><br><span class="line">    #print(response)</span><br><span class="line">    score = response.binary_score  # 获取二元评分结果</span><br><span class="line"> </span><br><span class="line">    # 根据评分决定下一步操作</span><br><span class="line">    if score == &quot;yes&quot;:</span><br><span class="line">        return &quot;generate_answer&quot;  # 文档相关，生成答案</span><br><span class="line">    else:</span><br><span class="line">        return &quot;rewrite_question&quot;  # 文档不相关，重写问题后重新检索</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from langchain_core.messages import convert_to_messages</span><br><span class="line"></span><br><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: convert_to_messages(#将一系列消息转换为 BaseMessage 类型的消息列表。</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;&quot;,</span><br><span class="line">                &quot;tool_calls&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;retrieve_blog_posts&quot;,</span><br><span class="line">                        &quot;args&quot;: &#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;&quot;role&quot;: &quot;tool&quot;, &quot;content&quot;: &quot;meow&quot;, &quot;tool_call_id&quot;: &quot;1&quot;&#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">grade_documents(input)</span><br></pre></td></tr></table></figure>
<h3 id="5-重写问题"><a href="#5-重写问题" class="headerlink" title="5. 重写问题"></a>5. 重写问题</h3><p>构建 <code>rewrite_question</code> 节点。</p>
<p>检索工具可能会返回潜在的不相关文档，这表明需要改进原始用户问题。为此，我们将调用 <code>rewrite_question</code> 节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">REWRITE_PROMPT = (</span><br><span class="line">    &quot;Look at the input and try to reason about the underlying semantic intent / meaning.\n&quot;</span><br><span class="line">    &quot;Here is the initial question:&quot;</span><br><span class="line">    &quot;\n ------- \n&quot;</span><br><span class="line">    &quot;&#123;question&#125;&quot;</span><br><span class="line">    &quot;\n ------- \n&quot;</span><br><span class="line">    &quot;Formulate an improved question:&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def rewrite_question(state: MessagesState):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    重写用户最初的提问，以更好地表达其语义意图。</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        state: 包含消息历史的状态对象，其中第一条消息是用户原始问题。</span><br><span class="line">    </span><br><span class="line">    返回:</span><br><span class="line">        一个字典，包含一条新的用户消息，内容为改写后的问题。</span><br><span class="line">        该消息将用于后续的检索步骤，以提高检索结果的相关性。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    messages = state[&quot;messages&quot;]</span><br><span class="line">    question = messages[0].content  # 获取用户最初的提问</span><br><span class="line">    prompt = REWRITE_PROMPT.format(question=question)  # 将问题填入提示模板</span><br><span class="line">    response = llm.invoke([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;])  # 调用模型生成改写后的问题</span><br><span class="line">    </span><br><span class="line">    # 返回新的消息结构，内容为改写后的问题</span><br><span class="line">    return &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: response.content&#125;]&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: convert_to_messages(</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;&quot;,</span><br><span class="line">                &quot;tool_calls&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;retrieve_blog_posts&quot;,</span><br><span class="line">                        &quot;args&quot;: &#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;&quot;role&quot;: &quot;tool&quot;, &quot;content&quot;: &quot;meow&quot;, &quot;tool_call_id&quot;: &quot;1&quot;&#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = rewrite_question(input)</span><br><span class="line">print(response[&quot;messages&quot;][-1][&quot;content&quot;])</span><br></pre></td></tr></table></figure>
<h3 id="6-生成答案"><a href="#6-生成答案" class="headerlink" title="6. 生成答案"></a>6. 生成答案</h3><p>构建 <code>generate_answer</code> 节点：如果我们通过了评分器的检查，我们可以根据原始问题和检索到的上下文生成最终答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GENERATE_PROMPT = (</span><br><span class="line">    &quot;You are an assistant for question-answering tasks. &quot;</span><br><span class="line">    &quot;Use the following pieces of retrieved context to answer the question. &quot;</span><br><span class="line">    &quot;If you don&#x27;t know the answer, just say that you don&#x27;t know. &quot;</span><br><span class="line">    &quot;Use three sentences maximum and keep the answer concise.\n&quot;</span><br><span class="line">    &quot;Question: &#123;question&#125; \n&quot;</span><br><span class="line">    &quot;Context: &#123;context&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_answer(state: MessagesState):</span><br><span class="line">    &quot;&quot;&quot;Generate an answer.&quot;&quot;&quot;</span><br><span class="line">    question = state[&quot;messages&quot;][0].content</span><br><span class="line">    context = state[&quot;messages&quot;][-1].content</span><br><span class="line">    prompt = GENERATE_PROMPT.format(question=question, context=context)</span><br><span class="line">    response = llm.invoke([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;])</span><br><span class="line">    return &#123;&quot;messages&quot;: [response]&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">input = &#123;</span><br><span class="line">    &quot;messages&quot;: convert_to_messages(</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;What does Lilian Weng say about types of reward hacking?&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;&quot;,</span><br><span class="line">                &quot;tool_calls&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;retrieve_blog_posts&quot;,</span><br><span class="line">                        &quot;args&quot;: &#123;&quot;query&quot;: &quot;types of reward hacking&quot;&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;role&quot;: &quot;tool&quot;,</span><br><span class="line">                &quot;content&quot;: &quot;reward hacking can be categorized into two types: environment or goal misspecification, and reward tampering&quot;,</span><br><span class="line">                &quot;tool_call_id&quot;: &quot;1&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = generate_answer(input)</span><br><span class="line">response[&quot;messages&quot;][-1].pretty_print()</span><br></pre></td></tr></table></figure>
<h3 id="7-组装图表"><a href="#7-组装图表" class="headerlink" title="7. 组装图表"></a>7. 组装图表</h3><p>以 <code>generate_query_or_respond</code> 开头，并确定是否需要调用 <code>retriever_tool</code></p>
<p>使用 <code>tools_condition</code> 跳转到下一步：</p>
<ul>
<li>如果 <code>generate_query_or_respond</code> 返回 <code>tool_calls</code> ，调用 <code>retriever_tool</code> 获取上下文</li>
<li>否则，直接回复用户</li>
</ul>
<p>对检索到的文档内容按与问题的相关性（ <code>grade_documents</code> ）进行评分，并路由到下一步：</p>
<ul>
<li>如果不相关，使用 <code>rewrite_question</code> 重写问题，然后再次调用 <code>generate_query_or_respond</code></li>
<li>如果相关，请继续到 <code>generate_answer</code> 并使用检索到的文档上下文生成最终响应 <code>ToolMessage</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import StateGraph, START, END</span><br><span class="line">from langgraph.prebuilt import ToolNode</span><br><span class="line">from langgraph.prebuilt import tools_condition</span><br><span class="line"></span><br><span class="line"># 创建一个基于状态图（StateGraph）的流程，用于管理对话或任务的执行流程</span><br><span class="line">workflow = StateGraph(MessagesState)</span><br><span class="line"></span><br><span class="line"># 定义流程中将循环执行的各个节点</span><br><span class="line">workflow.add_node(generate_query_or_respond)          # 判断是生成检索查询还是直接回复用户</span><br><span class="line">workflow.add_node(&quot;retrieve&quot;, ToolNode([retriever_tool]))  # 检索节点：使用检索工具（retriever_tool）从知识库中查找相关文档</span><br><span class="line">workflow.add_node(rewrite_question)                  # 重写问题节点：当检索结果不相关时，优化并重写用户的问题</span><br><span class="line">workflow.add_node(generate_answer)                   # 生成答案节点：基于检索到的信息生成最终回答</span><br><span class="line"></span><br><span class="line"># 设置流程的起始点：从 `generate_query_or_respond` 节点开始</span><br><span class="line">workflow.add_edge(START, &quot;generate_query_or_respond&quot;)</span><br><span class="line"></span><br><span class="line"># 添加条件边：决定是否进行文档检索</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    &quot;generate_query_or_respond&quot;,</span><br><span class="line">    # 使用 `tools_condition` 函数判断 LLM 的输出意图：</span><br><span class="line">    # 如果 LLM 决定调用 `retriever_tool` 工具，则进入检索；如果选择直接回复，则结束流程</span><br><span class="line">    tools_condition,</span><br><span class="line">    &#123;</span><br><span class="line">        # 将条件判断结果映射到图中的具体节点</span><br><span class="line">        &quot;tools&quot;: &quot;retrieve&quot;,   # 若需调用工具，则跳转到检索节点</span><br><span class="line">        END: END               # 若无需调用工具（即可以直接回答），则结束流程</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 在 `retrieve` 节点执行后，根据文档相关性判断下一步操作</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    &quot;retrieve&quot;,</span><br><span class="line">    # 调用 `grade_documents` 函数评估检索到的文档是否与问题相关</span><br><span class="line">    grade_documents,</span><br><span class="line">    # 根据评分结果决定流向：</span><br><span class="line">    # - 如果相关，进入 `generate_answer`</span><br><span class="line">    # - 如果不相关，进入 `rewrite_question`</span><br><span class="line">    # （该逻辑在 `grade_documents` 函数中返回 &quot;generate_answer&quot; 或 &quot;rewrite_question&quot;）</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 添加固定边：生成答案后流程结束</span><br><span class="line">workflow.add_edge(&quot;generate_answer&quot;, END)</span><br><span class="line"></span><br><span class="line"># 重写问题后，回到初始节点重新判断是否需要检索</span><br><span class="line">workflow.add_edge(&quot;rewrite_question&quot;, &quot;generate_query_or_respond&quot;)</span><br><span class="line"></span><br><span class="line"># 编译整个工作流，生成可执行的图结构</span><br><span class="line">graph = workflow.compile()</span><br></pre></td></tr></table></figure>
<p><img src="/2025/08/19/%E5%AD%A6%E4%B9%A0/rag/agentic-rag/image-20250826170834571.png" alt="image-20250826170834571"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/#2-create-a-retriever-tool">《Agentic RAG》 —- Agentic RAG</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zxjavatar.gif">
      <meta itemprop="name" content="张熙浚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang XiJun">
      <meta itemprop="description" content="zxj Blogs">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang XiJun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Multi-Agent Workflows梳理与实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-18 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-18T00:00:00+08:00">2025-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 15:13:56" itemprop="dateModified" datetime="2025-08-28T15:13:56+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/agent%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">agent实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>代码见<a target="_blank" rel="noopener" href="https://github.com/zxj-2023/learn-rag-langchain/tree/main/multi-agent">learn-rag-langchain/multi-agent at main · zxj-2023/learn-rag-langchain</a></p>
<h3 id="什么是多智能体"><a href="#什么是多智能体" class="headerlink" title="什么是多智能体"></a>什么是多智能体</h3><p>当我们谈论”多智能体”时，我们指的是由llm驱动的多个独立的agent以<strong>特定方式</strong>连接在一起。</p>
<p>每个agent可以拥有自己的提示、LLM、工具和其他自定义代码，以最佳方式与其他智能体协作。</p>
<p>这种思维方式非常适合用图来表示，就像 <code>langgraph</code> 所提供的那样。在这种方法中，每个智能体都是图中的<strong>一个节点</strong>，而它们之间的<strong>连接则表示为一条边</strong>。<strong>控制流由边管理</strong>，它们通过向图的状态中<strong>添加信息来进行通信</strong>。</p>
<h3 id="多智能体架构梳理"><a href="#多智能体架构梳理" class="headerlink" title="多智能体架构梳理"></a>多智能体架构梳理</h3><p>langgraph给我们提供了几种<strong>多智能体架构</strong></p>
<p><img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250818163359517.png" alt="image-20250818163359517"></p>
<p><strong>Network</strong>: 每个智能体可以与其他所有智能体通信。任何智能体都可以决定下一步调用哪个其他智能体。</p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/multi_agent/multi-agent-collaboration/">Multi-agent network</a></p>
<p><strong>Supervisor</strong>：每个智能体与一个单一的监督者智能体通信。监督者智能体决定下一步应该调用哪个智能体。</p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor/">代理监督者 —- Agent Supervisor</a></p>
<p><strong>Hierarchical</strong>: 你可以定义一个具有监督者监督者的多代理系统。这是监督者架构的泛化，并允许更复杂的控制流程。</p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams/">层级代理团队 —- Hierarchical Agent Teams</a></p>
<p><strong>Custom multi-agent workflow</strong>: 每个代理只与代理子集通信。流程的部分是确定的，只有一些代理可以决定下一步调用哪些其他代理。</p>
<h3 id="Agent-Supervisor"><a href="#Agent-Supervisor" class="headerlink" title="Agent Supervisor"></a>Agent Supervisor</h3><p>在本教程中，你将构建一个包含两个代理的监督者系统——一个研究专家和一个数学专家。</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U langgraph langgraph-supervisor langchain-tavily &quot;langchain[openai]&quot;</span><br></pre></td></tr></table></figure>
<h4 id="1-创建工作代理"><a href="#1-创建工作代理" class="headerlink" title="1. 创建工作代理"></a>1. 创建工作代理</h4><p>首先，让我们创建我们的专业工作代理——研究代理和数学代理：</p>
<ul>
<li>研究代理将使用 Tavily API 访问网络搜索工具 <a target="_blank" rel="noopener" href="https://www.tavily.com/">Tavily - The Web Access Layer for AI Agents</a></li>
<li>数学代理将访问简单的数学工具（ <code>add</code> , <code>multiply</code> , <code>divide</code> ）</li>
</ul>
<h5 id="研究代理"><a href="#研究代理" class="headerlink" title="研究代理"></a>研究代理</h5><p>对于网络搜索，我们将使用 <code>TavilySearch</code> 工具来自 <code>langchain-tavily</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from langchain_tavily import TavilySearch</span><br><span class="line"></span><br><span class="line">web_search = TavilySearch(max_results=3,tavily_api_key=&quot;tvly-dev-&quot;)</span><br><span class="line">web_search_results = web_search.invoke(&quot;南京在哪&quot;)</span><br><span class="line"></span><br><span class="line">print(web_search_results[&quot;results&quot;][0][&quot;content&quot;])</span><br></pre></td></tr></table></figure>
<p>为了创建单个工作代理，我们将使用 LangGraph 的<a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/agents/agents/">预构建代理</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.prebuilt import create_react_agent</span><br><span class="line">from langchain_openai import ChatOpenAI</span><br><span class="line"></span><br><span class="line">llm=ChatOpenAI(</span><br><span class="line">    model=&quot;qwen3-235b-a22b-thinking-2507&quot;,</span><br><span class="line">    api_key=&quot;sk-&quot;,</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">research_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[web_search],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个研究代理。\n\n指令：\n- 仅协助与研究相关的任务，不得进行任何数学计算\n- 完成任务后，直接向主管回复\n- 仅回复你的工作结果，不得包含任何其他文字。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;research_agent&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>让我们运行代理来验证它的行为是否符合预期。<strong>我们将使用</strong> <code>pretty_print_messages</code> <strong>辅助工具来美观地渲染流式代理输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">from langchain_core.messages import convert_to_messages</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pretty_print_message(message, indent=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    美化打印单条消息</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        message: 要打印的消息对象</span><br><span class="line">        indent: 是否需要缩进打印</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 将消息转换为美观的HTML格式表示</span><br><span class="line">    pretty_message = message.pretty_repr(html=True)</span><br><span class="line">    if not indent:</span><br><span class="line">        # 如果不需要缩进，直接打印</span><br><span class="line">        print(pretty_message)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 如果需要缩进，为每一行添加制表符前缀</span><br><span class="line">    indented = &quot;\n&quot;.join(&quot;\t&quot; + c for c in pretty_message.split(&quot;\n&quot;))</span><br><span class="line">    print(indented)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pretty_print_messages(update, last_message=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    美化打印消息更新</span><br><span class="line">    </span><br><span class="line">    Args:</span><br><span class="line">        update: 包含消息更新的数据结构</span><br><span class="line">        last_message: 是否只打印最后一条消息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    is_subgraph = False  # 标记是否为子图更新</span><br><span class="line">    </span><br><span class="line">    # 检查更新是否为元组格式（包含命名空间信息）</span><br><span class="line">    if isinstance(update, tuple):</span><br><span class="line">        ns, update = update</span><br><span class="line">        # 如果命名空间为空，跳过父图更新的打印</span><br><span class="line">        if len(ns) == 0:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 提取图ID并打印子图更新信息</span><br><span class="line">        graph_id = ns[-1].split(&quot;:&quot;)[0]</span><br><span class="line">        print(f&quot;来自子图 &#123;graph_id&#125; 的更新:&quot;)</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line">        is_subgraph = True</span><br><span class="line"></span><br><span class="line">    # 遍历每个节点的更新</span><br><span class="line">    for node_name, node_update in update.items():</span><br><span class="line">        # 构造更新标签</span><br><span class="line">        update_label = f&quot;来自节点 &#123;node_name&#125; 的更新:&quot;</span><br><span class="line">        if is_subgraph:</span><br><span class="line">            # 如果是子图，添加缩进</span><br><span class="line">            update_label = &quot;\t&quot; + update_label</span><br><span class="line"></span><br><span class="line">        print(update_label)</span><br><span class="line">        print(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">        # 将节点更新中的消息转换为消息对象列表</span><br><span class="line">        messages = convert_to_messages(node_update[&quot;messages&quot;])</span><br><span class="line">        # 如果只要求最后一条消息，则截取最后一条</span><br><span class="line">        if last_message:</span><br><span class="line">            messages = messages[-1:]</span><br><span class="line"></span><br><span class="line">        # 打印每条消息</span><br><span class="line">        for m in messages:</span><br><span class="line">            pretty_print_message(m, indent=is_subgraph)</span><br><span class="line">        print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for chunk in research_agent.stream(</span><br><span class="line">    &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;南京在哪?&quot;&#125;]&#125;</span><br><span class="line">):</span><br><span class="line">    pretty_print_messages(chunk)</span><br></pre></td></tr></table></figure>
<h5 id="数学代理"><a href="#数学代理" class="headerlink" title="数学代理"></a>数学代理</h5><p>对于数学代理工具，我们将使用纯 Python 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def add(a: float, b: float):</span><br><span class="line">    &quot;&quot;&quot;将两个数字相加。&quot;&quot;&quot;</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def multiply(a: float, b: float):</span><br><span class="line">    &quot;&quot;&quot;将两个数字相乘。&quot;&quot;&quot;</span><br><span class="line">    return a * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def divide(a: float, b: float):</span><br><span class="line">    &quot;&quot;&quot;将两个数字相除。&quot;&quot;&quot;</span><br><span class="line">    return a / b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">math_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[add, multiply, divide],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个数学代理。\n\n&quot;</span><br><span class="line">        &quot;指令：\n&quot;</span><br><span class="line">        &quot;- 仅协助处理数学相关任务\n&quot;</span><br><span class="line">        &quot;- 完成任务后，直接回复给主管\n&quot;</span><br><span class="line">        &quot;- 仅回复你的工作结果，不要包含任何其他文字。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;math_agent&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>让我们运行数学代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for chunk in math_agent.stream(</span><br><span class="line">    &#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;what&#x27;s (3 + 5) x 7&quot;&#125;]&#125;</span><br><span class="line">):</span><br><span class="line">    pretty_print_messages(chunk)</span><br></pre></td></tr></table></figure>
<h4 id="2-创建监督者-langgraph-supervisor"><a href="#2-创建监督者-langgraph-supervisor" class="headerlink" title="2.创建监督者 langgraph-supervisor"></a>2.创建监督者 <code>langgraph-supervisor</code></h4><p>为了实现我们的多智能体系统，我们将使用预构建的 <code>langgraph-supervisor</code> 库中的 <a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/reference/supervisor/#langgraph_supervisor.supervisor.create_supervisor"><code>create_supervisor</code></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from langgraph_supervisor import create_supervisor</span><br><span class="line">from langchain.chat_models import init_chat_model</span><br><span class="line"></span><br><span class="line">supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[research_agent, math_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个管理两个代理的主管：\n&quot;</span><br><span class="line">        &quot;- 一个研究代理。将研究相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;- 一个数学代理。将数学相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;一次只分配工作给一个代理，不要并行调用代理。\n&quot;</span><br><span class="line">        &quot;不要自己做任何工作。&quot;</span><br><span class="line">    ),</span><br><span class="line">    add_handoff_back_messages=True,</span><br><span class="line">    output_mode=&quot;full_history&quot;,</span><br><span class="line">).compile()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import display, Image</span><br><span class="line"></span><br><span class="line">display(Image(supervisor.get_graph().draw_mermaid_png()))</span><br></pre></td></tr></table></figure>
<p><img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250819113009108.png" alt="image-20250819113009108"></p>
<p>现在让我们用一个需要两个代理的查询来运行它：</p>
<p>研究代理将查找必要的 GDP 信息；数学代理将执行除法以找到纽约州 GDP 的百分比，如所请求</p>
<h4 id="3-从头创建监督者"><a href="#3-从头创建监督者" class="headerlink" title="3.从头创建监督者"></a>3.从头创建监督者</h4><p>现在让我们从头实现这个多智能体系统。我们需要：</p>
<ol>
<li>设置主管如何与各个代理进行沟通</li>
<li>创建监督代理</li>
<li>将监督代理和工作代理组合成一个多代理图。</li>
</ol>
<h5 id="设置代理通信"><a href="#设置代理通信" class="headerlink" title="设置代理通信"></a>设置代理通信</h5><p>我们需要定义一种方式，让监督代理能够与工作代理进行通信。在多代理架构中，实现这一功能的一种常见方法是使用<strong>handoffs</strong>，即一个代理将控制权交给另一个代理。交接允许你指定：</p>
<ul>
<li><strong>destination</strong>:要转移到的目标代理</li>
<li><strong>payload</strong>:要传递给该智能体的信息</li>
</ul>
<p>我们将通过<strong>handoff tools</strong>（转接工具）实现转接，并将这些工具交给监督代理：当监督代理调用这些工具时，它将控制权转交给工作代理，并将完整消息历史传递给该代理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from typing import Annotated</span><br><span class="line">from langchain_core.tools import tool, InjectedToolCallId</span><br><span class="line">from langgraph.prebuilt import InjectedState</span><br><span class="line">from langgraph.graph import StateGraph, START, MessagesState</span><br><span class="line">from langgraph.types import Command</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_handoff_tool(*, agent_name: str, description: str | None = None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建一个“交接”工具函数，用于在 LangGraph 的 Supervisor-Worker 架构中</span><br><span class="line">    把当前对话状态移交给指定名称的子 Agent。</span><br><span class="line"></span><br><span class="line">    参数</span><br><span class="line">    ----</span><br><span class="line">    agent_name : str</span><br><span class="line">        目标子 Agent 的名称，必须与 Supervisor 图中注册的节点名一致。</span><br><span class="line">    description : str | None</span><br><span class="line">        工具的描述文本。如果为 None，则使用默认描述 &quot;Ask &#123;agent_name&#125; for help.&quot;。</span><br><span class="line"></span><br><span class="line">    返回</span><br><span class="line">    ----</span><br><span class="line">    handoff_tool : Callable</span><br><span class="line">        一个已用 @tool 装饰的函数，可直接注入到 Supervisor 的工具列表。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 动态生成工具名，例如 agent_name=&quot;math_agent&quot; -&gt; &quot;transfer_to_math_agent&quot;</span><br><span class="line">    name = f&quot;transfer_to_&#123;agent_name&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # 如果调用者没有提供描述，则使用默认描述</span><br><span class="line">    description = description or f&quot;Ask &#123;agent_name&#125; for help.&quot;</span><br><span class="line"></span><br><span class="line">    # 用 LangGraph 的 @tool 装饰器注册工具</span><br><span class="line">    @tool(name, description=description)</span><br><span class="line">    def handoff_tool(</span><br><span class="line">        state: Annotated[MessagesState, InjectedState],</span><br><span class="line">        tool_call_id: Annotated[str, InjectedToolCallId],</span><br><span class="line">    ) -&gt; Command:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        实际执行交接逻辑的工具函数。</span><br><span class="line"></span><br><span class="line">        参数</span><br><span class="line">        ----</span><br><span class="line">        state : MessagesState</span><br><span class="line">            当前对话状态，由 LangGraph 注入。</span><br><span class="line">        tool_call_id : str</span><br><span class="line">            本次工具调用的唯一 ID，由 LangGraph 注入。</span><br><span class="line"></span><br><span class="line">        返回</span><br><span class="line">        ----</span><br><span class="line">        Command</span><br><span class="line">            一个 LangGraph Command 对象，告诉框架：</span><br><span class="line">            - goto=agent_name        : 跳转到哪个子 Agent</span><br><span class="line">            - update                 : 更新后的状态</span><br><span class="line">            - graph=Command.PARENT   : 在父图（Supervisor）作用域内执行</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 构造一条工具消息，记录交接动作</span><br><span class="line">        tool_message = &#123;</span><br><span class="line">            &quot;role&quot;: &quot;tool&quot;,</span><br><span class="line">            &quot;content&quot;: f&quot;Successfully transferred to &#123;agent_name&#125;&quot;,</span><br><span class="line">            &quot;name&quot;: name,</span><br><span class="line">            &quot;tool_call_id&quot;: tool_call_id,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 使用 Command 把对话状态连同新消息一起发送到目标 Agent</span><br><span class="line">        return Command(</span><br><span class="line">            goto=agent_name,</span><br><span class="line">            update=&#123;**state, &quot;messages&quot;: state[&quot;messages&quot;] + [tool_message]&#125;,</span><br><span class="line">            graph=Command.PARENT,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    # 返回已装饰的工具函数，供 Supervisor 添加进 tools 列表</span><br><span class="line">    return handoff_tool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建研究代理的交接工具</span><br><span class="line">assign_to_research_agent = create_handoff_tool(</span><br><span class="line">    agent_name=&quot;research_agent&quot;,</span><br><span class="line">    description=&quot;Assign task to a researcher agent.&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建数学代理的交接工具</span><br><span class="line">assign_to_math_agent = create_handoff_tool(</span><br><span class="line">    agent_name=&quot;math_agent&quot;,</span><br><span class="line">    description=&quot;Assign task to a math agent.&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="创建监督代理"><a href="#创建监督代理" class="headerlink" title="创建监督代理"></a>创建监督代理</h5><p>然后，我们使用刚刚定义的交接工具来创建监督代理。我们将使用预构建的 <code>create_react_agent</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">supervisor_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[assign_to_research_agent, assign_to_math_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是一个管理两个代理的主管：\n&quot;</span><br><span class="line">        &quot;- 一个研究代理。将研究相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;- 一个数学代理。将数学相关任务分配给这个代理\n&quot;</span><br><span class="line">        &quot;一次只分配工作给一个代理，不要并行调用代理。\n&quot;</span><br><span class="line">        &quot;不要自己做任何工作。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;supervisor&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="创建多智能体图"><a href="#创建多智能体图" class="headerlink" title="创建多智能体图"></a>创建多智能体图</h5><p>将这些内容整合起来，让我们为我们的整体多代理系统创建一个图。我们将添加监督代理和各个代理作为子图节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import END</span><br><span class="line"></span><br><span class="line"># 定义多代理主管图</span><br><span class="line">supervisor = (</span><br><span class="line">    StateGraph(MessagesState)</span><br><span class="line">    # 注意：`destinations` 仅用于可视化，不影响运行时行为</span><br><span class="line">    .add_node(supervisor_agent, destinations=(&quot;research_agent&quot;, &quot;math_agent&quot;, END))</span><br><span class="line">    .add_node(research_agent)</span><br><span class="line">    .add_node(math_agent)</span><br><span class="line">    .add_edge(START, &quot;supervisor&quot;)</span><br><span class="line">    # 总是返回到主管</span><br><span class="line">    .add_edge(&quot;research_agent&quot;, &quot;supervisor&quot;)</span><br><span class="line">    .add_edge(&quot;math_agent&quot;, &quot;supervisor&quot;)</span><br><span class="line">    .compile()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个代码中，去 <code>research_agent</code> 和 <code>math_agent</code> 的条件边是通过<strong>工具调用</strong>实现的，而不是显式的条件边。</p>
<p>工作机制：</p>
<ol>
<li><p><strong>工具作为交接手段</strong>：</p>
<ul>
<li><code>assign_to_research_agent</code> 和 <code>assign_to_math_agent</code> 这两个工具被添加到 <code>supervisor_agent</code> 中</li>
<li>当 supervisor_agent 决定需要某个代理帮助时，它会调用相应的工具</li>
</ul>
</li>
<li><p><strong>工具内部实现交接</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def handoff_tool(...) -&gt; Command:</span><br><span class="line">    return Command(</span><br><span class="line">        goto=agent_name,  # 这里指定了要跳转到哪个代理</span><br><span class="line">        update=&#123;...&#125;,</span><br><span class="line">        graph=Command.PARENT,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式的条件边</strong>：</p>
<ul>
<li>当 supervisor_agent 调用 <code>assign_to_research_agent</code> 工具时 → 自动跳转到 <code>research_agent</code></li>
<li>当 supervisor_agent 调用 <code>assign_to_math_agent</code> 工具时 → 自动跳转到 <code>math_agent</code></li>
</ul>
</li>
</ol>
<p>什么是 Command 机制</p>
<p>Command 机制是 LangGraph 提供的一种<strong>显式控制流程跳转</strong>的方式。它允许工具或节点直接指定下一步要执行什么操作，而不需要通过传统的条件边路由。</p>
<p>Command 的核心概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.types import Command</span><br><span class="line"></span><br><span class="line">Command(</span><br><span class="line">    goto=agent_name,           # 要跳转到的目标节点</span><br><span class="line">    update=state_update,       # 要更新的状态</span><br><span class="line">    graph=Command.PARENT      # 在哪个图中执行（父图/子图）</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>请注意，我们已经从工作代理添加了明确的边回到主管——这意味着它们保证会将控制权返回给主管。如果你希望代理直接响应用户（即，将系统转变为路由器），你可以移除这些边。</p>
<h3 id="Multi-agent-network"><a href="#Multi-agent-network" class="headerlink" title="Multi-agent network"></a>Multi-agent network</h3><p>一个单一智能体通常可以使用单个领域内的一小批工具来有效运作，但即使使用像 <code>gpt-4</code> 这样强大的模型，使用多个工具时也可能效果不佳。</p>
<p>处理复杂任务的一种方法是采用“分而治之”的方法：为每个任务或领域创建一个专门的智能体，并将任务路由到正确的“专家”。这是一个多智能体网络架构的例子。</p>
<p><img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250819150039818.png" alt="image-20250819150039818"></p>
<p><strong>这个多agent架构，就像多个agent进行讨论，所以也叫Multi Agent Collaboration，但是给我的感觉，比较混乱，agent直接的路由很难去定义，agent一多就搞不清楚了</strong>，所以这里也不实战了。</p>
<h3 id="Hierarchical-Agent-Teams"><a href="#Hierarchical-Agent-Teams" class="headerlink" title="Hierarchical Agent Teams"></a>Hierarchical Agent Teams</h3><p>对于某些应用，如果工作按层次分布，系统可能会更有效。你可以通过组合不同的子图，并创建一个顶层监督者以及中层监督者来实现这一点。</p>
<p><img src="/2025/08/18/%E5%AD%A6%E4%B9%A0/agent%E5%AE%9E%E6%88%98/Multi-Agent%20Workflows%E5%AE%9E%E6%88%98/image-20250819151813264.png" alt="image-20250819151813264"></p>
<p>使用预设的supervisor构建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># 1. 定义研究团队的代理</span><br><span class="line">@tool</span><br><span class="line">def web_search(query: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;执行网络搜索&quot;&quot;&quot;</span><br><span class="line">    return f&quot;搜索结果：关于&#x27;&#123;query&#125;&#x27;的最新信息...&quot;</span><br><span class="line"></span><br><span class="line">@tool</span><br><span class="line">def analyze_data(data: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;分析数据&quot;&quot;&quot;</span><br><span class="line">    return f&quot;数据分析结果：&#123;data&#125;的趋势显示...&quot;</span><br><span class="line"></span><br><span class="line">research_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[web_search, analyze_data],</span><br><span class="line">    prompt=&quot;你是一个研究专家，负责进行网络搜索和数据分析。&quot;,</span><br><span class="line">    name=&quot;research_specialist&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 2. 定义数学团队的代理</span><br><span class="line">@tool</span><br><span class="line">def calculate_statistics(numbers: list[float]) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;计算统计值&quot;&quot;&quot;</span><br><span class="line">    if not numbers:</span><br><span class="line">        return &quot;错误：数据列表为空&quot;</span><br><span class="line">    avg = sum(numbers) / len(numbers)</span><br><span class="line">    return f&quot;统计结果：平均值=&#123;avg:.2f&#125;，数据点数量=&#123;len(numbers)&#125;&quot;</span><br><span class="line"></span><br><span class="line">@tool</span><br><span class="line">def solve_equation(equation: str) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;解方程&quot;&quot;&quot;</span><br><span class="line">    return f&quot;方程 &#123;equation&#125; 的解为：x = 42&quot;</span><br><span class="line"></span><br><span class="line">math_agent = create_react_agent(</span><br><span class="line">    model=llm,</span><br><span class="line">    tools=[calculate_statistics, solve_equation],</span><br><span class="line">    prompt=&quot;你是一个数学专家，负责统计计算和方程求解。&quot;,</span><br><span class="line">    name=&quot;math_specialist&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 3. 创建研究团队主管</span><br><span class="line">research_supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[research_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是研究团队的主管。\n&quot;</span><br><span class="line">        &quot;你的团队有一个研究专家，负责网络搜索和数据分析。\n&quot;</span><br><span class="line">        &quot;根据任务需求，将工作分配给研究专家。\n&quot;</span><br><span class="line">        &quot;等待专家完成任务后，总结结果并报告给上级主管。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;research_supervisor&quot;</span><br><span class="line">).compile(name=&quot;research_supervisor&quot;)</span><br><span class="line"></span><br><span class="line"># 4. 创建数学团队主管</span><br><span class="line">math_supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[math_agent],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是数学团队的主管。\n&quot;</span><br><span class="line">        &quot;你的团队有一个数学专家，负责统计计算和方程求解。\n&quot;</span><br><span class="line">        &quot;根据任务需求，将工作分配给数学专家。\n&quot;</span><br><span class="line">        &quot;等待专家完成任务后，总结结果并报告给上级主管。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;math_supervisor&quot;</span><br><span class="line">).compile(name=&quot;math_supervisor&quot;)</span><br><span class="line"></span><br><span class="line"># 5. 创建顶层主管</span><br><span class="line">top_supervisor = create_supervisor(</span><br><span class="line">    model=llm,</span><br><span class="line">    agents=[research_supervisor, math_supervisor],</span><br><span class="line">    prompt=(</span><br><span class="line">        &quot;你是顶层主管，管理两个专业团队：\n&quot;</span><br><span class="line">        &quot;- 研究团队：负责市场调研、数据分析等任务\n&quot;</span><br><span class="line">        &quot;- 数学团队：负责统计计算、方程求解等任务\n&quot;</span><br><span class="line">        &quot;根据任务的性质，将工作分配给相应的团队主管。\n&quot;</span><br><span class="line">        &quot;等待团队完成任务后，整合所有结果并给出最终报告。&quot;</span><br><span class="line">    ),</span><br><span class="line">    name=&quot;top_supervisor&quot;</span><br><span class="line">).compile(name=&quot;top_supervisor&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://blog.langchain.com/langgraph-multi-agent-workflows/">LangGraph：多智能体工作流 —- LangGraph: Multi-Agent Workflows</a></p>
<p><a target="_blank" rel="noopener" href="https://langchain-ai.github.io/langgraph/concepts/multi_agent/">Overview</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张熙浚</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="本站访问数 fa fa-user 次"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="本站总访问量 fa fa-eye 次"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="400" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
